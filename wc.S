
sysroot/usr/bin/wc:     file format elf32-littlearm


Disassembly of section .init:

00008000 <_init>:
    8000:	e1a0c00d 	mov	ip, sp
    8004:	e92ddff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
    8008:	e24cb004 	sub	fp, ip, #4
    800c:	e24bd028 	sub	sp, fp, #40	@ 0x28
    8010:	e89d6ff0 	ldm	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
    8014:	e12fff1e 	bx	lr

Disassembly of section .text:

00008040 <main>:
}


int
main (int argc, char **argv)
{
    8040:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8044:	e1a06000 	mov	r6, r0
    8048:	ed2d8b04 	vpush	{d8-d9}
    804c:	e24ddf4b 	sub	sp, sp, #300	@ 0x12c
    8050:	e1a05001 	mov	r5, r1
  atexit (close_stdout);

  page_size = getpagesize ();
  /* Line buffer stdout to ensure lines are written atomically and immediately
     so that processes running in parallel do not intersperse their output.  */
  setvbuf (stdout, nullptr, _IOLBF, 0);
    8054:	e30ba1e8 	movw	sl, #45544	@ 0xb1e8
  set_program_name (argv[0]);
    8058:	e5910000 	ldr	r0, [r1]
  setvbuf (stdout, nullptr, _IOLBF, 0);
    805c:	e340a002 	movt	sl, #2
  set_program_name (argv[0]);
    8060:	eb000d48 	bl	b588 <set_program_name>
  setlocale (LC_ALL, "");
    8064:	e3081d5c 	movw	r1, #36188	@ 0x8d5c
    8068:	e3a00000 	mov	r0, #0
    806c:	e3401002 	movt	r1, #2
  page_size = getpagesize ();
    8070:	e30b4338 	movw	r4, #45880	@ 0xb338
  setlocale (LC_ALL, "");
    8074:	eb004c19 	bl	1b0e0 <setlocale>
  atexit (close_stdout);
    8078:	e3090f80 	movw	r0, #40832	@ 0x9f80
  page_size = getpagesize ();
    807c:	e3404002 	movt	r4, #2
  atexit (close_stdout);
    8080:	e3400000 	movt	r0, #0

  print_lines = print_words = print_chars = print_bytes = false;
  print_linelength = false;
  total_lines = total_words = total_chars = total_bytes = max_line_length = 0;

  while ((optc = getopt_long (argc, argv, "clLmw", longopts, nullptr)) != -1)
    8084:	e3087948 	movw	r7, #35144	@ 0x8948
  atexit (close_stdout);
    8088:	eb0039be 	bl	16788 <atexit>
  page_size = getpagesize ();
    808c:	e3a00008 	mov	r0, #8
  while ((optc = getopt_long (argc, argv, "clLmw", longopts, nullptr)) != -1)
    8090:	e3407002 	movt	r7, #2
  page_size = getpagesize ();
    8094:	eb005e0b 	bl	1f8c8 <sysconf>
  setvbuf (stdout, nullptr, _IOLBF, 0);
    8098:	e59a3000 	ldr	r3, [sl]
    809c:	e3a02001 	mov	r2, #1
  page_size = getpagesize ();
    80a0:	e584000c 	str	r0, [r4, #12]
    80a4:	e58d4024 	str	r4, [sp, #36]	@ 0x24
  setvbuf (stdout, nullptr, _IOLBF, 0);
    80a8:	e5930008 	ldr	r0, [r3, #8]
    80ac:	e3a03000 	mov	r3, #0
    80b0:	e1a01003 	mov	r1, r3
    80b4:	eb004471 	bl	19280 <setvbuf>
  posixly_correct = (getenv ("POSIXLY_CORRECT") != nullptr);
    80b8:	e3080914 	movw	r0, #35092	@ 0x8914
    80bc:	e3400002 	movt	r0, #2
    80c0:	eb0039c8 	bl	167e8 <getenv>
    80c4:	e2500000 	subs	r0, r0, #0
  print_lines = print_words = print_chars = print_bytes = false;
    80c8:	e3a03000 	mov	r3, #0
  posixly_correct = (getenv ("POSIXLY_CORRECT") != nullptr);
    80cc:	13a00001 	movne	r0, #1
  print_lines = print_words = print_chars = print_bytes = false;
    80d0:	e1a01004 	mov	r1, r4
    80d4:	e5c4300a 	strb	r3, [r4, #10]
  total_lines = total_words = total_chars = total_bytes = max_line_length = 0;
    80d8:	e3a02000 	mov	r2, #0
  print_lines = print_words = print_chars = print_bytes = false;
    80dc:	e5c43009 	strb	r3, [r4, #9]
  char *files_from = nullptr;
    80e0:	e1a0b003 	mov	fp, r3
  print_lines = print_words = print_chars = print_bytes = false;
    80e4:	e5c43008 	strb	r3, [r4, #8]
  while ((optc = getopt_long (argc, argv, "clLmw", longopts, nullptr)) != -1)
    80e8:	e1a08003 	mov	r8, r3
  print_lines = print_words = print_chars = print_bytes = false;
    80ec:	e5c43000 	strb	r3, [r4]
  print_linelength = false;
    80f0:	e5c4300b 	strb	r3, [r4, #11]
  total_lines = total_words = total_chars = total_bytes = max_line_length = 0;
    80f4:	e3a03000 	mov	r3, #0
  posixly_correct = (getenv ("POSIXLY_CORRECT") != nullptr);
    80f8:	e5c40010 	strb	r0, [r4, #16]
  total_lines = total_words = total_chars = total_bytes = max_line_length = 0;
    80fc:	e3094ba8 	movw	r4, #39848	@ 0x9ba8
    8100:	e3404002 	movt	r4, #2
    8104:	e1c125f8 	strd	r2, [r1, #88]	@ 0x58
  while ((optc = getopt_long (argc, argv, "clLmw", longopts, nullptr)) != -1)
    8108:	e2849058 	add	r9, r4, #88	@ 0x58
  total_lines = total_words = total_chars = total_bytes = max_line_length = 0;
    810c:	e1c124f8 	strd	r2, [r1, #72]	@ 0x48
    8110:	e1c123f8 	strd	r2, [r1, #56]	@ 0x38
    8114:	e1c122f8 	strd	r2, [r1, #40]	@ 0x28
    8118:	e1c121f8 	strd	r2, [r1, #24]
  while ((optc = getopt_long (argc, argv, "clLmw", longopts, nullptr)) != -1)
    811c:	e1a03009 	mov	r3, r9
    8120:	e1a02007 	mov	r2, r7
    8124:	e1a01005 	mov	r1, r5
    8128:	e1a00006 	mov	r0, r6
    812c:	e58d8000 	str	r8, [sp]
    8130:	eb000c6b 	bl	b2e4 <rpl_getopt_long>
    8134:	e3700001 	cmn	r0, #1
    8138:	0a000073 	beq	830c <main+0x2cc>
    switch (optc)
    813c:	e3500077 	cmp	r0, #119	@ 0x77
    8140:	ca00002a 	bgt	81f0 <main+0x1b0>
    8144:	e3500062 	cmp	r0, #98	@ 0x62
    8148:	da000032 	ble	8218 <main+0x1d8>
    814c:	e2400063 	sub	r0, r0, #99	@ 0x63
    8150:	e3500014 	cmp	r0, #20
    8154:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
    8158:	ea00002c 	b	8210 <main+0x1d0>
    815c:	000081e0 	.word	0x000081e0
    8160:	00008210 	.word	0x00008210
    8164:	00008210 	.word	0x00008210
    8168:	00008210 	.word	0x00008210
    816c:	00008210 	.word	0x00008210
    8170:	00008210 	.word	0x00008210
    8174:	00008210 	.word	0x00008210
    8178:	00008210 	.word	0x00008210
    817c:	00008210 	.word	0x00008210
    8180:	000081d0 	.word	0x000081d0
    8184:	000081c0 	.word	0x000081c0
    8188:	00008210 	.word	0x00008210
    818c:	00008210 	.word	0x00008210
    8190:	00008210 	.word	0x00008210
    8194:	00008210 	.word	0x00008210
    8198:	00008210 	.word	0x00008210
    819c:	00008210 	.word	0x00008210
    81a0:	00008210 	.word	0x00008210
    81a4:	00008210 	.word	0x00008210
    81a8:	00008210 	.word	0x00008210
    81ac:	000081b0 	.word	0x000081b0
      case 'l':
        print_lines = true;
        break;

      case 'w':
        print_words = true;
    81b0:	e59d2024 	ldr	r2, [sp, #36]	@ 0x24
    81b4:	e3a03001 	mov	r3, #1
    81b8:	e5c23008 	strb	r3, [r2, #8]
        break;
    81bc:	eaffffd6 	b	811c <main+0xdc>
        print_chars = true;
    81c0:	e59d2024 	ldr	r2, [sp, #36]	@ 0x24
    81c4:	e3a03001 	mov	r3, #1
    81c8:	e5c23009 	strb	r3, [r2, #9]
        break;
    81cc:	eaffffd2 	b	811c <main+0xdc>
        print_lines = true;
    81d0:	e59d2024 	ldr	r2, [sp, #36]	@ 0x24
    81d4:	e3a03001 	mov	r3, #1
    81d8:	e5c23000 	strb	r3, [r2]
        break;
    81dc:	eaffffce 	b	811c <main+0xdc>
        print_bytes = true;
    81e0:	e59d2024 	ldr	r2, [sp, #36]	@ 0x24
    81e4:	e3a03001 	mov	r3, #1
    81e8:	e5c2300a 	strb	r3, [r2, #10]
        break;
    81ec:	eaffffca 	b	811c <main+0xdc>
    switch (optc)
    81f0:	e3003101 	movw	r3, #257	@ 0x101
    81f4:	e1500003 	cmp	r0, r3
    81f8:	0a00003b 	beq	82ec <main+0x2ac>
    81fc:	e3003102 	movw	r3, #258	@ 0x102
    8200:	e1500003 	cmp	r0, r3
    8204:	0a000024 	beq	829c <main+0x25c>
    8208:	e3500c01 	cmp	r0, #256	@ 0x100
    820c:	0affffc2 	beq	811c <main+0xdc>
      if (optind < argc)
        {
          error (0, 0, _("extra operand %s"), quoteaf (argv[optind]));
          fprintf (stderr, "%s\n",
                   _("file operands cannot be combined with --files0-from"));
          usage (EXIT_FAILURE);
    8210:	e3a00001 	mov	r0, #1
    8214:	eb000540 	bl	971c <usage>
    switch (optc)
    8218:	e3700002 	cmn	r0, #2
    821c:	0a000242 	beq	8b2c <main+0xaec>
    8220:	e350004c 	cmp	r0, #76	@ 0x4c
    8224:	0a000034 	beq	82fc <main+0x2bc>
    8228:	e3700003 	cmn	r0, #3
    822c:	1afffff7 	bne	8210 <main+0x1d0>
      case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
    8230:	e59a2000 	ldr	r2, [sl]
    8234:	e308192c 	movw	r1, #35116	@ 0x892c
    8238:	e3401002 	movt	r1, #2
    823c:	e30b300c 	movw	r3, #45068	@ 0xb00c
    8240:	e3403002 	movt	r3, #2
    8244:	e1a00001 	mov	r0, r1
    8248:	e5925008 	ldr	r5, [r2, #8]
    824c:	e5936000 	ldr	r6, [r3]
    8250:	eb000cf8 	bl	b638 <proper_name_lite>
    8254:	e3081938 	movw	r1, #35128	@ 0x8938
    8258:	e1a04000 	mov	r4, r0
    825c:	e3401002 	movt	r1, #2
    8260:	e1a00001 	mov	r0, r1
    8264:	eb000cf3 	bl	b638 <proper_name_lite>
    8268:	e1a01000 	mov	r1, r0
    826c:	e3082848 	movw	r2, #34888	@ 0x8848
    8270:	e58d1004 	str	r1, [sp, #4]
    8274:	e3081360 	movw	r1, #33632	@ 0x8360
    8278:	e1a00005 	mov	r0, r5
    827c:	e1a03006 	mov	r3, r6
    8280:	e3402002 	movt	r2, #2
    8284:	e3401002 	movt	r1, #2
    8288:	e58d8008 	str	r8, [sp, #8]
    828c:	e58d4000 	str	r4, [sp]
    8290:	eb001703 	bl	dea4 <version_etc>
    8294:	e3a00000 	mov	r0, #0
    8298:	eb00393f 	bl	1679c <exit>
        total_mode = XARGMATCH ("--total", optarg, total_args, total_types);
    829c:	e30b3010 	movw	r3, #45072	@ 0xb010
    82a0:	e30b23e0 	movw	r2, #46048	@ 0xb3e0
    82a4:	e3403002 	movt	r3, #2
    82a8:	e3402002 	movt	r2, #2
    82ac:	e5933000 	ldr	r3, [r3]
    82b0:	e3080924 	movw	r0, #35108	@ 0x8924
    82b4:	e3400002 	movt	r0, #2
    82b8:	e58d3004 	str	r3, [sp, #4]
    82bc:	e59f390c 	ldr	r3, [pc, #2316]	@ 8bd0 <main+0xb90>
    82c0:	e5921000 	ldr	r1, [r2]
    82c4:	e3a02001 	mov	r2, #1
    82c8:	e58d2008 	str	r2, [sp, #8]
    82cc:	e58d2000 	str	r2, [sp]
    82d0:	e2832004 	add	r2, r3, #4
    82d4:	eb000667 	bl	9c78 <__xargmatch_internal>
    82d8:	e0840000 	add	r0, r4, r0
    82dc:	e59d2024 	ldr	r2, [sp, #36]	@ 0x24
    82e0:	e5d03040 	ldrb	r3, [r0, #64]	@ 0x40
    82e4:	e5c23011 	strb	r3, [r2, #17]
        break;
    82e8:	eaffff8b 	b	811c <main+0xdc>
        files_from = optarg;
    82ec:	e30b33e0 	movw	r3, #46048	@ 0xb3e0
    82f0:	e3403002 	movt	r3, #2
    82f4:	e593b000 	ldr	fp, [r3]
        break;
    82f8:	eaffff87 	b	811c <main+0xdc>
        print_linelength = true;
    82fc:	e59d2024 	ldr	r2, [sp, #36]	@ 0x24
    8300:	e3a03001 	mov	r3, #1
    8304:	e5c2300b 	strb	r3, [r2, #11]
        break;
    8308:	eaffff83 	b	811c <main+0xdc>
  if (! (print_lines || print_words || print_chars || print_bytes
    830c:	e59d2024 	ldr	r2, [sp, #36]	@ 0x24
    8310:	e5d23000 	ldrb	r3, [r2]
    8314:	e3530000 	cmp	r3, #0
    8318:	1a00000e 	bne	8358 <main+0x318>
    831c:	e5d23008 	ldrb	r3, [r2, #8]
    8320:	e3530000 	cmp	r3, #0
    8324:	1a00000b 	bne	8358 <main+0x318>
    8328:	e5d23009 	ldrb	r3, [r2, #9]
    832c:	e3530000 	cmp	r3, #0
    8330:	1a000008 	bne	8358 <main+0x318>
    8334:	e5d2300a 	ldrb	r3, [r2, #10]
    8338:	e3530000 	cmp	r3, #0
    833c:	1a000005 	bne	8358 <main+0x318>
    8340:	e5d2300b 	ldrb	r3, [r2, #11]
    8344:	e3530000 	cmp	r3, #0
    print_lines = print_words = print_bytes = true;
    8348:	03a03001 	moveq	r3, #1
    834c:	05c2300a 	strbeq	r3, [r2, #10]
    8350:	05c23008 	strbeq	r3, [r2, #8]
    8354:	05c23000 	strbeq	r3, [r2]
      if (optind < argc)
    8358:	e30b3018 	movw	r3, #45080	@ 0xb018
  if (files_from)
    835c:	e35b0000 	cmp	fp, #0
      if (optind < argc)
    8360:	e3403002 	movt	r3, #2
    8364:	e5937000 	ldr	r7, [r3]
  if (files_from)
    8368:	0a000069 	beq	8514 <main+0x4d4>
      if (optind < argc)
    836c:	e1570006 	cmp	r7, r6
    8370:	ba0001f9 	blt	8b5c <main+0xb1c>
        }

      if (STREQ (files_from, "-"))
    8374:	e3081998 	movw	r1, #35224	@ 0x8998
    8378:	e1a0000b 	mov	r0, fp
    837c:	e3401002 	movt	r1, #2
    8380:	fa005d96 	blx	1f9e0 <strcmp>
    8384:	e3500000 	cmp	r0, #0
    8388:	1a00016a 	bne	8938 <main+0x8f8>
        stream = stdin;
    838c:	e59a3000 	ldr	r3, [sl]
    8390:	e5935004 	ldr	r5, [r3, #4]
        }

      /* Read the file list into RAM if we can detect its size and that
         size is reasonable.  Otherwise, we'll read a name at a time.  */
      struct stat st;
      if (fstat (fileno (stream), &st) == 0
    8394:	e1a00005 	mov	r0, r5
    8398:	eb003f8d 	bl	181d4 <fileno>
    839c:	e28d3040 	add	r3, sp, #64	@ 0x40
    83a0:	e1a01003 	mov	r1, r3
    83a4:	e58d3028 	str	r3, [sp, #40]	@ 0x28
    83a8:	eb005c96 	bl	1f608 <fstat>
    83ac:	e3500000 	cmp	r0, #0
    83b0:	1a000003 	bne	83c4 <main+0x384>
          && S_ISREG (st.st_mode)
    83b4:	e59d3044 	ldr	r3, [sp, #68]	@ 0x44
    83b8:	e2033a0f 	and	r3, r3, #61440	@ 0xf000
    83bc:	e3530902 	cmp	r3, #32768	@ 0x8000
    83c0:	0a0001b0 	beq	8a88 <main+0xa48>
        }
      else
        {
          files = nullptr;
          nfiles = 0;
          ai = argv_iter_init_stream (stream);
    83c4:	e1a00005 	mov	r0, r5
    83c8:	eb000689 	bl	9df4 <argv_iter_init_stream>
      files = (optind < argc ? argv + optind : stdin_only);
      nfiles = (optind < argc ? argc - optind : 1);
      ai = argv_iter_init_argv (files);
    }

  if (!ai)
    83cc:	e2508000 	subs	r8, r0, #0
    83d0:	0a0001d7 	beq	8b34 <main+0xaf4>
  struct fstatus *fstatus = xnmalloc (nfiles ? nfiles : 1, sizeof *fstatus);
    83d4:	e3a01060 	mov	r1, #96	@ 0x60
    83d8:	e3a00001 	mov	r0, #1
  bool read_tokens = false;
    83dc:	e3a04000 	mov	r4, #0
  struct fstatus *fstatus = xnmalloc (nfiles ? nfiles : 1, sizeof *fstatus);
    83e0:	eb001722 	bl	e070 <xnmalloc>
    83e4:	e1a07004 	mov	r7, r4
    83e8:	e1a09000 	mov	r9, r0
    xalloc_die ();

  fstatus = get_input_fstatus (nfiles, files);
  if (total_mode == total_only)
    83ec:	e59d3024 	ldr	r3, [sp, #36]	@ 0x24
    fstatus[0].failed = 1;
    83f0:	e3a05001 	mov	r5, #1
    83f4:	e5895000 	str	r5, [r9]
  if (total_mode == total_only)
    83f8:	e5d33011 	ldrb	r3, [r3, #17]
    83fc:	e3530002 	cmp	r3, #2
    8400:	0a000001 	beq	840c <main+0x3cc>
  if (0 < nfiles && fstatus[0].failed <= 0)
    8404:	e3570000 	cmp	r7, #0
    8408:	1a000118 	bne	8870 <main+0x830>
    number_width = 1;  /* No extra padding, since no alignment requirement.  */
  else
    number_width = compute_number_width (nfiles, fstatus);
    840c:	e59d3024 	ldr	r3, [sp, #36]	@ 0x24
  if (! file || STREQ (file, "-"))
    8410:	e3081998 	movw	r1, #35224	@ 0x8998
            {
              /* Using the standard 'filename:line-number:' prefix here is
                 not totally appropriate, since NUL is the separator, not NL,
                 but it might be better than nothing.  */
              unsigned long int file_number = argv_iter_n_args (ai);
              error (0, 0, "%s:%lu: %s", quotef (files_from),
    8414:	e308ca5c 	movw	ip, #35420	@ 0x8a5c
    8418:	e3082a7c 	movw	r2, #35452	@ 0x8a7c
  if (! file || STREQ (file, "-"))
    841c:	e3401002 	movt	r1, #2
              error (0, 0, "%s:%lu: %s", quotef (files_from),
    8420:	e340c002 	movt	ip, #2
    8424:	e3402002 	movt	r2, #2
    number_width = compute_number_width (nfiles, fstatus);
    8428:	e3a06000 	mov	r6, #0
    842c:	e3a0a001 	mov	sl, #1
    8430:	e5835004 	str	r5, [r3, #4]
    8434:	e58d4038 	str	r4, [sp, #56]	@ 0x38
    8438:	e58d102c 	str	r1, [sp, #44]	@ 0x2c
    843c:	e58dc030 	str	ip, [sp, #48]	@ 0x30
    8440:	e58d2034 	str	r2, [sp, #52]	@ 0x34
    8444:	ea000021 	b	84d0 <main+0x490>
      if (files_from && STREQ (files_from, "-") && STREQ (file_name, "-"))
    8448:	e5db3001 	ldrb	r3, [fp, #1]
    844c:	e3530000 	cmp	r3, #0
    8450:	1a000028 	bne	84f8 <main+0x4b8>
    8454:	e59d102c 	ldr	r1, [sp, #44]	@ 0x2c
    8458:	fa005d60 	blx	1f9e0 <strcmp>
    845c:	e2504000 	subs	r4, r0, #0
    8460:	0a00005b 	beq	85d4 <main+0x594>
      if (!file_name[0])
    8464:	e5d53000 	ldrb	r3, [r5]
    8468:	e3530000 	cmp	r3, #0
    846c:	0a000064 	beq	8604 <main+0x5c4>
        }

      if (skip_file)
        ok = false;
      else
        ok &= wc_file (file_name, &fstatus[nfiles ? i : 0]);
    8470:	e3570000 	cmp	r7, #0
    8474:	01a04009 	moveq	r4, r9
    8478:	0a0000cb 	beq	87ac <main+0x76c>
    847c:	e1a04006 	mov	r4, r6
  if (! file || STREQ (file, "-"))
    8480:	e59d102c 	ldr	r1, [sp, #44]	@ 0x2c
    8484:	e1a00005 	mov	r0, r5
    8488:	fa005d54 	blx	1f9e0 <strcmp>
    848c:	e3500000 	cmp	r0, #0
        ok &= wc_file (file_name, &fstatus[nfiles ? i : 0]);
    8490:	e0894004 	add	r4, r9, r4
  if (! file || STREQ (file, "-"))
    8494:	1a0000c4 	bne	87ac <main+0x76c>
      have_read_stdin = true;
    8498:	e59dc024 	ldr	ip, [sp, #36]	@ 0x24
    849c:	e3a03001 	mov	r3, #1
      return wc (STDIN_FILENO, file, fstatus, -1);
    84a0:	e1a02004 	mov	r2, r4
    84a4:	e1a01005 	mov	r1, r5
      have_read_stdin = true;
    84a8:	e5cc3064 	strb	r3, [ip, #100]	@ 0x64
      return wc (STDIN_FILENO, file, fstatus, -1);
    84ac:	e3e03000 	mvn	r3, #0
    84b0:	eb000283 	bl	8ec4 <wc>
    84b4:	e1a04000 	mov	r4, r0
    84b8:	e004400a 	and	r4, r4, sl
    84bc:	e6efa074 	uxtb	sl, r4

      if (! nfiles)
    84c0:	e3570000 	cmp	r7, #0
        fstatus[0].failed = 1;
    84c4:	e2866060 	add	r6, r6, #96	@ 0x60
    84c8:	03a03001 	moveq	r3, #1
    84cc:	05893000 	streq	r3, [r9]
      char *file_name = argv_iter (ai, &ai_err);
    84d0:	e59d1028 	ldr	r1, [sp, #40]	@ 0x28
    84d4:	e1a00008 	mov	r0, r8
    84d8:	eb000652 	bl	9e28 <argv_iter>
      if (!file_name)
    84dc:	e2505000 	subs	r5, r0, #0
    84e0:	0a000062 	beq	8670 <main+0x630>
      if (files_from && STREQ (files_from, "-") && STREQ (file_name, "-"))
    84e4:	e35b0000 	cmp	fp, #0
    84e8:	0a000056 	beq	8648 <main+0x608>
    84ec:	e5db3000 	ldrb	r3, [fp]
    84f0:	e353002d 	cmp	r3, #45	@ 0x2d
    84f4:	0affffd3 	beq	8448 <main+0x408>
      if (!file_name[0])
    84f8:	e5d53000 	ldrb	r3, [r5]
    84fc:	e3530000 	cmp	r3, #0
    8500:	0a00003f 	beq	8604 <main+0x5c4>
        ok &= wc_file (file_name, &fstatus[nfiles ? i : 0]);
    8504:	e3570000 	cmp	r7, #0
    8508:	11a04006 	movne	r4, r6
    850c:	03a04000 	moveq	r4, #0
    8510:	eaffffda 	b	8480 <main+0x440>
      files = (optind < argc ? argv + optind : stdin_only);
    8514:	e1570006 	cmp	r7, r6
    8518:	a59f56b4 	ldrge	r5, [pc, #1716]	@ 8bd4 <main+0xb94>
    851c:	b0855107 	addlt	r5, r5, r7, lsl #2
      nfiles = (optind < argc ? argc - optind : 1);
    8520:	a3a07001 	movge	r7, #1
    8524:	b0467007 	sublt	r7, r6, r7
      ai = argv_iter_init_argv (files);
    8528:	e1a00005 	mov	r0, r5
    852c:	eb000626 	bl	9dcc <argv_iter_init_argv>
  if (!ai)
    8530:	e2508000 	subs	r8, r0, #0
    8534:	0a00017e 	beq	8b34 <main+0xaf4>
  struct fstatus *fstatus = xnmalloc (nfiles ? nfiles : 1, sizeof *fstatus);
    8538:	e3a01060 	mov	r1, #96	@ 0x60
    853c:	e1a00007 	mov	r0, r7
    8540:	eb0016ca 	bl	e070 <xnmalloc>
  bool read_tokens = false;
    8544:	e3a04000 	mov	r4, #0
  struct fstatus *fstatus = xnmalloc (nfiles ? nfiles : 1, sizeof *fstatus);
    8548:	e1a09000 	mov	r9, r0
  if (nfiles == 0
    854c:	e28d3040 	add	r3, sp, #64	@ 0x40
    8550:	e58d3028 	str	r3, [sp, #40]	@ 0x28
      || (nfiles == 1
    8554:	e3570001 	cmp	r7, #1
    8558:	0a000134 	beq	8a30 <main+0x9f0>
        fstatus[i].failed = (! file[i] || STREQ (file[i], "-")
    855c:	e3083998 	movw	r3, #35224	@ 0x8998
    8560:	e289a008 	add	sl, r9, #8
    8564:	e3403002 	movt	r3, #2
  struct fstatus *fstatus = xnmalloc (nfiles ? nfiles : 1, sizeof *fstatus);
    8568:	e58d402c 	str	r4, [sp, #44]	@ 0x2c
    856c:	e2455004 	sub	r5, r5, #4
    8570:	e1a0400a 	mov	r4, sl
    8574:	e3a06000 	mov	r6, #0
    8578:	e1a0a003 	mov	sl, r3
    857c:	e58d8030 	str	r8, [sp, #48]	@ 0x30
    8580:	ea000007 	b	85a4 <main+0x564>
                             ? fstat (STDIN_FILENO, &fstatus[i].st)
    8584:	e1a01004 	mov	r1, r4
    8588:	e3a00000 	mov	r0, #0
    858c:	eb005c1d 	bl	1f608 <fstat>
      for (size_t i = 0; i < nfiles; i++)
    8590:	e2866001 	add	r6, r6, #1
        fstatus[i].failed = (! file[i] || STREQ (file[i], "-")
    8594:	e5040008 	str	r0, [r4, #-8]
      for (size_t i = 0; i < nfiles; i++)
    8598:	e1560007 	cmp	r6, r7
    859c:	e2844060 	add	r4, r4, #96	@ 0x60
    85a0:	2a0000ac 	bcs	8858 <main+0x818>
        fstatus[i].failed = (! file[i] || STREQ (file[i], "-")
    85a4:	e5b58004 	ldr	r8, [r5, #4]!
                             : stat (file[i], &fstatus[i].st));
    85a8:	e3580000 	cmp	r8, #0
    85ac:	0afffff4 	beq	8584 <main+0x544>
        fstatus[i].failed = (! file[i] || STREQ (file[i], "-")
    85b0:	e1a0100a 	mov	r1, sl
    85b4:	e1a00008 	mov	r0, r8
    85b8:	fa005d08 	blx	1f9e0 <strcmp>
    85bc:	e3500000 	cmp	r0, #0
    85c0:	0affffef 	beq	8584 <main+0x544>
                             : stat (file[i], &fstatus[i].st));
    85c4:	e1a00008 	mov	r0, r8
    85c8:	e1a01004 	mov	r1, r4
    85cc:	eb00154a 	bl	dafc <rpl_stat>
    85d0:	eaffffee 	b	8590 <main+0x550>
          error (0, 0, _("when reading file names from stdin, "
    85d4:	e1a01005 	mov	r1, r5
    85d8:	e3a00004 	mov	r0, #4
    85dc:	eb001319 	bl	d248 <quotearg_style>
    85e0:	e3082a1c 	movw	r2, #35356	@ 0x8a1c
    85e4:	e1a03000 	mov	r3, r0
    85e8:	e3402002 	movt	r2, #2
    85ec:	e1a01004 	mov	r1, r4
    85f0:	e1a00004 	mov	r0, r4
    85f4:	eb0006cc 	bl	a12c <error>
      if (!file_name[0])
    85f8:	e5d53000 	ldrb	r3, [r5]
    85fc:	e3530000 	cmp	r3, #0
    8600:	1a00000e 	bne	8640 <main+0x600>
              unsigned long int file_number = argv_iter_n_args (ai);
    8604:	e1a00008 	mov	r0, r8
    8608:	eb00062f 	bl	9ecc <argv_iter_n_args>
              error (0, 0, "%s:%lu: %s", quotef (files_from),
    860c:	e1a0200b 	mov	r2, fp
              unsigned long int file_number = argv_iter_n_args (ai);
    8610:	e1a04000 	mov	r4, r0
              error (0, 0, "%s:%lu: %s", quotef (files_from),
    8614:	e3a01003 	mov	r1, #3
    8618:	e3a00000 	mov	r0, #0
    861c:	eb0013a8 	bl	d4c4 <quotearg_n_style_colon>
    8620:	e59d2030 	ldr	r2, [sp, #48]	@ 0x30
    8624:	e3a01000 	mov	r1, #0
    8628:	e1a03000 	mov	r3, r0
    862c:	e58d4000 	str	r4, [sp]
    8630:	e1a00001 	mov	r0, r1
    8634:	e58d2004 	str	r2, [sp, #4]
    8638:	e59d2034 	ldr	r2, [sp, #52]	@ 0x34
    863c:	eb0006ba 	bl	a12c <error>
        ok = false;
    8640:	e3a0a000 	mov	sl, #0
    8644:	eaffff9d 	b	84c0 <main+0x480>
      if (!file_name[0])
    8648:	e5d53000 	ldrb	r3, [r5]
    864c:	e3530000 	cmp	r3, #0
    8650:	1affffab 	bne	8504 <main+0x4c4>
            error (0, 0, "%s", _("invalid zero-length file name"));
    8654:	e3082bfc 	movw	r2, #35836	@ 0x8bfc
    8658:	e59d3030 	ldr	r3, [sp, #48]	@ 0x30
    865c:	e3402002 	movt	r2, #2
    8660:	e1a0100b 	mov	r1, fp
    8664:	e1a0000b 	mov	r0, fp
    8668:	eb0006af 	bl	a12c <error>
    866c:	eafffff3 	b	8640 <main+0x600>
          switch (ai_err)
    8670:	e5dd3040 	ldrb	r3, [sp, #64]	@ 0x40
    8674:	e59d4038 	ldr	r4, [sp, #56]	@ 0x38
    8678:	e3530003 	cmp	r3, #3
    867c:	0a00012c 	beq	8b34 <main+0xaf4>
    8680:	e3530004 	cmp	r3, #4
    8684:	0a000065 	beq	8820 <main+0x7e0>
    8688:	e3530002 	cmp	r3, #2
    868c:	1a000143 	bne	8ba0 <main+0xb60>
 argv_iter_done:

  /* No arguments on the command line is fine.  That means read from stdin.
     However, no arguments on the --files0-from input stream is an error
     means don't read anything.  */
  if (ok && !files_from && argv_iter_n_args (ai) == 0)
    8690:	e35b0000 	cmp	fp, #0
    8694:	13a06000 	movne	r6, #0
    8698:	020a6001 	andeq	r6, sl, #1
    869c:	e3560000 	cmp	r6, #0
    86a0:	0a000004 	beq	86b8 <main+0x678>
    86a4:	e1a00008 	mov	r0, r8
    86a8:	eb000607 	bl	9ecc <argv_iter_n_args>
    86ac:	e3500000 	cmp	r0, #0
    86b0:	11a0a006 	movne	sl, r6
    86b4:	0a0000ea 	beq	8a64 <main+0xa24>
    ok &= wc_file (nullptr, &fstatus[0]);

  if (read_tokens)
    86b8:	e3540000 	cmp	r4, #0
    86bc:	1a00007a 	bne	88ac <main+0x86c>
    readtokens0_free (&tok);

  if (total_mode != total_never
    86c0:	e59d3024 	ldr	r3, [sp, #36]	@ 0x24
    86c4:	e5d33011 	ldrb	r3, [r3, #17]
    86c8:	e3530003 	cmp	r3, #3
    86cc:	0a000029 	beq	8778 <main+0x738>
      && (total_mode != total_auto || 1 < argv_iter_n_args (ai)))
    86d0:	e3530000 	cmp	r3, #0
    86d4:	1a000003 	bne	86e8 <main+0x6a8>
    86d8:	e1a00008 	mov	r0, r8
    86dc:	eb0005fa 	bl	9ecc <argv_iter_n_args>
    86e0:	e3500001 	cmp	r0, #1
    86e4:	9a000023 	bls	8778 <main+0x738>
    {
      if (total_lines_overflow)
    86e8:	e59d2024 	ldr	r2, [sp, #36]	@ 0x24
    86ec:	e5923020 	ldr	r3, [r2, #32]
    86f0:	e5922024 	ldr	r2, [r2, #36]	@ 0x24
    86f4:	e1933002 	orrs	r3, r3, r2
    86f8:	1a0000c1 	bne	8a04 <main+0x9c4>
        {
          total_lines = UINTMAX_MAX;
          error (0, EOVERFLOW, _("total lines"));
          ok = false;
        }
      if (total_words_overflow)
    86fc:	e59d2024 	ldr	r2, [sp, #36]	@ 0x24
    8700:	e5923030 	ldr	r3, [r2, #48]	@ 0x30
    8704:	e5922034 	ldr	r2, [r2, #52]	@ 0x34
    8708:	e1933002 	orrs	r3, r3, r2
    870c:	1a0000b1 	bne	89d8 <main+0x998>
        {
          total_words = UINTMAX_MAX;
          error (0, EOVERFLOW, _("total words"));
          ok = false;
        }
      if (total_chars_overflow)
    8710:	e59d2024 	ldr	r2, [sp, #36]	@ 0x24
    8714:	e5923040 	ldr	r3, [r2, #64]	@ 0x40
    8718:	e5922044 	ldr	r2, [r2, #68]	@ 0x44
    871c:	e1933002 	orrs	r3, r3, r2
    8720:	1a0000a1 	bne	89ac <main+0x96c>
        {
          total_chars = UINTMAX_MAX;
          error (0, EOVERFLOW, _("total characters"));
          ok = false;
        }
      if (total_bytes_overflow)
    8724:	e59d2024 	ldr	r2, [sp, #36]	@ 0x24
    8728:	e5923050 	ldr	r3, [r2, #80]	@ 0x50
    872c:	e5922054 	ldr	r2, [r2, #84]	@ 0x54
    8730:	e1933002 	orrs	r3, r3, r2
    8734:	1a000091 	bne	8980 <main+0x940>
          total_bytes = UINTMAX_MAX;
          error (0, EOVERFLOW, _("total bytes"));
          ok = false;
        }

      write_counts (total_lines, total_words, total_chars, total_bytes,
    8738:	e59dc024 	ldr	ip, [sp, #36]	@ 0x24
    873c:	e308390c 	movw	r3, #35084	@ 0x890c
    8740:	e3403002 	movt	r3, #2
    8744:	e5dc2011 	ldrb	r2, [ip, #17]
    8748:	e3520002 	cmp	r2, #2
    874c:	11a05003 	movne	r5, r3
    8750:	e58d5018 	str	r5, [sp, #24]
    8754:	e1cc03d8 	ldrd	r0, [ip, #56]	@ 0x38
    8758:	e1cc22d8 	ldrd	r2, [ip, #40]	@ 0x28
    875c:	e1cd00f0 	strd	r0, [sp]
    8760:	e1cc04d8 	ldrd	r0, [ip, #72]	@ 0x48
    8764:	e1cd00f8 	strd	r0, [sp, #8]
    8768:	e1cc05d8 	ldrd	r0, [ip, #88]	@ 0x58
    876c:	e1cd01f0 	strd	r0, [sp, #16]
    8770:	e1cc01d8 	ldrd	r0, [ip, #24]
    8774:	eb000161 	bl	8d00 <write_counts>
                    max_line_length,
                    total_mode != total_only ? _("total") : nullptr);
    }

  argv_iter_free (ai);
    8778:	e1a00008 	mov	r0, r8
    877c:	eb0005d9 	bl	9ee8 <argv_iter_free>

  free (fstatus);
    8780:	e1a00009 	mov	r0, r9
    8784:	eb000733 	bl	a458 <rpl_free>

  if (have_read_stdin && close (STDIN_FILENO) != 0)
    8788:	e59d3024 	ldr	r3, [sp, #36]	@ 0x24
    878c:	e5d33064 	ldrb	r3, [r3, #100]	@ 0x64
    8790:	e3530000 	cmp	r3, #0
    8794:	1a00003a 	bne	8884 <main+0x844>
    error (EXIT_FAILURE, errno, "-");

  return ok ? EXIT_SUCCESS : EXIT_FAILURE;
    8798:	e22a0001 	eor	r0, sl, #1
    879c:	e6ef0070 	uxtb	r0, r0
}
    87a0:	e28ddf4b 	add	sp, sp, #300	@ 0x12c
    87a4:	ecbd8b04 	vpop	{d8-d9}
    87a8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
      int fd = open (file, O_RDONLY | O_BINARY);
    87ac:	e3a01000 	mov	r1, #0
    87b0:	e1a00005 	mov	r0, r5
    87b4:	eb004c80 	bl	1b9bc <open>
      if (fd == -1)
    87b8:	e3700001 	cmn	r0, #1
      int fd = open (file, O_RDONLY | O_BINARY);
    87bc:	e58d003c 	str	r0, [sp, #60]	@ 0x3c
      if (fd == -1)
    87c0:	0a000008 	beq	87e8 <main+0x7a8>
          bool ok = wc (fd, file, fstatus, 0);
    87c4:	e1a02004 	mov	r2, r4
    87c8:	e3a03000 	mov	r3, #0
    87cc:	e1a01005 	mov	r1, r5
    87d0:	eb0001bb 	bl	8ec4 <wc>
    87d4:	e1a04000 	mov	r4, r0
          if (close (fd) != 0)
    87d8:	e59d003c 	ldr	r0, [sp, #60]	@ 0x3c
    87dc:	eb005bcf 	bl	1f720 <close>
    87e0:	e3500000 	cmp	r0, #0
    87e4:	0affff33 	beq	84b8 <main+0x478>
              error (0, errno, "%s", quotef (file));
    87e8:	eb004c09 	bl	1b814 <__errno>
    87ec:	e5904000 	ldr	r4, [r0]
    87f0:	e1a02005 	mov	r2, r5
    87f4:	e3a01003 	mov	r1, #3
    87f8:	e3a00000 	mov	r0, #0
    87fc:	eb001330 	bl	d4c4 <quotearg_n_style_colon>
    8800:	e3082bfc 	movw	r2, #35836	@ 0x8bfc
    8804:	e1a03000 	mov	r3, r0
    8808:	e1a01004 	mov	r1, r4
    880c:	e3402002 	movt	r2, #2
    8810:	e3a00000 	mov	r0, #0
          return false;
    8814:	e3a04000 	mov	r4, #0
              error (0, errno, "%s", quotef (file));
    8818:	eb000643 	bl	a12c <error>
              return false;
    881c:	eaffff25 	b	84b8 <main+0x478>
              error (0, errno, _("%s: read error"),
    8820:	eb004bfb 	bl	1b814 <__errno>
    8824:	e5906000 	ldr	r6, [r0]
    8828:	e1a0200b 	mov	r2, fp
    882c:	e3a01003 	mov	r1, #3
    8830:	e1a00005 	mov	r0, r5
    8834:	eb001322 	bl	d4c4 <quotearg_n_style_colon>
    8838:	e30829d8 	movw	r2, #35288	@ 0x89d8
    883c:	e1a03000 	mov	r3, r0
    8840:	e1a01006 	mov	r1, r6
    8844:	e3402002 	movt	r2, #2
    8848:	e1a00005 	mov	r0, r5
              ok = false;
    884c:	e1a0a005 	mov	sl, r5
              error (0, errno, _("%s: read error"),
    8850:	eb000635 	bl	a12c <error>
  if (ok && !files_from && argv_iter_n_args (ai) == 0)
    8854:	eaffff97 	b	86b8 <main+0x678>
  if (total_mode == total_only)
    8858:	e59d3024 	ldr	r3, [sp, #36]	@ 0x24
    885c:	e59d402c 	ldr	r4, [sp, #44]	@ 0x2c
    8860:	e59d8030 	ldr	r8, [sp, #48]	@ 0x30
    8864:	e5d33011 	ldrb	r3, [r3, #17]
    8868:	e3530002 	cmp	r3, #2
    886c:	0a000002 	beq	887c <main+0x83c>
  if (0 < nfiles && fstatus[0].failed <= 0)
    8870:	e5993000 	ldr	r3, [r9]
    8874:	e3530000 	cmp	r3, #0
    8878:	da00000e 	ble	88b8 <main+0x878>
  if (total_mode == total_only)
    887c:	e3a05001 	mov	r5, #1
    8880:	eafffee1 	b	840c <main+0x3cc>
  if (have_read_stdin && close (STDIN_FILENO) != 0)
    8884:	e3a00000 	mov	r0, #0
    8888:	eb005ba4 	bl	1f720 <close>
    888c:	e3500000 	cmp	r0, #0
    8890:	0affffc0 	beq	8798 <main+0x758>
    error (EXIT_FAILURE, errno, "-");
    8894:	eb004bde 	bl	1b814 <__errno>
    8898:	e3082998 	movw	r2, #35224	@ 0x8998
    889c:	e5901000 	ldr	r1, [r0]
    88a0:	e3402002 	movt	r2, #2
    88a4:	e3a00001 	mov	r0, #1
    88a8:	eb00061f 	bl	a12c <error>
    readtokens0_free (&tok);
    88ac:	e28d0098 	add	r0, sp, #152	@ 0x98
    88b0:	eb00140a 	bl	d8e0 <readtokens0_free>
    88b4:	eaffff81 	b	86c0 <main+0x680>
    88b8:	e3a0c060 	mov	ip, #96	@ 0x60
      uintmax_t regular_total = 0;
    88bc:	e3a00000 	mov	r0, #0
    88c0:	e02c979c 	mla	ip, ip, r7, r9
    88c4:	e1a03009 	mov	r3, r9
      int minimum_width = 1;
    88c8:	e3a06001 	mov	r6, #1
      uintmax_t regular_total = 0;
    88cc:	e1a01000 	mov	r1, r0
        if (! fstatus[i].failed)
    88d0:	e5932000 	ldr	r2, [r3]
    88d4:	e3520000 	cmp	r2, #0
    88d8:	1a000007 	bne	88fc <main+0x8bc>
            if (S_ISREG (fstatus[i].st.st_mode))
    88dc:	e593200c 	ldr	r2, [r3, #12]
    88e0:	e2022a0f 	and	r2, r2, #61440	@ 0xf000
    88e4:	e3520902 	cmp	r2, #32768	@ 0x8000
              minimum_width = 7;
    88e8:	13a06007 	movne	r6, #7
            if (S_ISREG (fstatus[i].st.st_mode))
    88ec:	1a000002 	bne	88fc <main+0x8bc>
              regular_total += fstatus[i].st.st_size;
    88f0:	e5932018 	ldr	r2, [r3, #24]
    88f4:	e0920000 	adds	r0, r2, r0
    88f8:	e0a11fc2 	adc	r1, r1, r2, asr #31
      for (size_t i = 0; i < nfiles; i++)
    88fc:	e2833060 	add	r3, r3, #96	@ 0x60
    8900:	e15c0003 	cmp	ip, r3
    8904:	1afffff1 	bne	88d0 <main+0x890>
  int width = 1;
    8908:	e3a05001 	mov	r5, #1
    890c:	ea000003 	b	8920 <main+0x8e0>
      for (; 10 <= regular_total; regular_total /= 10)
    8910:	e3a0200a 	mov	r2, #10
    8914:	e3a03000 	mov	r3, #0
        width++;
    8918:	e2855001 	add	r5, r5, #1
      for (; 10 <= regular_total; regular_total /= 10)
    891c:	eb003723 	bl	165b0 <__aeabi_uldivmod>
    8920:	e350000a 	cmp	r0, #10
    8924:	e2d13000 	sbcs	r3, r1, #0
    8928:	2afffff8 	bcs	8910 <main+0x8d0>
      if (width < minimum_width)
    892c:	e1550006 	cmp	r5, r6
    8930:	b1a05006 	movlt	r5, r6
    8934:	eafffeb4 	b	840c <main+0x3cc>
          stream = fopen (files_from, "r");
    8938:	e3091258 	movw	r1, #37464	@ 0x9258
    893c:	e1a0000b 	mov	r0, fp
    8940:	e3401002 	movt	r1, #2
    8944:	eb0016aa 	bl	e3f4 <rpl_fopen>
          if (stream == nullptr)
    8948:	e2505000 	subs	r5, r0, #0
    894c:	1afffe90 	bne	8394 <main+0x354>
            error (EXIT_FAILURE, errno, _("cannot open %s for reading"),
    8950:	eb004baf 	bl	1b814 <__errno>
    8954:	e1a03000 	mov	r3, r0
    8958:	e1a0100b 	mov	r1, fp
    895c:	e5934000 	ldr	r4, [r3]
    8960:	e3a00004 	mov	r0, #4
    8964:	eb001237 	bl	d248 <quotearg_style>
    8968:	e308299c 	movw	r2, #35228	@ 0x899c
    896c:	e1a03000 	mov	r3, r0
    8970:	e1a01004 	mov	r1, r4
    8974:	e3402002 	movt	r2, #2
    8978:	e3a00001 	mov	r0, #1
    897c:	eb0005ea 	bl	a12c <error>
          total_bytes = UINTMAX_MAX;
    8980:	e59d3024 	ldr	r3, [sp, #36]	@ 0x24
    8984:	e3e00000 	mvn	r0, #0
    8988:	e3e01000 	mvn	r1, #0
          error (0, EOVERFLOW, _("total bytes"));
    898c:	e3082ab4 	movw	r2, #35508	@ 0x8ab4
    8990:	e3402002 	movt	r2, #2
          ok = false;
    8994:	e3a0a000 	mov	sl, #0
          total_bytes = UINTMAX_MAX;
    8998:	e1c304f8 	strd	r0, [r3, #72]	@ 0x48
          error (0, EOVERFLOW, _("total bytes"));
    899c:	e3a0108b 	mov	r1, #139	@ 0x8b
    89a0:	e3a00000 	mov	r0, #0
    89a4:	eb0005e0 	bl	a12c <error>
          ok = false;
    89a8:	eaffff62 	b	8738 <main+0x6f8>
          total_chars = UINTMAX_MAX;
    89ac:	e59d3024 	ldr	r3, [sp, #36]	@ 0x24
    89b0:	e3e00000 	mvn	r0, #0
    89b4:	e3e01000 	mvn	r1, #0
          error (0, EOVERFLOW, _("total characters"));
    89b8:	e3082aa0 	movw	r2, #35488	@ 0x8aa0
    89bc:	e3402002 	movt	r2, #2
          ok = false;
    89c0:	e3a0a000 	mov	sl, #0
          total_chars = UINTMAX_MAX;
    89c4:	e1c303f8 	strd	r0, [r3, #56]	@ 0x38
          error (0, EOVERFLOW, _("total characters"));
    89c8:	e3a0108b 	mov	r1, #139	@ 0x8b
    89cc:	e3a00000 	mov	r0, #0
    89d0:	eb0005d5 	bl	a12c <error>
          ok = false;
    89d4:	eaffff52 	b	8724 <main+0x6e4>
          total_words = UINTMAX_MAX;
    89d8:	e59d3024 	ldr	r3, [sp, #36]	@ 0x24
    89dc:	e3e00000 	mvn	r0, #0
    89e0:	e3e01000 	mvn	r1, #0
          error (0, EOVERFLOW, _("total words"));
    89e4:	e3082a94 	movw	r2, #35476	@ 0x8a94
    89e8:	e3402002 	movt	r2, #2
          ok = false;
    89ec:	e3a0a000 	mov	sl, #0
          total_words = UINTMAX_MAX;
    89f0:	e1c302f8 	strd	r0, [r3, #40]	@ 0x28
          error (0, EOVERFLOW, _("total words"));
    89f4:	e3a0108b 	mov	r1, #139	@ 0x8b
    89f8:	e3a00000 	mov	r0, #0
    89fc:	eb0005ca 	bl	a12c <error>
          ok = false;
    8a00:	eaffff42 	b	8710 <main+0x6d0>
          total_lines = UINTMAX_MAX;
    8a04:	e59d3024 	ldr	r3, [sp, #36]	@ 0x24
    8a08:	e3e00000 	mvn	r0, #0
    8a0c:	e3e01000 	mvn	r1, #0
          error (0, EOVERFLOW, _("total lines"));
    8a10:	e3082a88 	movw	r2, #35464	@ 0x8a88
    8a14:	e3402002 	movt	r2, #2
          ok = false;
    8a18:	e3a0a000 	mov	sl, #0
          total_lines = UINTMAX_MAX;
    8a1c:	e1c301f8 	strd	r0, [r3, #24]
          error (0, EOVERFLOW, _("total lines"));
    8a20:	e3a0108b 	mov	r1, #139	@ 0x8b
    8a24:	e3a00000 	mov	r0, #0
    8a28:	eb0005bf 	bl	a12c <error>
          ok = false;
    8a2c:	eaffff32 	b	86fc <main+0x6bc>
          && ((print_lines + print_words + print_chars
    8a30:	e59d1024 	ldr	r1, [sp, #36]	@ 0x24
    8a34:	e5d12008 	ldrb	r2, [r1, #8]
    8a38:	e5d13000 	ldrb	r3, [r1]
    8a3c:	e0833002 	add	r3, r3, r2
    8a40:	e5d12009 	ldrb	r2, [r1, #9]
    8a44:	e0833002 	add	r3, r3, r2
               + print_bytes + print_linelength)
    8a48:	e5d1200a 	ldrb	r2, [r1, #10]
    8a4c:	e0833002 	add	r3, r3, r2
    8a50:	e5d1200b 	ldrb	r2, [r1, #11]
    8a54:	e0833002 	add	r3, r3, r2
          && ((print_lines + print_words + print_chars
    8a58:	e3530001 	cmp	r3, #1
    8a5c:	1afffebe 	bne	855c <main+0x51c>
    8a60:	eafffe61 	b	83ec <main+0x3ac>
      have_read_stdin = true;
    8a64:	e59d2024 	ldr	r2, [sp, #36]	@ 0x24
    8a68:	e3a03001 	mov	r3, #1
      return wc (STDIN_FILENO, file, fstatus, -1);
    8a6c:	e1a01005 	mov	r1, r5
      have_read_stdin = true;
    8a70:	e5c23064 	strb	r3, [r2, #100]	@ 0x64
      return wc (STDIN_FILENO, file, fstatus, -1);
    8a74:	e3e03000 	mvn	r3, #0
    8a78:	e1a02009 	mov	r2, r9
    8a7c:	eb000110 	bl	8ec4 <wc>
    8a80:	e1a0a000 	mov	sl, r0
    8a84:	eaffff0b 	b	86b8 <main+0x678>
          && st.st_size <= MIN (10 * 1024 * 1024, physmem_available () / 2))
    8a88:	eddd7a14 	vldr	s15, [sp, #80]	@ 0x50
    8a8c:	ed9f9b4b 	vldr	d9, [pc, #300]	@ 8bc0 <main+0xb80>
    8a90:	eeb88be7 	vcvt.f64.s32	d8, s15
    8a94:	eb000a99 	bl	b500 <physmem_available>
    8a98:	ee200b09 	vmul.f64	d0, d0, d9
    8a9c:	ed9f7b49 	vldr	d7, [pc, #292]	@ 8bc8 <main+0xb88>
    8aa0:	eeb40bc7 	vcmpe.f64	d0, d7
    8aa4:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    8aa8:	da00001c 	ble	8b20 <main+0xae0>
    8aac:	eeb48bc7 	vcmpe.f64	d8, d7
    8ab0:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    8ab4:	8afffe42 	bhi	83c4 <main+0x384>
          readtokens0_init (&tok);
    8ab8:	e28d0098 	add	r0, sp, #152	@ 0x98
    8abc:	eb001368 	bl	d864 <readtokens0_init>
          if (! readtokens0 (stream, &tok) || fclose (stream) != 0)
    8ac0:	e28d1098 	add	r1, sp, #152	@ 0x98
    8ac4:	e1a00005 	mov	r0, r5
    8ac8:	eb001390 	bl	d910 <readtokens0>
    8acc:	e2504000 	subs	r4, r0, #0
    8ad0:	0a000018 	beq	8b38 <main+0xaf8>
    8ad4:	e1a00005 	mov	r0, r5
    8ad8:	eb000606 	bl	a2f8 <rpl_fclose>
    8adc:	e3500000 	cmp	r0, #0
    8ae0:	1a000014 	bne	8b38 <main+0xaf8>
          files = tok.tok;
    8ae4:	e59d509c 	ldr	r5, [sp, #156]	@ 0x9c
          nfiles = tok.n_tok;
    8ae8:	e59d7098 	ldr	r7, [sp, #152]	@ 0x98
          ai = argv_iter_init_argv (files);
    8aec:	e1a00005 	mov	r0, r5
    8af0:	eb0004b5 	bl	9dcc <argv_iter_init_argv>
  if (!ai)
    8af4:	e2508000 	subs	r8, r0, #0
    8af8:	0a00000d 	beq	8b34 <main+0xaf4>
  struct fstatus *fstatus = xnmalloc (nfiles ? nfiles : 1, sizeof *fstatus);
    8afc:	e3570001 	cmp	r7, #1
    8b00:	e3a01060 	mov	r1, #96	@ 0x60
    8b04:	21a00007 	movcs	r0, r7
    8b08:	33a00001 	movcc	r0, #1
    8b0c:	eb001557 	bl	e070 <xnmalloc>
  if (nfiles == 0
    8b10:	e3570000 	cmp	r7, #0
  struct fstatus *fstatus = xnmalloc (nfiles ? nfiles : 1, sizeof *fstatus);
    8b14:	e1a09000 	mov	r9, r0
  if (nfiles == 0
    8b18:	1afffe8d 	bne	8554 <main+0x514>
    8b1c:	eafffe32 	b	83ec <main+0x3ac>
          && st.st_size <= MIN (10 * 1024 * 1024, physmem_available () / 2))
    8b20:	eb000a76 	bl	b500 <physmem_available>
    8b24:	ee207b09 	vmul.f64	d7, d0, d9
    8b28:	eaffffdf 	b	8aac <main+0xa6c>
      case_GETOPT_HELP_CHAR;
    8b2c:	e3a00000 	mov	r0, #0
    8b30:	eb0002f9 	bl	971c <usage>
              xalloc_die ();
    8b34:	eb00160e 	bl	e374 <xalloc_die>
            error (EXIT_FAILURE, 0, _("cannot read file names from %s"),
    8b38:	e1a0100b 	mov	r1, fp
    8b3c:	e3a00004 	mov	r0, #4
    8b40:	eb0011c0 	bl	d248 <quotearg_style>
    8b44:	e30829b8 	movw	r2, #35256	@ 0x89b8
    8b48:	e1a03000 	mov	r3, r0
    8b4c:	e3402002 	movt	r2, #2
    8b50:	e3a01000 	mov	r1, #0
    8b54:	e3a00001 	mov	r0, #1
    8b58:	eb000573 	bl	a12c <error>
          error (0, 0, _("extra operand %s"), quoteaf (argv[optind]));
    8b5c:	e7951107 	ldr	r1, [r5, r7, lsl #2]
    8b60:	e3a00004 	mov	r0, #4
    8b64:	eb0011b7 	bl	d248 <quotearg_style>
    8b68:	e3a01000 	mov	r1, #0
    8b6c:	e3082950 	movw	r2, #35152	@ 0x8950
    8b70:	e1a03000 	mov	r3, r0
    8b74:	e3402002 	movt	r2, #2
    8b78:	e1a00001 	mov	r0, r1
    8b7c:	eb00056a 	bl	a12c <error>
          fprintf (stderr, "%s\n",
    8b80:	e59a3000 	ldr	r3, [sl]
    8b84:	e3082964 	movw	r2, #35172	@ 0x8964
    8b88:	e3081e3c 	movw	r1, #36412	@ 0x8e3c
    8b8c:	e3402002 	movt	r2, #2
    8b90:	e3401002 	movt	r1, #2
    8b94:	e593000c 	ldr	r0, [r3, #12]
    8b98:	eb003ee1 	bl	18724 <fprintf>
    8b9c:	eafffd9b 	b	8210 <main+0x1d0>
              affirm (!"unexpected error code from argv_iter");
    8ba0:	e30839e8 	movw	r3, #35304	@ 0x89e8
    8ba4:	e3080a10 	movw	r0, #35344	@ 0x8a10
    8ba8:	e59f2028 	ldr	r2, [pc, #40]	@ 8bd8 <main+0xb98>
    8bac:	e3403002 	movt	r3, #2
    8bb0:	e3a01feb 	mov	r1, #940	@ 0x3ac
    8bb4:	e3400002 	movt	r0, #2
    8bb8:	eb0036d8 	bl	16720 <__assert_func>
    8bbc:	e320f000 	nop	{0}
    8bc0:	00000000 	.word	0x00000000
    8bc4:	3fe00000 	.word	0x3fe00000
    8bc8:	00000000 	.word	0x00000000
    8bcc:	41640000 	.word	0x41640000
    8bd0:	00029be8 	.word	0x00029be8
    8bd4:	0002b398 	.word	0x0002b398
    8bd8:	00029cb0 	.word	0x00029cb0

00008bdc <deregister_tm_clones>:
    8bdc:	e30b0318 	movw	r0, #45848	@ 0xb318
    8be0:	e30b3318 	movw	r3, #45848	@ 0xb318
    8be4:	e3400002 	movt	r0, #2
    8be8:	e3403002 	movt	r3, #2
    8bec:	e1530000 	cmp	r3, r0
    8bf0:	012fff1e 	bxeq	lr
    8bf4:	e3003000 	movw	r3, #0
    8bf8:	e3403000 	movt	r3, #0
    8bfc:	e3530000 	cmp	r3, #0
    8c00:	012fff1e 	bxeq	lr
    8c04:	e12fff13 	bx	r3

00008c08 <register_tm_clones>:
    8c08:	e30b0318 	movw	r0, #45848	@ 0xb318
    8c0c:	e30b3318 	movw	r3, #45848	@ 0xb318
    8c10:	e3400002 	movt	r0, #2
    8c14:	e3403002 	movt	r3, #2
    8c18:	e0433000 	sub	r3, r3, r0
    8c1c:	e1a01fa3 	lsr	r1, r3, #31
    8c20:	e0811143 	add	r1, r1, r3, asr #2
    8c24:	e1b010c1 	asrs	r1, r1, #1
    8c28:	012fff1e 	bxeq	lr
    8c2c:	e3003000 	movw	r3, #0
    8c30:	e3403000 	movt	r3, #0
    8c34:	e3530000 	cmp	r3, #0
    8c38:	012fff1e 	bxeq	lr
    8c3c:	e12fff13 	bx	r3

00008c40 <__do_global_dtors_aux>:
    8c40:	e92d4010 	push	{r4, lr}
    8c44:	e30b4318 	movw	r4, #45848	@ 0xb318
    8c48:	e3404002 	movt	r4, #2
    8c4c:	e5d43000 	ldrb	r3, [r4]
    8c50:	e3530000 	cmp	r3, #0
    8c54:	18bd8010 	popne	{r4, pc}
    8c58:	ebffffdf 	bl	8bdc <deregister_tm_clones>
    8c5c:	e3003000 	movw	r3, #0
    8c60:	e3403000 	movt	r3, #0
    8c64:	e3530000 	cmp	r3, #0
    8c68:	0a000002 	beq	8c78 <__do_global_dtors_aux+0x38>
    8c6c:	e30a025c 	movw	r0, #41564	@ 0xa25c
    8c70:	e3400002 	movt	r0, #2
    8c74:	e320f000 	nop	{0}
    8c78:	e3a03001 	mov	r3, #1
    8c7c:	e5c43000 	strb	r3, [r4]
    8c80:	e8bd8010 	pop	{r4, pc}

00008c84 <frame_dummy>:
    8c84:	e3003000 	movw	r3, #0
    8c88:	e3403000 	movt	r3, #0
    8c8c:	e3530000 	cmp	r3, #0
    8c90:	0a000007 	beq	8cb4 <frame_dummy+0x30>
    8c94:	e30b131c 	movw	r1, #45852	@ 0xb31c
    8c98:	e30a025c 	movw	r0, #41564	@ 0xa25c
    8c9c:	e92d4010 	push	{r4, lr}
    8ca0:	e3401002 	movt	r1, #2
    8ca4:	e3400002 	movt	r0, #2
    8ca8:	e320f000 	nop	{0}
    8cac:	e8bd4010 	pop	{r4, lr}
    8cb0:	eaffffd4 	b	8c08 <register_tm_clones>
    8cb4:	eaffffd3 	b	8c08 <register_tm_clones>

00008cb8 <_start>:
  .text
  .globl  _start
_start:
  // Clear the frame pointer register (R11) so that stack backtraces will be
  // terminated properly.
  mov     r11, #0
    8cb8:	e3a0b000 	mov	fp, #0

  // Save program name into the global variable
  ldr     r3, =__progname
    8cbc:	e59f3034 	ldr	r3, [pc, #52]	@ 8cf8 <_start+0x40>
  cmp     r1, #0
    8cc0:	e3510000 	cmp	r1, #0
  beq     1f
    8cc4:	0a000002 	beq	8cd4 <_start+0x1c>
  ldr     r4, [r1]
    8cc8:	e5914000 	ldr	r4, [r1]
  cmp     r4, #0
    8ccc:	e3540000 	cmp	r4, #0
  strne   r4, [r3]
    8cd0:	15834000 	strne	r4, [r3]
1:

  // Save environment into the global variable
  ldr     r3, =environ
    8cd4:	e59f3020 	ldr	r3, [pc, #32]	@ 8cfc <_start+0x44>
  cmp     r2, #0
    8cd8:	e3520000 	cmp	r2, #0
  strne   r2, [r3]
    8cdc:	15832000 	strne	r2, [r3]

  stmdb   sp!,{r0-r2}
    8ce0:	e92d0007 	push	{r0, r1, r2}

  bl      __libc_init_array
    8ce4:	eb004ace 	bl	1b824 <__libc_init_array>

  ldmia   sp!,{r0-r2}
    8ce8:	e8bd0007 	pop	{r0, r1, r2}

  // Call the user main routine.
  bl      main
    8cec:	ebfffcd3 	bl	8040 <main>

  // Terminate the process with the exit code from main().
  bl      exit
    8cf0:	eb0036a9 	bl	1679c <exit>

  // Should not return.
  b       .         
    8cf4:	eafffffe 	b	8cf4 <_start+0x3c>
  ldr     r3, =__progname
    8cf8:	0002b85c 	.word	0x0002b85c
  ldr     r3, =environ
    8cfc:	0002b068 	.word	0x0002b068

00008d00 <write_counts>:
{
    8d00:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  if (print_lines)
    8d04:	e30b4338 	movw	r4, #45880	@ 0xb338
    8d08:	e3404002 	movt	r4, #2
{
    8d0c:	e1a07003 	mov	r7, r3
    8d10:	e24dd018 	sub	sp, sp, #24
    8d14:	e1a08002 	mov	r8, r2
  if (print_lines)
    8d18:	e5d43000 	ldrb	r3, [r4]
{
    8d1c:	e59d6048 	ldr	r6, [sp, #72]	@ 0x48
  if (print_lines)
    8d20:	e3530000 	cmp	r3, #0
  char const *format_int = format_sp_int + 1;
    8d24:	059f5194 	ldreq	r5, [pc, #404]	@ 8ec0 <write_counts+0x1c0>
  if (print_lines)
    8d28:	1a00005a 	bne	8e98 <write_counts+0x198>
  if (print_words)
    8d2c:	e5d43008 	ldrb	r3, [r4, #8]
    8d30:	e3530000 	cmp	r3, #0
    8d34:	1a00004b 	bne	8e68 <write_counts+0x168>
  if (print_chars)
    8d38:	e5d43009 	ldrb	r3, [r4, #9]
    8d3c:	e3530000 	cmp	r3, #0
    8d40:	1a00003d 	bne	8e3c <write_counts+0x13c>
  if (print_bytes)
    8d44:	e5d4300a 	ldrb	r3, [r4, #10]
    8d48:	e3530000 	cmp	r3, #0
    8d4c:	1a00002f 	bne	8e10 <write_counts+0x110>
  if (print_linelength)
    8d50:	e5d4300b 	ldrb	r3, [r4, #11]
    8d54:	e3530000 	cmp	r3, #0
    8d58:	1a000023 	bne	8dec <write_counts+0xec>
  if (file)
    8d5c:	e3560000 	cmp	r6, #0
    8d60:	0a00000d 	beq	8d9c <write_counts+0x9c>
    printf (" %s", strchr (file, '\n') ? quotef (file) : file);
    8d64:	e3a0100a 	mov	r1, #10
    8d68:	e1a00006 	mov	r0, r6
    8d6c:	eb00468d 	bl	1a7a8 <strchr>
    8d70:	e3500000 	cmp	r0, #0
    8d74:	0a000004 	beq	8d8c <write_counts+0x8c>
    8d78:	e1a02006 	mov	r2, r6
    8d7c:	e3a01003 	mov	r1, #3
    8d80:	e3a00000 	mov	r0, #0
    8d84:	eb0011ce 	bl	d4c4 <quotearg_n_style_colon>
    8d88:	e1a06000 	mov	r6, r0
    8d8c:	e3080bec 	movw	r0, #35820	@ 0x8bec
    8d90:	e1a01006 	mov	r1, r6
    8d94:	e3400002 	movt	r0, #2
    8d98:	eb004073 	bl	18f6c <printf>
static __inline int
_putchar_unlocked(int _c)
{
	struct _reent *_ptr;

	_ptr = _REENT;
    8d9c:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
    8da0:	e3403002 	movt	r3, #2
    8da4:	e5930000 	ldr	r0, [r3]
	return (__sputc_r(_ptr, _c, _stdout_r(_ptr)));
    8da8:	e5902008 	ldr	r2, [r0, #8]
	if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
    8dac:	e5923008 	ldr	r3, [r2, #8]
    8db0:	e2433001 	sub	r3, r3, #1
    8db4:	e3530000 	cmp	r3, #0
    8db8:	e5823008 	str	r3, [r2, #8]
    8dbc:	aa000003 	bge	8dd0 <write_counts+0xd0>
		return (__swbuf_r(_ptr, _c, _p));
    8dc0:	e3a0100a 	mov	r1, #10
    8dc4:	eb00427e 	bl	197c4 <__swbuf_r>
}
    8dc8:	e28dd018 	add	sp, sp, #24
    8dcc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
		return (*_p->_p++ = _c);
    8dd0:	e5923000 	ldr	r3, [r2]
    8dd4:	e3a0100a 	mov	r1, #10
    8dd8:	e2830001 	add	r0, r3, #1
    8ddc:	e5820000 	str	r0, [r2]
    8de0:	e5c31000 	strb	r1, [r3]
    8de4:	e28dd018 	add	sp, sp, #24
    8de8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
      printf (format_int, number_width, umaxtostr (linelength, buf));
    8dec:	e5944004 	ldr	r4, [r4, #4]
    8df0:	e1a0200d 	mov	r2, sp
    8df4:	e1cd04d0 	ldrd	r0, [sp, #64]	@ 0x40
    8df8:	eb000974 	bl	b3d0 <umaxtostr>
    8dfc:	e1a01004 	mov	r1, r4
    8e00:	e1a02000 	mov	r2, r0
    8e04:	e1a00005 	mov	r0, r5
    8e08:	eb004057 	bl	18f6c <printf>
    8e0c:	eaffffd2 	b	8d5c <write_counts+0x5c>
      printf (format_int, number_width, umaxtostr (bytes, buf));
    8e10:	e5947004 	ldr	r7, [r4, #4]
    8e14:	e1a0200d 	mov	r2, sp
    8e18:	e1cd03d8 	ldrd	r0, [sp, #56]	@ 0x38
    8e1c:	eb00096b 	bl	b3d0 <umaxtostr>
    8e20:	e1a01007 	mov	r1, r7
    8e24:	e1a02000 	mov	r2, r0
    8e28:	e1a00005 	mov	r0, r5
      format_int = format_sp_int;
    8e2c:	e3095ba8 	movw	r5, #39848	@ 0x9ba8
    8e30:	e3405002 	movt	r5, #2
      printf (format_int, number_width, umaxtostr (bytes, buf));
    8e34:	eb00404c 	bl	18f6c <printf>
      format_int = format_sp_int;
    8e38:	eaffffc4 	b	8d50 <write_counts+0x50>
      printf (format_int, number_width, umaxtostr (chars, buf));
    8e3c:	e5947004 	ldr	r7, [r4, #4]
    8e40:	e1a0200d 	mov	r2, sp
    8e44:	e1cd03d0 	ldrd	r0, [sp, #48]	@ 0x30
    8e48:	eb000960 	bl	b3d0 <umaxtostr>
    8e4c:	e1a01007 	mov	r1, r7
    8e50:	e1a02000 	mov	r2, r0
    8e54:	e1a00005 	mov	r0, r5
      format_int = format_sp_int;
    8e58:	e3095ba8 	movw	r5, #39848	@ 0x9ba8
    8e5c:	e3405002 	movt	r5, #2
      printf (format_int, number_width, umaxtostr (chars, buf));
    8e60:	eb004041 	bl	18f6c <printf>
      format_int = format_sp_int;
    8e64:	eaffffb6 	b	8d44 <write_counts+0x44>
      printf (format_int, number_width, umaxtostr (words, buf));
    8e68:	e1a01007 	mov	r1, r7
    8e6c:	e5947004 	ldr	r7, [r4, #4]
    8e70:	e1a0200d 	mov	r2, sp
    8e74:	e1a00008 	mov	r0, r8
    8e78:	eb000954 	bl	b3d0 <umaxtostr>
    8e7c:	e1a01007 	mov	r1, r7
    8e80:	e1a02000 	mov	r2, r0
    8e84:	e1a00005 	mov	r0, r5
      format_int = format_sp_int;
    8e88:	e3095ba8 	movw	r5, #39848	@ 0x9ba8
    8e8c:	e3405002 	movt	r5, #2
      printf (format_int, number_width, umaxtostr (words, buf));
    8e90:	eb004035 	bl	18f6c <printf>
      format_int = format_sp_int;
    8e94:	eaffffa7 	b	8d38 <write_counts+0x38>
      printf (format_int, number_width, umaxtostr (lines, buf));
    8e98:	e5945004 	ldr	r5, [r4, #4]
    8e9c:	e1a0200d 	mov	r2, sp
    8ea0:	eb00094a 	bl	b3d0 <umaxtostr>
    8ea4:	e1a02000 	mov	r2, r0
    8ea8:	e59f0010 	ldr	r0, [pc, #16]	@ 8ec0 <write_counts+0x1c0>
    8eac:	e1a01005 	mov	r1, r5
      format_int = format_sp_int;
    8eb0:	e3095ba8 	movw	r5, #39848	@ 0x9ba8
    8eb4:	e3405002 	movt	r5, #2
      printf (format_int, number_width, umaxtostr (lines, buf));
    8eb8:	eb00402b 	bl	18f6c <printf>
      format_int = format_sp_int;
    8ebc:	eaffff9a 	b	8d2c <write_counts+0x2c>
    8ec0:	00029ba9 	.word	0x00029ba9

00008ec4 <wc>:
  char const *file = file_x ? file_x : _("standard input");
    8ec4:	e251c000 	subs	ip, r1, #0
    8ec8:	e308134c 	movw	r1, #33612	@ 0x834c
{
    8ecc:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  char const *file = file_x ? file_x : _("standard input");
    8ed0:	e3401002 	movt	r1, #2
{
    8ed4:	e24dd901 	sub	sp, sp, #16384	@ 0x4000
  count_complicated = print_words || print_linelength;
    8ed8:	e30bb338 	movw	fp, #45880	@ 0xb338
{
    8edc:	e24dd054 	sub	sp, sp, #84	@ 0x54
    8ee0:	e1a05003 	mov	r5, r3
  count_complicated = print_words || print_linelength;
    8ee4:	e340b002 	movt	fp, #2
  char const *file = file_x ? file_x : _("standard input");
    8ee8:	11a0300c 	movne	r3, ip
    8eec:	01a03001 	moveq	r3, r1
{
    8ef0:	e1a04002 	mov	r4, r2
  char const *file = file_x ? file_x : _("standard input");
    8ef4:	e58d3040 	str	r3, [sp, #64]	@ 0x40
      count_bytes = print_bytes || print_chars;
    8ef8:	e5db300a 	ldrb	r3, [fp, #10]
  count_complicated = print_words || print_linelength;
    8efc:	e5db2008 	ldrb	r2, [fp, #8]
  char const *file = file_x ? file_x : _("standard input");
    8f00:	e58dc044 	str	ip, [sp, #68]	@ 0x44
      count_bytes = print_bytes || print_chars;
    8f04:	e3530000 	cmp	r3, #0
{
    8f08:	e58d0034 	str	r0, [sp, #52]	@ 0x34
      count_bytes = print_bytes || print_chars;
    8f0c:	1a000002 	bne	8f1c <wc+0x58>
    8f10:	e5db3009 	ldrb	r3, [fp, #9]
    8f14:	e3530000 	cmp	r3, #0
    8f18:	0a0000ae 	beq	91d8 <wc+0x314>
  count_complicated = print_words || print_linelength;
    8f1c:	e3520000 	cmp	r2, #0
    8f20:	0a00007a 	beq	9110 <wc+0x24c>
    fdadvise (fd, 0, 0, FADVISE_SEQUENTIAL);
    8f24:	e3a02000 	mov	r2, #0
    8f28:	e59d0034 	ldr	r0, [sp, #52]	@ 0x34
    8f2c:	e3a03001 	mov	r3, #1
    8f30:	e1a01002 	mov	r1, r2
    8f34:	eb0004eb 	bl	a2e8 <fdadvise>
                      in_word = true;
    8f38:	e3a02000 	mov	r2, #0
    8f3c:	e28d104c 	add	r1, sp, #76	@ 0x4c
    8f40:	e1a07002 	mov	r7, r2
    8f44:	e1a05002 	mov	r5, r2
    8f48:	e1a08002 	mov	r8, r2
    8f4c:	e1a04002 	mov	r4, r2
    8f50:	e1a09002 	mov	r9, r2
    8f54:	e1a0a002 	mov	sl, r2
    8f58:	e1a06002 	mov	r6, r2
    8f5c:	e58d2028 	str	r2, [sp, #40]	@ 0x28
    8f60:	e58d2024 	str	r2, [sp, #36]	@ 0x24
    8f64:	e58d2020 	str	r2, [sp, #32]
    8f68:	e58d2030 	str	r2, [sp, #48]	@ 0x30
    8f6c:	e58db038 	str	fp, [sp, #56]	@ 0x38
      while ((bytes_read = safe_read (fd, buf, BUFFER_SIZE)) > 0)
    8f70:	e3a02901 	mov	r2, #16384	@ 0x4000
    8f74:	e59d0034 	ldr	r0, [sp, #52]	@ 0x34
    8f78:	e58d102c 	str	r1, [sp, #44]	@ 0x2c
    8f7c:	eb0012c2 	bl	da8c <safe_read>
    8f80:	e2502000 	subs	r2, r0, #0
    8f84:	e59d102c 	ldr	r1, [sp, #44]	@ 0x2c
    8f88:	0a0000cd 	beq	92c4 <wc+0x400>
          if (bytes_read == SAFE_READ_ERROR)
    8f8c:	e3720001 	cmn	r2, #1
    8f90:	0a00012b 	beq	9444 <wc+0x580>
          bytes += bytes_read;
    8f94:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
          char const *p = buf;
    8f98:	e1a0b001 	mov	fp, r1
          bytes += bytes_read;
    8f9c:	e0920003 	adds	r0, r2, r3
    8fa0:	e59d3024 	ldr	r3, [sp, #36]	@ 0x24
    8fa4:	e0812002 	add	r2, r1, r2
    8fa8:	e58d0028 	str	r0, [sp, #40]	@ 0x28
    8fac:	e2a33000 	adc	r3, r3, #0
    8fb0:	e58d3024 	str	r3, [sp, #36]	@ 0x24
          char const *p = buf;
    8fb4:	e59d3030 	ldr	r3, [sp, #48]	@ 0x30
              switch (*p++)
    8fb8:	e4db0001 	ldrb	r0, [fp], #1
    8fbc:	e240c009 	sub	ip, r0, #9
    8fc0:	e35c0017 	cmp	ip, #23
    8fc4:	979ff10c 	ldrls	pc, [pc, ip, lsl #2]
    8fc8:	ea000017 	b	902c <wc+0x168>
    8fcc:	00009100 	.word	0x00009100
    8fd0:	000090ac 	.word	0x000090ac
    8fd4:	000090d4 	.word	0x000090d4
    8fd8:	000090bc 	.word	0x000090bc
    8fdc:	000090bc 	.word	0x000090bc
    8fe0:	0000902c 	.word	0x0000902c
    8fe4:	0000902c 	.word	0x0000902c
    8fe8:	0000902c 	.word	0x0000902c
    8fec:	0000902c 	.word	0x0000902c
    8ff0:	0000902c 	.word	0x0000902c
    8ff4:	0000902c 	.word	0x0000902c
    8ff8:	0000902c 	.word	0x0000902c
    8ffc:	0000902c 	.word	0x0000902c
    9000:	0000902c 	.word	0x0000902c
    9004:	0000902c 	.word	0x0000902c
    9008:	0000902c 	.word	0x0000902c
    900c:	0000902c 	.word	0x0000902c
    9010:	0000902c 	.word	0x0000902c
    9014:	0000902c 	.word	0x0000902c
    9018:	0000902c 	.word	0x0000902c
    901c:	0000902c 	.word	0x0000902c
    9020:	0000902c 	.word	0x0000902c
    9024:	0000902c 	.word	0x0000902c
    9028:	000090f4 	.word	0x000090f4
                  if (isprint (to_uchar (p[-1])))
    902c:	e59fc6e4 	ldr	ip, [pc, #1764]	@ 9718 <wc+0x854>
    9030:	e7dcc000 	ldrb	ip, [ip, r0]
    9034:	e31c0097 	tst	ip, #151	@ 0x97
    9038:	0a000029 	beq	90e4 <wc+0x220>
                      linepos++;
    903c:	e2955001 	adds	r5, r5, #1
    9040:	e2a88000 	adc	r8, r8, #0
                      if (isspace (to_uchar (p[-1]))
    9044:	e31c0008 	tst	ip, #8
    9048:	1a000021 	bne	90d4 <wc+0x210>
  return ! posixly_correct
    904c:	e59dc038 	ldr	ip, [sp, #56]	@ 0x38
    9050:	e5dcc010 	ldrb	ip, [ip, #16]
         && (wc == 0x00A0 || wc == 0x2007
    9054:	e35c0000 	cmp	ip, #0
                      in_word = true;
    9058:	11a0400c 	movne	r4, ip
         && (wc == 0x00A0 || wc == 0x2007
    905c:	1a000020 	bne	90e4 <wc+0x220>
    9060:	e58d103c 	str	r1, [sp, #60]	@ 0x3c
    9064:	e1cd22fc 	strd	r2, [sp, #44]	@ 0x2c
  return iswnbspace (btowc (c));
    9068:	eb0003a8 	bl	9f10 <rpl_btowc>
         && (wc == 0x00A0 || wc == 0x2007
    906c:	e302c007 	movw	ip, #8199	@ 0x2007
    9070:	e1cd22dc 	ldrd	r2, [sp, #44]	@ 0x2c
    9074:	e150000c 	cmp	r0, ip
    9078:	135000a0 	cmpne	r0, #160	@ 0xa0
    907c:	e59d103c 	ldr	r1, [sp, #60]	@ 0x3c
    9080:	0a000013 	beq	90d4 <wc+0x210>
             || wc == 0x202F || wc == 0x2060);
    9084:	e302e02f 	movw	lr, #8239	@ 0x202f
    9088:	e302c060 	movw	ip, #8288	@ 0x2060
    908c:	e150000c 	cmp	r0, ip
    9090:	1150000e 	cmpne	r0, lr
                      in_word = true;
    9094:	13a04001 	movne	r4, #1
             || wc == 0x202F || wc == 0x2060);
    9098:	0a00000d 	beq	90d4 <wc+0x210>
          while (--bytes_read);
    909c:	e152000b 	cmp	r2, fp
    90a0:	1affffc4 	bne	8fb8 <wc+0xf4>
    90a4:	e58d3030 	str	r3, [sp, #48]	@ 0x30
    90a8:	eaffffb0 	b	8f70 <wc+0xac>
                  lines++;
    90ac:	e59d0020 	ldr	r0, [sp, #32]
    90b0:	e2999001 	adds	r9, r9, #1
    90b4:	e2a00000 	adc	r0, r0, #0
    90b8:	e58d0020 	str	r0, [sp, #32]
                  if (linepos > linelength)
    90bc:	e15a0005 	cmp	sl, r5
    90c0:	e0d30008 	sbcs	r0, r3, r8
    90c4:	31a0a005 	movcc	sl, r5
                  linepos = 0;
    90c8:	e3a05000 	mov	r5, #0
                  if (linepos > linelength)
    90cc:	31a03008 	movcc	r3, r8
                  linepos = 0;
    90d0:	e1a08005 	mov	r8, r5
                  words += in_word;
    90d4:	e0944006 	adds	r4, r4, r6
    90d8:	e1a06004 	mov	r6, r4
    90dc:	e2a77000 	adc	r7, r7, #0
                  in_word = false;
    90e0:	e3a04000 	mov	r4, #0
          while (--bytes_read);
    90e4:	e152000b 	cmp	r2, fp
    90e8:	1affffb2 	bne	8fb8 <wc+0xf4>
    90ec:	e58d3030 	str	r3, [sp, #48]	@ 0x30
    90f0:	eaffff9e 	b	8f70 <wc+0xac>
                  linepos++;
    90f4:	e2955001 	adds	r5, r5, #1
    90f8:	e2a88000 	adc	r8, r8, #0
    90fc:	eafffff4 	b	90d4 <wc+0x210>
                  linepos += 8 - (linepos % 8);
    9100:	e3c55007 	bic	r5, r5, #7
    9104:	e2955008 	adds	r5, r5, #8
    9108:	e2a88000 	adc	r8, r8, #0
                  goto word_separator;
    910c:	eafffff0 	b	90d4 <wc+0x210>
  count_complicated = print_words || print_linelength;
    9110:	e5db300b 	ldrb	r3, [fp, #11]
    9114:	e3530000 	cmp	r3, #0
    9118:	e58d3030 	str	r3, [sp, #48]	@ 0x30
    911c:	1a000157 	bne	9680 <wc+0x7bc>
  if (!count_bytes || count_chars || print_lines || count_complicated)
    9120:	e5db3000 	ldrb	r3, [fp]
    9124:	e3530000 	cmp	r3, #0
    9128:	1a000172 	bne	96f8 <wc+0x834>
      if (0 < fstatus->failed)
    912c:	e5947000 	ldr	r7, [r4]
    9130:	e3570000 	cmp	r7, #0
    9134:	da000004 	ble	914c <wc+0x288>
        fstatus->failed = fstat (fd, &fstatus->st);
    9138:	e59d0034 	ldr	r0, [sp, #52]	@ 0x34
    913c:	e2841008 	add	r1, r4, #8
    9140:	eb005930 	bl	1f608 <fstat>
    9144:	e1a07000 	mov	r7, r0
    9148:	e5840000 	str	r0, [r4]
      if (! fstatus->failed && usable_st_size (&fstatus->st)
    914c:	e3570000 	cmp	r7, #0
    9150:	1a0000e3 	bne	94e4 <wc+0x620>

/* Return a boolean indicating whether SB->st_size is defined.  */
static inline bool
usable_st_size (struct stat const *sb)
{
  return (S_ISREG (sb->st_mode) || S_ISLNK (sb->st_mode)
    9154:	e594300c 	ldr	r3, [r4, #12]
    9158:	e2033a0d 	and	r3, r3, #53248	@ 0xd000
    915c:	e3530902 	cmp	r3, #32768	@ 0x8000
    9160:	1a0000df 	bne	94e4 <wc+0x620>
          && 0 <= fstatus->st.st_size)
    9164:	e5946018 	ldr	r6, [r4, #24]
    9168:	e3560000 	cmp	r6, #0
    916c:	ba0000dc 	blt	94e4 <wc+0x620>
          if (current_pos < 0)
    9170:	e3750001 	cmn	r5, #1
    9174:	0a0000c6 	beq	9494 <wc+0x5d0>
          if (end_pos % page_size)
    9178:	e59b100c 	ldr	r1, [fp, #12]
    917c:	e1a00006 	mov	r0, r6
    9180:	eb003471 	bl	1634c <__aeabi_uidivmod>
    9184:	e3510000 	cmp	r1, #0
    9188:	0a000141 	beq	9694 <wc+0x7d0>
              bytes = end_pos < current_pos ? 0 : end_pos - current_pos;
    918c:	e1a03fc6 	asr	r3, r6, #31
    9190:	e58d6028 	str	r6, [sp, #40]	@ 0x28
    9194:	e58d3024 	str	r3, [sp, #36]	@ 0x24
              if (bytes && 0 <= lseek (fd, bytes, SEEK_CUR))
    9198:	e59d0034 	ldr	r0, [sp, #52]	@ 0x34
    919c:	e1a01006 	mov	r1, r6
    91a0:	e3a02001 	mov	r2, #1
    91a4:	eb00599d 	bl	1f820 <lseek>
    91a8:	e3500000 	cmp	r0, #0
    91ac:	ba0000cc 	blt	94e4 <wc+0x620>
  lines = words = chars = bytes = linelength = 0;
    91b0:	e3a03000 	mov	r3, #0
  bool ok = true;
    91b4:	e3a02001 	mov	r2, #1
  lines = words = chars = bytes = linelength = 0;
    91b8:	e1a07003 	mov	r7, r3
    91bc:	e1a09003 	mov	r9, r3
    91c0:	e1a0a003 	mov	sl, r3
    91c4:	e1a04003 	mov	r4, r3
    91c8:	e58d302c 	str	r3, [sp, #44]	@ 0x2c
  bool ok = true;
    91cc:	e58d2030 	str	r2, [sp, #48]	@ 0x30
  lines = words = chars = bytes = linelength = 0;
    91d0:	e58d3020 	str	r3, [sp, #32]
    91d4:	ea000046 	b	92f4 <wc+0x430>
  count_complicated = print_words || print_linelength;
    91d8:	e3520000 	cmp	r2, #0
    91dc:	1affff50 	bne	8f24 <wc+0x60>
    91e0:	e5db200b 	ldrb	r2, [fp, #11]
    91e4:	e3520000 	cmp	r2, #0
    91e8:	1affff4d 	bne	8f24 <wc+0x60>
    fdadvise (fd, 0, 0, FADVISE_SEQUENTIAL);
    91ec:	e3a03001 	mov	r3, #1
    91f0:	e1a01002 	mov	r1, r2
    91f4:	eb00043b 	bl	a2e8 <fdadvise>
  bool long_lines = false;
    91f8:	e3a04000 	mov	r4, #0
    91fc:	e28d104c 	add	r1, sp, #76	@ 0x4c
      if (lines - plines <= bytes_read / 15)
    9200:	e3088889 	movw	r8, #34953	@ 0x8889
    9204:	e58db030 	str	fp, [sp, #48]	@ 0x30
  lines = bytes = 0;
    9208:	e1a05004 	mov	r5, r4
    920c:	e1a06004 	mov	r6, r4
    9210:	e1a07004 	mov	r7, r4
          *end = '\n';
    9214:	e3a0900a 	mov	r9, #10
    9218:	e1a0b001 	mov	fp, r1
      if (lines - plines <= bytes_read / 15)
    921c:	e3488888 	movt	r8, #34952	@ 0x8888
  lines = bytes = 0;
    9220:	e58d4024 	str	r4, [sp, #36]	@ 0x24
    9224:	e58d8020 	str	r8, [sp, #32]
  while ((bytes_read = safe_read (fd, buf, BUFFER_SIZE)) > 0)
    9228:	e59d0034 	ldr	r0, [sp, #52]	@ 0x34
    922c:	e3a02901 	mov	r2, #16384	@ 0x4000
    9230:	e1a0100b 	mov	r1, fp
    9234:	eb001214 	bl	da8c <safe_read>
    9238:	e250c000 	subs	ip, r0, #0
    923c:	0a0000f2 	beq	960c <wc+0x748>
      if (bytes_read == SAFE_READ_ERROR)
    9240:	e37c0001 	cmn	ip, #1
    9244:	0a0000d8 	beq	95ac <wc+0x6e8>
      bytes += bytes_read;
    9248:	e59d3024 	ldr	r3, [sp, #36]	@ 0x24
    924c:	e09c5005 	adds	r5, ip, r5
      char *end = buf + bytes_read;
    9250:	e08ba00c 	add	sl, fp, ip
      bytes += bytes_read;
    9254:	e2a33000 	adc	r3, r3, #0
      if (! long_lines)
    9258:	e3540000 	cmp	r4, #0
      bytes += bytes_read;
    925c:	e58d3024 	str	r3, [sp, #36]	@ 0x24
      if (! long_lines)
    9260:	1a0000c2 	bne	9570 <wc+0x6ac>
    9264:	e1a04006 	mov	r4, r6
    9268:	e1a08007 	mov	r8, r7
      char *p = buf;
    926c:	e1a0000b 	mov	r0, fp
            lines += *p++ == '\n';
    9270:	e4d03001 	ldrb	r3, [r0], #1
    9274:	e243300a 	sub	r3, r3, #10
    9278:	e16f3f13 	clz	r3, r3
    927c:	e1a032a3 	lsr	r3, r3, #5
    9280:	e0934004 	adds	r4, r3, r4
    9284:	e2a88000 	adc	r8, r8, #0
          while (p != end)
    9288:	e15a0000 	cmp	sl, r0
    928c:	1afffff7 	bne	9270 <wc+0x3ac>
      if (lines - plines <= bytes_read / 15)
    9290:	e59d3020 	ldr	r3, [sp, #32]
    9294:	e054e006 	subs	lr, r4, r6
    9298:	e3a02000 	mov	r2, #0
    929c:	e1a06004 	mov	r6, r4
    92a0:	e08c3c93 	umull	r3, ip, r3, ip
    92a4:	e0c83007 	sbc	r3, r8, r7
    92a8:	e1a07008 	mov	r7, r8
    92ac:	e1a0c1ac 	lsr	ip, ip, #3
    92b0:	e15c000e 	cmp	ip, lr
    92b4:	e0d22003 	sbcs	r2, r2, r3
    92b8:	23a04001 	movcs	r4, #1
    92bc:	33a04000 	movcc	r4, #0
    92c0:	eaffffd8 	b	9228 <wc+0x364>
  bool ok = true;
    92c4:	e59db038 	ldr	fp, [sp, #56]	@ 0x38
    92c8:	e3a03001 	mov	r3, #1
    92cc:	e58d902c 	str	r9, [sp, #44]	@ 0x2c
    92d0:	e1a0900a 	mov	r9, sl
    92d4:	e59da030 	ldr	sl, [sp, #48]	@ 0x30
    92d8:	e58d3030 	str	r3, [sp, #48]	@ 0x30
      if (linepos > linelength)
    92dc:	e1590005 	cmp	r9, r5
    92e0:	e0da3008 	sbcs	r3, sl, r8
    92e4:	31a09005 	movcc	r9, r5
    92e8:	31a0a008 	movcc	sl, r8
      words += in_word;
    92ec:	e0944006 	adds	r4, r4, r6
    92f0:	e2a77000 	adc	r7, r7, #0
  if (count_chars < print_chars)
    92f4:	e5db5009 	ldrb	r5, [fp, #9]
  if (total_mode != total_only)
    92f8:	e5db3011 	ldrb	r3, [fp, #17]
  if (count_chars < print_chars)
    92fc:	e3550000 	cmp	r5, #0
    chars = bytes;
    9300:	159d5028 	ldrne	r5, [sp, #40]	@ 0x28
  lines = words = chars = bytes = linelength = 0;
    9304:	01a06005 	moveq	r6, r5
    chars = bytes;
    9308:	159d6024 	ldrne	r6, [sp, #36]	@ 0x24
  if (total_mode != total_only)
    930c:	e3530002 	cmp	r3, #2
    9310:	0a00000d 	beq	934c <wc+0x488>
    write_counts (lines, words, chars, bytes, linelength, file_x);
    9314:	e59d3044 	ldr	r3, [sp, #68]	@ 0x44
    9318:	e1a02004 	mov	r2, r4
    931c:	e59d002c 	ldr	r0, [sp, #44]	@ 0x2c
    9320:	e59d1020 	ldr	r1, [sp, #32]
    9324:	e58d3018 	str	r3, [sp, #24]
    9328:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
    932c:	e58d9010 	str	r9, [sp, #16]
    9330:	e58da014 	str	sl, [sp, #20]
    9334:	e58d3008 	str	r3, [sp, #8]
    9338:	e59d3024 	ldr	r3, [sp, #36]	@ 0x24
    933c:	e88d0060 	stm	sp, {r5, r6}
    9340:	e58d300c 	str	r3, [sp, #12]
    9344:	e1a03007 	mov	r3, r7
    9348:	ebfffe6c 	bl	8d00 <write_counts>
  if (ckd_add (&total_lines, total_lines, lines))
    934c:	e59b3018 	ldr	r3, [fp, #24]
    9350:	e59d202c 	ldr	r2, [sp, #44]	@ 0x2c
    9354:	e59d1020 	ldr	r1, [sp, #32]
}
    9358:	e59d0030 	ldr	r0, [sp, #48]	@ 0x30
  if (ckd_add (&total_lines, total_lines, lines))
    935c:	e0933002 	adds	r3, r3, r2
    9360:	e59b201c 	ldr	r2, [fp, #28]
    9364:	e58b3018 	str	r3, [fp, #24]
    9368:	e0b22001 	adcs	r2, r2, r1
    936c:	e3a01000 	mov	r1, #0
    9370:	23a01001 	movcs	r1, #1
    9374:	e58b201c 	str	r2, [fp, #28]
    9378:	e3510000 	cmp	r1, #0
  if (ckd_add (&total_words, total_words, words))
    937c:	e3a01000 	mov	r1, #0
    total_lines_overflow = true;
    9380:	13a02001 	movne	r2, #1
    9384:	13a03000 	movne	r3, #0
    9388:	11cb22f0 	strdne	r2, [fp, #32]
  if (ckd_add (&total_words, total_words, words))
    938c:	e59b3028 	ldr	r3, [fp, #40]	@ 0x28
    9390:	e59b202c 	ldr	r2, [fp, #44]	@ 0x2c
    9394:	e0933004 	adds	r3, r3, r4
    9398:	e0b22007 	adcs	r2, r2, r7
    939c:	e58b3028 	str	r3, [fp, #40]	@ 0x28
    93a0:	23a01001 	movcs	r1, #1
    93a4:	e58b202c 	str	r2, [fp, #44]	@ 0x2c
    93a8:	e3510000 	cmp	r1, #0
  if (ckd_add (&total_chars, total_chars, chars))
    93ac:	e3a01000 	mov	r1, #0
    total_words_overflow = true;
    93b0:	13a02001 	movne	r2, #1
    93b4:	13a03000 	movne	r3, #0
    93b8:	11cb23f0 	strdne	r2, [fp, #48]	@ 0x30
  if (ckd_add (&total_chars, total_chars, chars))
    93bc:	e59b3038 	ldr	r3, [fp, #56]	@ 0x38
    93c0:	e59b203c 	ldr	r2, [fp, #60]	@ 0x3c
    93c4:	e0933005 	adds	r3, r3, r5
    93c8:	e0b22006 	adcs	r2, r2, r6
    93cc:	e58b3038 	str	r3, [fp, #56]	@ 0x38
    93d0:	23a01001 	movcs	r1, #1
    93d4:	e58b203c 	str	r2, [fp, #60]	@ 0x3c
    93d8:	e3510000 	cmp	r1, #0
  if (ckd_add (&total_bytes, total_bytes, bytes))
    93dc:	e59d1024 	ldr	r1, [sp, #36]	@ 0x24
    total_chars_overflow = true;
    93e0:	13a02001 	movne	r2, #1
    93e4:	13a03000 	movne	r3, #0
    93e8:	11cb24f0 	strdne	r2, [fp, #64]	@ 0x40
  if (ckd_add (&total_bytes, total_bytes, bytes))
    93ec:	e59b3048 	ldr	r3, [fp, #72]	@ 0x48
    93f0:	e59d2028 	ldr	r2, [sp, #40]	@ 0x28
    93f4:	e0933002 	adds	r3, r3, r2
    93f8:	e59b204c 	ldr	r2, [fp, #76]	@ 0x4c
    93fc:	e58b3048 	str	r3, [fp, #72]	@ 0x48
    9400:	e0b22001 	adcs	r2, r2, r1
    9404:	e3a01000 	mov	r1, #0
    9408:	23a01001 	movcs	r1, #1
    940c:	e58b204c 	str	r2, [fp, #76]	@ 0x4c
    9410:	e3510000 	cmp	r1, #0
    total_bytes_overflow = true;
    9414:	13a02001 	movne	r2, #1
    9418:	13a03000 	movne	r3, #0
    941c:	11cb25f0 	strdne	r2, [fp, #80]	@ 0x50
  if (linelength > max_line_length)
    9420:	e59b3058 	ldr	r3, [fp, #88]	@ 0x58
    9424:	e1530009 	cmp	r3, r9
    9428:	e59b305c 	ldr	r3, [fp, #92]	@ 0x5c
    942c:	e0d3300a 	sbcs	r3, r3, sl
    max_line_length = linelength;
    9430:	358b9058 	strcc	r9, [fp, #88]	@ 0x58
    9434:	358ba05c 	strcc	sl, [fp, #92]	@ 0x5c
}
    9438:	e28dd901 	add	sp, sp, #16384	@ 0x4000
    943c:	e28dd054 	add	sp, sp, #84	@ 0x54
    9440:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
              error (0, errno, "%s", quotef (file));
    9444:	e58d902c 	str	r9, [sp, #44]	@ 0x2c
    9448:	e1a0900a 	mov	r9, sl
    944c:	e59db038 	ldr	fp, [sp, #56]	@ 0x38
    9450:	e59da030 	ldr	sl, [sp, #48]	@ 0x30
    9454:	eb0048ee 	bl	1b814 <__errno>
    9458:	e5903000 	ldr	r3, [r0]
    945c:	e3a01003 	mov	r1, #3
    9460:	e59d2040 	ldr	r2, [sp, #64]	@ 0x40
    9464:	e3a00000 	mov	r0, #0
    9468:	e58d3030 	str	r3, [sp, #48]	@ 0x30
    946c:	eb001014 	bl	d4c4 <quotearg_n_style_colon>
    9470:	e3082bfc 	movw	r2, #35836	@ 0x8bfc
    9474:	e1a03000 	mov	r3, r0
    9478:	e59d1030 	ldr	r1, [sp, #48]	@ 0x30
    947c:	e3402002 	movt	r2, #2
    9480:	e3a00000 	mov	r0, #0
    9484:	eb000328 	bl	a12c <error>
              ok = false;
    9488:	e3a03000 	mov	r3, #0
    948c:	e58d3030 	str	r3, [sp, #48]	@ 0x30
              break;
    9490:	eaffff91 	b	92dc <wc+0x418>
            current_pos = lseek (fd, 0, SEEK_CUR);
    9494:	e1a01007 	mov	r1, r7
    9498:	e3a02001 	mov	r2, #1
    949c:	e59d0034 	ldr	r0, [sp, #52]	@ 0x34
    94a0:	eb0058de 	bl	1f820 <lseek>
          if (end_pos % page_size)
    94a4:	e59b100c 	ldr	r1, [fp, #12]
            current_pos = lseek (fd, 0, SEEK_CUR);
    94a8:	e1a07000 	mov	r7, r0
          if (end_pos % page_size)
    94ac:	e1a00006 	mov	r0, r6
    94b0:	eb0033a5 	bl	1634c <__aeabi_uidivmod>
    94b4:	e3510000 	cmp	r1, #0
              if (0 <= current_pos && current_pos < hi_pos
    94b8:	01e05007 	mvneq	r5, r7
    94bc:	01a05fa5 	lsreq	r5, r5, #31
          if (end_pos % page_size)
    94c0:	0a000074 	beq	9698 <wc+0x7d4>
              bytes = end_pos < current_pos ? 0 : end_pos - current_pos;
    94c4:	e1560007 	cmp	r6, r7
    94c8:	ba000005 	blt	94e4 <wc+0x620>
    94cc:	e0466007 	sub	r6, r6, r7
    94d0:	e1a03fc6 	asr	r3, r6, #31
              if (bytes && 0 <= lseek (fd, bytes, SEEK_CUR))
    94d4:	e3560000 	cmp	r6, #0
              bytes = end_pos < current_pos ? 0 : end_pos - current_pos;
    94d8:	e58d6028 	str	r6, [sp, #40]	@ 0x28
    94dc:	e58d3024 	str	r3, [sp, #36]	@ 0x24
              if (bytes && 0 <= lseek (fd, bytes, SEEK_CUR))
    94e0:	1affff2c 	bne	9198 <wc+0x2d4>
  lines = words = chars = bytes = linelength = 0;
    94e4:	e3a03000 	mov	r3, #0
    94e8:	e58d3028 	str	r3, [sp, #40]	@ 0x28
    94ec:	e58d3024 	str	r3, [sp, #36]	@ 0x24
          fdadvise (fd, 0, 0, FADVISE_SEQUENTIAL);
    94f0:	e59d6034 	ldr	r6, [sp, #52]	@ 0x34
    94f4:	e3a02000 	mov	r2, #0
    94f8:	e1a01002 	mov	r1, r2
    94fc:	e3a03001 	mov	r3, #1
    9500:	e1a00006 	mov	r0, r6
    9504:	eb000377 	bl	a2e8 <fdadvise>
          while ((bytes_read = safe_read (fd, buf, BUFFER_SIZE)) > 0)
    9508:	e28d104c 	add	r1, sp, #76	@ 0x4c
    950c:	e59d4028 	ldr	r4, [sp, #40]	@ 0x28
    9510:	e59d5024 	ldr	r5, [sp, #36]	@ 0x24
    9514:	e1a07001 	mov	r7, r1
    9518:	ea000003 	b	952c <wc+0x668>
              if (bytes_read == SAFE_READ_ERROR)
    951c:	e3700001 	cmn	r0, #1
    9520:	0a000040 	beq	9628 <wc+0x764>
              bytes += bytes_read;
    9524:	e0904004 	adds	r4, r0, r4
    9528:	e2a55000 	adc	r5, r5, #0
          while ((bytes_read = safe_read (fd, buf, BUFFER_SIZE)) > 0)
    952c:	e3a02901 	mov	r2, #16384	@ 0x4000
    9530:	e1a01007 	mov	r1, r7
    9534:	e1a00006 	mov	r0, r6
    9538:	eb001153 	bl	da8c <safe_read>
    953c:	e3500000 	cmp	r0, #0
    9540:	1afffff5 	bne	951c <wc+0x658>
  bool ok = true;
    9544:	e3a02001 	mov	r2, #1
  lines = words = chars = bytes = linelength = 0;
    9548:	e58d4028 	str	r4, [sp, #40]	@ 0x28
    954c:	e1a07000 	mov	r7, r0
    9550:	e1a09000 	mov	r9, r0
    9554:	e1a0a000 	mov	sl, r0
    9558:	e1a04000 	mov	r4, r0
    955c:	e58d5024 	str	r5, [sp, #36]	@ 0x24
    9560:	e58d002c 	str	r0, [sp, #44]	@ 0x2c
  bool ok = true;
    9564:	e58d2030 	str	r2, [sp, #48]	@ 0x30
  lines = words = chars = bytes = linelength = 0;
    9568:	e58d0020 	str	r0, [sp, #32]
    956c:	eaffff60 	b	92f4 <wc+0x430>
          while ((p = rawmemchr (p, '\n')) < end)
    9570:	e1a04006 	mov	r4, r6
    9574:	e1a08007 	mov	r8, r7
      char *p = buf;
    9578:	e1a0000b 	mov	r0, fp
          *end = '\n';
    957c:	e7cb900c 	strb	r9, [fp, ip]
          while ((p = rawmemchr (p, '\n')) < end)
    9580:	e58dc028 	str	ip, [sp, #40]	@ 0x28
    9584:	ea000001 	b	9590 <wc+0x6cc>
              ++lines;
    9588:	e2944001 	adds	r4, r4, #1
    958c:	e2a88000 	adc	r8, r8, #0
          while ((p = rawmemchr (p, '\n')) < end)
    9590:	e3a0100a 	mov	r1, #10
    9594:	eb00457e 	bl	1ab94 <rawmemchr>
    9598:	e15a0000 	cmp	sl, r0
              ++p;
    959c:	e2800001 	add	r0, r0, #1
          while ((p = rawmemchr (p, '\n')) < end)
    95a0:	8afffff8 	bhi	9588 <wc+0x6c4>
    95a4:	e59dc028 	ldr	ip, [sp, #40]	@ 0x28
    95a8:	eaffff38 	b	9290 <wc+0x3cc>
          error (0, errno, "%s", quotef (file));
    95ac:	e59db030 	ldr	fp, [sp, #48]	@ 0x30
    95b0:	eb004897 	bl	1b814 <__errno>
    95b4:	e5904000 	ldr	r4, [r0]
    95b8:	e3a01003 	mov	r1, #3
    95bc:	e59d2040 	ldr	r2, [sp, #64]	@ 0x40
    95c0:	e3a00000 	mov	r0, #0
    95c4:	eb000fbe 	bl	d4c4 <quotearg_n_style_colon>
    95c8:	e3082bfc 	movw	r2, #35836	@ 0x8bfc
    95cc:	e1a03000 	mov	r3, r0
    95d0:	e3402002 	movt	r2, #2
    95d4:	e1a01004 	mov	r1, r4
    95d8:	e3a00000 	mov	r0, #0
    95dc:	eb0002d2 	bl	a12c <error>
  lines = words = chars = bytes = linelength = 0;
    95e0:	e3a03000 	mov	r3, #0
    95e4:	e58d3028 	str	r3, [sp, #40]	@ 0x28
    95e8:	e58d3024 	str	r3, [sp, #36]	@ 0x24
    95ec:	e58d302c 	str	r3, [sp, #44]	@ 0x2c
    95f0:	e58d3020 	str	r3, [sp, #32]
      return false;
    95f4:	e58d3030 	str	r3, [sp, #48]	@ 0x30
  lines = words = chars = bytes = linelength = 0;
    95f8:	e3a09000 	mov	r9, #0
    95fc:	e1a0a009 	mov	sl, r9
    9600:	e1a04009 	mov	r4, r9
    9604:	e1a07009 	mov	r7, r9
    9608:	eaffff39 	b	92f4 <wc+0x430>
  return true;
    960c:	e3a03001 	mov	r3, #1
    9610:	e59db030 	ldr	fp, [sp, #48]	@ 0x30
    9614:	e58d5028 	str	r5, [sp, #40]	@ 0x28
    9618:	e58d602c 	str	r6, [sp, #44]	@ 0x2c
    961c:	e58d7020 	str	r7, [sp, #32]
    9620:	e58d3030 	str	r3, [sp, #48]	@ 0x30
    9624:	eafffff3 	b	95f8 <wc+0x734>
                  error (0, errno, "%s", quotef (file));
    9628:	e58d4028 	str	r4, [sp, #40]	@ 0x28
    962c:	e58d5024 	str	r5, [sp, #36]	@ 0x24
    9630:	eb004877 	bl	1b814 <__errno>
    9634:	e5904000 	ldr	r4, [r0]
    9638:	e3a01003 	mov	r1, #3
    963c:	e59d2040 	ldr	r2, [sp, #64]	@ 0x40
    9640:	e3a00000 	mov	r0, #0
    9644:	eb000f9e 	bl	d4c4 <quotearg_n_style_colon>
    9648:	e3082bfc 	movw	r2, #35836	@ 0x8bfc
    964c:	e1a03000 	mov	r3, r0
    9650:	e1a01004 	mov	r1, r4
    9654:	e3402002 	movt	r2, #2
    9658:	e3a00000 	mov	r0, #0
    965c:	eb0002b2 	bl	a12c <error>
  lines = words = chars = bytes = linelength = 0;
    9660:	e3a03000 	mov	r3, #0
    9664:	e1a07003 	mov	r7, r3
    9668:	e1a09003 	mov	r9, r3
    966c:	e1a0a003 	mov	sl, r3
    9670:	e1a04003 	mov	r4, r3
    9674:	e58d302c 	str	r3, [sp, #44]	@ 0x2c
    9678:	e58d3020 	str	r3, [sp, #32]
                  break;
    967c:	eaffff1c 	b	92f4 <wc+0x430>
    fdadvise (fd, 0, 0, FADVISE_SEQUENTIAL);
    9680:	e59d0034 	ldr	r0, [sp, #52]	@ 0x34
    9684:	e3a03001 	mov	r3, #1
    9688:	e1a01002 	mov	r1, r2
    968c:	eb000315 	bl	a2e8 <fdadvise>
  else if (!count_chars && !count_complicated)
    9690:	eafffe28 	b	8f38 <wc+0x74>
          if (end_pos % page_size)
    9694:	e3a05001 	mov	r5, #1
              off_t hi_pos = end_pos - end_pos % (ST_BLKSIZE (fstatus->st) + 1);
    9698:	e5941050 	ldr	r1, [r4, #80]	@ 0x50
    969c:	e1a00006 	mov	r0, r6
    96a0:	e2413001 	sub	r3, r1, #1
    96a4:	e373021e 	cmn	r3, #-536870911	@ 0xe0000001
    96a8:	92811001 	addls	r1, r1, #1
    96ac:	83011001 	movwhi	r1, #4097	@ 0x1001
    96b0:	eb0033b5 	bl	1658c <__aeabi_idivmod>
    96b4:	e0466001 	sub	r6, r6, r1
              if (0 <= current_pos && current_pos < hi_pos
    96b8:	e1560007 	cmp	r6, r7
    96bc:	d3a05000 	movle	r5, #0
    96c0:	c2055001 	andgt	r5, r5, #1
    96c4:	e3550000 	cmp	r5, #0
    96c8:	0affff85 	beq	94e4 <wc+0x620>
                  && 0 <= lseek (fd, hi_pos, SEEK_CUR))
    96cc:	e59d0034 	ldr	r0, [sp, #52]	@ 0x34
    96d0:	e3a02001 	mov	r2, #1
    96d4:	e1a01006 	mov	r1, r6
    96d8:	eb005850 	bl	1f820 <lseek>
    96dc:	e3500000 	cmp	r0, #0
    96e0:	baffff7f 	blt	94e4 <wc+0x620>
                bytes = hi_pos - current_pos;
    96e4:	e0466007 	sub	r6, r6, r7
    96e8:	e1a03fc6 	asr	r3, r6, #31
    96ec:	e58d6028 	str	r6, [sp, #40]	@ 0x28
    96f0:	e58d3024 	str	r3, [sp, #36]	@ 0x24
      if (! skip_read)
    96f4:	eaffff7d 	b	94f0 <wc+0x62c>
    fdadvise (fd, 0, 0, FADVISE_SEQUENTIAL);
    96f8:	e3a03001 	mov	r3, #1
    96fc:	e59d0034 	ldr	r0, [sp, #52]	@ 0x34
    9700:	e1a01002 	mov	r1, r2
    9704:	eb0002f7 	bl	a2e8 <fdadvise>
  if (count_bytes && !count_chars && !print_lines && !count_complicated)
    9708:	e5db3000 	ldrb	r3, [fp]
    970c:	e3530000 	cmp	r3, #0
    9710:	1afffeb8 	bne	91f8 <wc+0x334>
    9714:	eafffe84 	b	912c <wc+0x268>
    9718:	00029e51 	.word	0x00029e51

0000971c <usage>:
{
    971c:	e92d4080 	push	{r7, lr}
    emit_try_help ();
    9720:	e30b33e4 	movw	r3, #46052	@ 0xb3e4
  if (status != EXIT_SUCCESS)
    9724:	e2507000 	subs	r7, r0, #0
    emit_try_help ();
    9728:	e3403002 	movt	r3, #2
{
    972c:	e24dd038 	sub	sp, sp, #56	@ 0x38
    emit_try_help ();
    9730:	e5932000 	ldr	r2, [r3]
  if (status != EXIT_SUCCESS)
    9734:	0a000008 	beq	975c <usage+0x40>
    emit_try_help ();
    9738:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
    973c:	e3081364 	movw	r1, #33636	@ 0x8364
    9740:	e3403002 	movt	r3, #2
    9744:	e3401002 	movt	r1, #2
    9748:	e5933000 	ldr	r3, [r3]
    974c:	e593000c 	ldr	r0, [r3, #12]
    9750:	eb003bf3 	bl	18724 <fprintf>
  exit (status);
    9754:	e1a00007 	mov	r0, r7
    9758:	eb00340f 	bl	1679c <exit>
      printf (_("\
    975c:	e308038c 	movw	r0, #33676	@ 0x838c
      fputs (_("\
    9760:	e30b61e8 	movw	r6, #45544	@ 0xb1e8
    9764:	e3406002 	movt	r6, #2
      printf (_("\
    9768:	e1a01002 	mov	r1, r2
    976c:	e3400002 	movt	r0, #2
  struct infomap { char const *program; char const *node; } const infomap[] = {
    9770:	e59f4244 	ldr	r4, [pc, #580]	@ 99bc <usage+0x2a0>
    9774:	eb003dfc 	bl	18f6c <printf>
      fputs (_("\
    9778:	e5963000 	ldr	r3, [r6]
    977c:	e30803d4 	movw	r0, #33748	@ 0x83d4
    9780:	e3a020c1 	mov	r2, #193	@ 0xc1
    9784:	e3a01001 	mov	r1, #1
    9788:	e3400002 	movt	r0, #2
  struct infomap const *map_prog = infomap;
    978c:	e1a0500d 	mov	r5, sp
    9790:	e5933008 	ldr	r3, [r3, #8]
    9794:	eb004308 	bl	1a3bc <fwrite_unlocked>
  fputs (_("\n\
    9798:	e5963000 	ldr	r3, [r6]
    979c:	e3080498 	movw	r0, #33944	@ 0x8498
    97a0:	e3a02037 	mov	r2, #55	@ 0x37
    97a4:	e3a01001 	mov	r1, #1
    97a8:	e3400002 	movt	r0, #2
    97ac:	e5933008 	ldr	r3, [r3, #8]
    97b0:	eb004301 	bl	1a3bc <fwrite_unlocked>
      fputs (_("\
    97b4:	e5963000 	ldr	r3, [r6]
    97b8:	e30804d0 	movw	r0, #34000	@ 0x84d0
    97bc:	e3a02f4b 	mov	r2, #300	@ 0x12c
    97c0:	e3a01001 	mov	r1, #1
    97c4:	e3400002 	movt	r0, #2
    97c8:	e5933008 	ldr	r3, [r3, #8]
    97cc:	eb0042fa 	bl	1a3bc <fwrite_unlocked>
      fputs (_("\
    97d0:	e5963000 	ldr	r3, [r6]
    97d4:	e3080600 	movw	r0, #34304	@ 0x8600
    97d8:	e3a02f4b 	mov	r2, #300	@ 0x12c
    97dc:	e3a01001 	mov	r1, #1
    97e0:	e3400002 	movt	r0, #2
    97e4:	e5933008 	ldr	r3, [r3, #8]
    97e8:	eb0042f3 	bl	1a3bc <fwrite_unlocked>
      fputs (_("\
    97ec:	e5963000 	ldr	r3, [r6]
    97f0:	e3080730 	movw	r0, #34608	@ 0x8730
    97f4:	e3a02083 	mov	r2, #131	@ 0x83
    97f8:	e3a01001 	mov	r1, #1
    97fc:	e3400002 	movt	r0, #2
    9800:	e5933008 	ldr	r3, [r3, #8]
    9804:	eb0042ec 	bl	1a3bc <fwrite_unlocked>
      fputs (HELP_OPTION_DESCRIPTION, stdout);
    9808:	e5963000 	ldr	r3, [r6]
    980c:	e30807b4 	movw	r0, #34740	@ 0x87b4
    9810:	e3a0202f 	mov	r2, #47	@ 0x2f
    9814:	e3a01001 	mov	r1, #1
    9818:	e3400002 	movt	r0, #2
    981c:	e5933008 	ldr	r3, [r3, #8]
    9820:	eb0042e5 	bl	1a3bc <fwrite_unlocked>
      fputs (VERSION_OPTION_DESCRIPTION, stdout);
    9824:	e5963000 	ldr	r3, [r6]
    9828:	e30807e4 	movw	r0, #34788	@ 0x87e4
    982c:	e3a02038 	mov	r2, #56	@ 0x38
    9830:	e3a01001 	mov	r1, #1
    9834:	e3400002 	movt	r0, #2
    9838:	e5933008 	ldr	r3, [r3, #8]
    983c:	eb0042de 	bl	1a3bc <fwrite_unlocked>
  struct infomap { char const *program; char const *node; } const infomap[] = {
    9840:	e8b4000f 	ldm	r4!, {r0, r1, r2, r3}
    9844:	e1a0e00d 	mov	lr, sp
  while (map_prog->program && ! STREQ (program, map_prog->program))
    9848:	e308c35c 	movw	ip, #33628	@ 0x835c
    984c:	e340c002 	movt	ip, #2
  struct infomap { char const *program; char const *node; } const infomap[] = {
    9850:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
    9854:	e8b4000f 	ldm	r4!, {r0, r1, r2, r3}
    9858:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
    985c:	e8b4000f 	ldm	r4!, {r0, r1, r2, r3}
    9860:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
    9864:	e8940003 	ldm	r4, {r0, r1}
    9868:	e88e0003 	stm	lr, {r0, r1}
  while (map_prog->program && ! STREQ (program, map_prog->program))
    986c:	e5dc3000 	ldrb	r3, [ip]
    9870:	e3530077 	cmp	r3, #119	@ 0x77
    9874:	1a00002e 	bne	9934 <usage+0x218>
    9878:	e5dc3001 	ldrb	r3, [ip, #1]
    987c:	e3530063 	cmp	r3, #99	@ 0x63
    9880:	1a00002b 	bne	9934 <usage+0x218>
    9884:	e5dc3002 	ldrb	r3, [ip, #2]
    9888:	e3530000 	cmp	r3, #0
    988c:	1a000028 	bne	9934 <usage+0x218>
  if (map_prog->node)
    9890:	e5954004 	ldr	r4, [r5, #4]
  printf (_("\n%s online help: <%s>\n"), PACKAGE_NAME, PACKAGE_URL);
    9894:	e3082820 	movw	r2, #34848	@ 0x8820
    9898:	e3081848 	movw	r1, #34888	@ 0x8848
    989c:	e3080858 	movw	r0, #34904	@ 0x8858
    98a0:	e3402002 	movt	r2, #2
    98a4:	e3401002 	movt	r1, #2
  if (map_prog->node)
    98a8:	e3540000 	cmp	r4, #0
  printf (_("\n%s online help: <%s>\n"), PACKAGE_NAME, PACKAGE_URL);
    98ac:	e3400002 	movt	r0, #2
  if (map_prog->node)
    98b0:	0a000023 	beq	9944 <usage+0x228>
  printf (_("\n%s online help: <%s>\n"), PACKAGE_NAME, PACKAGE_URL);
    98b4:	eb003dac 	bl	18f6c <printf>
  char const *lc_messages = setlocale (LC_MESSAGES, nullptr);
    98b8:	e3a01000 	mov	r1, #0
    98bc:	e3a00006 	mov	r0, #6
    98c0:	eb004606 	bl	1b0e0 <setlocale>
  if (lc_messages && STRNCMP_LIT (lc_messages, "en_"))
    98c4:	e3500000 	cmp	r0, #0
    98c8:	e3085360 	movw	r5, #33632	@ 0x8360
    98cc:	e3405002 	movt	r5, #2
    98d0:	0a000005 	beq	98ec <usage+0x1d0>
    98d4:	e3081870 	movw	r1, #34928	@ 0x8870
    98d8:	e3a02003 	mov	r2, #3
    98dc:	e3401002 	movt	r1, #2
    98e0:	eb004413 	bl	1a934 <strncmp>
    98e4:	e3500000 	cmp	r0, #0
    98e8:	1a00001f 	bne	996c <usage+0x250>
  printf (_("Full documentation <%s%s>\n"),
    98ec:	e3082360 	movw	r2, #33632	@ 0x8360
    98f0:	e3081820 	movw	r1, #34848	@ 0x8820
    98f4:	e30808bc 	movw	r0, #35004	@ 0x88bc
    98f8:	e3402002 	movt	r2, #2
    98fc:	e3401002 	movt	r1, #2
    9900:	e3400002 	movt	r0, #2
    9904:	eb003d98 	bl	18f6c <printf>
  printf (_("or available locally via: info '(coreutils) %s%s'\n"),
    9908:	e3083ac4 	movw	r3, #35524	@ 0x8ac4
    990c:	e3082d5c 	movw	r2, #36188	@ 0x8d5c
    9910:	e3403002 	movt	r3, #2
    9914:	e1540005 	cmp	r4, r5
    9918:	e3402002 	movt	r2, #2
    991c:	01a02003 	moveq	r2, r3
    9920:	e30808d8 	movw	r0, #35032	@ 0x88d8
    9924:	e1a01004 	mov	r1, r4
    9928:	e3400002 	movt	r0, #2
    992c:	eb003d8e 	bl	18f6c <printf>
}
    9930:	eaffff87 	b	9754 <usage+0x38>
  while (map_prog->program && ! STREQ (program, map_prog->program))
    9934:	e5b5c008 	ldr	ip, [r5, #8]!
    9938:	e35c0000 	cmp	ip, #0
    993c:	1affffca 	bne	986c <usage+0x150>
    9940:	eaffffd2 	b	9890 <usage+0x174>
  printf (_("\n%s online help: <%s>\n"), PACKAGE_NAME, PACKAGE_URL);
    9944:	eb003d88 	bl	18f6c <printf>
  char const *lc_messages = setlocale (LC_MESSAGES, nullptr);
    9948:	e1a01004 	mov	r1, r4
    994c:	e3a00006 	mov	r0, #6
    9950:	eb0045e2 	bl	1b0e0 <setlocale>
  if (lc_messages && STRNCMP_LIT (lc_messages, "en_"))
    9954:	e3500000 	cmp	r0, #0
    9958:	0a00000b 	beq	998c <usage+0x270>
  char const *node = program;
    995c:	e3085360 	movw	r5, #33632	@ 0x8360
    9960:	e3405002 	movt	r5, #2
    9964:	e1a04005 	mov	r4, r5
    9968:	eaffffd9 	b	98d4 <usage+0x1b8>
      fputs (_("Report any translation bugs to "
    996c:	e5963000 	ldr	r3, [r6]
    9970:	e3080874 	movw	r0, #34932	@ 0x8874
    9974:	e3a02046 	mov	r2, #70	@ 0x46
    9978:	e3a01001 	mov	r1, #1
    997c:	e3400002 	movt	r0, #2
    9980:	e5933008 	ldr	r3, [r3, #8]
    9984:	eb00428c 	bl	1a3bc <fwrite_unlocked>
    9988:	eaffffd7 	b	98ec <usage+0x1d0>
  printf (_("Full documentation <%s%s>\n"),
    998c:	e3082360 	movw	r2, #33632	@ 0x8360
    9990:	e3081820 	movw	r1, #34848	@ 0x8820
    9994:	e30808bc 	movw	r0, #35004	@ 0x88bc
    9998:	e3402002 	movt	r2, #2
    999c:	e3401002 	movt	r1, #2
    99a0:	e3400002 	movt	r0, #2
  char const *node = program;
    99a4:	e3084360 	movw	r4, #33632	@ 0x8360
  printf (_("Full documentation <%s%s>\n"),
    99a8:	eb003d6f 	bl	18f6c <printf>
  printf (_("or available locally via: info '(coreutils) %s%s'\n"),
    99ac:	e3082ac4 	movw	r2, #35524	@ 0x8ac4
  char const *node = program;
    99b0:	e3404002 	movt	r4, #2
  printf (_("or available locally via: info '(coreutils) %s%s'\n"),
    99b4:	e3402002 	movt	r2, #2
    99b8:	eaffffd8 	b	9920 <usage+0x204>
    99bc:	00029bb0 	.word	0x00029bb0

000099c0 <__argmatch_die>:
#endif

static void
__argmatch_die (void)
{
  ARGMATCH_DIE;
    99c0:	e3a00001 	mov	r0, #1
    99c4:	eaffff54 	b	971c <usage>

000099c8 <argmatch>:
   "y" is a valid argument, for 0, and "n" for 1.  */

ptrdiff_t
argmatch (const char *arg, const char *const *arglist,
          const void *vallist, size_t valsize)
{
    99c8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    99cc:	e1a06001 	mov	r6, r1
    99d0:	e24dd00c 	sub	sp, sp, #12
    99d4:	e1a0a002 	mov	sl, r2
    99d8:	e1a07003 	mov	r7, r3
    99dc:	e58d0000 	str	r0, [sp]
  size_t i;                     /* Temporary index in ARGLIST.  */
  size_t arglen;                /* Length of ARG.  */
  ptrdiff_t matchind = -1;      /* Index of first nonexact match.  */
  bool ambiguous = false;       /* If true, multiple nonexact match(es).  */

  arglen = strlen (arg);
    99e0:	fa005aa6 	blx	20480 <strlen>

  /* Test all elements for either exact match or abbreviated matches.  */
  for (i = 0; arglist[i]; i++)
    99e4:	e5964000 	ldr	r4, [r6]
    99e8:	e3540000 	cmp	r4, #0
    99ec:	0a000031 	beq	9ab8 <argmatch+0xf0>
  bool ambiguous = false;       /* If true, multiple nonexact match(es).  */
    99f0:	e3a01000 	mov	r1, #0
    99f4:	e1a0b000 	mov	fp, r0
    99f8:	e1a0500a 	mov	r5, sl
  ptrdiff_t matchind = -1;      /* Index of first nonexact match.  */
    99fc:	e3e09000 	mvn	r9, #0
  for (i = 0; arglist[i]; i++)
    9a00:	e1a08001 	mov	r8, r1
    9a04:	e58d1004 	str	r1, [sp, #4]
    9a08:	ea000009 	b	9a34 <argmatch+0x6c>
            matchind = i;
          else
            {
              /* Second nonexact match found.  */
              if (vallist == NULL
                  || memcmp ((char const *) vallist + valsize * matchind,
    9a0c:	eb00429b 	bl	1a480 <memcmp>
                             (char const *) vallist + valsize * i, valsize))
                {
                  /* There is a real ambiguity, or we could not
                     disambiguate. */
                  ambiguous = true;
    9a10:	e59d3004 	ldr	r3, [sp, #4]
    9a14:	e3500000 	cmp	r0, #0
    9a18:	13a03001 	movne	r3, #1
    9a1c:	e58d3004 	str	r3, [sp, #4]
  for (i = 0; arglist[i]; i++)
    9a20:	e5b64004 	ldr	r4, [r6, #4]!
    9a24:	e2888001 	add	r8, r8, #1
    9a28:	e0855007 	add	r5, r5, r7
    9a2c:	e3540000 	cmp	r4, #0
    9a30:	0a000016 	beq	9a90 <argmatch+0xc8>
      if (!strncmp (arglist[i], arg, arglen))
    9a34:	e1a0200b 	mov	r2, fp
    9a38:	e59d1000 	ldr	r1, [sp]
    9a3c:	e1a00004 	mov	r0, r4
    9a40:	eb0043bb 	bl	1a934 <strncmp>
    9a44:	e1a02000 	mov	r2, r0
          if (strlen (arglist[i]) == arglen)
    9a48:	e1a00004 	mov	r0, r4
      if (!strncmp (arglist[i], arg, arglen))
    9a4c:	e3520000 	cmp	r2, #0
    9a50:	1afffff2 	bne	9a20 <argmatch+0x58>
          if (strlen (arglist[i]) == arglen)
    9a54:	fa005a89 	blx	20480 <strlen>
    9a58:	e1a03000 	mov	r3, r0
                  || memcmp ((char const *) vallist + valsize * matchind,
    9a5c:	e1a02007 	mov	r2, r7
          if (strlen (arglist[i]) == arglen)
    9a60:	e153000b 	cmp	r3, fp
                  || memcmp ((char const *) vallist + valsize * matchind,
    9a64:	e1a01005 	mov	r1, r5
    9a68:	e020a997 	mla	r0, r7, r9, sl
          if (strlen (arglist[i]) == arglen)
    9a6c:	0a00000d 	beq	9aa8 <argmatch+0xe0>
          else if (matchind == -1)
    9a70:	e3790001 	cmn	r9, #1
            matchind = i;
    9a74:	01a09008 	moveq	r9, r8
          else if (matchind == -1)
    9a78:	0affffe8 	beq	9a20 <argmatch+0x58>
              if (vallist == NULL
    9a7c:	e35a0000 	cmp	sl, #0
    9a80:	1affffe1 	bne	9a0c <argmatch+0x44>
                  ambiguous = true;
    9a84:	e3a03001 	mov	r3, #1
    9a88:	e58d3004 	str	r3, [sp, #4]
    9a8c:	eaffffe3 	b	9a20 <argmatch+0x58>
                }
            }
        }
    }
  if (ambiguous)
    return -2;
    9a90:	e59d1004 	ldr	r1, [sp, #4]
    9a94:	e3510000 	cmp	r1, #0
    9a98:	13e09001 	mvnne	r9, #1
  else
    return matchind;
}
    9a9c:	e1a00009 	mov	r0, r9
    9aa0:	e28dd00c 	add	sp, sp, #12
    9aa4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
            return i;
    9aa8:	e1a09008 	mov	r9, r8
}
    9aac:	e1a00009 	mov	r0, r9
    9ab0:	e28dd00c 	add	sp, sp, #12
    9ab4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  ptrdiff_t matchind = -1;      /* Index of first nonexact match.  */
    9ab8:	e3e09000 	mvn	r9, #0
    return matchind;
    9abc:	eafffff6 	b	9a9c <argmatch+0xd4>

00009ac0 <argmatch_exact>:

ptrdiff_t
argmatch_exact (const char *arg, const char *const *arglist)
{
    9ac0:	e92d4070 	push	{r4, r5, r6, lr}
    9ac4:	e1a06000 	mov	r6, r0
  size_t i;

  /* Test elements for exact match.  */
  for (i = 0; arglist[i]; i++)
    9ac8:	e5910000 	ldr	r0, [r1]
    9acc:	e3500000 	cmp	r0, #0
    9ad0:	0a00000c 	beq	9b08 <argmatch_exact+0x48>
    9ad4:	e1a04001 	mov	r4, r1
    9ad8:	e3a05000 	mov	r5, #0
    9adc:	ea000003 	b	9af0 <argmatch_exact+0x30>
    9ae0:	e5b40004 	ldr	r0, [r4, #4]!
    9ae4:	e2855001 	add	r5, r5, #1
    9ae8:	e3500000 	cmp	r0, #0
    9aec:	0a000005 	beq	9b08 <argmatch_exact+0x48>
    {
      if (!strcmp (arglist[i], arg))
    9af0:	e1a01006 	mov	r1, r6
    9af4:	fa0057b9 	blx	1f9e0 <strcmp>
    9af8:	e3500000 	cmp	r0, #0
    9afc:	1afffff7 	bne	9ae0 <argmatch_exact+0x20>
        return i;
    9b00:	e1a00005 	mov	r0, r5
    9b04:	e8bd8070 	pop	{r4, r5, r6, pc}
    }

  return -1;
    9b08:	e3e00000 	mvn	r0, #0
}
    9b0c:	e8bd8070 	pop	{r4, r5, r6, pc}

00009b10 <argmatch_invalid>:
   VALUE is the invalid value that was given.
   PROBLEM is the return value from argmatch.  */

void
argmatch_invalid (const char *context, const char *value, ptrdiff_t problem)
{
    9b10:	e92d4070 	push	{r4, r5, r6, lr}
  char const *format = (problem == -1
                        ? _("invalid argument %s for %s")
                        : _("ambiguous argument %s for %s"));
    9b14:	e3083bb0 	movw	r3, #35760	@ 0x8bb0
{
    9b18:	e1a0e002 	mov	lr, r2
                        : _("ambiguous argument %s for %s"));
    9b1c:	e308cb94 	movw	ip, #35732	@ 0x8b94
{
    9b20:	e24dd008 	sub	sp, sp, #8
                        : _("ambiguous argument %s for %s"));
    9b24:	e37e0001 	cmn	lr, #1
    9b28:	e3403002 	movt	r3, #2
    9b2c:	e340c002 	movt	ip, #2

  error (0, 0, format, quotearg_n_style (0, ARGMATCH_QUOTING_STYLE, value),
    9b30:	e1a02001 	mov	r2, r1
{
    9b34:	e1a06000 	mov	r6, r0
  error (0, 0, format, quotearg_n_style (0, ARGMATCH_QUOTING_STYLE, value),
    9b38:	e3a01008 	mov	r1, #8
    9b3c:	e3a00000 	mov	r0, #0
                        : _("ambiguous argument %s for %s"));
    9b40:	11a04003 	movne	r4, r3
    9b44:	01a0400c 	moveq	r4, ip
  error (0, 0, format, quotearg_n_style (0, ARGMATCH_QUOTING_STYLE, value),
    9b48:	eb000d85 	bl	d164 <quotearg_n_style>
    9b4c:	e1a01006 	mov	r1, r6
    9b50:	e1a05000 	mov	r5, r0
    9b54:	e3a00001 	mov	r0, #1
    9b58:	eb000f03 	bl	d76c <quote_n>
    9b5c:	e3a01000 	mov	r1, #0
    9b60:	e1a0c000 	mov	ip, r0
    9b64:	e1a03005 	mov	r3, r5
    9b68:	e1a02004 	mov	r2, r4
    9b6c:	e1a00001 	mov	r0, r1
    9b70:	e58dc000 	str	ip, [sp]
    9b74:	eb00016c 	bl	a12c <error>
         quote_n (1, context));
}
    9b78:	e28dd008 	add	sp, sp, #8
    9b7c:	e8bd8070 	pop	{r4, r5, r6, pc}

00009b80 <argmatch_valid>:
   VALLIST is a pointer to an array of values.
   VALSIZE is the size of the elements of VALLIST */
void
argmatch_valid (const char *const *arglist,
                const void *vallist, size_t valsize)
{
    9b80:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  size_t i;
  const char *last_val = NULL;

  /* We try to put synonyms on the same line.  The assumption is that
     synonyms follow each other */
  fputs (_("Valid arguments are:"), stderr);
    9b84:	e30bb1e8 	movw	fp, #45544	@ 0xb1e8
    9b88:	e340b002 	movt	fp, #2
{
    9b8c:	e1a06000 	mov	r6, r0
  fputs (_("Valid arguments are:"), stderr);
    9b90:	e3080bd0 	movw	r0, #35792	@ 0x8bd0
{
    9b94:	e24dd00c 	sub	sp, sp, #12
  fputs (_("Valid arguments are:"), stderr);
    9b98:	e59b3000 	ldr	r3, [fp]
{
    9b9c:	e1a08001 	mov	r8, r1
    9ba0:	e1a07002 	mov	r7, r2
  fputs (_("Valid arguments are:"), stderr);
    9ba4:	e3400002 	movt	r0, #2
    9ba8:	e3a02014 	mov	r2, #20
    9bac:	e3a01001 	mov	r1, #1
    9bb0:	e593300c 	ldr	r3, [r3, #12]
    9bb4:	eb004200 	bl	1a3bc <fwrite_unlocked>
  for (i = 0; arglist[i]; i++)
    9bb8:	e5965000 	ldr	r5, [r6]
    9bbc:	e3550000 	cmp	r5, #0
    9bc0:	0a000026 	beq	9c60 <argmatch_valid+0xe0>
        fprintf (stderr, "\n  - %s", quote (arglist[i]));
        last_val = (char const *) vallist + valsize * i;
      }
    else
      {
        fprintf (stderr, ", %s", quote (arglist[i]));
    9bc4:	e59b9000 	ldr	r9, [fp]
        fprintf (stderr, "\n  - %s", quote (arglist[i]));
    9bc8:	e3083be8 	movw	r3, #35816	@ 0x8be8
        fprintf (stderr, ", %s", quote (arglist[i]));
    9bcc:	e3081bf0 	movw	r1, #35824	@ 0x8bf0
    9bd0:	e1a04008 	mov	r4, r8
        fprintf (stderr, "\n  - %s", quote (arglist[i]));
    9bd4:	e3403002 	movt	r3, #2
        fprintf (stderr, ", %s", quote (arglist[i]));
    9bd8:	e3401002 	movt	r1, #2
    9bdc:	e1a02009 	mov	r2, r9
    9be0:	e1a09005 	mov	r9, r5
    9be4:	e1a05002 	mov	r5, r2
    9be8:	e58d3000 	str	r3, [sp]
    9bec:	e58d1004 	str	r1, [sp, #4]
        fprintf (stderr, "\n  - %s", quote (arglist[i]));
    9bf0:	e595a00c 	ldr	sl, [r5, #12]
    9bf4:	e1a00009 	mov	r0, r9
    9bf8:	eb000edf 	bl	d77c <quote>
    9bfc:	e1a02000 	mov	r2, r0
    9c00:	e59d1000 	ldr	r1, [sp]
    9c04:	e1a0000a 	mov	r0, sl
        last_val = (char const *) vallist + valsize * i;
    9c08:	e1a0a008 	mov	sl, r8
        fprintf (stderr, "\n  - %s", quote (arglist[i]));
    9c0c:	eb003ac4 	bl	18724 <fprintf>
  for (i = 0; arglist[i]; i++)
    9c10:	e5b69004 	ldr	r9, [r6, #4]!
    9c14:	e0844007 	add	r4, r4, r7
        || memcmp (last_val, (char const *) vallist + valsize * i, valsize))
    9c18:	e1a02007 	mov	r2, r7
    9c1c:	e1a0000a 	mov	r0, sl
    9c20:	e1a01004 	mov	r1, r4
    9c24:	e1a08004 	mov	r8, r4
  for (i = 0; arglist[i]; i++)
    9c28:	e3590000 	cmp	r9, #0
    9c2c:	0a00000b 	beq	9c60 <argmatch_valid+0xe0>
        || memcmp (last_val, (char const *) vallist + valsize * i, valsize))
    9c30:	eb004212 	bl	1a480 <memcmp>
    9c34:	e3500000 	cmp	r0, #0
        fprintf (stderr, ", %s", quote (arglist[i]));
    9c38:	e59b5000 	ldr	r5, [fp]
        || memcmp (last_val, (char const *) vallist + valsize * i, valsize))
    9c3c:	1affffeb 	bne	9bf0 <argmatch_valid+0x70>
        fprintf (stderr, ", %s", quote (arglist[i]));
    9c40:	e595500c 	ldr	r5, [r5, #12]
    9c44:	e1a00009 	mov	r0, r9
    9c48:	eb000ecb 	bl	d77c <quote>
    9c4c:	e59d1004 	ldr	r1, [sp, #4]
    9c50:	e1a02000 	mov	r2, r0
    9c54:	e1a00005 	mov	r0, r5
    9c58:	eb003ab1 	bl	18724 <fprintf>
    9c5c:	eaffffeb 	b	9c10 <argmatch_valid+0x90>
      }
  putc ('\n', stderr);
    9c60:	e59b3000 	ldr	r3, [fp]
    9c64:	e3a0000a 	mov	r0, #10
    9c68:	e593100c 	ldr	r1, [r3, #12]
}
    9c6c:	e28dd00c 	add	sp, sp, #12
    9c70:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  putc ('\n', stderr);
    9c74:	ea003d25 	b	19110 <putc_unlocked>

00009c78 <__xargmatch_internal>:
__xargmatch_internal (const char *context,
                      const char *arg, const char *const *arglist,
                      const void *vallist, size_t valsize,
                      argmatch_exit_fn exit_fn,
                      bool allow_abbreviation)
{
    9c78:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
    9c7c:	e24dd00c 	sub	sp, sp, #12
    9c80:	e5dd4030 	ldrb	r4, [sp, #48]	@ 0x30
    9c84:	e1a08000 	mov	r8, r0
    9c88:	e1a05001 	mov	r5, r1
    9c8c:	e1a06002 	mov	r6, r2
    9c90:	e1a07003 	mov	r7, r3
  ptrdiff_t res;

  if (allow_abbreviation)
    9c94:	e3540000 	cmp	r4, #0
    9c98:	1a000026 	bne	9d38 <__xargmatch_internal+0xc0>
  for (i = 0; arglist[i]; i++)
    9c9c:	e5920000 	ldr	r0, [r2]
    9ca0:	e3500000 	cmp	r0, #0
    9ca4:	11a09002 	movne	r9, r2
    9ca8:	1a00001b 	bne	9d1c <__xargmatch_internal+0xa4>
                        : _("ambiguous argument %s for %s"));
    9cac:	e3084b94 	movw	r4, #35732	@ 0x8b94
    9cb0:	e3404002 	movt	r4, #2
  error (0, 0, format, quotearg_n_style (0, ARGMATCH_QUOTING_STYLE, value),
    9cb4:	e1a02005 	mov	r2, r5
    9cb8:	e3a01008 	mov	r1, #8
    9cbc:	e3a00000 	mov	r0, #0
    9cc0:	eb000d27 	bl	d164 <quotearg_n_style>
    9cc4:	e1a01008 	mov	r1, r8
    9cc8:	e1a05000 	mov	r5, r0
    9ccc:	e3a00001 	mov	r0, #1
    9cd0:	eb000ea5 	bl	d76c <quote_n>
    9cd4:	e3a01000 	mov	r1, #0
    9cd8:	e1a03005 	mov	r3, r5
    9cdc:	e1a02004 	mov	r2, r4
    9ce0:	e58d0000 	str	r0, [sp]
    9ce4:	e1a00001 	mov	r0, r1
    9ce8:	eb00010f 	bl	a12c <error>
    /* Success. */
    return res;

  /* We failed.  Explain why. */
  argmatch_invalid (context, arg, res);
  argmatch_valid (arglist, vallist, valsize);
    9cec:	e1a00006 	mov	r0, r6
    9cf0:	e59d2028 	ldr	r2, [sp, #40]	@ 0x28
    9cf4:	e1a01007 	mov	r1, r7
    9cf8:	ebffffa0 	bl	9b80 <argmatch_valid>
  (*exit_fn) ();
    9cfc:	e59d302c 	ldr	r3, [sp, #44]	@ 0x2c
    9d00:	e12fff33 	blx	r3

  return -1; /* To please the compilers. */
    9d04:	e3e00000 	mvn	r0, #0
    9d08:	ea000011 	b	9d54 <__xargmatch_internal+0xdc>
  for (i = 0; arglist[i]; i++)
    9d0c:	e5b90004 	ldr	r0, [r9, #4]!
    9d10:	e2844001 	add	r4, r4, #1
    9d14:	e3500000 	cmp	r0, #0
    9d18:	0affffe3 	beq	9cac <__xargmatch_internal+0x34>
      if (!strcmp (arglist[i], arg))
    9d1c:	e1a01005 	mov	r1, r5
    9d20:	fa00572e 	blx	1f9e0 <strcmp>
    9d24:	e3500000 	cmp	r0, #0
    9d28:	1afffff7 	bne	9d0c <__xargmatch_internal+0x94>
        return i;
    9d2c:	e1a00004 	mov	r0, r4
}
    9d30:	e28dd00c 	add	sp, sp, #12
    9d34:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
    res = argmatch (arg, arglist, vallist, valsize);
    9d38:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
    9d3c:	e1a02007 	mov	r2, r7
    9d40:	e1a01006 	mov	r1, r6
    9d44:	e1a00005 	mov	r0, r5
    9d48:	ebffff1e 	bl	99c8 <argmatch>
  if (res >= 0)
    9d4c:	e3500000 	cmp	r0, #0
    9d50:	ba000001 	blt	9d5c <__xargmatch_internal+0xe4>
}
    9d54:	e28dd00c 	add	sp, sp, #12
    9d58:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
                        : _("ambiguous argument %s for %s"));
    9d5c:	e3083bb0 	movw	r3, #35760	@ 0x8bb0
    9d60:	e3084b94 	movw	r4, #35732	@ 0x8b94
    9d64:	e3403002 	movt	r3, #2
    9d68:	e3700001 	cmn	r0, #1
    9d6c:	e3404002 	movt	r4, #2
    9d70:	11a04003 	movne	r4, r3
    9d74:	eaffffce 	b	9cb4 <__xargmatch_internal+0x3c>

00009d78 <argmatch_to_argument>:
   return the first corresponding argument in ARGLIST */
const char *
argmatch_to_argument (const void *value,
                      const char *const *arglist,
                      const void *vallist, size_t valsize)
{
    9d78:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  size_t i;

  for (i = 0; arglist[i]; i++)
    9d7c:	e5917000 	ldr	r7, [r1]
    9d80:	e3570000 	cmp	r7, #0
    9d84:	0a00000e 	beq	9dc4 <argmatch_to_argument+0x4c>
    9d88:	e1a05001 	mov	r5, r1
    9d8c:	e1a08000 	mov	r8, r0
    9d90:	e1a04002 	mov	r4, r2
    9d94:	e1a06003 	mov	r6, r3
    9d98:	ea000002 	b	9da8 <argmatch_to_argument+0x30>
    9d9c:	e5b57004 	ldr	r7, [r5, #4]!
    9da0:	e3570000 	cmp	r7, #0
    9da4:	0a000006 	beq	9dc4 <argmatch_to_argument+0x4c>
    if (!memcmp (value, (char const *) vallist + valsize * i, valsize))
    9da8:	e1a01004 	mov	r1, r4
    9dac:	e1a02006 	mov	r2, r6
    9db0:	e1a00008 	mov	r0, r8
  for (i = 0; arglist[i]; i++)
    9db4:	e0844006 	add	r4, r4, r6
    if (!memcmp (value, (char const *) vallist + valsize * i, valsize))
    9db8:	eb0041b0 	bl	1a480 <memcmp>
    9dbc:	e3500000 	cmp	r0, #0
    9dc0:	1afffff5 	bne	9d9c <argmatch_to_argument+0x24>
      return arglist[i];
  return NULL;
}
    9dc4:	e1a00007 	mov	r0, r7
    9dc8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

00009dcc <argv_iter_init_argv>:
  char **p;
};

struct argv_iterator *
argv_iter_init_argv (char **argv)
{
    9dcc:	e92d4010 	push	{r4, lr}
    9dd0:	e1a04000 	mov	r4, r0
  struct argv_iterator *ai = malloc (sizeof *ai);
    9dd4:	e3a00018 	mov	r0, #24
    9dd8:	eb00120d 	bl	e614 <rpl_malloc>
  if (!ai)
    9ddc:	e3500000 	cmp	r0, #0
    return NULL;
  ai->fp = NULL;
    9de0:	13a03000 	movne	r3, #0
  ai->arg_list = argv;
    9de4:	15804010 	strne	r4, [r0, #16]
  ai->fp = NULL;
    9de8:	15803000 	strne	r3, [r0]
  ai->arg_list = argv;
    9dec:	15804014 	strne	r4, [r0, #20]
  ai->p = argv;
  return ai;
}
    9df0:	e8bd8010 	pop	{r4, pc}

00009df4 <argv_iter_init_stream>:

/* Initialize to read from the stream, FP.
   The input is expected to contain a list of NUL-delimited tokens.  */
struct argv_iterator *
argv_iter_init_stream (FILE *fp)
{
    9df4:	e92d4010 	push	{r4, lr}
    9df8:	e1a04000 	mov	r4, r0
  struct argv_iterator *ai = malloc (sizeof *ai);
    9dfc:	e3a00018 	mov	r0, #24
    9e00:	eb001203 	bl	e614 <rpl_malloc>
  if (!ai)
    9e04:	e3500000 	cmp	r0, #0
    9e08:	08bd8010 	popeq	{r4, pc}
    return NULL;
  ai->fp = fp;
  ai->tok = NULL;
    9e0c:	e3a03000 	mov	r3, #0
  ai->fp = fp;
    9e10:	e5804000 	str	r4, [r0]
  ai->tok = NULL;
    9e14:	e5803008 	str	r3, [r0, #8]
  ai->buf_len = 0;
    9e18:	e580300c 	str	r3, [r0, #12]

  ai->item_idx = 0;
    9e1c:	e5803004 	str	r3, [r0, #4]
  ai->arg_list = NULL;
    9e20:	e5803010 	str	r3, [r0, #16]
  return ai;
}
    9e24:	e8bd8010 	pop	{r4, pc}

00009e28 <argv_iter>:

char *
argv_iter (struct argv_iterator *ai, enum argv_iter_err *err)
{
  if (ai->fp)
    9e28:	e5903000 	ldr	r3, [r0]
{
    9e2c:	e92d4070 	push	{r4, r5, r6, lr}
    9e30:	e1a04000 	mov	r4, r0
    9e34:	e1a05001 	mov	r5, r1
  if (ai->fp)
    9e38:	e3530000 	cmp	r3, #0
    9e3c:	0a00000c 	beq	9e74 <argv_iter+0x4c>
    {
      ssize_t len = getdelim (&ai->tok, &ai->buf_len, '\0', ai->fp);
    9e40:	e280100c 	add	r1, r0, #12
    9e44:	e3a02000 	mov	r2, #0
    9e48:	e2800008 	add	r0, r0, #8
    9e4c:	eb0001c3 	bl	a560 <getdelim>
      if (len < 0)
    9e50:	e3500000 	cmp	r0, #0
    9e54:	ba000011 	blt	9ea0 <argv_iter+0x78>
        {
          *err = feof (ai->fp) ? AI_ERR_EOF : AI_ERR_READ;
          return NULL;
        }

      *err = AI_ERR_OK;
    9e58:	e3a03001 	mov	r3, #1
    9e5c:	e5c53000 	strb	r3, [r5]
      ai->item_idx++;
    9e60:	e5943004 	ldr	r3, [r4, #4]
      return ai->tok;
    9e64:	e5940008 	ldr	r0, [r4, #8]
      ai->item_idx++;
    9e68:	e2833001 	add	r3, r3, #1
    9e6c:	e5843004 	str	r3, [r4, #4]
      return ai->tok;
    9e70:	e8bd8070 	pop	{r4, r5, r6, pc}
    }
  else
    {
      if (*(ai->p) == NULL)
    9e74:	e5903014 	ldr	r3, [r0, #20]
    9e78:	e5933000 	ldr	r3, [r3]
    9e7c:	e3530000 	cmp	r3, #0
    9e80:	0a00000e 	beq	9ec0 <argv_iter+0x98>
          *err = AI_ERR_EOF;
          return NULL;
        }
      else
        {
          *err = AI_ERR_OK;
    9e84:	e3a03001 	mov	r3, #1
    9e88:	e5c13000 	strb	r3, [r1]
          return *(ai->p++);
    9e8c:	e5903014 	ldr	r3, [r0, #20]
    9e90:	e5930000 	ldr	r0, [r3]
    9e94:	e2833004 	add	r3, r3, #4
    9e98:	e5843014 	str	r3, [r4, #20]
        }
    }
}
    9e9c:	e8bd8070 	pop	{r4, r5, r6, pc}
          *err = feof (ai->fp) ? AI_ERR_EOF : AI_ERR_READ;
    9ea0:	e5943000 	ldr	r3, [r4]
    9ea4:	e1d330bc 	ldrh	r3, [r3, #12]
    9ea8:	e3130020 	tst	r3, #32
    9eac:	03a03004 	moveq	r3, #4
    9eb0:	13a03002 	movne	r3, #2
    9eb4:	e5c53000 	strb	r3, [r5]
          return NULL;
    9eb8:	e3a00000 	mov	r0, #0
    9ebc:	e8bd8070 	pop	{r4, r5, r6, pc}
          *err = AI_ERR_EOF;
    9ec0:	e3a03002 	mov	r3, #2
    9ec4:	e5c13000 	strb	r3, [r1]
          return NULL;
    9ec8:	eafffffa 	b	9eb8 <argv_iter+0x90>

00009ecc <argv_iter_n_args>:

size_t
argv_iter_n_args (struct argv_iterator const *ai)
{
  return ai->fp ? ai->item_idx : ai->p - ai->arg_list;
    9ecc:	e5903000 	ldr	r3, [r0]
    9ed0:	e3530000 	cmp	r3, #0
    9ed4:	01c021d0 	ldrdeq	r2, [r0, #16]
    9ed8:	15900004 	ldrne	r0, [r0, #4]
    9edc:	00430002 	subeq	r0, r3, r2
    9ee0:	01a00140 	asreq	r0, r0, #2
}
    9ee4:	e12fff1e 	bx	lr

00009ee8 <argv_iter_free>:

void
argv_iter_free (struct argv_iterator *ai)
{
  if (ai->fp)
    9ee8:	e5903000 	ldr	r3, [r0]
{
    9eec:	e92d4010 	push	{r4, lr}
    9ef0:	e1a04000 	mov	r4, r0
  if (ai->fp)
    9ef4:	e3530000 	cmp	r3, #0
    9ef8:	0a000001 	beq	9f04 <argv_iter_free+0x1c>
    free (ai->tok);
    9efc:	e5900008 	ldr	r0, [r0, #8]
    9f00:	eb000154 	bl	a458 <rpl_free>
  free (ai);
    9f04:	e1a00004 	mov	r0, r4
}
    9f08:	e8bd4010 	pop	{r4, lr}
  free (ai);
    9f0c:	ea000151 	b	a458 <rpl_free>

00009f10 <rpl_btowc>:
#include <string.h>

wint_t
btowc (int c)
{
  if (c != EOF)
    9f10:	e3700001 	cmn	r0, #1
    9f14:	0a00000f 	beq	9f58 <rpl_btowc+0x48>
{
    9f18:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
_GL_INLINE
# endif
_GL_ARG_NONNULL ((1)) void
mbszero (mbstate_t *ps)
{
  memset (ps, 0, _GL_MBSTATE_ZERO_SIZE);
    9f1c:	e3a01000 	mov	r1, #0
    9f20:	e24dd014 	sub	sp, sp, #20

      buf[0] = c;
#if HAVE_MBRTOWC
      mbstate_t state;
      mbszero (&state);
      size_t ret = mbrtowc (&wc, buf, 1, &state);
    9f24:	e3a02001 	mov	r2, #1
    9f28:	e28d3008 	add	r3, sp, #8
      buf[0] = c;
    9f2c:	e5cd0000 	strb	r0, [sp]
      size_t ret = mbrtowc (&wc, buf, 1, &state);
    9f30:	e28d0004 	add	r0, sp, #4
    9f34:	e58d1008 	str	r1, [sp, #8]
    9f38:	e58d100c 	str	r1, [sp, #12]
    9f3c:	e1a0100d 	mov	r1, sp
    9f40:	eb000546 	bl	b460 <rpl_mbrtowc>
      if (!(ret == (size_t)(-1) || ret == (size_t)(-2)))
    9f44:	e3700003 	cmn	r0, #3
#else
      if (mbtowc (&wc, buf, 1) >= 0)
#endif
        return wc;
    9f48:	959d0004 	ldrls	r0, [sp, #4]
    }
  return WEOF;
    9f4c:	83e00000 	mvnhi	r0, #0
}
    9f50:	e28dd014 	add	sp, sp, #20
    9f54:	e49df004 	pop	{pc}		@ (ldr pc, [sp], #4)
  return WEOF;
    9f58:	e3e00000 	mvn	r0, #0
}
    9f5c:	e12fff1e 	bx	lr

00009f60 <close_stdout_set_file_name>:
/* Set the file name to be reported in the event an error is detected
   by close_stdout.  */
void
close_stdout_set_file_name (const char *file)
{
  file_name = file;
    9f60:	e30b33a0 	movw	r3, #45984	@ 0xb3a0
    9f64:	e3403002 	movt	r3, #2
    9f68:	e5830000 	str	r0, [r3]
}
    9f6c:	e12fff1e 	bx	lr

00009f70 <close_stdout_set_ignore_EPIPE>:
   and should not lead to a diagnostic message.  */

void
close_stdout_set_ignore_EPIPE (bool ignore)
{
  ignore_EPIPE = ignore;
    9f70:	e30b33a0 	movw	r3, #45984	@ 0xb3a0
    9f74:	e3403002 	movt	r3, #2
    9f78:	e5c30004 	strb	r0, [r3, #4]
}
    9f7c:	e12fff1e 	bx	lr

00009f80 <close_stdout>:
   tools (most notably 'make' and other build-management systems) depend
   on being able to detect failure in other tools via their exit status.  */

void
close_stdout (void)
{
    9f80:	e92d4030 	push	{r4, r5, lr}
  if (close_stream (stdout) != 0
    9f84:	e30b41e8 	movw	r4, #45544	@ 0xb1e8
    9f88:	e3404002 	movt	r4, #2
{
    9f8c:	e24dd00c 	sub	sp, sp, #12
  if (close_stream (stdout) != 0
    9f90:	e5943000 	ldr	r3, [r4]
    9f94:	e5930008 	ldr	r0, [r3, #8]
    9f98:	eb001208 	bl	e7c0 <close_stream>
    9f9c:	e3500000 	cmp	r0, #0
    9fa0:	0a000008 	beq	9fc8 <close_stdout+0x48>
      && !(ignore_EPIPE && errno == EPIPE))
    9fa4:	e30b53a0 	movw	r5, #45984	@ 0xb3a0
    9fa8:	e3405002 	movt	r5, #2
    9fac:	e5d53004 	ldrb	r3, [r5, #4]
    9fb0:	e3530000 	cmp	r3, #0
    9fb4:	0a00000a 	beq	9fe4 <close_stdout+0x64>
    9fb8:	eb004615 	bl	1b814 <__errno>
    9fbc:	e5903000 	ldr	r3, [r0]
    9fc0:	e3530020 	cmp	r3, #32
    9fc4:	1a000006 	bne	9fe4 <close_stdout+0x64>
      _exit (exit_failure);
    }

  /* Close stderr only if not sanitizing, as sanitizers may report to
     stderr after this function returns.  */
  if (!SANITIZE_ADDRESS && close_stream (stderr) != 0)
    9fc8:	e5943000 	ldr	r3, [r4]
    9fcc:	e593000c 	ldr	r0, [r3, #12]
    9fd0:	eb0011fa 	bl	e7c0 <close_stream>
    9fd4:	e3500000 	cmp	r0, #0
    9fd8:	1a000012 	bne	a028 <close_stdout+0xa8>
    _exit (exit_failure);
}
    9fdc:	e28dd00c 	add	sp, sp, #12
    9fe0:	e8bd8030 	pop	{r4, r5, pc}
      if (file_name)
    9fe4:	e5954000 	ldr	r4, [r5]
    9fe8:	e3540000 	cmp	r4, #0
    9fec:	0a000011 	beq	a038 <close_stdout+0xb8>
        error (0, errno, "%s: %s", quotearg_colon (file_name),
    9ff0:	eb004607 	bl	1b814 <__errno>
    9ff4:	e1a03000 	mov	r3, r0
    9ff8:	e5950000 	ldr	r0, [r5]
    9ffc:	e5934000 	ldr	r4, [r3]
    a000:	eb000cfe 	bl	d400 <quotearg_colon>
    a004:	e308cc00 	movw	ip, #35840	@ 0x8c00
    a008:	e3082bf8 	movw	r2, #35832	@ 0x8bf8
    a00c:	e340c002 	movt	ip, #2
    a010:	e1a03000 	mov	r3, r0
    a014:	e3402002 	movt	r2, #2
    a018:	e1a01004 	mov	r1, r4
    a01c:	e3a00000 	mov	r0, #0
    a020:	e58dc000 	str	ip, [sp]
    a024:	eb000040 	bl	a12c <error>
    _exit (exit_failure);
    a028:	e30b3014 	movw	r3, #45076	@ 0xb014
    a02c:	e3403002 	movt	r3, #2
    a030:	e5930000 	ldr	r0, [r3]
    a034:	eb00559e 	bl	1f6b4 <_exit>
        error (0, errno, "%s", write_error);
    a038:	eb0045f5 	bl	1b814 <__errno>
    a03c:	e3083c00 	movw	r3, #35840	@ 0x8c00
    a040:	e3082bfc 	movw	r2, #35836	@ 0x8bfc
    a044:	e5901000 	ldr	r1, [r0]
    a048:	e3403002 	movt	r3, #2
    a04c:	e3402002 	movt	r2, #2
    a050:	e1a00004 	mov	r0, r4
    a054:	eb000034 	bl	a12c <error>
      _exit (exit_failure);
    a058:	eafffff2 	b	a028 <close_stdout+0xa8>

0000a05c <print_errno_message>:
    fflush (stdout);
}

static void
print_errno_message (int errnum)
{
    a05c:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
    a060:	e24ddb01 	sub	sp, sp, #1024	@ 0x400
    a064:	e24dd004 	sub	sp, sp, #4
  char const *s;

#if _LIBC || GNULIB_STRERROR_R_POSIX || defined HAVE_STRERROR_R
  char errbuf[1024];
# if _LIBC || (!GNULIB_STRERROR_R_POSIX && STRERROR_R_CHAR_P)
  s = __strerror_r (errnum, errbuf, sizeof errbuf);
    a068:	e3a02b01 	mov	r2, #1024	@ 0x400
    a06c:	e1a0100d 	mov	r1, sp
    a070:	eb00421a 	bl	1a8e0 <strerror_r>
#endif

#if _LIBC
  __fxprintf (NULL, ": %s", s);
#else
  fprintf (stderr, ": %s", s);
    a074:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
    a078:	e3500000 	cmp	r0, #0
    a07c:	e3403002 	movt	r3, #2
    s = _("Unknown system error");
    a080:	e3082c0c 	movw	r2, #35852	@ 0x8c0c
  fprintf (stderr, ": %s", s);
    a084:	e5933000 	ldr	r3, [r3]
    a088:	e3081c24 	movw	r1, #35876	@ 0x8c24
    s = _("Unknown system error");
    a08c:	e3402002 	movt	r2, #2
  fprintf (stderr, ": %s", s);
    a090:	e3401002 	movt	r1, #2
    a094:	11a02000 	movne	r2, r0
    a098:	e593000c 	ldr	r0, [r3, #12]
    a09c:	eb0039a0 	bl	18724 <fprintf>
#endif
}
    a0a0:	e28ddb01 	add	sp, sp, #1024	@ 0x400
    a0a4:	e28dd004 	add	sp, sp, #4
    a0a8:	e49df004 	pop	{pc}		@ (ldr pc, [sp], #4)

0000a0ac <error_tail>:

static void _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD (3, 0) _GL_ARG_NONNULL ((3))
error_tail (int status, int errnum, const char *message, va_list args)
{
    a0ac:	e92d4070 	push	{r4, r5, r6, lr}
      if (use_malloc)
        free (wmessage);
    }
  else
#endif
    vfprintf (stderr, message, args);
    a0b0:	e30b41e8 	movw	r4, #45544	@ 0xb1e8
    a0b4:	e3404002 	movt	r4, #2
{
    a0b8:	e1a0c002 	mov	ip, r2
    vfprintf (stderr, message, args);
    a0bc:	e1a02003 	mov	r2, r3
{
    a0c0:	e1a05001 	mov	r5, r1
    vfprintf (stderr, message, args);
    a0c4:	e5943000 	ldr	r3, [r4]
    a0c8:	e1a0100c 	mov	r1, ip
{
    a0cc:	e1a06000 	mov	r6, r0
    vfprintf (stderr, message, args);
    a0d0:	e593000c 	ldr	r0, [r3, #12]
    a0d4:	eb00116b 	bl	e688 <rpl_vfprintf>

  ++error_message_count;
    a0d8:	e30b33a8 	movw	r3, #45992	@ 0xb3a8
  if (errnum)
    a0dc:	e3550000 	cmp	r5, #0
  ++error_message_count;
    a0e0:	e3403002 	movt	r3, #2
    a0e4:	e5932000 	ldr	r2, [r3]
    a0e8:	e2822001 	add	r2, r2, #1
    a0ec:	e5832000 	str	r2, [r3]
  if (errnum)
    a0f0:	1a00000a 	bne	a120 <error_tail+0x74>
    print_errno_message (errnum);
#if _LIBC
  __fxprintf (NULL, "\n");
#else
  putc ('\n', stderr);
    a0f4:	e5943000 	ldr	r3, [r4]
    a0f8:	e3a0000a 	mov	r0, #10
    a0fc:	e593100c 	ldr	r1, [r3, #12]
    a100:	eb003c02 	bl	19110 <putc_unlocked>
#endif
  fflush (stderr);
    a104:	e5943000 	ldr	r3, [r4]
    a108:	e593000c 	ldr	r0, [r3, #12]
    a10c:	eb003fbd 	bl	1a008 <fflush_unlocked>
  if (status)
    a110:	e3560000 	cmp	r6, #0
    a114:	08bd8070 	popeq	{r4, r5, r6, pc}
    exit (status);
    a118:	e1a00006 	mov	r0, r6
    a11c:	eb00319e 	bl	1679c <exit>
    print_errno_message (errnum);
    a120:	e1a00005 	mov	r0, r5
    a124:	ebffffcc 	bl	a05c <print_errno_message>
    a128:	eafffff1 	b	a0f4 <error_tail+0x48>

0000a12c <error>:
   format string with optional args.
   If ERRNUM is nonzero, print its corresponding system error message.
   Exit with status STATUS if it is nonzero.  */
void
error (int status, int errnum, const char *message, ...)
{
    a12c:	e92d000c 	push	{r2, r3}
    a130:	e92d4070 	push	{r4, r5, r6, lr}
    a134:	e1a04000 	mov	r4, r0
    a138:	e24dd008 	sub	sp, sp, #8
    a13c:	e1a05001 	mov	r5, r1
  return 0 <= fcntl (fd, F_GETFL);
    a140:	e3a00001 	mov	r0, #1
    a144:	e3a01003 	mov	r1, #3
    a148:	eb0045e3 	bl	1b8dc <fcntl>
  if (0 <= stdout_fd && is_open (stdout_fd))
    a14c:	e3500000 	cmp	r0, #0
    a150:	ba000004 	blt	a168 <error+0x3c>
    fflush (stdout);
    a154:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
    a158:	e3403002 	movt	r3, #2
    a15c:	e5933000 	ldr	r3, [r3]
    a160:	e5930008 	ldr	r0, [r3, #8]
    a164:	eb003fa7 	bl	1a008 <fflush_unlocked>

  flush_stdout ();
#ifdef _LIBC
  _IO_flockfile (stderr);
#endif
  if (error_print_progname)
    a168:	e30b33a8 	movw	r3, #45992	@ 0xb3a8
    a16c:	e3403002 	movt	r3, #2
    a170:	e5933004 	ldr	r3, [r3, #4]
    a174:	e3530000 	cmp	r3, #0
    a178:	0a00000a 	beq	a1a8 <error+0x7c>
    (*error_print_progname) ();
    a17c:	e12fff33 	blx	r3
#else
      fprintf (stderr, "%s: ", program_name);
#endif
    }

  va_start (args, message);
    a180:	e28d301c 	add	r3, sp, #28
  error_tail (status, errnum, message, args);
    a184:	e59d2018 	ldr	r2, [sp, #24]
    a188:	e1a01005 	mov	r1, r5
    a18c:	e1a00004 	mov	r0, r4
  va_start (args, message);
    a190:	e58d3004 	str	r3, [sp, #4]
  error_tail (status, errnum, message, args);
    a194:	ebffffc4 	bl	a0ac <error_tail>
  _IO_funlockfile (stderr);
# ifdef __libc_ptf_call
  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);
# endif
#endif
}
    a198:	e28dd008 	add	sp, sp, #8
    a19c:	e8bd4070 	pop	{r4, r5, r6, lr}
    a1a0:	e28dd008 	add	sp, sp, #8
    a1a4:	e12fff1e 	bx	lr
      fprintf (stderr, "%s: ", program_name);
    a1a8:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
    a1ac:	e3403002 	movt	r3, #2
    a1b0:	e5933000 	ldr	r3, [r3]
    a1b4:	e593600c 	ldr	r6, [r3, #12]
    a1b8:	eb000476 	bl	b398 <getprogname>
    a1bc:	e3081c2c 	movw	r1, #35884	@ 0x8c2c
    a1c0:	e1a02000 	mov	r2, r0
    a1c4:	e3401002 	movt	r1, #2
    a1c8:	e1a00006 	mov	r0, r6
    a1cc:	eb003954 	bl	18724 <fprintf>
    a1d0:	eaffffea 	b	a180 <error+0x54>

0000a1d4 <error_at_line>:
int error_one_per_line;

void
error_at_line (int status, int errnum, const char *file_name,
               unsigned int line_number, const char *message, ...)
{
    a1d4:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
  va_list args;

  if (error_one_per_line)
    a1d8:	e30b43a8 	movw	r4, #45992	@ 0xb3a8
    a1dc:	e3404002 	movt	r4, #2
{
    a1e0:	e1a06003 	mov	r6, r3
    a1e4:	e24dd00c 	sub	sp, sp, #12
    a1e8:	e1a08000 	mov	r8, r0
  if (error_one_per_line)
    a1ec:	e5943008 	ldr	r3, [r4, #8]
{
    a1f0:	e1a09001 	mov	r9, r1
    a1f4:	e1a05002 	mov	r5, r2
  if (error_one_per_line)
    a1f8:	e3530000 	cmp	r3, #0
    a1fc:	0a000004 	beq	a214 <error_at_line+0x40>
    {
      static const char *old_file_name;
      static unsigned int old_line_number;

      if (old_line_number == line_number
    a200:	e594300c 	ldr	r3, [r4, #12]
    a204:	e1530006 	cmp	r3, r6
    a208:	0a000022 	beq	a298 <error_at_line+0xc4>
                  && strcmp (old_file_name, file_name) == 0)))

        /* Simply return and print nothing.  */
        return;

      old_file_name = file_name;
    a20c:	e5845010 	str	r5, [r4, #16]
      old_line_number = line_number;
    a210:	e584600c 	str	r6, [r4, #12]
  return 0 <= fcntl (fd, F_GETFL);
    a214:	e3a01003 	mov	r1, #3
    a218:	e3a00001 	mov	r0, #1
    a21c:	eb0045ae 	bl	1b8dc <fcntl>
  if (0 <= stdout_fd && is_open (stdout_fd))
    a220:	e3500000 	cmp	r0, #0
    fflush (stdout);
    a224:	e30b71e8 	movw	r7, #45544	@ 0xb1e8
    a228:	e3407002 	movt	r7, #2
  if (0 <= stdout_fd && is_open (stdout_fd))
    a22c:	ba000002 	blt	a23c <error_at_line+0x68>
    fflush (stdout);
    a230:	e5973000 	ldr	r3, [r7]
    a234:	e5930008 	ldr	r0, [r3, #8]
    a238:	eb003f72 	bl	1a008 <fflush_unlocked>

  flush_stdout ();
#ifdef _LIBC
  _IO_flockfile (stderr);
#endif
  if (error_print_progname)
    a23c:	e5943004 	ldr	r3, [r4, #4]
    a240:	e3530000 	cmp	r3, #0
    a244:	0a00001e 	beq	a2c4 <error_at_line+0xf0>
    (*error_print_progname) ();
    a248:	e12fff33 	blx	r3

#if _LIBC
  __fxprintf (NULL, file_name != NULL ? "%s:%u: " : " ",
              file_name, line_number);
#else
  fprintf (stderr, file_name != NULL ? "%s:%u: " : " ",
    a24c:	e5972000 	ldr	r2, [r7]
    a250:	e3550000 	cmp	r5, #0
    a254:	e3081c34 	movw	r1, #35892	@ 0x8c34
    a258:	e1a03006 	mov	r3, r6
    a25c:	e3401002 	movt	r1, #2
    a260:	e592000c 	ldr	r0, [r2, #12]
    a264:	e3082c3c 	movw	r2, #35900	@ 0x8c3c
    a268:	e3402002 	movt	r2, #2
    a26c:	01a01002 	moveq	r1, r2
    a270:	e1a02005 	mov	r2, r5
    a274:	eb00392a 	bl	18724 <fprintf>
           file_name, line_number);
#endif

  va_start (args, message);
    a278:	e28d302c 	add	r3, sp, #44	@ 0x2c
  error_tail (status, errnum, message, args);
    a27c:	e59d2028 	ldr	r2, [sp, #40]	@ 0x28
    a280:	e1a01009 	mov	r1, r9
    a284:	e1a00008 	mov	r0, r8
  va_start (args, message);
    a288:	e58d3004 	str	r3, [sp, #4]
  error_tail (status, errnum, message, args);
    a28c:	ebffff86 	bl	a0ac <error_tail>
  _IO_funlockfile (stderr);
# ifdef __libc_ptf_call
  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);
# endif
#endif
}
    a290:	e28dd00c 	add	sp, sp, #12
    a294:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
          && (file_name == old_file_name
    a298:	e5940010 	ldr	r0, [r4, #16]
    a29c:	e1500002 	cmp	r0, r2
    a2a0:	0afffffa 	beq	a290 <error_at_line+0xbc>
                  && file_name != NULL
    a2a4:	e3520000 	cmp	r2, #0
    a2a8:	13500000 	cmpne	r0, #0
    a2ac:	0affffd6 	beq	a20c <error_at_line+0x38>
                  && strcmp (old_file_name, file_name) == 0)))
    a2b0:	e1a01002 	mov	r1, r2
    a2b4:	fa0055c9 	blx	1f9e0 <strcmp>
    a2b8:	e3500000 	cmp	r0, #0
    a2bc:	1affffd2 	bne	a20c <error_at_line+0x38>
    a2c0:	eafffff2 	b	a290 <error_at_line+0xbc>
      fprintf (stderr, "%s:", program_name);
    a2c4:	e5973000 	ldr	r3, [r7]
    a2c8:	e593400c 	ldr	r4, [r3, #12]
    a2cc:	eb000431 	bl	b398 <getprogname>
    a2d0:	e3081c40 	movw	r1, #35904	@ 0x8c40
    a2d4:	e1a02000 	mov	r2, r0
    a2d8:	e3401002 	movt	r1, #2
    a2dc:	e1a00004 	mov	r0, r4
    a2e0:	eb00390f 	bl	18724 <fprintf>
    a2e4:	eaffffd8 	b	a24c <error_at_line+0x78>

0000a2e8 <fdadvise>:
fdadvise (int fd, off_t offset, off_t len, fadvice_t advice)
{
#if HAVE_POSIX_FADVISE
  ignore_value (posix_fadvise (fd, offset, len, advice));
#endif
}
    a2e8:	e12fff1e 	bx	lr

0000a2ec <fadvise>:

void
fadvise (FILE *fp, fadvice_t advice)
{
  if (fp)
    a2ec:	e3500000 	cmp	r0, #0
    a2f0:	012fff1e 	bxeq	lr
    fdadvise (fileno (fp), 0, 0, advice);
    a2f4:	ea0037b6 	b	181d4 <fileno>

0000a2f8 <rpl_fclose>:

/* Override fclose() to call the overridden fflush() or close().  */

int
rpl_fclose (FILE *fp)
{
    a2f8:	e92d4010 	push	{r4, lr}
    a2fc:	e1a04000 	mov	r4, r0
  int saved_errno = 0;
  int fd;
  int result = 0;

  /* Don't change behavior on memstreams.  */
  fd = fileno (fp);
    a300:	eb0037b3 	bl	181d4 <fileno>
  if (fd < 0)
    a304:	e3500000 	cmp	r0, #0
    a308:	ba000006 	blt	a328 <rpl_fclose+0x30>
    return fclose_nothrow (fp);

  /* We only need to flush the file if it is not reading or if it is
     seekable.  This only guarantees the file position of input files
     if the fflush module is also in use.  */
  if ((!freading (fp) || lseek (fileno (fp), 0, SEEK_CUR) != -1)
    a30c:	e1d430bc 	ldrh	r3, [r4, #12]
    a310:	e3130004 	tst	r3, #4
    a314:	1a000006 	bne	a334 <rpl_fclose+0x3c>
      && fflush (fp))
    a318:	e1a00004 	mov	r0, r4
    a31c:	eb00001b 	bl	a390 <rpl_fflush>
    a320:	e3500000 	cmp	r0, #0
    a324:	1a00000d 	bne	a360 <rpl_fclose+0x68>
  result = fclose_nothrow (fp);
  if (result == 0)
    _gl_unregister_fd (fd);
# else
  /* No race condition here.  */
  result = fclose_nothrow (fp);
    a328:	e1a00004 	mov	r0, r4
      errno = saved_errno;
      result = EOF;
    }

  return result;
}
    a32c:	e8bd4010 	pop	{r4, lr}
  result = fclose_nothrow (fp);
    a330:	ea00367c 	b	17d28 <fclose>
  if ((!freading (fp) || lseek (fileno (fp), 0, SEEK_CUR) != -1)
    a334:	e1a00004 	mov	r0, r4
    a338:	eb0037a5 	bl	181d4 <fileno>
    a33c:	e3a02001 	mov	r2, #1
    a340:	e3a01000 	mov	r1, #0
    a344:	eb005535 	bl	1f820 <lseek>
    a348:	e3700001 	cmn	r0, #1
    a34c:	0afffff5 	beq	a328 <rpl_fclose+0x30>
      && fflush (fp))
    a350:	e1a00004 	mov	r0, r4
    a354:	eb00000d 	bl	a390 <rpl_fflush>
    a358:	e3500000 	cmp	r0, #0
    a35c:	0afffff1 	beq	a328 <rpl_fclose+0x30>
    saved_errno = errno;
    a360:	eb00452b 	bl	1b814 <__errno>
    a364:	e1a03000 	mov	r3, r0
  result = fclose_nothrow (fp);
    a368:	e1a00004 	mov	r0, r4
    saved_errno = errno;
    a36c:	e5934000 	ldr	r4, [r3]
  result = fclose_nothrow (fp);
    a370:	eb00366c 	bl	17d28 <fclose>
  if (saved_errno != 0)
    a374:	e3540000 	cmp	r4, #0
    a378:	08bd8010 	popeq	{r4, pc}
      errno = saved_errno;
    a37c:	eb004524 	bl	1b814 <__errno>
    a380:	e1a03000 	mov	r3, r0
      result = EOF;
    a384:	e3e00000 	mvn	r0, #0
      errno = saved_errno;
    a388:	e5834000 	str	r4, [r3]
}
    a38c:	e8bd8010 	pop	{r4, pc}

0000a390 <rpl_fflush>:

/* Flush all pending data on STREAM according to POSIX rules.  Both
   output and seekable input streams are supported.  */
int
rpl_fflush (FILE *stream)
{
    a390:	e92d4070 	push	{r4, r5, r6, lr}
     fflush in this case.

     We test ! freading (stream) here, rather than fwriting (stream), because
     what we need to know is whether the stream holds a "read buffer", and on
     mingw this is indicated by _IOREAD, regardless of _IOWRT.  */
  if (stream == NULL || ! freading (stream))
    a394:	e2504000 	subs	r4, r0, #0
    a398:	0a000002 	beq	a3a8 <rpl_fflush+0x18>
    a39c:	e1d430bc 	ldrh	r3, [r4, #12]
    a3a0:	e3130004 	tst	r3, #4
    a3a4:	1a000002 	bne	a3b4 <rpl_fflush+0x24>
    return fflush (stream);
    a3a8:	e1a00004 	mov	r0, r4
    return 0;

# endif
  }
#endif
}
    a3ac:	e8bd4070 	pop	{r4, r5, r6, lr}
    return fflush (stream);
    a3b0:	ea003735 	b	1808c <fflush>
    off_t pos = ftello (stream);
    a3b4:	eb003efa 	bl	19fa4 <ftello>
    if (pos == -1)
    a3b8:	e3700001 	cmn	r0, #1
    off_t pos = ftello (stream);
    a3bc:	e1a05000 	mov	r5, r0
    if (pos == -1)
    a3c0:	0a00001a 	beq	a430 <rpl_fflush+0xa0>
  if (HASUB (fp))
    a3c4:	e5943030 	ldr	r3, [r4, #48]	@ 0x30
    a3c8:	e3530000 	cmp	r3, #0
    a3cc:	0a000005 	beq	a3e8 <rpl_fflush+0x58>
      fp_->_p += fp_->_r;
    a3d0:	e5943000 	ldr	r3, [r4]
      fp_->_r = 0;
    a3d4:	e3a01000 	mov	r1, #0
      fp_->_p += fp_->_r;
    a3d8:	e5942004 	ldr	r2, [r4, #4]
      fp_->_r = 0;
    a3dc:	e5841004 	str	r1, [r4, #4]
      fp_->_p += fp_->_r;
    a3e0:	e0833002 	add	r3, r3, r2
    a3e4:	e5843000 	str	r3, [r4]
      int result = fpurge (stream);
    a3e8:	e1a00004 	mov	r0, r4
    a3ec:	eb000015 	bl	a448 <rpl_fpurge>
      if (result != 0)
    a3f0:	e3500000 	cmp	r0, #0
    a3f4:	18bd8070 	popne	{r4, r5, r6, pc}
  int saved_flags = fp_->_flags & (__SOPT | __SNPT);
    a3f8:	e1d460fc 	ldrsh	r6, [r4, #12]
      int result = fseeko (stream, pos, SEEK_SET);
    a3fc:	e1a02000 	mov	r2, r0
    a400:	e1a01005 	mov	r1, r5
    a404:	e1a00004 	mov	r0, r4
  fp_->_flags = (fp_->_flags & ~__SOPT) | __SNPT;
    a408:	e3c63b03 	bic	r3, r6, #3072	@ 0xc00
  fp_->_flags = (fp_->_flags & ~(__SOPT | __SNPT)) | saved_flags;
    a40c:	e2066b03 	and	r6, r6, #3072	@ 0xc00
  fp_->_flags = (fp_->_flags & ~__SOPT) | __SNPT;
    a410:	e3833b02 	orr	r3, r3, #2048	@ 0x800
    a414:	e1c430bc 	strh	r3, [r4, #12]
      int result = fseeko (stream, pos, SEEK_SET);
    a418:	eb000028 	bl	a4c0 <rpl_fseeko>
  fp_->_flags = (fp_->_flags & ~(__SOPT | __SNPT)) | saved_flags;
    a41c:	e1d430bc 	ldrh	r3, [r4, #12]
    a420:	e3c33b03 	bic	r3, r3, #3072	@ 0xc00
    a424:	e1833006 	orr	r3, r3, r6
    a428:	e1c430bc 	strh	r3, [r4, #12]
}
    a42c:	e8bd8070 	pop	{r4, r5, r6, pc}
        errno = EBADF;
    a430:	eb0044f7 	bl	1b814 <__errno>
    a434:	e3a02009 	mov	r2, #9
    a438:	e1a03000 	mov	r3, r0
    a43c:	e5832000 	str	r2, [r3]
        return EOF;
    a440:	e1a00005 	mov	r0, r5
    a444:	e8bd8070 	pop	{r4, r5, r6, pc}

0000a448 <rpl_fpurge>:

#include "stdio-impl.h"

int
fpurge (FILE *fp)
{
    a448:	e92d4010 	push	{r4, lr}
#if HAVE___FPURGE                   /* glibc >= 2.2, Haiku, Solaris >= 7, UnixWare >= 7.1.4.MP4, Cygwin >= 1.7.10, Android API >= 23, musl libc */

  __fpurge (fp);
    a44c:	eb003f5c 	bl	1a1c4 <__fpurge>
# else
#  error "Please port gnulib fpurge.c to your platform! Look at the definitions of fflush, setvbuf and ungetc on your system, then report this to bug-gnulib."
# endif

#endif
}
    a450:	e3a00000 	mov	r0, #0
    a454:	e8bd8010 	pop	{r4, pc}

0000a458 <rpl_free>:
# include <errno.h>

void
rpl_free (void *p)
# undef free
{
    a458:	e92d4010 	push	{r4, lr}
    a45c:	e24dd008 	sub	sp, sp, #8
    a460:	e1a04000 	mov	r4, r0
     <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=98396>
     would optimize away the assignments in the code below, when link-time
     optimization (LTO) is enabled.  Make the code more complicated, so that
     GCC does not grok how to optimize it.  */
  int err[2];
  err[0] = errno;
    a464:	eb0044ea 	bl	1b814 <__errno>
    a468:	e5903000 	ldr	r3, [r0]
    a46c:	e58d3000 	str	r3, [sp]
  err[1] = errno;
    a470:	eb0044e7 	bl	1b814 <__errno>
    a474:	e5903000 	ldr	r3, [r0]
    a478:	e58d3004 	str	r3, [sp, #4]
  errno = 0;
    a47c:	eb0044e4 	bl	1b814 <__errno>
    a480:	e3a02000 	mov	r2, #0
    a484:	e1a03000 	mov	r3, r0
    a488:	e5832000 	str	r2, [r3]
  free (p);
    a48c:	e1a00004 	mov	r0, r4
    a490:	eb005063 	bl	1e624 <free>
  errno = err[errno == 0];
    a494:	eb0044de 	bl	1b814 <__errno>
    a498:	e5904000 	ldr	r4, [r0]
    a49c:	eb0044dc 	bl	1b814 <__errno>
    a4a0:	e28d3008 	add	r3, sp, #8
    a4a4:	e16f4f14 	clz	r4, r4
    a4a8:	e1a042a4 	lsr	r4, r4, #5
    a4ac:	e0834104 	add	r4, r3, r4, lsl #2
    a4b0:	e5143008 	ldr	r3, [r4, #-8]
    a4b4:	e5803000 	str	r3, [r0]
# else
  int err = errno;
  free (p);
  errno = err;
# endif
}
    a4b8:	e28dd008 	add	sp, sp, #8
    a4bc:	e8bd8010 	pop	{r4, pc}

0000a4c0 <rpl_fseeko>:
#  define fseeko _fseeki64
# else /* mingw before msvcrt8.0 */
#  define fseeko fseeko64
# endif
#endif
{
    a4c0:	e92d4030 	push	{r4, r5, lr}
    a4c4:	e1a04000 	mov	r4, r0
      fp->_flags |= __SL64;
      fp->_seek64 = tmp->_seek64;
      fclose (tmp);
    }
# endif
  if (fp_->_p == fp_->_bf._base
    a4c8:	e5943010 	ldr	r3, [r4, #16]
{
    a4cc:	e24dd00c 	sub	sp, sp, #12
  if (fp_->_p == fp_->_bf._base
    a4d0:	e5900000 	ldr	r0, [r0]
    a4d4:	e1500003 	cmp	r0, r3
    a4d8:	0a000003 	beq	a4ec <rpl_fseeko+0x2c>
      fp->__offset = pos;
      fp->__eof = 0;
#endif
      return 0;
    }
  return fseeko (fp, offset, whence);
    a4dc:	e1a00004 	mov	r0, r4
}
    a4e0:	e28dd00c 	add	sp, sp, #12
    a4e4:	e8bd4030 	pop	{r4, r5, lr}
  return fseeko (fp, offset, whence);
    a4e8:	ea003e66 	b	19e88 <fseeko>
      && fp_->_r == 0
    a4ec:	e5945004 	ldr	r5, [r4, #4]
    a4f0:	e3550000 	cmp	r5, #0
    a4f4:	1afffff8 	bne	a4dc <rpl_fseeko+0x1c>
                     : 0)
    a4f8:	e1d430bc 	ldrh	r3, [r4, #12]
      && fp_->_w == ((fp_->_flags & (__SLBF | __SNBF | __SRD)) == 0 /* fully buffered and not currently reading? */
    a4fc:	e5940008 	ldr	r0, [r4, #8]
                     : 0)
    a500:	e3130007 	tst	r3, #7
    a504:	05943014 	ldreq	r3, [r4, #20]
    a508:	11a03005 	movne	r3, r5
      && fp_->_w == ((fp_->_flags & (__SLBF | __SNBF | __SRD)) == 0 /* fully buffered and not currently reading? */
    a50c:	e1500003 	cmp	r0, r3
    a510:	1afffff1 	bne	a4dc <rpl_fseeko+0x1c>
      && fp_ub._base == NULL)
    a514:	e5943030 	ldr	r3, [r4, #48]	@ 0x30
    a518:	e3530000 	cmp	r3, #0
    a51c:	1affffee 	bne	a4dc <rpl_fseeko+0x1c>
      off_t pos = lseek (fileno (fp), offset, whence);
    a520:	e1a00004 	mov	r0, r4
    a524:	e88d0006 	stm	sp, {r1, r2}
    a528:	eb003729 	bl	181d4 <fileno>
    a52c:	e89d0006 	ldm	sp, {r1, r2}
    a530:	eb0054ba 	bl	1f820 <lseek>
          fp_->_flags &= ~__SOFF;
    a534:	e1d430bc 	ldrh	r3, [r4, #12]
      if (pos == -1)
    a538:	e3700001 	cmn	r0, #1
          return -1;
    a53c:	01a05000 	moveq	r5, r0
        fp_->_offset = u.f;
    a540:	15840050 	strne	r0, [r4, #80]	@ 0x50
}
    a544:	e1a00005 	mov	r0, r5
      fp_->_flags &= ~__SEOF;
    a548:	13c33020 	bicne	r3, r3, #32
          fp_->_flags &= ~__SOFF;
    a54c:	03c33a01 	biceq	r3, r3, #4096	@ 0x1000
      fp_->_flags &= ~__SEOF;
    a550:	13833a01 	orrne	r3, r3, #4096	@ 0x1000
    a554:	e1c430bc 	strh	r3, [r4, #12]
}
    a558:	e28dd00c 	add	sp, sp, #12
    a55c:	e8bd8030 	pop	{r4, r5, pc}

0000a560 <getdelim>:
getdelim (char **lineptr, size_t *n, int delimiter, FILE *fp)
{
  ssize_t result;
  size_t cur_len = 0;

  if (lineptr == NULL || n == NULL || fp == NULL)
    a560:	e3530000 	cmp	r3, #0
    a564:	13510000 	cmpne	r1, #0
{
    a568:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a56c:	e1a09002 	mov	r9, r2
  if (lineptr == NULL || n == NULL || fp == NULL)
    a570:	03a02001 	moveq	r2, #1
    a574:	13a02000 	movne	r2, #0
    a578:	e3500000 	cmp	r0, #0
    a57c:	03822001 	orreq	r2, r2, #1
    a580:	e3520000 	cmp	r2, #0
    a584:	1a000041 	bne	a690 <getdelim+0x130>
    a588:	e1a06000 	mov	r6, r0
      return -1;
    }

  flockfile (fp);

  if (*lineptr == NULL || *n == 0)
    a58c:	e5900000 	ldr	r0, [r0]
    a590:	e1a07001 	mov	r7, r1
    a594:	e1a08003 	mov	r8, r3
    a598:	e3500000 	cmp	r0, #0
    a59c:	0a000028 	beq	a644 <getdelim+0xe4>
    a5a0:	e5913000 	ldr	r3, [r1]
    a5a4:	e3530000 	cmp	r3, #0
    a5a8:	0a000025 	beq	a644 <getdelim+0xe4>
{
    a5ac:	e3a0b000 	mov	fp, #0
    a5b0:	ea000004 	b	a5c8 <getdelim+0x68>
              result = -1;
              errno = EOVERFLOW;
              goto unlock_return;
            }

          new_lineptr = (char *) realloc (*lineptr, needed);
    a5b4:	e5960000 	ldr	r0, [r6]
        }

      (*lineptr)[cur_len] = i;
      cur_len++;

      if (i == delimiter)
    a5b8:	e1550009 	cmp	r5, r9
      (*lineptr)[cur_len] = i;
    a5bc:	e7c0500b 	strb	r5, [r0, fp]
      cur_len++;
    a5c0:	e1a0b00a 	mov	fp, sl
      if (i == delimiter)
    a5c4:	0a000019 	beq	a630 <getdelim+0xd0>
      i = getc_maybe_unlocked (fp);
    a5c8:	e1a00008 	mov	r0, r8
      if (cur_len + 1 >= *n)
    a5cc:	e28ba001 	add	sl, fp, #1
      i = getc_maybe_unlocked (fp);
    a5d0:	eb003a4a 	bl	18f00 <getc_unlocked>
      if (i == EOF)
    a5d4:	e3700001 	cmn	r0, #1
      i = getc_maybe_unlocked (fp);
    a5d8:	e1a05000 	mov	r5, r0
      if (i == EOF)
    a5dc:	0a00001f 	beq	a660 <getdelim+0x100>
      if (cur_len + 1 >= *n)
    a5e0:	e5974000 	ldr	r4, [r7]
    a5e4:	e15a0004 	cmp	sl, r4
          size_t needed = 2 * *n + 1;   /* Be generous. */
    a5e8:	e1a04084 	lsl	r4, r4, #1
      if (cur_len + 1 >= *n)
    a5ec:	3afffff0 	bcc	a5b4 <getdelim+0x54>
          size_t needed = 2 * *n + 1;   /* Be generous. */
    a5f0:	e2844001 	add	r4, r4, #1
          if (needed_max < needed)
    a5f4:	e3540102 	cmp	r4, #-2147483648	@ 0x80000000
    a5f8:	23a04102 	movcs	r4, #-2147483648	@ 0x80000000
          if (cur_len + 1 >= needed)
    a5fc:	e154000a 	cmp	r4, sl
          new_lineptr = (char *) realloc (*lineptr, needed);
    a600:	e1a01004 	mov	r1, r4
          if (cur_len + 1 >= needed)
    a604:	9a00001c 	bls	a67c <getdelim+0x11c>
          new_lineptr = (char *) realloc (*lineptr, needed);
    a608:	e5960000 	ldr	r0, [r6]
    a60c:	eb00100c 	bl	e644 <rpl_realloc>
          if (new_lineptr == NULL)
    a610:	e3500000 	cmp	r0, #0
    a614:	0a00001b 	beq	a688 <getdelim+0x128>
      if (i == delimiter)
    a618:	e1550009 	cmp	r5, r9
          *lineptr = new_lineptr;
    a61c:	e5860000 	str	r0, [r6]
          *n = needed;
    a620:	e5874000 	str	r4, [r7]
      (*lineptr)[cur_len] = i;
    a624:	e7c0500b 	strb	r5, [r0, fp]
      cur_len++;
    a628:	e1a0b00a 	mov	fp, sl
      if (i == delimiter)
    a62c:	1affffe5 	bne	a5c8 <getdelim+0x68>
        break;
    }
  (*lineptr)[cur_len] = '\0';
    a630:	e5963000 	ldr	r3, [r6]
    a634:	e3a02000 	mov	r2, #0
  result = cur_len ? cur_len : result;
    a638:	e1a0000b 	mov	r0, fp
  (*lineptr)[cur_len] = '\0';
    a63c:	e7c3200a 	strb	r2, [r3, sl]

 unlock_return:
  funlockfile (fp); /* doesn't set errno */

  return result;
}
    a640:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      *n = 120;
    a644:	e3a01078 	mov	r1, #120	@ 0x78
    a648:	e5871000 	str	r1, [r7]
      new_lineptr = (char *) realloc (*lineptr, *n);
    a64c:	eb000ffc 	bl	e644 <rpl_realloc>
      if (new_lineptr == NULL)
    a650:	e3500000 	cmp	r0, #0
    a654:	0a00000b 	beq	a688 <getdelim+0x128>
      *lineptr = new_lineptr;
    a658:	e5860000 	str	r0, [r6]
    a65c:	eaffffd2 	b	a5ac <getdelim+0x4c>
  (*lineptr)[cur_len] = '\0';
    a660:	e5963000 	ldr	r3, [r6]
  result = cur_len ? cur_len : result;
    a664:	e35b0000 	cmp	fp, #0
  (*lineptr)[cur_len] = '\0';
    a668:	e3a02000 	mov	r2, #0
    a66c:	e7c3200b 	strb	r2, [r3, fp]
  result = cur_len ? cur_len : result;
    a670:	0a000004 	beq	a688 <getdelim+0x128>
    a674:	e1a0000b 	mov	r0, fp
}
    a678:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
              errno = EOVERFLOW;
    a67c:	eb004464 	bl	1b814 <__errno>
    a680:	e3a0308b 	mov	r3, #139	@ 0x8b
    a684:	e5803000 	str	r3, [r0]
      return -1;
    a688:	e3e00000 	mvn	r0, #0
    a68c:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      errno = EINVAL;
    a690:	eb00445f 	bl	1b814 <__errno>
    a694:	e3a03016 	mov	r3, #22
    a698:	e5803000 	str	r3, [r0]
      return -1;
    a69c:	eafffff9 	b	a688 <getdelim+0x128>

0000a6a0 <exchange>:
   'first_nonopt' and 'last_nonopt' are relocated so that they describe
   the new indices of the non-options in ARGV after they are moved.  */

static void
exchange (char **argv, struct _getopt_data *d)
{
    a6a0:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    a6a4:	e1a06001 	mov	r6, r1
  int bottom = d->__first_nonopt;
    a6a8:	e591801c 	ldr	r8, [r1, #28]
  int middle = d->__last_nonopt;
  int top = d->optind;
    a6ac:	e5967000 	ldr	r7, [r6]
  int middle = d->__last_nonopt;
    a6b0:	e5911020 	ldr	r1, [r1, #32]
  /* Exchange the shorter segment with the far end of the longer segment.
     That puts the shorter segment into the right place.
     It leaves the longer segment in the right place overall,
     but it consists of two parts that need to be swapped next.  */

  while (top > middle && middle > bottom)
    a6b4:	e1510007 	cmp	r1, r7
    a6b8:	b1580001 	cmplt	r8, r1
    a6bc:	aa00001b 	bge	a730 <exchange+0x90>
    a6c0:	e1a05000 	mov	r5, r0
    a6c4:	e0800101 	add	r0, r0, r1, lsl #2
  int top = d->optind;
    a6c8:	e1a04007 	mov	r4, r7
  int bottom = d->__first_nonopt;
    a6cc:	e1a02008 	mov	r2, r8
    {
      if (top - middle > middle - bottom)
    a6d0:	e0443001 	sub	r3, r4, r1
    a6d4:	e041c002 	sub	ip, r1, r2
    a6d8:	e153000c 	cmp	r3, ip
    a6dc:	ca000018 	bgt	a744 <exchange+0xa4>
	  /* Top segment is the short one.  */
	  int len = top - middle;
	  int i;

	  /* Swap it with the bottom part of the bottom segment.  */
	  for (i = 0; i < len; i++)
    a6e0:	e3530000 	cmp	r3, #0
    a6e4:	e083a002 	add	sl, r3, r2
    a6e8:	da000008 	ble	a710 <exchange+0x70>
    a6ec:	e085910a 	add	r9, r5, sl, lsl #2
    a6f0:	e0853102 	add	r3, r5, r2, lsl #2
    a6f4:	e1a02000 	mov	r2, r0
	    {
	      tem = argv[bottom + i];
	      argv[bottom + i] = argv[middle + i];
    a6f8:	e592e000 	ldr	lr, [r2]
	      tem = argv[bottom + i];
    a6fc:	e593c000 	ldr	ip, [r3]
	      argv[bottom + i] = argv[middle + i];
    a700:	e483e004 	str	lr, [r3], #4
	  for (i = 0; i < len; i++)
    a704:	e1530009 	cmp	r3, r9
	      argv[middle + i] = tem;
    a708:	e482c004 	str	ip, [r2], #4
	  for (i = 0; i < len; i++)
    a70c:	1afffff9 	bne	a6f8 <exchange+0x58>
	    }
	  /* Exclude the moved top segment from further swapping.  */
	  bottom += len;
    a710:	e1a0200a 	mov	r2, sl
  while (top > middle && middle > bottom)
    a714:	e1540001 	cmp	r4, r1
    a718:	d3a03000 	movle	r3, #0
    a71c:	c3a03001 	movgt	r3, #1
    a720:	e1520001 	cmp	r2, r1
    a724:	a3a03000 	movge	r3, #0
    a728:	e3530000 	cmp	r3, #0
    a72c:	1affffe7 	bne	a6d0 <exchange+0x30>
	}
    }

  /* Update records for the slots the non-options now occupy.  */

  d->__first_nonopt += (d->optind - d->__last_nonopt);
    a730:	e0471001 	sub	r1, r7, r1
  d->__last_nonopt = d->optind;
    a734:	e5867020 	str	r7, [r6, #32]
  d->__first_nonopt += (d->optind - d->__last_nonopt);
    a738:	e0811008 	add	r1, r1, r8
    a73c:	e586101c 	str	r1, [r6, #28]
}
    a740:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
	      argv[bottom + i] = argv[top - (middle - bottom) + i];
    a744:	e044400c 	sub	r4, r4, ip
    a748:	e0853102 	add	r3, r5, r2, lsl #2
    a74c:	e085c104 	add	ip, r5, r4, lsl #2
    a750:	e59c9000 	ldr	r9, [ip]
	      tem = argv[bottom + i];
    a754:	e593e000 	ldr	lr, [r3]
	      argv[bottom + i] = argv[top - (middle - bottom) + i];
    a758:	e4839004 	str	r9, [r3], #4
	  for (i = 0; i < len; i++)
    a75c:	e1500003 	cmp	r0, r3
	      argv[top - (middle - bottom) + i] = tem;
    a760:	e48ce004 	str	lr, [ip], #4
	  for (i = 0; i < len; i++)
    a764:	1afffff9 	bne	a750 <exchange+0xb0>
    a768:	eaffffe9 	b	a714 <exchange+0x74>

0000a76c <process_long_option>:
static int
process_long_option (int argc, char **argv, const char *optstring,
		     const struct option *longopts, int *longind,
		     int long_only, struct _getopt_data *d,
		     int print_errors, const char *prefix)
{
    a76c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a770:	e24dd02c 	sub	sp, sp, #44	@ 0x2c
    a774:	e59d7058 	ldr	r7, [sp, #88]	@ 0x58
    a778:	e58d0018 	str	r0, [sp, #24]
  const struct option *p;
  const struct option *pfound = NULL;
  int n_options;
  int option_index;

  for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)
    a77c:	e5979014 	ldr	r9, [r7, #20]
{
    a780:	e58d1014 	str	r1, [sp, #20]
    a784:	e58d201c 	str	r2, [sp, #28]
  for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)
    a788:	e5d95000 	ldrb	r5, [r9]
    a78c:	e1a0b009 	mov	fp, r9
{
    a790:	e58d300c 	str	r3, [sp, #12]
  for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)
    a794:	e3550000 	cmp	r5, #0
    a798:	1355003d 	cmpne	r5, #61	@ 0x3d
    a79c:	13a05001 	movne	r5, #1
    a7a0:	03a05000 	moveq	r5, #0
    a7a4:	0a000004 	beq	a7bc <process_long_option+0x50>
    a7a8:	e5fb3001 	ldrb	r3, [fp, #1]!
    a7ac:	e3530000 	cmp	r3, #0
    a7b0:	1353003d 	cmpne	r3, #61	@ 0x3d
    a7b4:	1afffffb 	bne	a7a8 <process_long_option+0x3c>
    /* Do nothing.  */ ;
  namelen = nameend - d->__nextchar;
    a7b8:	e04b5009 	sub	r5, fp, r9

  /* First look for an exact match, counting the options as a side
     effect.  */
  for (p = longopts, n_options = 0; p->name; p++, n_options++)
    a7bc:	e59d300c 	ldr	r3, [sp, #12]
    a7c0:	e5930000 	ldr	r0, [r3]
    a7c4:	e3500000 	cmp	r0, #0
    a7c8:	0a000077 	beq	a9ac <process_long_option+0x240>
    a7cc:	e59d400c 	ldr	r4, [sp, #12]
    a7d0:	e1a0a000 	mov	sl, r0
    a7d4:	e58d7058 	str	r7, [sp, #88]	@ 0x58
    a7d8:	e3a06000 	mov	r6, #0
    a7dc:	e1a07000 	mov	r7, r0
    a7e0:	e1a08004 	mov	r8, r4
    if (!strncmp (p->name, d->__nextchar, namelen)
    a7e4:	e1a02005 	mov	r2, r5
    a7e8:	e1a01009 	mov	r1, r9
    a7ec:	e1a00007 	mov	r0, r7
    a7f0:	eb00404f 	bl	1a934 <strncmp>
    a7f4:	e1a02000 	mov	r2, r0
	&& namelen == strlen (p->name))
    a7f8:	e1a00007 	mov	r0, r7
    if (!strncmp (p->name, d->__nextchar, namelen)
    a7fc:	e3520000 	cmp	r2, #0
    a800:	1a000002 	bne	a810 <process_long_option+0xa4>
	&& namelen == strlen (p->name))
    a804:	fa00571d 	blx	20480 <strlen>
    a808:	e1500005 	cmp	r0, r5
    a80c:	0a000027 	beq	a8b0 <process_long_option+0x144>
  for (p = longopts, n_options = 0; p->name; p++, n_options++)
    a810:	e5b47010 	ldr	r7, [r4, #16]!
    a814:	e2866001 	add	r6, r6, #1
    a818:	e3570000 	cmp	r7, #0
    a81c:	1afffff0 	bne	a7e4 <process_long_option+0x78>
    a820:	e59d7058 	ldr	r7, [sp, #88]	@ 0x58
    a824:	e1a0000a 	mov	r0, sl
    a828:	e3a03000 	mov	r3, #0
			    memset (ambig_set, 0, n_options);
			    ambig_set[indfound] = 1;
			  }
		      }
		    if (ambig_set)
		      ambig_set[option_index] = 1;
    a82c:	e1a01009 	mov	r1, r9
  for (p = longopts, n_options = 0; p->name; p++, n_options++)
    a830:	e1a0a003 	mov	sl, r3
    a834:	e1a04003 	mov	r4, r3
		      ambig_set[option_index] = 1;
    a838:	e1a09003 	mov	r9, r3
  for (p = longopts, n_options = 0; p->name; p++, n_options++)
    a83c:	e3e02000 	mvn	r2, #0
    a840:	e1cd22f0 	strd	r2, [sp, #32]
    a844:	e58d3010 	str	r3, [sp, #16]
	if (!strncmp (p->name, d->__nextchar, namelen))
    a848:	e1a02005 	mov	r2, r5
    a84c:	eb004038 	bl	1a934 <strncmp>
    a850:	e3500000 	cmp	r0, #0
    a854:	1a00000f 	bne	a898 <process_long_option+0x12c>
	    if (pfound == NULL)
    a858:	e3540000 	cmp	r4, #0
    a85c:	0a00003e 	beq	a95c <process_long_option+0x1f0>
	    else if (long_only
    a860:	e59d3054 	ldr	r3, [sp, #84]	@ 0x54
    a864:	e3530000 	cmp	r3, #0
    a868:	0a00002e 	beq	a928 <process_long_option+0x1bc>
		if (!ambig_fallback)
    a86c:	e3590000 	cmp	r9, #0
    a870:	1a000008 	bne	a898 <process_long_option+0x12c>
		    if (!print_errors)
    a874:	e59d305c 	ldr	r3, [sp, #92]	@ 0x5c
    a878:	e3530000 	cmp	r3, #0
		    if (ambig_set)
    a87c:	e59d3010 	ldr	r3, [sp, #16]
		    if (!print_errors)
    a880:	0a000045 	beq	a99c <process_long_option+0x230>
		    else if (!ambig_set)
    a884:	e3530000 	cmp	r3, #0
    a888:	0a000090 	beq	aad0 <process_long_option+0x364>
		      ambig_set[option_index] = 1;
    a88c:	e59d3010 	ldr	r3, [sp, #16]
    a890:	e3a02001 	mov	r2, #1
    a894:	e7c3200a 	strb	r2, [r3, sl]
      for (p = longopts, option_index = 0; p->name; p++, option_index++)
    a898:	e5b80010 	ldr	r0, [r8, #16]!
    a89c:	e28aa001 	add	sl, sl, #1
    a8a0:	e3500000 	cmp	r0, #0
    a8a4:	0a000032 	beq	a974 <process_long_option+0x208>
      if (ambig_set || ambig_fallback)
	{
	  if (print_errors)
	    {
	      if (ambig_fallback)
		fprintf (stderr, _("%s: option '%s%s' is ambiguous\n"),
    a8a8:	e5971014 	ldr	r1, [r7, #20]
    a8ac:	eaffffe5 	b	a848 <process_long_option+0xdc>
  if (pfound == NULL)
    a8b0:	e3540000 	cmp	r4, #0
    a8b4:	e59d7058 	ldr	r7, [sp, #88]	@ 0x58
    a8b8:	e1a0000a 	mov	r0, sl
    a8bc:	0affffd9 	beq	a828 <process_long_option+0xbc>
      /* Otherwise interpret it as a short option.  */
      return -1;
    }

  /* We have found a matching long option.  Consume it.  */
  d->optind++;
    a8c0:	e5973000 	ldr	r3, [r7]
  d->__nextchar = NULL;
    a8c4:	e3a01000 	mov	r1, #0
    a8c8:	e5871014 	str	r1, [r7, #20]
  if (*nameend)
    {
      /* Don't test has_arg with >, because some C compilers don't
	 allow it to be used on enums.  */
      if (pfound->has_arg)
    a8cc:	e5940004 	ldr	r0, [r4, #4]
  d->optind++;
    a8d0:	e2831001 	add	r1, r3, #1
    a8d4:	e5871000 	str	r1, [r7]
  if (*nameend)
    a8d8:	e5dbc000 	ldrb	ip, [fp]
    a8dc:	e35c0000 	cmp	ip, #0
    a8e0:	1a00000b 	bne	a914 <process_long_option+0x1a8>

	  d->optopt = pfound->val;
	  return '?';
	}
    }
  else if (pfound->has_arg == 1)
    a8e4:	e3500001 	cmp	r0, #1
    a8e8:	0a00004a 	beq	aa18 <process_long_option+0x2ac>
	  d->optopt = pfound->val;
	  return optstring[0] == ':' ? ':' : '?';
	}
    }

  if (longind != NULL)
    a8ec:	e59d3050 	ldr	r3, [sp, #80]	@ 0x50
    a8f0:	e3530000 	cmp	r3, #0
    *longind = option_index;
    a8f4:	15836000 	strne	r6, [r3]
  if (pfound->flag)
    a8f8:	e5943008 	ldr	r3, [r4, #8]
    {
      *(pfound->flag) = pfound->val;
    a8fc:	e594000c 	ldr	r0, [r4, #12]
  if (pfound->flag)
    a900:	e3530000 	cmp	r3, #0
      *(pfound->flag) = pfound->val;
    a904:	15830000 	strne	r0, [r3]
      return 0;
    a908:	13a00000 	movne	r0, #0
    }
  return pfound->val;
}
    a90c:	e28dd02c 	add	sp, sp, #44	@ 0x2c
    a910:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (pfound->has_arg)
    a914:	e3500000 	cmp	r0, #0
    a918:	0a000047 	beq	aa3c <process_long_option+0x2d0>
	d->optarg = nameend + 1;
    a91c:	e28b2001 	add	r2, fp, #1
    a920:	e587200c 	str	r2, [r7, #12]
    a924:	eafffff0 	b	a8ec <process_long_option+0x180>
		     || pfound->has_arg != p->has_arg
    a928:	e5941004 	ldr	r1, [r4, #4]
    a92c:	e5982004 	ldr	r2, [r8, #4]
    a930:	e1510002 	cmp	r1, r2
    a934:	1affffcc 	bne	a86c <process_long_option+0x100>
		     || pfound->flag != p->flag
    a938:	e5941008 	ldr	r1, [r4, #8]
    a93c:	e5982008 	ldr	r2, [r8, #8]
    a940:	e1510002 	cmp	r1, r2
    a944:	1affffc8 	bne	a86c <process_long_option+0x100>
		     || pfound->val != p->val)
    a948:	e594100c 	ldr	r1, [r4, #12]
    a94c:	e598200c 	ldr	r2, [r8, #12]
    a950:	e1510002 	cmp	r1, r2
    a954:	1affffc4 	bne	a86c <process_long_option+0x100>
    a958:	eaffffce 	b	a898 <process_long_option+0x12c>
		pfound = p;
    a95c:	e1a04008 	mov	r4, r8
      for (p = longopts, option_index = 0; p->name; p++, option_index++)
    a960:	e5b80010 	ldr	r0, [r8, #16]!
		indfound = option_index;
    a964:	e58da020 	str	sl, [sp, #32]
      for (p = longopts, option_index = 0; p->name; p++, option_index++)
    a968:	e28aa001 	add	sl, sl, #1
    a96c:	e3500000 	cmp	r0, #0
    a970:	1affffcc 	bne	a8a8 <process_long_option+0x13c>
      if (ambig_set || ambig_fallback)
    a974:	e59d2010 	ldr	r2, [sp, #16]
    a978:	e1a03009 	mov	r3, r9
    a97c:	e3520000 	cmp	r2, #0
    a980:	13833001 	orrne	r3, r3, #1
    a984:	e3130001 	tst	r3, #1
    a988:	1a000031 	bne	aa54 <process_long_option+0x2e8>
  if (pfound == NULL)
    a98c:	e3540000 	cmp	r4, #0
    a990:	0a000005 	beq	a9ac <process_long_option+0x240>
    a994:	e59d6020 	ldr	r6, [sp, #32]
    a998:	eaffffc8 	b	a8c0 <process_long_option+0x154>
		    if (ambig_set)
    a99c:	e3530000 	cmp	r3, #0
    a9a0:	e3a09001 	mov	r9, #1
    a9a4:	0affffbb 	beq	a898 <process_long_option+0x12c>
    a9a8:	eaffffb7 	b	a88c <process_long_option+0x120>
      if (!long_only || argv[d->optind][1] == '-'
    a9ac:	e59d3054 	ldr	r3, [sp, #84]	@ 0x54
    a9b0:	e3530000 	cmp	r3, #0
    a9b4:	0a00000c 	beq	a9ec <process_long_option+0x280>
    a9b8:	e5973000 	ldr	r3, [r7]
    a9bc:	e59d2014 	ldr	r2, [sp, #20]
    a9c0:	e7923103 	ldr	r3, [r2, r3, lsl #2]
    a9c4:	e5d33001 	ldrb	r3, [r3, #1]
    a9c8:	e353002d 	cmp	r3, #45	@ 0x2d
    a9cc:	0a000006 	beq	a9ec <process_long_option+0x280>
	  || strchr (optstring, *d->__nextchar) == NULL)
    a9d0:	e5973014 	ldr	r3, [r7, #20]
    a9d4:	e59d001c 	ldr	r0, [sp, #28]
    a9d8:	e5d31000 	ldrb	r1, [r3]
    a9dc:	eb003f71 	bl	1a7a8 <strchr>
    a9e0:	e3500000 	cmp	r0, #0
      return -1;
    a9e4:	13e00000 	mvnne	r0, #0
    a9e8:	1affffc7 	bne	a90c <process_long_option+0x1a0>
	  if (print_errors)
    a9ec:	e59d305c 	ldr	r3, [sp, #92]	@ 0x5c
    a9f0:	e3530000 	cmp	r3, #0
    a9f4:	1a000043 	bne	ab08 <process_long_option+0x39c>
	  d->optind++;
    a9f8:	e5973000 	ldr	r3, [r7]
	  d->__nextchar = NULL;
    a9fc:	e3a02000 	mov	r2, #0
    aa00:	e5872014 	str	r2, [r7, #20]
	  d->optopt = 0;
    aa04:	e5872008 	str	r2, [r7, #8]
	  d->optind++;
    aa08:	e2833001 	add	r3, r3, #1
    aa0c:	e5873000 	str	r3, [r7]
	  return '?';
    aa10:	e3a0003f 	mov	r0, #63	@ 0x3f
    aa14:	eaffffbc 	b	a90c <process_long_option+0x1a0>
      if (d->optind < argc)
    aa18:	e59d2018 	ldr	r2, [sp, #24]
    aa1c:	e1510002 	cmp	r1, r2
    aa20:	aa000048 	bge	ab48 <process_long_option+0x3dc>
	d->optarg = argv[d->optind++];
    aa24:	e59d2014 	ldr	r2, [sp, #20]
    aa28:	e2833002 	add	r3, r3, #2
    aa2c:	e7922101 	ldr	r2, [r2, r1, lsl #2]
    aa30:	e5873000 	str	r3, [r7]
    aa34:	e587200c 	str	r2, [r7, #12]
    aa38:	eaffffab 	b	a8ec <process_long_option+0x180>
	  if (print_errors)
    aa3c:	e59d305c 	ldr	r3, [sp, #92]	@ 0x5c
    aa40:	e3530000 	cmp	r3, #0
    aa44:	1a000049 	bne	ab70 <process_long_option+0x404>
	  d->optopt = pfound->val;
    aa48:	e594300c 	ldr	r3, [r4, #12]
    aa4c:	e5873008 	str	r3, [r7, #8]
	  return '?';
    aa50:	eaffffee 	b	aa10 <process_long_option+0x2a4>
	  if (print_errors)
    aa54:	e59d305c 	ldr	r3, [sp, #92]	@ 0x5c
    aa58:	e3530000 	cmp	r3, #0
    aa5c:	0a00000d 	beq	aa98 <process_long_option+0x32c>
		fprintf (stderr, _("%s: option '%s%s' is ambiguous\n"),
    aa60:	e59d3014 	ldr	r3, [sp, #20]
    aa64:	e30b51e8 	movw	r5, #45544	@ 0xb1e8
    aa68:	e3405002 	movt	r5, #2
	      if (ambig_fallback)
    aa6c:	e3590000 	cmp	r9, #0
		fprintf (stderr, _("%s: option '%s%s' is ambiguous\n"),
    aa70:	e5951000 	ldr	r1, [r5]
    aa74:	e5932000 	ldr	r2, [r3]
    aa78:	e5973014 	ldr	r3, [r7, #20]
    aa7c:	e591000c 	ldr	r0, [r1, #12]
    aa80:	e58d3000 	str	r3, [sp]
	      if (ambig_fallback)
    aa84:	0a000053 	beq	abd8 <process_long_option+0x46c>
		fprintf (stderr, _("%s: option '%s%s' is ambiguous\n"),
    aa88:	e3081c44 	movw	r1, #35908	@ 0x8c44
    aa8c:	e59d3060 	ldr	r3, [sp, #96]	@ 0x60
    aa90:	e3401002 	movt	r1, #2
    aa94:	eb003722 	bl	18724 <fprintf>
	  if (ambig_malloced)
    aa98:	e59d3024 	ldr	r3, [sp, #36]	@ 0x24
    aa9c:	e3530000 	cmp	r3, #0
    aaa0:	1a000025 	bne	ab3c <process_long_option+0x3d0>
	  d->__nextchar += strlen (d->__nextchar);
    aaa4:	e5974014 	ldr	r4, [r7, #20]
    aaa8:	e1a00004 	mov	r0, r4
    aaac:	fa005673 	blx	20480 <strlen>
	  d->optind++;
    aab0:	e5973000 	ldr	r3, [r7]
	  d->__nextchar += strlen (d->__nextchar);
    aab4:	e0844000 	add	r4, r4, r0
	  d->optopt = 0;
    aab8:	e3a02000 	mov	r2, #0
	  d->__nextchar += strlen (d->__nextchar);
    aabc:	e5874014 	str	r4, [r7, #20]
	  d->optopt = 0;
    aac0:	e5872008 	str	r2, [r7, #8]
	  d->optind++;
    aac4:	e2833001 	add	r3, r3, #1
    aac8:	e5873000 	str	r3, [r7]
	  return '?';
    aacc:	eaffffcf 	b	aa10 <process_long_option+0x2a4>
			else if ((ambig_set = malloc (n_options)) == NULL)
    aad0:	e1a00006 	mov	r0, r6
    aad4:	eb000ece 	bl	e614 <rpl_malloc>
    aad8:	e2503000 	subs	r3, r0, #0
    aadc:	e58d3010 	str	r3, [sp, #16]
    aae0:	0a00005c 	beq	ac58 <process_long_option+0x4ec>

__BEGIN_DECLS
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
__ssp_bos_icheck3(memmove, void *, const void *)
__ssp_bos_icheck3_restrict(mempcpy, void *, const void *)
__ssp_bos_icheck3(memset, void *, int)
    aae4:	e1a02006 	mov	r2, r6
    aae8:	e1a01009 	mov	r1, r9
    aaec:	eb003eef 	bl	1a6b0 <memset>
			    ambig_set[indfound] = 1;
    aaf0:	e59d3010 	ldr	r3, [sp, #16]
    aaf4:	e3a02001 	mov	r2, #1
    aaf8:	e59d1020 	ldr	r1, [sp, #32]
			  ambig_malloced = 1;
    aafc:	e58d2024 	str	r2, [sp, #36]	@ 0x24
			    ambig_set[indfound] = 1;
    ab00:	e7c32001 	strb	r2, [r3, r1]
		    if (ambig_set)
    ab04:	eaffff60 	b	a88c <process_long_option+0x120>
	    fprintf (stderr, _("%s: unrecognized option '%s%s'\n"),
    ab08:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
    ab0c:	e597c014 	ldr	ip, [r7, #20]
    ab10:	e3403002 	movt	r3, #2
    ab14:	e3081c9c 	movw	r1, #35996	@ 0x8c9c
    ab18:	e5930000 	ldr	r0, [r3]
    ab1c:	e3401002 	movt	r1, #2
    ab20:	e59d3014 	ldr	r3, [sp, #20]
    ab24:	e590000c 	ldr	r0, [r0, #12]
    ab28:	e5932000 	ldr	r2, [r3]
    ab2c:	e59d3060 	ldr	r3, [sp, #96]	@ 0x60
    ab30:	e58dc000 	str	ip, [sp]
    ab34:	eb0036fa 	bl	18724 <fprintf>
    ab38:	eaffffae 	b	a9f8 <process_long_option+0x28c>
	    free (ambig_set);
    ab3c:	e59d0010 	ldr	r0, [sp, #16]
    ab40:	ebfffe44 	bl	a458 <rpl_free>
    ab44:	eaffffd6 	b	aaa4 <process_long_option+0x338>
	  if (print_errors)
    ab48:	e59d305c 	ldr	r3, [sp, #92]	@ 0x5c
    ab4c:	e3530000 	cmp	r3, #0
    ab50:	1a000013 	bne	aba4 <process_long_option+0x438>
	  d->optopt = pfound->val;
    ab54:	e594300c 	ldr	r3, [r4, #12]
    ab58:	e5873008 	str	r3, [r7, #8]
	  return optstring[0] == ':' ? ':' : '?';
    ab5c:	e59d301c 	ldr	r3, [sp, #28]
    ab60:	e5d30000 	ldrb	r0, [r3]
    ab64:	e350003a 	cmp	r0, #58	@ 0x3a
    ab68:	1affffa8 	bne	aa10 <process_long_option+0x2a4>
    ab6c:	eaffff66 	b	a90c <process_long_option+0x1a0>
	    fprintf (stderr,
    ab70:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
    ab74:	e5941000 	ldr	r1, [r4]
    ab78:	e3403002 	movt	r3, #2
    ab7c:	e59d2014 	ldr	r2, [sp, #20]
    ab80:	e5933000 	ldr	r3, [r3]
    ab84:	e5922000 	ldr	r2, [r2]
    ab88:	e593000c 	ldr	r0, [r3, #12]
    ab8c:	e58d1000 	str	r1, [sp]
    ab90:	e3081cbc 	movw	r1, #36028	@ 0x8cbc
    ab94:	e59d3060 	ldr	r3, [sp, #96]	@ 0x60
    ab98:	e3401002 	movt	r1, #2
    ab9c:	eb0036e0 	bl	18724 <fprintf>
    aba0:	eaffffa8 	b	aa48 <process_long_option+0x2dc>
	    fprintf (stderr,
    aba4:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
    aba8:	e59d2014 	ldr	r2, [sp, #20]
    abac:	e3403002 	movt	r3, #2
    abb0:	e3081cec 	movw	r1, #36076	@ 0x8cec
    abb4:	e5933000 	ldr	r3, [r3]
    abb8:	e3401002 	movt	r1, #2
    abbc:	e5922000 	ldr	r2, [r2]
    abc0:	e593000c 	ldr	r0, [r3, #12]
    abc4:	e5943000 	ldr	r3, [r4]
    abc8:	e58d3000 	str	r3, [sp]
    abcc:	e59d3060 	ldr	r3, [sp, #96]	@ 0x60
    abd0:	eb0036d3 	bl	18724 <fprintf>
    abd4:	eaffffde 	b	ab54 <process_long_option+0x3e8>
		  fprintf (stderr,
    abd8:	e3081c64 	movw	r1, #35940	@ 0x8c64
    abdc:	e59d3060 	ldr	r3, [sp, #96]	@ 0x60
    abe0:	e3401002 	movt	r1, #2
    abe4:	eb0036ce 	bl	18724 <fprintf>
		  for (option_index = 0; option_index < n_options; option_index++)
    abe8:	e3560000 	cmp	r6, #0
    abec:	0a000014 	beq	ac44 <process_long_option+0x4d8>
    abf0:	e59d3010 	ldr	r3, [sp, #16]
    abf4:	e2466001 	sub	r6, r6, #1
		      fprintf (stderr, " '%s%s'",
    abf8:	e3088c94 	movw	r8, #35988	@ 0x8c94
    abfc:	e59da00c 	ldr	sl, [sp, #12]
    ac00:	e3408002 	movt	r8, #2
    ac04:	e0836006 	add	r6, r3, r6
    ac08:	e2434001 	sub	r4, r3, #1
    ac0c:	ea000002 	b	ac1c <process_long_option+0x4b0>
		  for (option_index = 0; option_index < n_options; option_index++)
    ac10:	e1560004 	cmp	r6, r4
    ac14:	e2899001 	add	r9, r9, #1
    ac18:	0a000009 	beq	ac44 <process_long_option+0x4d8>
		    if (ambig_set[option_index])
    ac1c:	e5f43001 	ldrb	r3, [r4, #1]!
    ac20:	e3530000 	cmp	r3, #0
    ac24:	0afffff9 	beq	ac10 <process_long_option+0x4a4>
		      fprintf (stderr, " '%s%s'",
    ac28:	e5953000 	ldr	r3, [r5]
    ac2c:	e1a01008 	mov	r1, r8
    ac30:	e59d2060 	ldr	r2, [sp, #96]	@ 0x60
    ac34:	e593000c 	ldr	r0, [r3, #12]
    ac38:	e79a3209 	ldr	r3, [sl, r9, lsl #4]
    ac3c:	eb0036b8 	bl	18724 <fprintf>
    ac40:	eafffff2 	b	ac10 <process_long_option+0x4a4>
		  fprintf (stderr, "\n");
    ac44:	e5953000 	ldr	r3, [r5]
    ac48:	e3a0000a 	mov	r0, #10
    ac4c:	e593100c 	ldr	r1, [r3, #12]
    ac50:	eb0036d4 	bl	187a8 <fputc>
    ac54:	eaffff8f 	b	aa98 <process_long_option+0x32c>
			  ambig_fallback = 1;
    ac58:	e3a09001 	mov	r9, #1
    ac5c:	eaffff0d 	b	a898 <process_long_option+0x12c>

0000ac60 <_getopt_internal_r>:

int
_getopt_internal_r (int argc, char **argv, const char *optstring,
		    const struct option *longopts, int *longind,
		    int long_only, struct _getopt_data *d, int posixly_correct)
{
    ac60:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ac64:	e24dd024 	sub	sp, sp, #36	@ 0x24
    ac68:	e59d4050 	ldr	r4, [sp, #80]	@ 0x50
  int print_errors = d->opterr;

  if (argc < 1)
    ac6c:	e2506000 	subs	r6, r0, #0
  int print_errors = d->opterr;
    ac70:	e594a004 	ldr	sl, [r4, #4]
  if (argc < 1)
    ac74:	da000085 	ble	ae90 <_getopt_internal_r+0x230>
    ac78:	e1a09003 	mov	r9, r3
    return -1;

  d->optarg = NULL;

  if (d->optind == 0 || !d->__initialized)
    ac7c:	e5943000 	ldr	r3, [r4]
    ac80:	e1a07002 	mov	r7, r2
  d->optarg = NULL;
    ac84:	e3a02000 	mov	r2, #0
    ac88:	e1a08001 	mov	r8, r1
    ac8c:	e584200c 	str	r2, [r4, #12]
  if (d->optind == 0 || !d->__initialized)
    ac90:	e3530000 	cmp	r3, #0
    ac94:	0a00002b 	beq	ad48 <_getopt_internal_r+0xe8>
    ac98:	e5942010 	ldr	r2, [r4, #16]
    ac9c:	e3520000 	cmp	r2, #0
    aca0:	0a00002a 	beq	ad50 <_getopt_internal_r+0xf0>
    optstring = _getopt_initialize (argc, argv, optstring, d, posixly_correct);
  else if (optstring[0] == '-' || optstring[0] == '+')
    aca4:	e5d73000 	ldrb	r3, [r7]
    print_errors = 0;

  /* Test whether ARGV[optind] points to a non-option argument.  */
#define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\0')

  if (d->__nextchar == NULL || *d->__nextchar == '\0')
    aca8:	e5945014 	ldr	r5, [r4, #20]
  else if (optstring[0] == '-' || optstring[0] == '+')
    acac:	e243202b 	sub	r2, r3, #43	@ 0x2b
    acb0:	e31200fd 	tst	r2, #253	@ 0xfd
  if (optstring[0] == ':')
    acb4:	05d73001 	ldrbeq	r3, [r7, #1]
    optstring++;
    acb8:	02877001 	addeq	r7, r7, #1
    print_errors = 0;
    acbc:	e353003a 	cmp	r3, #58	@ 0x3a
    acc0:	03a0a000 	moveq	sl, #0
  if (d->__nextchar == NULL || *d->__nextchar == '\0')
    acc4:	e3550000 	cmp	r5, #0
    acc8:	0a00003a 	beq	adb8 <_getopt_internal_r+0x158>
    accc:	e5d53000 	ldrb	r3, [r5]
    acd0:	e3530000 	cmp	r3, #0
    acd4:	0a000037 	beq	adb8 <_getopt_internal_r+0x158>
    }

  /* Look at and handle the next short option-character.  */

  {
    char c = *d->__nextchar++;
    acd8:	e2853001 	add	r3, r5, #1
    const char *temp = strchr (optstring, c);
    acdc:	e1a00007 	mov	r0, r7
    char c = *d->__nextchar++;
    ace0:	e5843014 	str	r3, [r4, #20]
    ace4:	e5d5b000 	ldrb	fp, [r5]
    ace8:	e58d301c 	str	r3, [sp, #28]
    const char *temp = strchr (optstring, c);
    acec:	e1a0100b 	mov	r1, fp
    acf0:	e58db018 	str	fp, [sp, #24]
    acf4:	eb003eab 	bl	1a7a8 <strchr>

    /* Increment 'optind' when we start to process its last character.  */
    if (*d->__nextchar == '\0')
    acf8:	e5d51001 	ldrb	r1, [r5, #1]
    acfc:	e1a0200b 	mov	r2, fp
    ad00:	e59d301c 	ldr	r3, [sp, #28]
    ad04:	e3510000 	cmp	r1, #0
      ++d->optind;
    ad08:	05941000 	ldreq	r1, [r4]
    ad0c:	02811001 	addeq	r1, r1, #1
    ad10:	05841000 	streq	r1, [r4]

    if (temp == NULL || c == ':' || c == ';')
    ad14:	e24b103a 	sub	r1, fp, #58	@ 0x3a
    ad18:	e3500000 	cmp	r0, #0
    ad1c:	13510001 	cmpne	r1, #1
    ad20:	9a0000e5 	bls	b0bc <_getopt_internal_r+0x45c>
	d->optopt = c;
	return '?';
      }

    /* Convenience. Treat POSIX -W foo same as long option --foo */
    if (temp[0] == 'W' && temp[1] == ';' && longopts != NULL)
    ad24:	e5d01000 	ldrb	r1, [r0]
    ad28:	e3510057 	cmp	r1, #87	@ 0x57
    ad2c:	e5d01001 	ldrb	r1, [r0, #1]
    ad30:	0a00009b 	beq	afa4 <_getopt_internal_r+0x344>
	d->__nextchar = d->optarg;
	d->optarg = NULL;
	return process_long_option (argc, argv, optstring, longopts, longind,
				    0 /* long_only */, d, print_errors, "-W ");
      }
    if (temp[1] == ':')
    ad34:	e351003a 	cmp	r1, #58	@ 0x3a
    ad38:	0a0000c2 	beq	b048 <_getopt_internal_r+0x3e8>
	    d->__nextchar = NULL;
	  }
      }
    return c;
  }
}
    ad3c:	e1a00002 	mov	r0, r2
    ad40:	e28dd024 	add	sp, sp, #36	@ 0x24
    ad44:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d->optind = 1;
    ad48:	e3a03001 	mov	r3, #1
    ad4c:	e5843000 	str	r3, [r4]
  d->__nextchar = NULL;
    ad50:	e3a05000 	mov	r5, #0
  d->__first_nonopt = d->__last_nonopt = d->optind;
    ad54:	e584301c 	str	r3, [r4, #28]
    ad58:	e5843020 	str	r3, [r4, #32]
  d->__nextchar = NULL;
    ad5c:	e5845014 	str	r5, [r4, #20]
  if (optstring[0] == '-')
    ad60:	e5d73000 	ldrb	r3, [r7]
    ad64:	e353002d 	cmp	r3, #45	@ 0x2d
    ad68:	0a00000a 	beq	ad98 <_getopt_internal_r+0x138>
  else if (optstring[0] == '+')
    ad6c:	e353002b 	cmp	r3, #43	@ 0x2b
    ad70:	0a0000c9 	beq	b09c <_getopt_internal_r+0x43c>
  else if (posixly_correct || !!getenv ("POSIXLY_CORRECT"))
    ad74:	e59d3054 	ldr	r3, [sp, #84]	@ 0x54
    ad78:	e3530000 	cmp	r3, #0
    ad7c:	0a0000a8 	beq	b024 <_getopt_internal_r+0x3c4>
    d->__ordering = REQUIRE_ORDER;
    ad80:	e3a03000 	mov	r3, #0
    ad84:	e5c43018 	strb	r3, [r4, #24]
  d->__initialized = 1;
    ad88:	e3a03001 	mov	r3, #1
    ad8c:	e5843010 	str	r3, [r4, #16]
  if (optstring[0] == ':')
    ad90:	e5d73000 	ldrb	r3, [r7]
    optstring = _getopt_initialize (argc, argv, optstring, d, posixly_correct);
    ad94:	eaffffc8 	b	acbc <_getopt_internal_r+0x5c>
      d->__ordering = RETURN_IN_ORDER;
    ad98:	e3a03002 	mov	r3, #2
    optstring = _getopt_initialize (argc, argv, optstring, d, posixly_correct);
    ad9c:	e2877001 	add	r7, r7, #1
      d->__ordering = RETURN_IN_ORDER;
    ada0:	e5c43018 	strb	r3, [r4, #24]
  d->__initialized = 1;
    ada4:	e3a03001 	mov	r3, #1
    ada8:	e5843010 	str	r3, [r4, #16]
  if (optstring[0] == ':')
    adac:	e5d73000 	ldrb	r3, [r7]
    optstring = _getopt_initialize (argc, argv, optstring, d, posixly_correct);
    adb0:	e353003a 	cmp	r3, #58	@ 0x3a
    adb4:	01a0a005 	moveq	sl, r5
      if (d->__last_nonopt > d->optind)
    adb8:	e5945000 	ldr	r5, [r4]
    adbc:	e5943020 	ldr	r3, [r4, #32]
    adc0:	e1530005 	cmp	r3, r5
      if (d->__first_nonopt > d->optind)
    adc4:	e594301c 	ldr	r3, [r4, #28]
	d->__last_nonopt = d->optind;
    adc8:	c5845020 	strgt	r5, [r4, #32]
      if (d->__first_nonopt > d->optind)
    adcc:	e1550003 	cmp	r5, r3
      if (d->__ordering == PERMUTE)
    add0:	e5d43018 	ldrb	r3, [r4, #24]
	d->__first_nonopt = d->optind;
    add4:	b584501c 	strlt	r5, [r4, #28]
      if (d->__ordering == PERMUTE)
    add8:	e3530001 	cmp	r3, #1
    addc:	0a00002d 	beq	ae98 <_getopt_internal_r+0x238>
      if (d->optind != argc && !strcmp (argv[d->optind], "--"))
    ade0:	e1560005 	cmp	r6, r5
    ade4:	0a000025 	beq	ae80 <_getopt_internal_r+0x220>
    ade8:	e798b105 	ldr	fp, [r8, r5, lsl #2]
    adec:	e5db3000 	ldrb	r3, [fp]
    adf0:	e353002d 	cmp	r3, #45	@ 0x2d
    adf4:	1a000014 	bne	ae4c <_getopt_internal_r+0x1ec>
    adf8:	e5db3001 	ldrb	r3, [fp, #1]
    adfc:	e353002d 	cmp	r3, #45	@ 0x2d
    ae00:	1a000011 	bne	ae4c <_getopt_internal_r+0x1ec>
    ae04:	e5db3002 	ldrb	r3, [fp, #2]
    ae08:	e3530000 	cmp	r3, #0
    ae0c:	1a00000e 	bne	ae4c <_getopt_internal_r+0x1ec>
	  if (d->__first_nonopt != d->__last_nonopt
    ae10:	e594301c 	ldr	r3, [r4, #28]
	  d->optind++;
    ae14:	e2855001 	add	r5, r5, #1
	  if (d->__first_nonopt != d->__last_nonopt
    ae18:	e5942020 	ldr	r2, [r4, #32]
	  d->optind++;
    ae1c:	e5845000 	str	r5, [r4]
	  if (d->__first_nonopt != d->__last_nonopt
    ae20:	e1530002 	cmp	r3, r2
    ae24:	0a0000af 	beq	b0e8 <_getopt_internal_r+0x488>
	      && d->__last_nonopt != d->optind)
    ae28:	e1550002 	cmp	r5, r2
    ae2c:	0a000003 	beq	ae40 <_getopt_internal_r+0x1e0>
	    exchange (argv, d);
    ae30:	e1a01004 	mov	r1, r4
    ae34:	e1a00008 	mov	r0, r8
    ae38:	ebfffe18 	bl	a6a0 <exchange>
	  if (d->__first_nonopt != d->__last_nonopt)
    ae3c:	e594301c 	ldr	r3, [r4, #28]
	  d->__last_nonopt = argc;
    ae40:	e5846020 	str	r6, [r4, #32]
	  d->optind = argc;
    ae44:	e5846000 	str	r6, [r4]
    ae48:	ea00000e 	b	ae88 <_getopt_internal_r+0x228>
      if (NONOPTION_P)
    ae4c:	e5db3000 	ldrb	r3, [fp]
    ae50:	e353002d 	cmp	r3, #45	@ 0x2d
    ae54:	0a00002a 	beq	af04 <_getopt_internal_r+0x2a4>
	  if (d->__ordering == REQUIRE_ORDER)
    ae58:	e5d43018 	ldrb	r3, [r4, #24]
    ae5c:	e3530000 	cmp	r3, #0
    ae60:	0a00000a 	beq	ae90 <_getopt_internal_r+0x230>
	  d->optarg = argv[d->optind++];
    ae64:	e2855001 	add	r5, r5, #1
	  return 1;
    ae68:	e3a02001 	mov	r2, #1
}
    ae6c:	e1a00002 	mov	r0, r2
	  d->optarg = argv[d->optind++];
    ae70:	e5845000 	str	r5, [r4]
    ae74:	e584b00c 	str	fp, [r4, #12]
}
    ae78:	e28dd024 	add	sp, sp, #36	@ 0x24
    ae7c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
	  if (d->__first_nonopt != d->__last_nonopt)
    ae80:	e594301c 	ldr	r3, [r4, #28]
    ae84:	e5946020 	ldr	r6, [r4, #32]
    ae88:	e1530006 	cmp	r3, r6
	    d->optind = d->__first_nonopt;
    ae8c:	15843000 	strne	r3, [r4]
    return -1;
    ae90:	e3e02000 	mvn	r2, #0
    ae94:	eaffffa8 	b	ad3c <_getopt_internal_r+0xdc>
	  if (d->__first_nonopt != d->__last_nonopt
    ae98:	e1c421dc 	ldrd	r2, [r4, #28]
    ae9c:	e1520003 	cmp	r2, r3
    aea0:	0a000078 	beq	b088 <_getopt_internal_r+0x428>
	      && d->__last_nonopt != d->optind)
    aea4:	e1550003 	cmp	r5, r3
    aea8:	0a000002 	beq	aeb8 <_getopt_internal_r+0x258>
	    exchange (argv, d);
    aeac:	e1a01004 	mov	r1, r4
    aeb0:	e1a00008 	mov	r0, r8
    aeb4:	ebfffdf9 	bl	a6a0 <exchange>
	  while (d->optind < argc && NONOPTION_P)
    aeb8:	e1550006 	cmp	r5, r6
    aebc:	aa000074 	bge	b094 <_getopt_internal_r+0x434>
    aec0:	e0882105 	add	r2, r8, r5, lsl #2
    aec4:	ea000003 	b	aed8 <_getopt_internal_r+0x278>
	    d->optind++;
    aec8:	e2855001 	add	r5, r5, #1
	  while (d->optind < argc && NONOPTION_P)
    aecc:	e1550006 	cmp	r5, r6
	    d->optind++;
    aed0:	e5845000 	str	r5, [r4]
	  while (d->optind < argc && NONOPTION_P)
    aed4:	0a00006e 	beq	b094 <_getopt_internal_r+0x434>
    aed8:	e4923004 	ldr	r3, [r2], #4
    aedc:	e5d31000 	ldrb	r1, [r3]
    aee0:	e351002d 	cmp	r1, #45	@ 0x2d
    aee4:	1afffff7 	bne	aec8 <_getopt_internal_r+0x268>
    aee8:	e5d33001 	ldrb	r3, [r3, #1]
    aeec:	e3530000 	cmp	r3, #0
    aef0:	0afffff4 	beq	aec8 <_getopt_internal_r+0x268>
      if (d->optind != argc && !strcmp (argv[d->optind], "--"))
    aef4:	e1a03005 	mov	r3, r5
    aef8:	e5945000 	ldr	r5, [r4]
	  d->__last_nonopt = d->optind;
    aefc:	e5843020 	str	r3, [r4, #32]
    af00:	eaffffb6 	b	ade0 <_getopt_internal_r+0x180>
      if (NONOPTION_P)
    af04:	e5db1001 	ldrb	r1, [fp, #1]
    af08:	e3510000 	cmp	r1, #0
    af0c:	0affffd1 	beq	ae58 <_getopt_internal_r+0x1f8>
      if (longopts)
    af10:	e3590000 	cmp	r9, #0
    af14:	0a000020 	beq	af9c <_getopt_internal_r+0x33c>
	  if (argv[d->optind][1] == '-')
    af18:	e351002d 	cmp	r1, #45	@ 0x2d
    af1c:	0a00008f 	beq	b160 <_getopt_internal_r+0x500>
	  if (long_only && (argv[d->optind][2]
    af20:	e59d304c 	ldr	r3, [sp, #76]	@ 0x4c
    af24:	e3530000 	cmp	r3, #0
    af28:	0a00001b 	beq	af9c <_getopt_internal_r+0x33c>
    af2c:	e5db3002 	ldrb	r3, [fp, #2]
    af30:	e3530000 	cmp	r3, #0
    af34:	1a000003 	bne	af48 <_getopt_internal_r+0x2e8>
			    || !strchr (optstring, argv[d->optind][1])))
    af38:	e1a00007 	mov	r0, r7
    af3c:	eb003e19 	bl	1a7a8 <strchr>
    af40:	e3500000 	cmp	r0, #0
    af44:	1a000014 	bne	af9c <_getopt_internal_r+0x33c>
	      code = process_long_option (argc, argv, optstring, longopts,
    af48:	e59d304c 	ldr	r3, [sp, #76]	@ 0x4c
	      d->__nextchar = argv[d->optind] + 1;
    af4c:	e28b5001 	add	r5, fp, #1
    af50:	e5845014 	str	r5, [r4, #20]
	      code = process_long_option (argc, argv, optstring, longopts,
    af54:	e1a02007 	mov	r2, r7
    af58:	e1a01008 	mov	r1, r8
    af5c:	e1a00006 	mov	r0, r6
    af60:	e58d3004 	str	r3, [sp, #4]
    af64:	e59d3048 	ldr	r3, [sp, #72]	@ 0x48
    af68:	e58da00c 	str	sl, [sp, #12]
    af6c:	e58d4008 	str	r4, [sp, #8]
    af70:	e58d3000 	str	r3, [sp]
    af74:	e3083998 	movw	r3, #35224	@ 0x8998
    af78:	e3403002 	movt	r3, #2
    af7c:	e58d3010 	str	r3, [sp, #16]
    af80:	e1a03009 	mov	r3, r9
    af84:	ebfffdf8 	bl	a76c <process_long_option>
	      if (code != -1)
    af88:	e3700001 	cmn	r0, #1
	      code = process_long_option (argc, argv, optstring, longopts,
    af8c:	e1a02000 	mov	r2, r0
	      if (code != -1)
    af90:	1affff69 	bne	ad3c <_getopt_internal_r+0xdc>
      d->__nextchar = argv[d->optind] + 1;
    af94:	e5943000 	ldr	r3, [r4]
    af98:	e798b103 	ldr	fp, [r8, r3, lsl #2]
    af9c:	e28b5001 	add	r5, fp, #1
    afa0:	eaffff4c 	b	acd8 <_getopt_internal_r+0x78>
    if (temp[0] == 'W' && temp[1] == ';' && longopts != NULL)
    afa4:	e241c03b 	sub	ip, r1, #59	@ 0x3b
    afa8:	e3590000 	cmp	r9, #0
    afac:	e16fcf1c 	clz	ip, ip
    afb0:	e1a0c2ac 	lsr	ip, ip, #5
    afb4:	03a0c000 	moveq	ip, #0
    afb8:	e35c0000 	cmp	ip, #0
    afbc:	0affff5c 	beq	ad34 <_getopt_internal_r+0xd4>
	if (*d->__nextchar != '\0')
    afc0:	e5d52001 	ldrb	r2, [r5, #1]
    afc4:	e3520000 	cmp	r2, #0
    afc8:	1a000003 	bne	afdc <_getopt_internal_r+0x37c>
	else if (d->optind == argc)
    afcc:	e5943000 	ldr	r3, [r4]
    afd0:	e1530006 	cmp	r3, r6
	  d->optarg = argv[d->optind];
    afd4:	17983103 	ldrne	r3, [r8, r3, lsl #2]
	else if (d->optind == argc)
    afd8:	0a000072 	beq	b1a8 <_getopt_internal_r+0x548>
	return process_long_option (argc, argv, optstring, longopts, longind,
    afdc:	e59dc048 	ldr	ip, [sp, #72]	@ 0x48
    afe0:	e1a02007 	mov	r2, r7
	d->__nextchar = d->optarg;
    afe4:	e5843014 	str	r3, [r4, #20]
	return process_long_option (argc, argv, optstring, longopts, longind,
    afe8:	e1a01008 	mov	r1, r8
    afec:	e58da00c 	str	sl, [sp, #12]
    aff0:	e1a03009 	mov	r3, r9
    aff4:	e58dc000 	str	ip, [sp]
    aff8:	e308cd60 	movw	ip, #36192	@ 0x8d60
    affc:	e340c002 	movt	ip, #2
    b000:	e58d4008 	str	r4, [sp, #8]
    b004:	e58dc010 	str	ip, [sp, #16]
	d->optarg = NULL;
    b008:	e3a0c000 	mov	ip, #0
    b00c:	e584c00c 	str	ip, [r4, #12]
	return process_long_option (argc, argv, optstring, longopts, longind,
    b010:	e1a00006 	mov	r0, r6
    b014:	e58dc004 	str	ip, [sp, #4]
    b018:	ebfffdd3 	bl	a76c <process_long_option>
    b01c:	e1a02000 	mov	r2, r0
    b020:	eaffff45 	b	ad3c <_getopt_internal_r+0xdc>
  else if (posixly_correct || !!getenv ("POSIXLY_CORRECT"))
    b024:	e3080914 	movw	r0, #35092	@ 0x8914
    b028:	e3400002 	movt	r0, #2
    b02c:	eb002ded 	bl	167e8 <getenv>
    b030:	e3500000 	cmp	r0, #0
  if (d->__nextchar == NULL || *d->__nextchar == '\0')
    b034:	e5945014 	ldr	r5, [r4, #20]
  else if (posixly_correct || !!getenv ("POSIXLY_CORRECT"))
    b038:	1affff50 	bne	ad80 <_getopt_internal_r+0x120>
    d->__ordering = PERMUTE;
    b03c:	e3a03001 	mov	r3, #1
    b040:	e5c43018 	strb	r3, [r4, #24]
    b044:	eaffff4f 	b	ad88 <_getopt_internal_r+0x128>
	if (temp[2] == ':')
    b048:	e5d01002 	ldrb	r1, [r0, #2]
    b04c:	e351003a 	cmp	r1, #58	@ 0x3a
	if (*d->__nextchar != '\0')
    b050:	e5d51001 	ldrb	r1, [r5, #1]
	if (temp[2] == ':')
    b054:	0a000030 	beq	b11c <_getopt_internal_r+0x4bc>
	    if (*d->__nextchar != '\0')
    b058:	e3510000 	cmp	r1, #0
	else if (d->optind == argc)
    b05c:	e5941000 	ldr	r1, [r4]
	    if (*d->__nextchar != '\0')
    b060:	1a00001c 	bne	b0d8 <_getopt_internal_r+0x478>
	    else if (d->optind == argc)
    b064:	e1560001 	cmp	r6, r1
    b068:	0a000034 	beq	b140 <_getopt_internal_r+0x4e0>
	      d->optarg = argv[d->optind++];
    b06c:	e7983101 	ldr	r3, [r8, r1, lsl #2]
    b070:	e2811001 	add	r1, r1, #1
    b074:	e5841000 	str	r1, [r4]
    b078:	e584300c 	str	r3, [r4, #12]
	    d->__nextchar = NULL;
    b07c:	e3a03000 	mov	r3, #0
    b080:	e5843014 	str	r3, [r4, #20]
    return c;
    b084:	eaffff2c 	b	ad3c <_getopt_internal_r+0xdc>
	  else if (d->__last_nonopt != d->optind)
    b088:	e1550002 	cmp	r5, r2
	    d->__first_nonopt = d->optind;
    b08c:	1584501c 	strne	r5, [r4, #28]
    b090:	eaffff88 	b	aeb8 <_getopt_internal_r+0x258>
    b094:	e1a03005 	mov	r3, r5
    b098:	eaffff97 	b	aefc <_getopt_internal_r+0x29c>
  d->__initialized = 1;
    b09c:	e3a03001 	mov	r3, #1
      d->__ordering = REQUIRE_ORDER;
    b0a0:	e5c45018 	strb	r5, [r4, #24]
  d->__initialized = 1;
    b0a4:	e5843010 	str	r3, [r4, #16]
    optstring = _getopt_initialize (argc, argv, optstring, d, posixly_correct);
    b0a8:	e2877001 	add	r7, r7, #1
  if (optstring[0] == ':')
    b0ac:	e5d73000 	ldrb	r3, [r7]
    optstring = _getopt_initialize (argc, argv, optstring, d, posixly_correct);
    b0b0:	e353003a 	cmp	r3, #58	@ 0x3a
    b0b4:	03a0a000 	moveq	sl, #0
    b0b8:	eaffff3e 	b	adb8 <_getopt_internal_r+0x158>
	if (print_errors)
    b0bc:	e35a0000 	cmp	sl, #0
    b0c0:	1a00000b 	bne	b0f4 <_getopt_internal_r+0x494>
	return '?';
    b0c4:	e3a0203f 	mov	r2, #63	@ 0x3f
	d->optopt = c;
    b0c8:	e584b008 	str	fp, [r4, #8]
}
    b0cc:	e1a00002 	mov	r0, r2
    b0d0:	e28dd024 	add	sp, sp, #36	@ 0x24
    b0d4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
		d->optind++;
    b0d8:	e2811001 	add	r1, r1, #1
		d->optarg = d->__nextchar;
    b0dc:	e584300c 	str	r3, [r4, #12]
		d->optind++;
    b0e0:	e5841000 	str	r1, [r4]
    b0e4:	eaffffe4 	b	b07c <_getopt_internal_r+0x41c>
	    d->__first_nonopt = d->optind;
    b0e8:	e1a03005 	mov	r3, r5
    b0ec:	e584501c 	str	r5, [r4, #28]
    b0f0:	eaffff52 	b	ae40 <_getopt_internal_r+0x1e0>
	  fprintf (stderr, _("%s: invalid option -- '%c'\n"), argv[0], c);
    b0f4:	e30b11e8 	movw	r1, #45544	@ 0xb1e8
    b0f8:	e5982000 	ldr	r2, [r8]
    b0fc:	e3401002 	movt	r1, #2
    b100:	e1a0300b 	mov	r3, fp
    b104:	e5911000 	ldr	r1, [r1]
    b108:	e591000c 	ldr	r0, [r1, #12]
    b10c:	e3081d18 	movw	r1, #36120	@ 0x8d18
    b110:	e3401002 	movt	r1, #2
    b114:	eb003582 	bl	18724 <fprintf>
    b118:	eaffffe9 	b	b0c4 <_getopt_internal_r+0x464>
	    if (*d->__nextchar != '\0')
    b11c:	e3510000 	cmp	r1, #0
		d->optind++;
    b120:	15941000 	ldrne	r1, [r4]
	      d->optarg = NULL;
    b124:	01a03001 	moveq	r3, r1
    b128:	e584300c 	str	r3, [r4, #12]
		d->optind++;
    b12c:	12811001 	addne	r1, r1, #1
    b130:	15841000 	strne	r1, [r4]
	    d->__nextchar = NULL;
    b134:	e3a01000 	mov	r1, #0
    b138:	e5841014 	str	r1, [r4, #20]
    b13c:	eafffefe 	b	ad3c <_getopt_internal_r+0xdc>
		if (print_errors)
    b140:	e35a0000 	cmp	sl, #0
    b144:	1a00001f 	bne	b1c8 <_getopt_internal_r+0x568>
		d->optopt = c;
    b148:	e584b008 	str	fp, [r4, #8]
		if (optstring[0] == ':')
    b14c:	e5d73000 	ldrb	r3, [r7]
    b150:	e353003a 	cmp	r3, #58	@ 0x3a
    b154:	13a0203f 	movne	r2, #63	@ 0x3f
    b158:	03a0203a 	moveq	r2, #58	@ 0x3a
    b15c:	eaffffc6 	b	b07c <_getopt_internal_r+0x41c>
	      return process_long_option (argc, argv, optstring, longopts,
    b160:	e59dc04c 	ldr	ip, [sp, #76]	@ 0x4c
	      d->__nextchar = argv[d->optind] + 2;
    b164:	e28b5002 	add	r5, fp, #2
	      return process_long_option (argc, argv, optstring, longopts,
    b168:	e58da00c 	str	sl, [sp, #12]
    b16c:	e1a02007 	mov	r2, r7
	      d->__nextchar = argv[d->optind] + 2;
    b170:	e5845014 	str	r5, [r4, #20]
	      return process_long_option (argc, argv, optstring, longopts,
    b174:	e1a03009 	mov	r3, r9
    b178:	e58dc004 	str	ip, [sp, #4]
    b17c:	e1a01008 	mov	r1, r8
    b180:	e59dc048 	ldr	ip, [sp, #72]	@ 0x48
    b184:	e1a00006 	mov	r0, r6
    b188:	e58d4008 	str	r4, [sp, #8]
    b18c:	e58dc000 	str	ip, [sp]
    b190:	e308cd14 	movw	ip, #36116	@ 0x8d14
    b194:	e340c002 	movt	ip, #2
    b198:	e58dc010 	str	ip, [sp, #16]
    b19c:	ebfffd72 	bl	a76c <process_long_option>
    b1a0:	e1a02000 	mov	r2, r0
    b1a4:	eafffee4 	b	ad3c <_getopt_internal_r+0xdc>
	    if (print_errors)
    b1a8:	e35a0000 	cmp	sl, #0
    b1ac:	1a00000f 	bne	b1f0 <_getopt_internal_r+0x590>
	    d->optopt = c;
    b1b0:	e584b008 	str	fp, [r4, #8]
	    if (optstring[0] == ':')
    b1b4:	e5d73000 	ldrb	r3, [r7]
    b1b8:	e353003a 	cmp	r3, #58	@ 0x3a
    b1bc:	13a0203f 	movne	r2, #63	@ 0x3f
    b1c0:	03a0203a 	moveq	r2, #58	@ 0x3a
    b1c4:	eafffedc 	b	ad3c <_getopt_internal_r+0xdc>
		  fprintf (stderr,
    b1c8:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
    b1cc:	e3081d34 	movw	r1, #36148	@ 0x8d34
    b1d0:	e3403002 	movt	r3, #2
    b1d4:	e5982000 	ldr	r2, [r8]
    b1d8:	e5933000 	ldr	r3, [r3]
    b1dc:	e3401002 	movt	r1, #2
    b1e0:	e593000c 	ldr	r0, [r3, #12]
    b1e4:	e1a0300b 	mov	r3, fp
    b1e8:	eb00354d 	bl	18724 <fprintf>
    b1ec:	eaffffd5 	b	b148 <_getopt_internal_r+0x4e8>
	      fprintf (stderr,
    b1f0:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
    b1f4:	e3081d34 	movw	r1, #36148	@ 0x8d34
    b1f8:	e3403002 	movt	r3, #2
    b1fc:	e5982000 	ldr	r2, [r8]
    b200:	e5933000 	ldr	r3, [r3]
    b204:	e3401002 	movt	r1, #2
    b208:	e593000c 	ldr	r0, [r3, #12]
    b20c:	e1a0300b 	mov	r3, fp
    b210:	eb003543 	bl	18724 <fprintf>
    b214:	eaffffe5 	b	b1b0 <_getopt_internal_r+0x550>

0000b218 <rpl_getopt_internal>:

int
_getopt_internal (int argc, char **argv, const char *optstring,
		  const struct option *longopts, int *longind, int long_only,
		  int posixly_correct)
{
    b218:	e92d4030 	push	{r4, r5, lr}
    b21c:	e24dd014 	sub	sp, sp, #20
    b220:	e59dc020 	ldr	ip, [sp, #32]
  int result;

  getopt_data.optind = optind;
    b224:	e30b5018 	movw	r5, #45080	@ 0xb018
    b228:	e3405002 	movt	r5, #2
    b22c:	e30b43bc 	movw	r4, #46012	@ 0xb3bc
    b230:	e3404002 	movt	r4, #2
  getopt_data.opterr = opterr;

  result = _getopt_internal_r (argc, argv, optstring, longopts,
    b234:	e58dc000 	str	ip, [sp]
{
    b238:	e59dc024 	ldr	ip, [sp, #36]	@ 0x24
  result = _getopt_internal_r (argc, argv, optstring, longopts,
    b23c:	e58dc004 	str	ip, [sp, #4]
{
    b240:	e59dc028 	ldr	ip, [sp, #40]	@ 0x28
  result = _getopt_internal_r (argc, argv, optstring, longopts,
    b244:	e58dc00c 	str	ip, [sp, #12]
  getopt_data.optind = optind;
    b248:	e595e000 	ldr	lr, [r5]
  getopt_data.opterr = opterr;
    b24c:	e595c004 	ldr	ip, [r5, #4]
  getopt_data.optind = optind;
    b250:	e584e000 	str	lr, [r4]
  getopt_data.opterr = opterr;
    b254:	e584c004 	str	ip, [r4, #4]
  result = _getopt_internal_r (argc, argv, optstring, longopts,
    b258:	e58d4008 	str	r4, [sp, #8]
    b25c:	ebfffe7f 	bl	ac60 <_getopt_internal_r>
			       longind, long_only, &getopt_data,
			       posixly_correct);

  optind = getopt_data.optind;
  optarg = getopt_data.optarg;
    b260:	e594300c 	ldr	r3, [r4, #12]
  optind = getopt_data.optind;
    b264:	e5942000 	ldr	r2, [r4]
  optarg = getopt_data.optarg;
    b268:	e5843024 	str	r3, [r4, #36]	@ 0x24
  optopt = getopt_data.optopt;
    b26c:	e5943008 	ldr	r3, [r4, #8]
  optind = getopt_data.optind;
    b270:	e5852000 	str	r2, [r5]
  optopt = getopt_data.optopt;
    b274:	e5853008 	str	r3, [r5, #8]

  return result;
}
    b278:	e28dd014 	add	sp, sp, #20
    b27c:	e8bd8030 	pop	{r4, r5, pc}

0000b280 <rpl_getopt>:

#ifdef _LIBC
GETOPT_ENTRY(getopt, 0)
GETOPT_ENTRY(__posix_getopt, 1)
#else
GETOPT_ENTRY(getopt, 1)
    b280:	e92d4030 	push	{r4, r5, lr}
  getopt_data.optind = optind;
    b284:	e30b5018 	movw	r5, #45080	@ 0xb018
    b288:	e30b43bc 	movw	r4, #46012	@ 0xb3bc
GETOPT_ENTRY(getopt, 1)
    b28c:	e24dd014 	sub	sp, sp, #20
  getopt_data.optind = optind;
    b290:	e3404002 	movt	r4, #2
    b294:	e3405002 	movt	r5, #2
  result = _getopt_internal_r (argc, argv, optstring, longopts,
    b298:	e58d4008 	str	r4, [sp, #8]
    b29c:	e3a0c001 	mov	ip, #1
  getopt_data.optind = optind;
    b2a0:	e5953000 	ldr	r3, [r5]
    b2a4:	e5843000 	str	r3, [r4]
  getopt_data.opterr = opterr;
    b2a8:	e5953004 	ldr	r3, [r5, #4]
    b2ac:	e5843004 	str	r3, [r4, #4]
  result = _getopt_internal_r (argc, argv, optstring, longopts,
    b2b0:	e3a03000 	mov	r3, #0
    b2b4:	e58d3004 	str	r3, [sp, #4]
    b2b8:	e58d3000 	str	r3, [sp]
    b2bc:	e58dc00c 	str	ip, [sp, #12]
    b2c0:	ebfffe66 	bl	ac60 <_getopt_internal_r>
  optarg = getopt_data.optarg;
    b2c4:	e594300c 	ldr	r3, [r4, #12]
  optind = getopt_data.optind;
    b2c8:	e5942000 	ldr	r2, [r4]
  optarg = getopt_data.optarg;
    b2cc:	e5843024 	str	r3, [r4, #36]	@ 0x24
  optopt = getopt_data.optopt;
    b2d0:	e5943008 	ldr	r3, [r4, #8]
  optind = getopt_data.optind;
    b2d4:	e5852000 	str	r2, [r5]
  optopt = getopt_data.optopt;
    b2d8:	e5853008 	str	r3, [r5, #8]
GETOPT_ENTRY(getopt, 1)
    b2dc:	e28dd014 	add	sp, sp, #20
    b2e0:	e8bd8030 	pop	{r4, r5, pc}

0000b2e4 <rpl_getopt_long>:
#include "getopt_int.h"

int
getopt_long (int argc, char *__getopt_argv_const *argv, const char *options,
	     const struct option *long_options, int *opt_index)
{
    b2e4:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
    b2e8:	e24dd014 	sub	sp, sp, #20
    b2ec:	e59dc018 	ldr	ip, [sp, #24]
  return _getopt_internal (argc, (char **) argv, options, long_options,
    b2f0:	e58dc000 	str	ip, [sp]
    b2f4:	e3a0c000 	mov	ip, #0
    b2f8:	e58dc008 	str	ip, [sp, #8]
    b2fc:	e58dc004 	str	ip, [sp, #4]
    b300:	ebffffc4 	bl	b218 <rpl_getopt_internal>
			   opt_index, 0, 0);
}
    b304:	e28dd014 	add	sp, sp, #20
    b308:	e49df004 	pop	{pc}		@ (ldr pc, [sp], #4)

0000b30c <_getopt_long_r>:

int
_getopt_long_r (int argc, char **argv, const char *options,
		const struct option *long_options, int *opt_index,
		struct _getopt_data *d)
{
    b30c:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
    b310:	e24dd014 	sub	sp, sp, #20
    b314:	e59dc018 	ldr	ip, [sp, #24]
  return _getopt_internal_r (argc, argv, options, long_options, opt_index,
    b318:	e58dc000 	str	ip, [sp]
{
    b31c:	e59dc01c 	ldr	ip, [sp, #28]
  return _getopt_internal_r (argc, argv, options, long_options, opt_index,
    b320:	e58dc008 	str	ip, [sp, #8]
    b324:	e3a0c000 	mov	ip, #0
    b328:	e58dc00c 	str	ip, [sp, #12]
    b32c:	e58dc004 	str	ip, [sp, #4]
    b330:	ebfffe4a 	bl	ac60 <_getopt_internal_r>
			     0, d, 0);
}
    b334:	e28dd014 	add	sp, sp, #20
    b338:	e49df004 	pop	{pc}		@ (ldr pc, [sp], #4)

0000b33c <rpl_getopt_long_only>:

int
getopt_long_only (int argc, char *__getopt_argv_const *argv,
		  const char *options,
		  const struct option *long_options, int *opt_index)
{
    b33c:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
    b340:	e24dd014 	sub	sp, sp, #20
    b344:	e59dc018 	ldr	ip, [sp, #24]
  return _getopt_internal (argc, (char **) argv, options, long_options,
    b348:	e3a0e000 	mov	lr, #0
    b34c:	e58dc000 	str	ip, [sp]
    b350:	e3a0c001 	mov	ip, #1
    b354:	e98d5000 	stmib	sp, {ip, lr}
    b358:	ebffffae 	bl	b218 <rpl_getopt_internal>
			   opt_index, 1, 0);
}
    b35c:	e28dd014 	add	sp, sp, #20
    b360:	e49df004 	pop	{pc}		@ (ldr pc, [sp], #4)

0000b364 <_getopt_long_only_r>:

int
_getopt_long_only_r (int argc, char **argv, const char *options,
		     const struct option *long_options, int *opt_index,
		     struct _getopt_data *d)
{
    b364:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
    b368:	e24dd014 	sub	sp, sp, #20
    b36c:	e59dc018 	ldr	ip, [sp, #24]
  return _getopt_internal_r (argc, argv, options, long_options, opt_index,
    b370:	e58dc000 	str	ip, [sp]
{
    b374:	e59dc01c 	ldr	ip, [sp, #28]
  return _getopt_internal_r (argc, argv, options, long_options, opt_index,
    b378:	e58dc008 	str	ip, [sp, #8]
    b37c:	e3a0c001 	mov	ip, #1
    b380:	e58dc004 	str	ip, [sp, #4]
    b384:	e3a0c000 	mov	ip, #0
    b388:	e58dc00c 	str	ip, [sp, #12]
    b38c:	ebfffe33 	bl	ac60 <_getopt_internal_r>
			     1, d, 0);
}
    b390:	e28dd014 	add	sp, sp, #20
    b394:	e49df004 	pop	{pc}		@ (ldr pc, [sp], #4)

0000b398 <getprogname>:
  /* Be careful to declare this only when we absolutely need it
     (OpenBSD 5.1), rather than when it's available.  Otherwise,
     its mere declaration makes program_invocation_short_name
     malfunction (have zero length) with Fedora 25's glibc.  */
  extern char *__progname;
  const char *p = __progname;
    b398:	e30b385c 	movw	r3, #47196	@ 0xb85c
    b39c:	e3403002 	movt	r3, #2
    b3a0:	e5930000 	ldr	r0, [r3]
#  if defined __ANDROID__
  return last_component (p);
#  else
  return p && p[0] ? p : "?";
    b3a4:	e3500000 	cmp	r0, #0
    b3a8:	0a000005 	beq	b3c4 <getprogname+0x2c>
    b3ac:	e5d02000 	ldrb	r2, [r0]
    b3b0:	e3083d64 	movw	r3, #36196	@ 0x8d64
    b3b4:	e3403002 	movt	r3, #2
    b3b8:	e3520000 	cmp	r2, #0
    b3bc:	01a00003 	moveq	r0, r3
    b3c0:	e12fff1e 	bx	lr
    b3c4:	e3080d64 	movw	r0, #36196	@ 0x8d64
    b3c8:	e3400002 	movt	r0, #2
    }
  return "?";
# else
#  error "getprogname module not ported to this OS"
# endif
}
    b3cc:	e12fff1e 	bx	lr

0000b3d0 <umaxtostr>:
   INT_BUFSIZE_BOUND (INTTYPE) bytes long.  Return the address of the
   printable string, which need not start at BUF.  */

_GL_ATTRIBUTE_NODISCARD char *
anytostr (inttype i, char *buf)
{
    b3d0:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
    b3d4:	e30c4ccd 	movw	r4, #52429	@ 0xcccd
    b3d8:	e30c7ccc 	movw	r7, #52428	@ 0xcccc
    b3dc:	e1a03000 	mov	r3, r0
    b3e0:	e34c4ccc 	movt	r4, #52428	@ 0xcccc
  char *p = buf + INT_STRLEN_BOUND (inttype);
    b3e4:	e2820014 	add	r0, r2, #20
  *p = 0;
    b3e8:	e34c7ccc 	movt	r7, #52428	@ 0xcccc
    b3ec:	e3a06005 	mov	r6, #5
    b3f0:	e3a0c000 	mov	ip, #0
    b3f4:	e5c2c014 	strb	ip, [r2, #20]
      *--p = '-';
    }
  else
    {
      do
        *--p = '0' + i % 10;
    b3f8:	e093c001 	adds	ip, r3, r1
    b3fc:	e1a08003 	mov	r8, r3
    b400:	e2acc000 	adc	ip, ip, #0
    b404:	e1a05001 	mov	r5, r1
    b408:	e08e2c94 	umull	r2, lr, r4, ip
    b40c:	e3ce2003 	bic	r2, lr, #3
    b410:	e082212e 	add	r2, r2, lr, lsr #2
    b414:	e04cc002 	sub	ip, ip, r2
    b418:	e053200c 	subs	r2, r3, ip
    b41c:	e0893492 	umull	r3, r9, r2, r4
    b420:	e2c11000 	sbc	r1, r1, #0
    b424:	e0020297 	mul	r2, r7, r2
    b428:	e0222194 	mla	r2, r4, r1, r2
    b42c:	e2031001 	and	r1, r3, #1
    b430:	e1a030a3 	lsr	r3, r3, #1
    b434:	e081e691 	umull	lr, r1, r1, r6
    b438:	e0822009 	add	r2, r2, r9
      while ((i /= 10) != 0);
    b43c:	e1833f82 	orr	r3, r3, r2, lsl #31
    b440:	e1a010a2 	lsr	r1, r2, #1
    b444:	e09ee00c 	adds	lr, lr, ip
    b448:	e358000a 	cmp	r8, #10
    b44c:	e2d55000 	sbcs	r5, r5, #0
        *--p = '0' + i % 10;
    b450:	e28ee030 	add	lr, lr, #48	@ 0x30
    b454:	e560e001 	strb	lr, [r0, #-1]!
      while ((i /= 10) != 0);
    b458:	2affffe6 	bcs	b3f8 <umaxtostr+0x28>
    b45c:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}

0000b460 <rpl_mbrtowc>:

# undef mbrtowc

size_t
rpl_mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)
{
    b460:	e92d40f0 	push	{r4, r5, r6, r7, lr}
# if MBRTOWC_EMPTY_INPUT_BUG
  if (n == 0)
    return (size_t) -2;
# endif

  if (! pwc)
    b464:	e2507000 	subs	r7, r0, #0
{
    b468:	e24dd00c 	sub	sp, sp, #12
    b46c:	e1a05002 	mov	r5, r2
    pwc = &wc;
    b470:	028d7004 	addeq	r7, sp, #4
{
    b474:	e1a06001 	mov	r6, r1
# if MBRTOWC_STORES_INCOMPLETE_BUG
  ret = mbrtowc (&wc, s, n, ps);
  if (ret < (size_t) -2 && pwc != NULL)
    *pwc = wc;
# else
  ret = mbrtowc (pwc, s, n, ps);
    b478:	e1a00007 	mov	r0, r7
    b47c:	eb002d31 	bl	16948 <mbrtowc>
  if (ret < (size_t) -2 && !*pwc)
    return 0;
# endif

# if MBRTOWC_IN_C_LOCALE_MAYBE_EILSEQ
  if ((size_t) -2 <= ret && n != 0 && ! hard_locale (LC_CTYPE))
    b480:	e3550000 	cmp	r5, #0
    b484:	13700003 	cmnne	r0, #3
  ret = mbrtowc (pwc, s, n, ps);
    b488:	e1a04000 	mov	r4, r0
  if ((size_t) -2 <= ret && n != 0 && ! hard_locale (LC_CTYPE))
    b48c:	8a000002 	bhi	b49c <rpl_mbrtowc+0x3c>
      return 1;
    }
# endif

  return ret;
}
    b490:	e1a00004 	mov	r0, r4
    b494:	e28dd00c 	add	sp, sp, #12
    b498:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
  if ((size_t) -2 <= ret && n != 0 && ! hard_locale (LC_CTYPE))
    b49c:	e3a00002 	mov	r0, #2
    b4a0:	eb000ce3 	bl	e834 <hard_locale>
    b4a4:	e3500000 	cmp	r0, #0
      *pwc = uc;
    b4a8:	05d63000 	ldrbeq	r3, [r6]
      return 1;
    b4ac:	03a04001 	moveq	r4, #1
}
    b4b0:	e1a00004 	mov	r0, r4
      *pwc = uc;
    b4b4:	05873000 	streq	r3, [r7]
}
    b4b8:	e28dd00c 	add	sp, sp, #12
    b4bc:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

0000b4c0 <physmem_total>:
#define ARRAY_SIZE(a) (sizeof (a) / sizeof ((a)[0]))

/* Return the total amount of physical memory.  */
double
physmem_total (void)
{
    b4c0:	e92d4010 	push	{r4, lr}
#if defined _SC_PHYS_PAGES && defined _SC_PAGESIZE
  { /* This works on linux-gnu, kfreebsd-gnu, solaris2, and cygwin.  */
    double pages = sysconf (_SC_PHYS_PAGES);
    b4c4:	e3a0000b 	mov	r0, #11
    b4c8:	eb0050fe 	bl	1f8c8 <sysconf>
    b4cc:	e1a04000 	mov	r4, r0
    double pagesize = sysconf (_SC_PAGESIZE);
    b4d0:	e3a00008 	mov	r0, #8
    b4d4:	eb0050fb 	bl	1f8c8 <sysconf>
    if (0 <= pages && 0 <= pagesize)
    b4d8:	e1943000 	orrs	r3, r4, r0
    double pages = sysconf (_SC_PHYS_PAGES);
    b4dc:	5e074a90 	vmovpl	s15, r4
    b4e0:	5eb80be7 	vcvtpl.f64.s32	d0, s15
    double pagesize = sysconf (_SC_PAGESIZE);
    b4e4:	5e070a90 	vmovpl	s15, r0
    b4e8:	5eb87be7 	vcvtpl.f64.s32	d7, s15
      return pages * pagesize;
    b4ec:	5e200b07 	vmulpl.f64	d0, d0, d7
      }
  }
#endif

  /* Guess 64 MB.  It's probably an older host, so guess small.  */
  return 64 * 1024 * 1024;
    b4f0:	4d9f0b00 	vldrmi	d0, [pc]	@ b4f8 <physmem_total+0x38>
}
    b4f4:	e8bd8010 	pop	{r4, pc}
    b4f8:	00000000 	.word	0x00000000
    b4fc:	41900000 	.word	0x41900000

0000b500 <physmem_available>:

/* Return the amount of physical memory available.  */
double
physmem_available (void)
{
    b500:	e92d4010 	push	{r4, lr}
#if defined _SC_AVPHYS_PAGES && defined _SC_PAGESIZE
  { /* This works on linux-gnu, kfreebsd-gnu, solaris2, and cygwin.  */
    double pages = sysconf (_SC_AVPHYS_PAGES);
    b504:	e3a0000c 	mov	r0, #12
    b508:	eb0050ee 	bl	1f8c8 <sysconf>
    b50c:	e1a04000 	mov	r4, r0
    double pagesize = sysconf (_SC_PAGESIZE);
    b510:	e3a00008 	mov	r0, #8
    b514:	eb0050eb 	bl	1f8c8 <sysconf>
    if (0 <= pages && 0 <= pagesize)
    b518:	e1943000 	orrs	r3, r4, r0
    b51c:	5a00000e 	bpl	b55c <physmem_available+0x5c>
    double pages = sysconf (_SC_PHYS_PAGES);
    b520:	e3a0000b 	mov	r0, #11
    b524:	eb0050e7 	bl	1f8c8 <sysconf>
    b528:	e1a04000 	mov	r4, r0
    double pagesize = sysconf (_SC_PAGESIZE);
    b52c:	e3a00008 	mov	r0, #8
    b530:	eb0050e4 	bl	1f8c8 <sysconf>
    if (0 <= pages && 0 <= pagesize)
    b534:	e1943000 	orrs	r3, r4, r0
      }
  }
#endif

  /* Guess 25% of physical memory.  */
  return physmem_total () / 4;
    b538:	5d9f6b0e 	vldrpl	d6, [pc, #56]	@ b578 <physmem_available+0x78>
    double pages = sysconf (_SC_PHYS_PAGES);
    b53c:	5e074a90 	vmovpl	s15, r4
    b540:	5eb80be7 	vcvtpl.f64.s32	d0, s15
    double pagesize = sysconf (_SC_PAGESIZE);
    b544:	5e070a90 	vmovpl	s15, r0
    b548:	5eb87be7 	vcvtpl.f64.s32	d7, s15
      return pages * pagesize;
    b54c:	5e200b07 	vmulpl.f64	d0, d0, d7
  return physmem_total () / 4;
    b550:	5e200b06 	vmulpl.f64	d0, d0, d6
    b554:	4d9f0b09 	vldrmi	d0, [pc, #36]	@ b580 <physmem_available+0x80>
}
    b558:	e8bd8010 	pop	{r4, pc}
    double pages = sysconf (_SC_AVPHYS_PAGES);
    b55c:	ee074a90 	vmov	s15, r4
    b560:	eeb80be7 	vcvt.f64.s32	d0, s15
    double pagesize = sysconf (_SC_PAGESIZE);
    b564:	ee070a90 	vmov	s15, r0
    b568:	eeb87be7 	vcvt.f64.s32	d7, s15
      return pages * pagesize;
    b56c:	ee200b07 	vmul.f64	d0, d0, d7
    b570:	e8bd8010 	pop	{r4, pc}
    b574:	e320f000 	nop	{0}
    b578:	00000000 	.word	0x00000000
    b57c:	3fd00000 	.word	0x3fd00000
    b580:	00000000 	.word	0x00000000
    b584:	41700000 	.word	0x41700000

0000b588 <set_program_name>:
/* Set program_name, based on argv[0].
   argv0 must be a string allocated with indefinite extent, and must not be
   modified after this call.  */
void
set_program_name (const char *argv0)
{
    b588:	e92d4070 	push	{r4, r5, r6, lr}
  const char *slash;
  const char *base;

  /* Sanity check.  POSIX requires the invoking process to pass a non-NULL
     argv[0].  */
  if (argv0 == NULL)
    b58c:	e2504000 	subs	r4, r0, #0
    b590:	0a00001e 	beq	b610 <set_program_name+0x88>
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }

  slash = strrchr (argv0, '/');
    b594:	e3a0102f 	mov	r1, #47	@ 0x2f
    b598:	eb003d60 	bl	1ab20 <strrchr>
  base = (slash != NULL ? slash + 1 : argv0);
    b59c:	e2505000 	subs	r5, r0, #0
    b5a0:	0a000014 	beq	b5f8 <set_program_name+0x70>
    b5a4:	e2856001 	add	r6, r5, #1
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    b5a8:	e0463004 	sub	r3, r6, r4
    b5ac:	e3530006 	cmp	r3, #6
    b5b0:	da000010 	ble	b5f8 <set_program_name+0x70>
    b5b4:	e3081da0 	movw	r1, #36256	@ 0x8da0
    b5b8:	e3a02007 	mov	r2, #7
    b5bc:	e3401002 	movt	r1, #2
    b5c0:	e2450006 	sub	r0, r5, #6
    b5c4:	eb003cda 	bl	1a934 <strncmp>
    b5c8:	e3500000 	cmp	r0, #0
    b5cc:	1a000009 	bne	b5f8 <set_program_name+0x70>
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
    b5d0:	e5d53001 	ldrb	r3, [r5, #1]
    b5d4:	e353006c 	cmp	r3, #108	@ 0x6c
    b5d8:	1a00000a 	bne	b608 <set_program_name+0x80>
    b5dc:	e5d63001 	ldrb	r3, [r6, #1]
    b5e0:	e3530074 	cmp	r3, #116	@ 0x74
    b5e4:	1a000007 	bne	b608 <set_program_name+0x80>
    b5e8:	e5d63002 	ldrb	r3, [r6, #2]
    b5ec:	e353002d 	cmp	r3, #45	@ 0x2d
    b5f0:	1a000004 	bne	b608 <set_program_name+0x80>
        {
          argv0 = base + 3;
    b5f4:	e2854004 	add	r4, r5, #4
         /some/hidden/place/bin/cp: `foo' and `foo' are the same file
     not
         cp: `foo' and `foo' are the same file
   */

  program_name = argv0;
    b5f8:	e30b33e4 	movw	r3, #46052	@ 0xb3e4
    b5fc:	e3403002 	movt	r3, #2
    b600:	e5834000 	str	r4, [r3]
     variable program_invocation_name, not program_name.  So set this variable
     as well.  */
#if HAVE_DECL_PROGRAM_INVOCATION_NAME
  program_invocation_name = (char *) argv0;
#endif
}
    b604:	e8bd8070 	pop	{r4, r5, r6, pc}
      argv0 = base;
    b608:	e1a04006 	mov	r4, r6
    b60c:	eafffff9 	b	b5f8 <set_program_name+0x70>
             stderr);
    b610:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
    b614:	e3080d68 	movw	r0, #36200	@ 0x8d68
             stderr);
    b618:	e3403002 	movt	r3, #2
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
    b61c:	e3a02037 	mov	r2, #55	@ 0x37
             stderr);
    b620:	e5933000 	ldr	r3, [r3]
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
    b624:	e3a01001 	mov	r1, #1
    b628:	e3400002 	movt	r0, #2
    b62c:	e593300c 	ldr	r3, [r3, #12]
    b630:	eb0035f5 	bl	18e0c <fwrite>
      abort ();
    b634:	eb002c34 	bl	1670c <abort>

0000b638 <proper_name_lite>:
/* Return the localization of the name spelled NAME_ASCII in ASCII,
   and NAME_UTF8 in UTF-8.  */

char const *
proper_name_lite (char const *name_ascii, char const *name_utf8)
{
    b638:	e92d4070 	push	{r4, r5, r6, lr}
    b63c:	e1a04001 	mov	r4, r1
    b640:	e1a05000 	mov	r5, r0
  char const *translation = gettext (name_ascii);
  return (translation != name_ascii ? translation
          : c_strcasecmp (locale_charset (), "UTF-8") == 0 ? name_utf8
    b644:	eb000c91 	bl	e890 <locale_charset>
    b648:	e3081da8 	movw	r1, #36264	@ 0x8da8
    b64c:	e3401002 	movt	r1, #2
    b650:	eb000c3b 	bl	e744 <c_strcasecmp>
          : name_ascii);
}
    b654:	e3500000 	cmp	r0, #0
    b658:	11a00005 	movne	r0, r5
    b65c:	01a00004 	moveq	r0, r4
    b660:	e8bd8070 	pop	{r4, r5, r6, pc}

0000b664 <gettext_quote>:
   has one; otherwise, return either it or "\"", depending on S.

   S is either clocale_quoting_style or locale_quoting_style.  */
static char const *
gettext_quote (char const *msgid, enum quoting_style s)
{
    b664:	e92d4070 	push	{r4, r5, r6, lr}
    b668:	e1a05000 	mov	r5, r0
    b66c:	e1a04001 	mov	r4, r1
        BIG5-HKSCS   0xA1 0xA5            EUC-CN       0xA1 0xAE
        GBK          0xA1 0xAE            Georgian-PS  0x91
        PT154        0x91

     None of these is still in wide use; using iconv is overkill.  */
  locale_code = locale_charset ();
    b670:	eb000c86 	bl	e890 <locale_charset>
}

static inline int
strcaseeq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)
{
  if (CASEEQ (s1[0], s20))
    b674:	e5d02000 	ldrb	r2, [r0]
    b678:	e3c22020 	bic	r2, r2, #32
    b67c:	e3520055 	cmp	r2, #85	@ 0x55
    b680:	1a000018 	bne	b6e8 <gettext_quote+0x84>
  if (CASEEQ (s1[1], s21))
    b684:	e5d02001 	ldrb	r2, [r0, #1]
    b688:	e3c22020 	bic	r2, r2, #32
    b68c:	e3520054 	cmp	r2, #84	@ 0x54
    b690:	1a00001d 	bne	b70c <gettext_quote+0xa8>
  if (CASEEQ (s1[2], s22))
    b694:	e5d02002 	ldrb	r2, [r0, #2]
    b698:	e3c22020 	bic	r2, r2, #32
    b69c:	e3520046 	cmp	r2, #70	@ 0x46
    b6a0:	1a000019 	bne	b70c <gettext_quote+0xa8>
  if (CASEEQ (s1[3], s23))
    b6a4:	e5d02003 	ldrb	r2, [r0, #3]
    b6a8:	e352002d 	cmp	r2, #45	@ 0x2d
    b6ac:	1a000016 	bne	b70c <gettext_quote+0xa8>
  if (CASEEQ (s1[4], s24))
    b6b0:	e5d02004 	ldrb	r2, [r0, #4]
    b6b4:	e3520038 	cmp	r2, #56	@ 0x38
    b6b8:	1a000013 	bne	b70c <gettext_quote+0xa8>
  if (CASEEQ (s1[5], s25))
    b6bc:	e5d03005 	ldrb	r3, [r0, #5]
    b6c0:	e3530000 	cmp	r3, #0
    b6c4:	1a000010 	bne	b70c <gettext_quote+0xa8>
  if (STRCASEEQ (locale_code, "UTF-8", 'U','T','F','-','8',0,0,0,0))
    return msgid[0] == '`' ? "\xe2\x80\x98": "\xe2\x80\x99";
    b6c8:	e5d52000 	ldrb	r2, [r5]
    b6cc:	e3083dc4 	movw	r3, #36292	@ 0x8dc4
    b6d0:	e3403002 	movt	r3, #2
    b6d4:	e3080db4 	movw	r0, #36276	@ 0x8db4
    b6d8:	e3400002 	movt	r0, #2
    b6dc:	e3520060 	cmp	r2, #96	@ 0x60
    b6e0:	01a00003 	moveq	r0, r3
    b6e4:	e8bd8070 	pop	{r4, r5, r6, pc}
  if (CASEEQ (s1[0], s20))
    b6e8:	e3520047 	cmp	r2, #71	@ 0x47
    b6ec:	1a000006 	bne	b70c <gettext_quote+0xa8>
  if (CASEEQ (s1[1], s21))
    b6f0:	e5d02001 	ldrb	r2, [r0, #1]
    b6f4:	e3c22020 	bic	r2, r2, #32
    b6f8:	e3520042 	cmp	r2, #66	@ 0x42
    b6fc:	1a000002 	bne	b70c <gettext_quote+0xa8>
  if (CASEEQ (s1[2], s22))
    b700:	e5d02002 	ldrb	r2, [r0, #2]
    b704:	e3520031 	cmp	r2, #49	@ 0x31
    b708:	0a000006 	beq	b728 <gettext_quote+0xc4>
  if (STRCASEEQ (locale_code, "GB18030", 'G','B','1','8','0','3','0',0,0))
    return msgid[0] == '`' ? "\xa1\ae": "\xa1\xaf";

  return (s == clocale_quoting_style ? "\"" : "'");
    b70c:	e3083dbc 	movw	r3, #36284	@ 0x8dbc
    b710:	e3540009 	cmp	r4, #9
    b714:	e3403002 	movt	r3, #2
    b718:	e3080db0 	movw	r0, #36272	@ 0x8db0
    b71c:	e3400002 	movt	r0, #2
    b720:	01a00003 	moveq	r0, r3
}
    b724:	e8bd8070 	pop	{r4, r5, r6, pc}
  if (CASEEQ (s1[3], s23))
    b728:	e5d02003 	ldrb	r2, [r0, #3]
    b72c:	e3520038 	cmp	r2, #56	@ 0x38
    b730:	1afffff5 	bne	b70c <gettext_quote+0xa8>
  if (CASEEQ (s1[4], s24))
    b734:	e5d02004 	ldrb	r2, [r0, #4]
    b738:	e3520030 	cmp	r2, #48	@ 0x30
    b73c:	1afffff2 	bne	b70c <gettext_quote+0xa8>
  if (CASEEQ (s1[5], s25))
    b740:	e5d02005 	ldrb	r2, [r0, #5]
    b744:	e3520033 	cmp	r2, #51	@ 0x33
    b748:	1affffef 	bne	b70c <gettext_quote+0xa8>
  if (CASEEQ (s1[6], s26))
    b74c:	e5d02006 	ldrb	r2, [r0, #6]
    b750:	e3520030 	cmp	r2, #48	@ 0x30
    b754:	1affffec 	bne	b70c <gettext_quote+0xa8>
  if (CASEEQ (s1[7], s27))
    b758:	e5d03007 	ldrb	r3, [r0, #7]
    b75c:	e3530000 	cmp	r3, #0
    b760:	1affffe9 	bne	b70c <gettext_quote+0xa8>
    return msgid[0] == '`' ? "\xa1\ae": "\xa1\xaf";
    b764:	e5d52000 	ldrb	r2, [r5]
    b768:	e3083dc0 	movw	r3, #36288	@ 0x8dc0
    b76c:	e3403002 	movt	r3, #2
    b770:	e3080db8 	movw	r0, #36280	@ 0x8db8
    b774:	e3400002 	movt	r0, #2
    b778:	e3520060 	cmp	r2, #96	@ 0x60
    b77c:	01a00003 	moveq	r0, r3
    b780:	e8bd8070 	pop	{r4, r5, r6, pc}

0000b784 <quotearg_buffer_restyled>:
                          char const *arg, size_t argsize,
                          enum quoting_style quoting_style, int flags,
                          unsigned int const *quote_these_too,
                          char const *left_quote,
                          char const *right_quote)
{
    b784:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b788:	e24dd06c 	sub	sp, sp, #108	@ 0x6c
    b78c:	e58d2004 	str	r2, [sp, #4]
            goto force_outer_quoting_style;
          is_right_quote = true;
        }

      c = arg[i];
      switch (c)
    b790:	e30f2f82 	movw	r2, #65410	@ 0xff82
    b794:	e340207f 	movt	r2, #127	@ 0x7f
    b798:	e58d203c 	str	r2, [sp, #60]	@ 0x3c
    b79c:	e30521c1 	movw	r2, #20929	@ 0x51c1
    b7a0:	e3432800 	movt	r2, #14336	@ 0x3800
{
    b7a4:	e5dd8090 	ldrb	r8, [sp, #144]	@ 0x90
    b7a8:	e58d2054 	str	r2, [sp, #84]	@ 0x54
    b7ac:	e59d2094 	ldr	r2, [sp, #148]	@ 0x94
    b7b0:	e59d909c 	ldr	r9, [sp, #156]	@ 0x9c
    b7b4:	e1a0a008 	mov	sl, r8
    b7b8:	e58d0010 	str	r0, [sp, #16]
    b7bc:	e2026002 	and	r6, r2, #2
    b7c0:	e58d3000 	str	r3, [sp]
    b7c4:	e58d6038 	str	r6, [sp, #56]	@ 0x38
    b7c8:	e1a06001 	mov	r6, r1
  bool unibyte_locale = MB_CUR_MAX == 1;
    b7cc:	eb003e3f 	bl	1b0d0 <__locale_mb_cur_max>
  bool elide_outer_quotes = (flags & QA_ELIDE_OUTER_QUOTES) != 0;
    b7d0:	e59d3038 	ldr	r3, [sp, #56]	@ 0x38
  bool unibyte_locale = MB_CUR_MAX == 1;
    b7d4:	e58d0040 	str	r0, [sp, #64]	@ 0x40
  bool elide_outer_quotes = (flags & QA_ELIDE_OUTER_QUOTES) != 0;
    b7d8:	e2533000 	subs	r3, r3, #0
    b7dc:	13a03001 	movne	r3, #1
    b7e0:	e58d3008 	str	r3, [sp, #8]
  switch (quoting_style)
    b7e4:	e35a000a 	cmp	sl, #10
    b7e8:	979ff10a 	ldrls	pc, [pc, sl, lsl #2]
    b7ec:	ea000521 	b	cc78 <quotearg_buffer_restyled+0x14f4>
    b7f0:	0000bd00 	.word	0x0000bd00
    b7f4:	0000bd2c 	.word	0x0000bd2c
    b7f8:	0000cbac 	.word	0x0000cbac
    b7fc:	0000bda0 	.word	0x0000bda0
    b800:	0000bc7c 	.word	0x0000bc7c
    b804:	0000bc28 	.word	0x0000bc28
    b808:	0000bd68 	.word	0x0000bd68
    b80c:	0000bcd4 	.word	0x0000bcd4
    b810:	0000b81c 	.word	0x0000b81c
    b814:	0000b81c 	.word	0x0000b81c
    b818:	0000b81c 	.word	0x0000b81c
        if (quoting_style != custom_quoting_style)
    b81c:	e35a000a 	cmp	sl, #10
    b820:	0a000009 	beq	b84c <quotearg_buffer_restyled+0xc8>
            left_quote = gettext_quote (N_("`"), quoting_style);
    b824:	e3080dc8 	movw	r0, #36296	@ 0x8dc8
    b828:	e1a0100a 	mov	r1, sl
    b82c:	e3400002 	movt	r0, #2
    b830:	ebffff8b 	bl	b664 <gettext_quote>
    b834:	e1a09000 	mov	r9, r0
            right_quote = gettext_quote (N_("'"), quoting_style);
    b838:	e3080db0 	movw	r0, #36272	@ 0x8db0
    b83c:	e3400002 	movt	r0, #2
    b840:	e1a0100a 	mov	r1, sl
    b844:	ebffff86 	bl	b664 <gettext_quote>
    b848:	e58d00a0 	str	r0, [sp, #160]	@ 0xa0
        if (!elide_outer_quotes)
    b84c:	e59d3038 	ldr	r3, [sp, #56]	@ 0x38
    b850:	e3530000 	cmp	r3, #0
    b854:	13a0b000 	movne	fp, #0
    b858:	0a00045f 	beq	c9dc <quotearg_buffer_restyled+0x1258>
        quote_string_len = strlen (quote_string);
    b85c:	e59d00a0 	ldr	r0, [sp, #160]	@ 0xa0
    b860:	fa005306 	blx	20480 <strlen>
        quote_string = right_quote;
    b864:	e59d10a0 	ldr	r1, [sp, #160]	@ 0xa0
      break;
    b868:	e3a03000 	mov	r3, #0
    b86c:	e3a02001 	mov	r2, #1
        quote_string_len = strlen (quote_string);
    b870:	e58d001c 	str	r0, [sp, #28]
      break;
    b874:	e58d302c 	str	r3, [sp, #44]	@ 0x2c
    b878:	e58d200c 	str	r2, [sp, #12]
        quote_string = right_quote;
    b87c:	e58d1028 	str	r1, [sp, #40]	@ 0x28
      break;
    b880:	e58d3014 	str	r3, [sp, #20]
    b884:	e58d3034 	str	r3, [sp, #52]	@ 0x34
        backslash_escapes = true;
    b888:	e58d2018 	str	r2, [sp, #24]
      switch (c)
    b88c:	e3a03075 	mov	r3, #117	@ 0x75
  for (i = 0;  ! (argsize == SIZE_MAX ? arg[i] == '\0' : i == argsize);  i++)
    b890:	e3a05000 	mov	r5, #0
      switch (c)
    b894:	e3403780 	movt	r3, #1920	@ 0x780
    b898:	e58d3030 	str	r3, [sp, #48]	@ 0x30
  for (i = 0;  ! (argsize == SIZE_MAX ? arg[i] == '\0' : i == argsize);  i++)
    b89c:	e59d3000 	ldr	r3, [sp]
    b8a0:	e3730001 	cmn	r3, #1
    b8a4:	0a000088 	beq	bacc <quotearg_buffer_restyled+0x348>
    b8a8:	e59d3000 	ldr	r3, [sp]
    b8ac:	e0534005 	subs	r4, r3, r5
    b8b0:	13a04001 	movne	r4, #1
    b8b4:	e3540000 	cmp	r4, #0
    b8b8:	0a0002e5 	beq	c454 <quotearg_buffer_restyled+0xcd0>
    b8bc:	e59d3004 	ldr	r3, [sp, #4]
          && quoting_style != shell_always_quoting_style
    b8c0:	e59d8018 	ldr	r8, [sp, #24]
  for (i = 0;  ! (argsize == SIZE_MAX ? arg[i] == '\0' : i == argsize);  i++)
    b8c4:	e0833005 	add	r3, r3, r5
    b8c8:	e58d3020 	str	r3, [sp, #32]
          && quoting_style != shell_always_quoting_style
    b8cc:	e35a0002 	cmp	sl, #2
    b8d0:	03a08000 	moveq	r8, #0
    b8d4:	12088001 	andne	r8, r8, #1
          && quote_string_len
    b8d8:	e59d301c 	ldr	r3, [sp, #28]
    b8dc:	e3530000 	cmp	r3, #0
    b8e0:	03a07000 	moveq	r7, #0
    b8e4:	12087001 	andne	r7, r8, #1
    b8e8:	e3570000 	cmp	r7, #0
    b8ec:	1a000181 	bne	bef8 <quotearg_buffer_restyled+0x774>
      c = arg[i];
    b8f0:	e59d3004 	ldr	r3, [sp, #4]
    b8f4:	e7d31005 	ldrb	r1, [r3, r5]
      switch (c)
    b8f8:	e3510023 	cmp	r1, #35	@ 0x23
    b8fc:	8a000135 	bhi	bdd8 <quotearg_buffer_restyled+0x654>
    b900:	e3510023 	cmp	r1, #35	@ 0x23
    b904:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
    b908:	ea000024 	b	b9a0 <quotearg_buffer_restyled+0x21c>
    b90c:	0000bbd0 	.word	0x0000bbd0
    b910:	0000b9a0 	.word	0x0000b9a0
    b914:	0000b9a0 	.word	0x0000b9a0
    b918:	0000b9a0 	.word	0x0000b9a0
    b91c:	0000b9a0 	.word	0x0000b9a0
    b920:	0000b9a0 	.word	0x0000b9a0
    b924:	0000b9a0 	.word	0x0000b9a0
    b928:	0000bbbc 	.word	0x0000bbbc
    b92c:	0000bba8 	.word	0x0000bba8
    b930:	0000bbf8 	.word	0x0000bbf8
    b934:	0000bc20 	.word	0x0000bc20
    b938:	0000bb94 	.word	0x0000bb94
    b93c:	0000bb54 	.word	0x0000bb54
    b940:	0000bc18 	.word	0x0000bc18
    b944:	0000b9a0 	.word	0x0000b9a0
    b948:	0000b9a0 	.word	0x0000b9a0
    b94c:	0000b9a0 	.word	0x0000b9a0
    b950:	0000b9a0 	.word	0x0000b9a0
    b954:	0000b9a0 	.word	0x0000b9a0
    b958:	0000b9a0 	.word	0x0000b9a0
    b95c:	0000b9a0 	.word	0x0000b9a0
    b960:	0000b9a0 	.word	0x0000b9a0
    b964:	0000b9a0 	.word	0x0000b9a0
    b968:	0000b9a0 	.word	0x0000b9a0
    b96c:	0000b9a0 	.word	0x0000b9a0
    b970:	0000b9a0 	.word	0x0000b9a0
    b974:	0000b9a0 	.word	0x0000b9a0
    b978:	0000b9a0 	.word	0x0000b9a0
    b97c:	0000b9a0 	.word	0x0000b9a0
    b980:	0000b9a0 	.word	0x0000b9a0
    b984:	0000b9a0 	.word	0x0000b9a0
    b988:	0000b9a0 	.word	0x0000b9a0
    b98c:	0000bae4 	.word	0x0000bae4
    b990:	0000bae0 	.word	0x0000bae0
    b994:	0000bae0 	.word	0x0000bae0
    b998:	0000bb44 	.word	0x0000bb44
    b99c:	e3a07000 	mov	r7, #0
            /* Length of multibyte sequence found so far.  */
            size_t m;

            bool printable;

            if (unibyte_locale)
    b9a0:	e59d3040 	ldr	r3, [sp, #64]	@ 0x40
    b9a4:	e3530001 	cmp	r3, #1
    b9a8:	1a0002ea 	bne	c558 <quotearg_buffer_restyled+0xdd4>
              {
                m = 1;
                printable = isprint (c) != 0;
    b9ac:	e59f2fc4 	ldr	r2, [pc, #4036]	@ c978 <quotearg_buffer_restyled+0x11f4>
    b9b0:	e7d22001 	ldrb	r2, [r2, r1]
    b9b4:	e2022097 	and	r2, r2, #151	@ 0x97
    b9b8:	e3520000 	cmp	r2, #0
                m = 1;
    b9bc:	e1a02003 	mov	r2, r3
                  }
              }

            c_and_shell_quote_compat = printable;

            if (1 < m || (backslash_escapes && ! printable))
    b9c0:	e59d3018 	ldr	r3, [sp, #24]
                printable = isprint (c) != 0;
    b9c4:	13a04001 	movne	r4, #1
    b9c8:	03a04000 	moveq	r4, #0
            if (1 < m || (backslash_escapes && ! printable))
    b9cc:	13a0c000 	movne	ip, #0
    b9d0:	0203c001 	andeq	ip, r3, #1
    b9d4:	e35c0000 	cmp	ip, #0
    b9d8:	1a0003b8 	bne	c8c0 <quotearg_buffer_restyled+0x113c>
                goto store_c;
              }
          }
        }

      if (! (((backslash_escapes && quoting_style != shell_always_quoting_style)
    b9dc:	e59d3008 	ldr	r3, [sp, #8]
    b9e0:	e1880003 	orr	r0, r8, r3
              || elide_outer_quotes)
    b9e4:	e21000ff 	ands	r0, r0, #255	@ 0xff
    b9e8:	0a00000a 	beq	ba18 <quotearg_buffer_restyled+0x294>
    b9ec:	e3a00000 	mov	r0, #0
             && quote_these_too
    b9f0:	e59d3098 	ldr	r3, [sp, #152]	@ 0x98
    b9f4:	e3530000 	cmp	r3, #0
    b9f8:	0a000006 	beq	ba18 <quotearg_buffer_restyled+0x294>
             && quote_these_too[c / INT_BITS] >> (c % INT_BITS) & 1)
    b9fc:	e59d2098 	ldr	r2, [sp, #152]	@ 0x98
    ba00:	e7e732d1 	ubfx	r3, r1, #5, #8
    ba04:	e7923103 	ldr	r3, [r2, r3, lsl #2]
    ba08:	e201201f 	and	r2, r1, #31
    ba0c:	e1a03233 	lsr	r3, r3, r2
      if (! (((backslash_escapes && quoting_style != shell_always_quoting_style)
    ba10:	e3130001 	tst	r3, #1
    ba14:	1a000001 	bne	ba20 <quotearg_buffer_restyled+0x29c>
          && !is_right_quote)
    ba18:	e3570000 	cmp	r7, #0
    ba1c:	0a000121 	beq	bea8 <quotearg_buffer_restyled+0x724>
              START_ESC ();
    ba20:	e24a3002 	sub	r3, sl, #2
    ba24:	e16f3f13 	clz	r3, r3
    ba28:	e1a032a3 	lsr	r3, r3, #5
        goto store_c;

    store_escape:
      START_ESC ();
    ba2c:	e59d2008 	ldr	r2, [sp, #8]
    ba30:	e3520000 	cmp	r2, #0
    ba34:	1a000052 	bne	bb84 <quotearg_buffer_restyled+0x400>
    ba38:	e59d2014 	ldr	r2, [sp, #20]
    ba3c:	e2222001 	eor	r2, r2, #1
    ba40:	e0133002 	ands	r3, r3, r2
    ba44:	0a00000f 	beq	ba88 <quotearg_buffer_restyled+0x304>
    ba48:	e156000b 	cmp	r6, fp
    ba4c:	e58d3014 	str	r3, [sp, #20]
    ba50:	859d0010 	ldrhi	r0, [sp, #16]
    ba54:	83a02027 	movhi	r2, #39	@ 0x27
    ba58:	87c0200b 	strbhi	r2, [r0, fp]
    ba5c:	e28b2001 	add	r2, fp, #1
    ba60:	e1560002 	cmp	r6, r2
    ba64:	859dc010 	ldrhi	ip, [sp, #16]
    ba68:	83a00024 	movhi	r0, #36	@ 0x24
    ba6c:	87cc0002 	strbhi	r0, [ip, r2]
    ba70:	e28b2002 	add	r2, fp, #2
    ba74:	e1560002 	cmp	r6, r2
    ba78:	e28bb003 	add	fp, fp, #3
    ba7c:	859dc010 	ldrhi	ip, [sp, #16]
    ba80:	83a00027 	movhi	r0, #39	@ 0x27
    ba84:	87cc0002 	strbhi	r0, [ip, r2]
    ba88:	e15b0006 	cmp	fp, r6
  for (i = 0;  ! (argsize == SIZE_MAX ? arg[i] == '\0' : i == argsize);  i++)
    ba8c:	e2855001 	add	r5, r5, #1
      START_ESC ();
    ba90:	359d2010 	ldrcc	r2, [sp, #16]
    ba94:	33a0305c 	movcc	r3, #92	@ 0x5c
    ba98:	37c2300b 	strbcc	r3, [r2, fp]
    ba9c:	e28bb001 	add	fp, fp, #1

    store_c:
      END_ESC ();
      STORE (c);
    baa0:	e15b0006 	cmp	fp, r6
    baa4:	359d3010 	ldrcc	r3, [sp, #16]
    baa8:	37c3100b 	strbcc	r1, [r3, fp]

      if (! c_and_shell_quote_compat)
        all_c_and_shell_quote_compat = false;
    baac:	e3540000 	cmp	r4, #0
    bab0:	e59d300c 	ldr	r3, [sp, #12]
    bab4:	03a03000 	moveq	r3, #0
      STORE (c);
    bab8:	e28bb001 	add	fp, fp, #1
        all_c_and_shell_quote_compat = false;
    babc:	e58d300c 	str	r3, [sp, #12]
  for (i = 0;  ! (argsize == SIZE_MAX ? arg[i] == '\0' : i == argsize);  i++)
    bac0:	e59d3000 	ldr	r3, [sp]
    bac4:	e3730001 	cmn	r3, #1
    bac8:	1affff76 	bne	b8a8 <quotearg_buffer_restyled+0x124>
    bacc:	e59d3004 	ldr	r3, [sp, #4]
    bad0:	e7d34005 	ldrb	r4, [r3, r5]
    bad4:	e2544000 	subs	r4, r4, #0
    bad8:	13a04001 	movne	r4, #1
    badc:	eaffff74 	b	b8b4 <quotearg_buffer_restyled+0x130>
      switch (c)
    bae0:	e3a04000 	mov	r4, #0
          if (quoting_style == shell_always_quoting_style
    bae4:	e59d3008 	ldr	r3, [sp, #8]
    bae8:	e35a0002 	cmp	sl, #2
    baec:	13a03000 	movne	r3, #0
    baf0:	02033001 	andeq	r3, r3, #1
    baf4:	e3530000 	cmp	r3, #0
    baf8:	0affffb7 	beq	b9dc <quotearg_buffer_restyled+0x258>
    }

  if (len == 0 && quoting_style == shell_always_quoting_style
      && elide_outer_quotes)
    bafc:	e3a0a002 	mov	sl, #2

 force_outer_quoting_style:
  /* Don't reuse quote_these_too, since the addition of outer quotes
     sufficiently quotes the specified characters.  */
  if (quoting_style == shell_always_quoting_style && backslash_escapes)
    quoting_style = shell_escape_always_quoting_style;
    bb00:	e59d3018 	ldr	r3, [sp, #24]
    bb04:	e3530000 	cmp	r3, #0
    bb08:	13a0a004 	movne	sl, #4
  return quotearg_buffer_restyled (buffer, buffersize, arg, argsize,
    bb0c:	e59d3094 	ldr	r3, [sp, #148]	@ 0x94
    bb10:	e3c33002 	bic	r3, r3, #2
    bb14:	e58d3094 	str	r3, [sp, #148]	@ 0x94
    bb18:	e3a03000 	mov	r3, #0
    bb1c:	e58d3098 	str	r3, [sp, #152]	@ 0x98
    bb20:	e58d3038 	str	r3, [sp, #56]	@ 0x38
    bb24:	eaffff28 	b	b7cc <quotearg_buffer_restyled+0x48>
      switch (c)
    bb28:	e3a07000 	mov	r7, #0
          if (! (argsize == SIZE_MAX ? arg[1] == '\0' : argsize == 1))
    bb2c:	e59d3000 	ldr	r3, [sp]
    bb30:	e3730001 	cmn	r3, #1
    bb34:	0a000261 	beq	c4c0 <quotearg_buffer_restyled+0xd3c>
    bb38:	e59d3000 	ldr	r3, [sp]
    bb3c:	e3530001 	cmp	r3, #1
    bb40:	1a000001 	bne	bb4c <quotearg_buffer_restyled+0x3c8>
          if (i != 0)
    bb44:	e3550000 	cmp	r5, #0
    bb48:	0affffe5 	beq	bae4 <quotearg_buffer_restyled+0x360>
      bool c_and_shell_quote_compat = false;
    bb4c:	e3a04000 	mov	r4, #0
                    break;
    bb50:	eaffffa1 	b	b9dc <quotearg_buffer_restyled+0x258>
              START_ESC ();
    bb54:	e24a3002 	sub	r3, sl, #2
        case '\f': esc = 'f'; goto c_escape;
    bb58:	e3a02066 	mov	r2, #102	@ 0x66
              START_ESC ();
    bb5c:	e16f3f13 	clz	r3, r3
    bb60:	e1a032a3 	lsr	r3, r3, #5
          if (backslash_escapes)
    bb64:	e59d0018 	ldr	r0, [sp, #24]
    bb68:	e3500000 	cmp	r0, #0
    bb6c:	0afffff6 	beq	bb4c <quotearg_buffer_restyled+0x3c8>
              c = esc;
    bb70:	e1a01002 	mov	r1, r2
      START_ESC ();
    bb74:	e59d2008 	ldr	r2, [sp, #8]
      bool c_and_shell_quote_compat = false;
    bb78:	e3a04000 	mov	r4, #0
      START_ESC ();
    bb7c:	e3520000 	cmp	r2, #0
    bb80:	0affffac 	beq	ba38 <quotearg_buffer_restyled+0x2b4>
  if (quoting_style == shell_always_quoting_style && backslash_escapes)
    bb84:	e59d2018 	ldr	r2, [sp, #24]
    bb88:	e0022003 	and	r2, r2, r3
    bb8c:	e58d2018 	str	r2, [sp, #24]
    bb90:	eaffffda 	b	bb00 <quotearg_buffer_restyled+0x37c>
              START_ESC ();
    bb94:	e24a3002 	sub	r3, sl, #2
        case '\v': esc = 'v'; goto c_escape;
    bb98:	e3a02076 	mov	r2, #118	@ 0x76
              START_ESC ();
    bb9c:	e16f3f13 	clz	r3, r3
    bba0:	e1a032a3 	lsr	r3, r3, #5
        case '\v': esc = 'v'; goto c_escape;
    bba4:	eaffffee 	b	bb64 <quotearg_buffer_restyled+0x3e0>
              START_ESC ();
    bba8:	e24a3002 	sub	r3, sl, #2
        case '\b': esc = 'b'; goto c_escape;
    bbac:	e3a02062 	mov	r2, #98	@ 0x62
              START_ESC ();
    bbb0:	e16f3f13 	clz	r3, r3
    bbb4:	e1a032a3 	lsr	r3, r3, #5
        case '\b': esc = 'b'; goto c_escape;
    bbb8:	eaffffe9 	b	bb64 <quotearg_buffer_restyled+0x3e0>
              START_ESC ();
    bbbc:	e24a3002 	sub	r3, sl, #2
        case '\a': esc = 'a'; goto c_escape;
    bbc0:	e3a02061 	mov	r2, #97	@ 0x61
              START_ESC ();
    bbc4:	e16f3f13 	clz	r3, r3
    bbc8:	e1a032a3 	lsr	r3, r3, #5
    bbcc:	eaffffe4 	b	bb64 <quotearg_buffer_restyled+0x3e0>
          if (backslash_escapes)
    bbd0:	e59d3018 	ldr	r3, [sp, #24]
    bbd4:	e3530000 	cmp	r3, #0
    bbd8:	1a00016b 	bne	c18c <quotearg_buffer_restyled+0xa08>
          else if (flags & QA_ELIDE_NULL_BYTES)
    bbdc:	e59d3094 	ldr	r3, [sp, #148]	@ 0x94
    bbe0:	e3130001 	tst	r3, #1
                  && i + 1 < argsize && '0' <= arg[i + 1] && arg[i + 1] <= '9')
    bbe4:	12855001 	addne	r5, r5, #1
          else if (flags & QA_ELIDE_NULL_BYTES)
    bbe8:	1affff2b 	bne	b89c <quotearg_buffer_restyled+0x118>
    bbec:	e59d4018 	ldr	r4, [sp, #24]
    bbf0:	e1a07004 	mov	r7, r4
    bbf4:	eaffff78 	b	b9dc <quotearg_buffer_restyled+0x258>
        case '\t': esc = 't'; goto c_and_shell_escape;
    bbf8:	e3a02074 	mov	r2, #116	@ 0x74
          if (quoting_style == shell_always_quoting_style
    bbfc:	e24a3002 	sub	r3, sl, #2
    bc00:	e59d0008 	ldr	r0, [sp, #8]
    bc04:	e16f3f13 	clz	r3, r3
    bc08:	e1a032a3 	lsr	r3, r3, #5
    bc0c:	e0137000 	ands	r7, r3, r0
    bc10:	0affffd3 	beq	bb64 <quotearg_buffer_restyled+0x3e0>
    bc14:	eaffffb8 	b	bafc <quotearg_buffer_restyled+0x378>
        case '\r': esc = 'r'; goto c_and_shell_escape;
    bc18:	e3a02072 	mov	r2, #114	@ 0x72
    bc1c:	eafffff6 	b	bbfc <quotearg_buffer_restyled+0x478>
      switch (c)
    bc20:	e3a0206e 	mov	r2, #110	@ 0x6e
    bc24:	eafffff4 	b	bbfc <quotearg_buffer_restyled+0x478>
      if (!elide_outer_quotes)
    bc28:	e59d2038 	ldr	r2, [sp, #56]	@ 0x38
    bc2c:	e3520000 	cmp	r2, #0
    bc30:	1a000399 	bne	ca9c <quotearg_buffer_restyled+0x1318>
        STORE ('"');
    bc34:	e3560000 	cmp	r6, #0
    bc38:	0a00034f 	beq	c97c <quotearg_buffer_restyled+0x11f8>
    bc3c:	e59d0010 	ldr	r0, [sp, #16]
    bc40:	e3a03022 	mov	r3, #34	@ 0x22
    bc44:	e3a01001 	mov	r1, #1
    bc48:	e58d202c 	str	r2, [sp, #44]	@ 0x2c
    bc4c:	e1a0b001 	mov	fp, r1
    bc50:	e58d100c 	str	r1, [sp, #12]
    bc54:	e5c03000 	strb	r3, [r0]
      quote_string = "\"";
    bc58:	e3083dbc 	movw	r3, #36284	@ 0x8dbc
    bc5c:	e3403002 	movt	r3, #2
        STORE ('"');
    bc60:	e58d2014 	str	r2, [sp, #20]
      quote_string = "\"";
    bc64:	e58d3028 	str	r3, [sp, #40]	@ 0x28
        STORE ('"');
    bc68:	e58d2034 	str	r2, [sp, #52]	@ 0x34
    bc6c:	e58d2008 	str	r2, [sp, #8]
      backslash_escapes = true;
    bc70:	e58d1018 	str	r1, [sp, #24]
      quote_string_len = 1;
    bc74:	e58d101c 	str	r1, [sp, #28]
    bc78:	eaffff03 	b	b88c <quotearg_buffer_restyled+0x108>
      if (!elide_outer_quotes)
    bc7c:	e59d3038 	ldr	r3, [sp, #56]	@ 0x38
    bc80:	e3530000 	cmp	r3, #0
    bc84:	1a0003d6 	bne	cbe4 <quotearg_buffer_restyled+0x1460>
    bc88:	e3a02001 	mov	r2, #1
    bc8c:	e58d302c 	str	r3, [sp, #44]	@ 0x2c
    bc90:	e58d200c 	str	r2, [sp, #12]
    bc94:	e58d3014 	str	r3, [sp, #20]
    bc98:	e58d3034 	str	r3, [sp, #52]	@ 0x34
        backslash_escapes = true;
    bc9c:	e58d2018 	str	r2, [sp, #24]
      quote_string = "'";
    bca0:	e3083db0 	movw	r3, #36272	@ 0x8db0
        STORE ('\'');
    bca4:	e3560000 	cmp	r6, #0
      quote_string = "'";
    bca8:	e3403002 	movt	r3, #2
        STORE ('\'');
    bcac:	e3a0b001 	mov	fp, #1
      quote_string = "'";
    bcb0:	e58d3028 	str	r3, [sp, #40]	@ 0x28
    bcb4:	e3a03000 	mov	r3, #0
      quoting_style = shell_always_quoting_style;
    bcb8:	e3a0a002 	mov	sl, #2
      quote_string_len = 1;
    bcbc:	e58db01c 	str	fp, [sp, #28]
    bcc0:	e58d3008 	str	r3, [sp, #8]
        STORE ('\'');
    bcc4:	159d2010 	ldrne	r2, [sp, #16]
    bcc8:	13a03027 	movne	r3, #39	@ 0x27
    bccc:	15c23000 	strbne	r3, [r2]
    bcd0:	eafffeed 	b	b88c <quotearg_buffer_restyled+0x108>
  switch (quoting_style)
    bcd4:	e3a03000 	mov	r3, #0
    bcd8:	e3a02001 	mov	r2, #1
    bcdc:	e1a0b003 	mov	fp, r3
    bce0:	e58d302c 	str	r3, [sp, #44]	@ 0x2c
    bce4:	e58d200c 	str	r2, [sp, #12]
    bce8:	e58d3014 	str	r3, [sp, #20]
    bcec:	e58d3034 	str	r3, [sp, #52]	@ 0x34
      elide_outer_quotes = false;
    bcf0:	e58d3008 	str	r3, [sp, #8]
  switch (quoting_style)
    bcf4:	e1cd21f8 	strd	r2, [sp, #24]
    bcf8:	e58d3028 	str	r3, [sp, #40]	@ 0x28
    bcfc:	eafffee2 	b	b88c <quotearg_buffer_restyled+0x108>
      break;
    bd00:	e3a0b000 	mov	fp, #0
    bd04:	e3a03001 	mov	r3, #1
    bd08:	e58db02c 	str	fp, [sp, #44]	@ 0x2c
    bd0c:	e58d300c 	str	r3, [sp, #12]
    bd10:	e58db014 	str	fp, [sp, #20]
    bd14:	e58db034 	str	fp, [sp, #52]	@ 0x34
      elide_outer_quotes = false;
    bd18:	e58db008 	str	fp, [sp, #8]
      break;
    bd1c:	e58db018 	str	fp, [sp, #24]
    bd20:	e58db01c 	str	fp, [sp, #28]
    bd24:	e58db028 	str	fp, [sp, #40]	@ 0x28
    bd28:	eafffed7 	b	b88c <quotearg_buffer_restyled+0x108>
      quote_string = "'";
    bd2c:	e3081db0 	movw	r1, #36272	@ 0x8db0
  switch (quoting_style)
    bd30:	e3a03000 	mov	r3, #0
    bd34:	e3a02001 	mov	r2, #1
      quote_string = "'";
    bd38:	e3401002 	movt	r1, #2
  switch (quoting_style)
    bd3c:	e1a0b003 	mov	fp, r3
      quoting_style = shell_always_quoting_style;
    bd40:	e3a0a002 	mov	sl, #2
  switch (quoting_style)
    bd44:	e58d302c 	str	r3, [sp, #44]	@ 0x2c
    bd48:	e58d200c 	str	r2, [sp, #12]
      quote_string = "'";
    bd4c:	e58d1028 	str	r1, [sp, #40]	@ 0x28
  switch (quoting_style)
    bd50:	e58d3014 	str	r3, [sp, #20]
    bd54:	e58d3034 	str	r3, [sp, #52]	@ 0x34
    bd58:	e58d2008 	str	r2, [sp, #8]
    bd5c:	e58d3018 	str	r3, [sp, #24]
      quote_string_len = 1;
    bd60:	e58d201c 	str	r2, [sp, #28]
    bd64:	eafffec8 	b	b88c <quotearg_buffer_restyled+0x108>
      quote_string = "\"";
    bd68:	e3082dbc 	movw	r2, #36284	@ 0x8dbc
  switch (quoting_style)
    bd6c:	e3a03001 	mov	r3, #1
    bd70:	e3a0b000 	mov	fp, #0
      quote_string = "\"";
    bd74:	e3402002 	movt	r2, #2
  switch (quoting_style)
    bd78:	e3a0a005 	mov	sl, #5
    bd7c:	e58d300c 	str	r3, [sp, #12]
    bd80:	e58db02c 	str	fp, [sp, #44]	@ 0x2c
      quote_string = "\"";
    bd84:	e58d2028 	str	r2, [sp, #40]	@ 0x28
  switch (quoting_style)
    bd88:	e58db014 	str	fp, [sp, #20]
    bd8c:	e58db034 	str	fp, [sp, #52]	@ 0x34
      elide_outer_quotes = true;
    bd90:	e58d3008 	str	r3, [sp, #8]
      backslash_escapes = true;
    bd94:	e58d3018 	str	r3, [sp, #24]
      quote_string_len = 1;
    bd98:	e58d301c 	str	r3, [sp, #28]
    bd9c:	eafffeba 	b	b88c <quotearg_buffer_restyled+0x108>
  switch (quoting_style)
    bda0:	e3082db0 	movw	r2, #36272	@ 0x8db0
    bda4:	e3a03001 	mov	r3, #1
    bda8:	e3a0b000 	mov	fp, #0
    bdac:	e3402002 	movt	r2, #2
    bdb0:	e3a0a002 	mov	sl, #2
    bdb4:	e58d300c 	str	r3, [sp, #12]
    bdb8:	e58db02c 	str	fp, [sp, #44]	@ 0x2c
    bdbc:	e58d2028 	str	r2, [sp, #40]	@ 0x28
    bdc0:	e58db014 	str	fp, [sp, #20]
    bdc4:	e58db034 	str	fp, [sp, #52]	@ 0x34
    bdc8:	e58d3008 	str	r3, [sp, #8]
    bdcc:	e58d3018 	str	r3, [sp, #24]
    bdd0:	e58d301c 	str	r3, [sp, #28]
    bdd4:	eafffeac 	b	b88c <quotearg_buffer_restyled+0x108>
      switch (c)
    bdd8:	e351007a 	cmp	r1, #122	@ 0x7a
    bddc:	8a000140 	bhi	c2e4 <quotearg_buffer_restyled+0xb60>
    bde0:	e351005b 	cmp	r1, #91	@ 0x5b
    bde4:	8a00012c 	bhi	c29c <quotearg_buffer_restyled+0xb18>
    bde8:	e351003e 	cmp	r1, #62	@ 0x3e
    bdec:	8a00015d 	bhi	c368 <quotearg_buffer_restyled+0xbe4>
    bdf0:	e2412024 	sub	r2, r1, #36	@ 0x24
    bdf4:	e3a03001 	mov	r3, #1
    bdf8:	e6ef2072 	uxtb	r2, r2
    bdfc:	e1a03213 	lsl	r3, r3, r2
    be00:	e59d203c 	ldr	r2, [sp, #60]	@ 0x3c
    be04:	e1130002 	tst	r3, r2
    be08:	1afffef3 	bne	b9dc <quotearg_buffer_restyled+0x258>
    be0c:	e59d2030 	ldr	r2, [sp, #48]	@ 0x30
    be10:	e0133002 	ands	r3, r3, r2
    be14:	1a000177 	bne	c3f8 <quotearg_buffer_restyled+0xc74>
          if (quoting_style == shell_always_quoting_style)
    be18:	e35a0002 	cmp	sl, #2
      c = arg[i];
    be1c:	13a01027 	movne	r1, #39	@ 0x27
          encountered_single_quote = true;
    be20:	158d402c 	strne	r4, [sp, #44]	@ 0x2c
          if (quoting_style == shell_always_quoting_style)
    be24:	1afffeec 	bne	b9dc <quotearg_buffer_restyled+0x258>
              if (elide_outer_quotes)
    be28:	e59d2008 	ldr	r2, [sp, #8]
    be2c:	e3520000 	cmp	r2, #0
    be30:	1affff32 	bne	bb00 <quotearg_buffer_restyled+0x37c>
              if (buffersize && ! orig_buffersize)
    be34:	e59d1034 	ldr	r1, [sp, #52]	@ 0x34
    be38:	e2562000 	subs	r2, r6, #0
    be3c:	13a02001 	movne	r2, #1
    be40:	e3510000 	cmp	r1, #0
    be44:	13a02000 	movne	r2, #0
    be48:	e3520000 	cmp	r2, #0
                  orig_buffersize = buffersize;
    be4c:	158d6034 	strne	r6, [sp, #52]	@ 0x34
              if (buffersize && ! orig_buffersize)
    be50:	1a00000e 	bne	be90 <quotearg_buffer_restyled+0x70c>
              STORE ('\'');
    be54:	e156000b 	cmp	r6, fp
    be58:	859d2010 	ldrhi	r2, [sp, #16]
    be5c:	83a03027 	movhi	r3, #39	@ 0x27
    be60:	87c2300b 	strbhi	r3, [r2, fp]
    be64:	e28b3001 	add	r3, fp, #1
              STORE ('\\');
    be68:	e1560003 	cmp	r6, r3
    be6c:	859d1010 	ldrhi	r1, [sp, #16]
    be70:	83a0205c 	movhi	r2, #92	@ 0x5c
    be74:	87c12003 	strbhi	r2, [r1, r3]
    be78:	e28b3002 	add	r3, fp, #2
              STORE ('\'');
    be7c:	e1560003 	cmp	r6, r3
    be80:	859d1010 	ldrhi	r1, [sp, #16]
    be84:	83a02027 	movhi	r2, #39	@ 0x27
    be88:	87c12003 	strbhi	r2, [r1, r3]
      switch (c)
    be8c:	e1a03006 	mov	r3, r6
              STORE ('\'');
    be90:	e28bb003 	add	fp, fp, #3
    be94:	e1a06003 	mov	r6, r3
      c = arg[i];
    be98:	e3a01027 	mov	r1, #39	@ 0x27
      bool escaping = false;
    be9c:	e3a00000 	mov	r0, #0
          encountered_single_quote = true;
    bea0:	e58d402c 	str	r4, [sp, #44]	@ 0x2c
              pending_shell_escape_end = false;
    bea4:	e58d0014 	str	r0, [sp, #20]
      END_ESC ();
    bea8:	e59d3014 	ldr	r3, [sp, #20]
    beac:	e2200001 	eor	r0, r0, #1
  for (i = 0;  ! (argsize == SIZE_MAX ? arg[i] == '\0' : i == argsize);  i++)
    beb0:	e2855001 	add	r5, r5, #1
      END_ESC ();
    beb4:	e0000003 	and	r0, r0, r3
    beb8:	e6ef0070 	uxtb	r0, r0
    bebc:	e3500000 	cmp	r0, #0
    bec0:	0afffef6 	beq	baa0 <quotearg_buffer_restyled+0x31c>
    bec4:	e156000b 	cmp	r6, fp
    bec8:	859d2010 	ldrhi	r2, [sp, #16]
    becc:	83a03027 	movhi	r3, #39	@ 0x27
    bed0:	87c2300b 	strbhi	r3, [r2, fp]
    bed4:	e28b3001 	add	r3, fp, #1
    bed8:	e1560003 	cmp	r6, r3
    bedc:	e28bb002 	add	fp, fp, #2
    bee0:	859d0010 	ldrhi	r0, [sp, #16]
    bee4:	83a02027 	movhi	r2, #39	@ 0x27
    bee8:	87c02003 	strbhi	r2, [r0, r3]
    beec:	e3a03000 	mov	r3, #0
    bef0:	e58d3014 	str	r3, [sp, #20]
    bef4:	eafffee9 	b	baa0 <quotearg_buffer_restyled+0x31c>
                  ? (argsize = strlen (arg)) : argsize))
    bef8:	e59d1000 	ldr	r1, [sp]
    befc:	e3530001 	cmp	r3, #1
    bf00:	e1a02003 	mov	r2, r3
    bf04:	93a02000 	movls	r2, #0
    bf08:	83a02001 	movhi	r2, #1
          && (i + quote_string_len
    bf0c:	e0853003 	add	r3, r5, r3
                  ? (argsize = strlen (arg)) : argsize))
    bf10:	e3710001 	cmn	r1, #1
    bf14:	13a02000 	movne	r2, #0
    bf18:	e3520000 	cmp	r2, #0
    bf1c:	0a000004 	beq	bf34 <quotearg_buffer_restyled+0x7b0>
    bf20:	e59d0004 	ldr	r0, [sp, #4]
    bf24:	e58d3024 	str	r3, [sp, #36]	@ 0x24
    bf28:	fa005154 	blx	20480 <strlen>
    bf2c:	e59d3024 	ldr	r3, [sp, #36]	@ 0x24
    bf30:	e58d0000 	str	r0, [sp]
          && (i + quote_string_len
    bf34:	e59d2000 	ldr	r2, [sp]
    bf38:	e1530002 	cmp	r3, r2
    bf3c:	8a000067 	bhi	c0e0 <quotearg_buffer_restyled+0x95c>
          && memcmp (arg + i, quote_string, quote_string_len) == 0)
    bf40:	e59d201c 	ldr	r2, [sp, #28]
    bf44:	e59d1028 	ldr	r1, [sp, #40]	@ 0x28
    bf48:	e59d0020 	ldr	r0, [sp, #32]
    bf4c:	eb00394b 	bl	1a480 <memcmp>
    bf50:	e3500000 	cmp	r0, #0
    bf54:	1a000061 	bne	c0e0 <quotearg_buffer_restyled+0x95c>
          if (elide_outer_quotes)
    bf58:	e59d3008 	ldr	r3, [sp, #8]
    bf5c:	e3530000 	cmp	r3, #0
    bf60:	1afffee9 	bne	bb0c <quotearg_buffer_restyled+0x388>
      c = arg[i];
    bf64:	e59d3020 	ldr	r3, [sp, #32]
    bf68:	e5d31000 	ldrb	r1, [r3]
      switch (c)
    bf6c:	e3510023 	cmp	r1, #35	@ 0x23
    bf70:	8a000122 	bhi	c400 <quotearg_buffer_restyled+0xc7c>
    bf74:	e3510023 	cmp	r1, #35	@ 0x23
    bf78:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
    bf7c:	eafffe87 	b	b9a0 <quotearg_buffer_restyled+0x21c>
    bf80:	0000c080 	.word	0x0000c080
    bf84:	0000b9a0 	.word	0x0000b9a0
    bf88:	0000b9a0 	.word	0x0000b9a0
    bf8c:	0000b9a0 	.word	0x0000b9a0
    bf90:	0000b9a0 	.word	0x0000b9a0
    bf94:	0000b9a0 	.word	0x0000b9a0
    bf98:	0000b9a0 	.word	0x0000b9a0
    bf9c:	0000c028 	.word	0x0000c028
    bfa0:	0000c060 	.word	0x0000c060
    bfa4:	0000c054 	.word	0x0000c054
    bfa8:	0000c01c 	.word	0x0000c01c
    bfac:	0000c070 	.word	0x0000c070
    bfb0:	0000c044 	.word	0x0000c044
    bfb4:	0000c038 	.word	0x0000c038
    bfb8:	0000b9a0 	.word	0x0000b9a0
    bfbc:	0000b9a0 	.word	0x0000b9a0
    bfc0:	0000b9a0 	.word	0x0000b9a0
    bfc4:	0000b9a0 	.word	0x0000b9a0
    bfc8:	0000b9a0 	.word	0x0000b9a0
    bfcc:	0000b9a0 	.word	0x0000b9a0
    bfd0:	0000b9a0 	.word	0x0000b9a0
    bfd4:	0000b9a0 	.word	0x0000b9a0
    bfd8:	0000b9a0 	.word	0x0000b9a0
    bfdc:	0000b9a0 	.word	0x0000b9a0
    bfe0:	0000b9a0 	.word	0x0000b9a0
    bfe4:	0000b9a0 	.word	0x0000b9a0
    bfe8:	0000b9a0 	.word	0x0000b9a0
    bfec:	0000b9a0 	.word	0x0000b9a0
    bff0:	0000b9a0 	.word	0x0000b9a0
    bff4:	0000b9a0 	.word	0x0000b9a0
    bff8:	0000b9a0 	.word	0x0000b9a0
    bffc:	0000b9a0 	.word	0x0000b9a0
    c000:	0000c014 	.word	0x0000c014
    c004:	0000bb4c 	.word	0x0000bb4c
    c008:	0000bb4c 	.word	0x0000bb4c
    c00c:	0000bb44 	.word	0x0000bb44
    c010:	e3a07000 	mov	r7, #0
    c014:	e1a04007 	mov	r4, r7
    c018:	eafffe6f 	b	b9dc <quotearg_buffer_restyled+0x258>
          if (quoting_style == shell_always_quoting_style
    c01c:	e3a03000 	mov	r3, #0
      switch (c)
    c020:	e3a0206e 	mov	r2, #110	@ 0x6e
    c024:	eafffece 	b	bb64 <quotearg_buffer_restyled+0x3e0>
    c028:	e3a03000 	mov	r3, #0
              c = esc;
    c02c:	e3a01061 	mov	r1, #97	@ 0x61
      bool c_and_shell_quote_compat = false;
    c030:	e1a04003 	mov	r4, r3
    c034:	eafffe7f 	b	ba38 <quotearg_buffer_restyled+0x2b4>
          if (quoting_style == shell_always_quoting_style
    c038:	e3a03000 	mov	r3, #0
        case '\r': esc = 'r'; goto c_and_shell_escape;
    c03c:	e3a02072 	mov	r2, #114	@ 0x72
    c040:	eafffec7 	b	bb64 <quotearg_buffer_restyled+0x3e0>
              START_ESC ();
    c044:	e3a03000 	mov	r3, #0
              c = esc;
    c048:	e3a01066 	mov	r1, #102	@ 0x66
      bool c_and_shell_quote_compat = false;
    c04c:	e1a04003 	mov	r4, r3
    c050:	eafffe78 	b	ba38 <quotearg_buffer_restyled+0x2b4>
          if (quoting_style == shell_always_quoting_style
    c054:	e3a03000 	mov	r3, #0
        case '\t': esc = 't'; goto c_and_shell_escape;
    c058:	e3a02074 	mov	r2, #116	@ 0x74
    c05c:	eafffec0 	b	bb64 <quotearg_buffer_restyled+0x3e0>
              START_ESC ();
    c060:	e3a03000 	mov	r3, #0
              c = esc;
    c064:	e3a01062 	mov	r1, #98	@ 0x62
      bool c_and_shell_quote_compat = false;
    c068:	e1a04003 	mov	r4, r3
    c06c:	eafffe71 	b	ba38 <quotearg_buffer_restyled+0x2b4>
              START_ESC ();
    c070:	e3a03000 	mov	r3, #0
              c = esc;
    c074:	e3a01076 	mov	r1, #118	@ 0x76
      bool c_and_shell_quote_compat = false;
    c078:	e1a04003 	mov	r4, r3
    c07c:	eafffe6d 	b	ba38 <quotearg_buffer_restyled+0x2b4>
              START_ESC ();
    c080:	e1a00007 	mov	r0, r7
    c084:	e28b3001 	add	r3, fp, #1
    c088:	e156000b 	cmp	r6, fp
    c08c:	9a00021a 	bls	c8fc <quotearg_buffer_restyled+0x1178>
    c090:	e59d1010 	ldr	r1, [sp, #16]
              if (quoting_style != shell_always_quoting_style
    c094:	e3580000 	cmp	r8, #0
              START_ESC ();
    c098:	e3a0205c 	mov	r2, #92	@ 0x5c
    c09c:	e7c1200b 	strb	r2, [r1, fp]
              if (quoting_style != shell_always_quoting_style
    c0a0:	0a000217 	beq	c904 <quotearg_buffer_restyled+0x1180>
                  && i + 1 < argsize && '0' <= arg[i + 1] && arg[i + 1] <= '9')
    c0a4:	e59d1000 	ldr	r1, [sp]
    c0a8:	e2852001 	add	r2, r5, #1
    c0ac:	e1520001 	cmp	r2, r1
    c0b0:	2a000004 	bcs	c0c8 <quotearg_buffer_restyled+0x944>
    c0b4:	e59d1004 	ldr	r1, [sp, #4]
    c0b8:	e7d12002 	ldrb	r2, [r1, r2]
    c0bc:	e2422030 	sub	r2, r2, #48	@ 0x30
    c0c0:	e3520009 	cmp	r2, #9
    c0c4:	9a000239 	bls	c9b0 <quotearg_buffer_restyled+0x122c>
      if (! (((backslash_escapes && quoting_style != shell_always_quoting_style)
    c0c8:	e1a07000 	mov	r7, r0
    c0cc:	e1a0b003 	mov	fp, r3
    c0d0:	e1a00004 	mov	r0, r4
    c0d4:	e3a01030 	mov	r1, #48	@ 0x30
    c0d8:	e3a04000 	mov	r4, #0
    c0dc:	eafffe43 	b	b9f0 <quotearg_buffer_restyled+0x26c>
      c = arg[i];
    c0e0:	e59d3020 	ldr	r3, [sp, #32]
    c0e4:	e5d31000 	ldrb	r1, [r3]
      switch (c)
    c0e8:	e3510023 	cmp	r1, #35	@ 0x23
    c0ec:	8a000087 	bhi	c310 <quotearg_buffer_restyled+0xb8c>
    c0f0:	e3510023 	cmp	r1, #35	@ 0x23
    c0f4:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
    c0f8:	eafffe27 	b	b99c <quotearg_buffer_restyled+0x218>
    c0fc:	0000c18c 	.word	0x0000c18c
    c100:	0000b99c 	.word	0x0000b99c
    c104:	0000b99c 	.word	0x0000b99c
    c108:	0000b99c 	.word	0x0000b99c
    c10c:	0000b99c 	.word	0x0000b99c
    c110:	0000b99c 	.word	0x0000b99c
    c114:	0000b99c 	.word	0x0000b99c
    c118:	0000c23c 	.word	0x0000c23c
    c11c:	0000c24c 	.word	0x0000c24c
    c120:	0000c26c 	.word	0x0000c26c
    c124:	0000c22c 	.word	0x0000c22c
    c128:	0000c28c 	.word	0x0000c28c
    c12c:	0000c27c 	.word	0x0000c27c
    c130:	0000c25c 	.word	0x0000c25c
    c134:	0000b99c 	.word	0x0000b99c
    c138:	0000b99c 	.word	0x0000b99c
    c13c:	0000b99c 	.word	0x0000b99c
    c140:	0000b99c 	.word	0x0000b99c
    c144:	0000b99c 	.word	0x0000b99c
    c148:	0000b99c 	.word	0x0000b99c
    c14c:	0000b99c 	.word	0x0000b99c
    c150:	0000b99c 	.word	0x0000b99c
    c154:	0000b99c 	.word	0x0000b99c
    c158:	0000b99c 	.word	0x0000b99c
    c15c:	0000b99c 	.word	0x0000b99c
    c160:	0000b99c 	.word	0x0000b99c
    c164:	0000b99c 	.word	0x0000b99c
    c168:	0000b99c 	.word	0x0000b99c
    c16c:	0000b99c 	.word	0x0000b99c
    c170:	0000b99c 	.word	0x0000b99c
    c174:	0000b99c 	.word	0x0000b99c
    c178:	0000b99c 	.word	0x0000b99c
    c17c:	0000c220 	.word	0x0000c220
    c180:	0000c010 	.word	0x0000c010
    c184:	0000c010 	.word	0x0000c010
    c188:	0000c218 	.word	0x0000c218
              START_ESC ();
    c18c:	e59d3008 	ldr	r3, [sp, #8]
    c190:	e3530000 	cmp	r3, #0
    c194:	1a00028d 	bne	cbd0 <quotearg_buffer_restyled+0x144c>
    c198:	e59d3014 	ldr	r3, [sp, #20]
    c19c:	e2230001 	eor	r0, r3, #1
    c1a0:	e28b3001 	add	r3, fp, #1
    c1a4:	e35a0002 	cmp	sl, #2
    c1a8:	13a00000 	movne	r0, #0
    c1ac:	02000001 	andeq	r0, r0, #1
    c1b0:	e3500000 	cmp	r0, #0
    c1b4:	0affffb3 	beq	c088 <quotearg_buffer_restyled+0x904>
    c1b8:	e156000b 	cmp	r6, fp
    c1bc:	859d1010 	ldrhi	r1, [sp, #16]
    c1c0:	83a02027 	movhi	r2, #39	@ 0x27
    c1c4:	87c1200b 	strbhi	r2, [r1, fp]
    c1c8:	e1560003 	cmp	r6, r3
    c1cc:	859d1010 	ldrhi	r1, [sp, #16]
    c1d0:	83a02024 	movhi	r2, #36	@ 0x24
    c1d4:	87c12003 	strbhi	r2, [r1, r3]
    c1d8:	e28b3002 	add	r3, fp, #2
    c1dc:	e1560003 	cmp	r6, r3
    c1e0:	859d1010 	ldrhi	r1, [sp, #16]
    c1e4:	83a02027 	movhi	r2, #39	@ 0x27
    c1e8:	87c12003 	strbhi	r2, [r1, r3]
    c1ec:	e28b3003 	add	r3, fp, #3
    c1f0:	e1560003 	cmp	r6, r3
    c1f4:	e28bb004 	add	fp, fp, #4
    c1f8:	9a0001c7 	bls	c91c <quotearg_buffer_restyled+0x1198>
    c1fc:	e59d1010 	ldr	r1, [sp, #16]
    c200:	e3a0205c 	mov	r2, #92	@ 0x5c
      bool c_and_shell_quote_compat = false;
    c204:	e3a04000 	mov	r4, #0
              START_ESC ();
    c208:	e58d0014 	str	r0, [sp, #20]
    c20c:	e7c12003 	strb	r2, [r1, r3]
              c = '0';
    c210:	e3a01030 	mov	r1, #48	@ 0x30
    c214:	eaffff23 	b	bea8 <quotearg_buffer_restyled+0x724>
      switch (c)
    c218:	e3a07000 	mov	r7, #0
    c21c:	eafffe48 	b	bb44 <quotearg_buffer_restyled+0x3c0>
          c_and_shell_quote_compat = true;
    c220:	e1a04007 	mov	r4, r7
      switch (c)
    c224:	e3a07000 	mov	r7, #0
    c228:	eafffdeb 	b	b9dc <quotearg_buffer_restyled+0x258>
          if (quoting_style == shell_always_quoting_style
    c22c:	e3a03000 	mov	r3, #0
      switch (c)
    c230:	e3a0206e 	mov	r2, #110	@ 0x6e
    c234:	e1a07003 	mov	r7, r3
    c238:	eafffe49 	b	bb64 <quotearg_buffer_restyled+0x3e0>
    c23c:	e3a03000 	mov	r3, #0
              c = esc;
    c240:	e3a01061 	mov	r1, #97	@ 0x61
      bool c_and_shell_quote_compat = false;
    c244:	e1a04003 	mov	r4, r3
    c248:	eafffdf7 	b	ba2c <quotearg_buffer_restyled+0x2a8>
              START_ESC ();
    c24c:	e3a03000 	mov	r3, #0
              c = esc;
    c250:	e3a01062 	mov	r1, #98	@ 0x62
      bool c_and_shell_quote_compat = false;
    c254:	e1a04003 	mov	r4, r3
    c258:	eafffdf3 	b	ba2c <quotearg_buffer_restyled+0x2a8>
          if (quoting_style == shell_always_quoting_style
    c25c:	e3a03000 	mov	r3, #0
        case '\r': esc = 'r'; goto c_and_shell_escape;
    c260:	e3a02072 	mov	r2, #114	@ 0x72
      switch (c)
    c264:	e1a07003 	mov	r7, r3
    c268:	eafffe3d 	b	bb64 <quotearg_buffer_restyled+0x3e0>
          if (quoting_style == shell_always_quoting_style
    c26c:	e3a03000 	mov	r3, #0
        case '\t': esc = 't'; goto c_and_shell_escape;
    c270:	e3a02074 	mov	r2, #116	@ 0x74
      switch (c)
    c274:	e1a07003 	mov	r7, r3
    c278:	eafffe39 	b	bb64 <quotearg_buffer_restyled+0x3e0>
              START_ESC ();
    c27c:	e3a03000 	mov	r3, #0
              c = esc;
    c280:	e3a01066 	mov	r1, #102	@ 0x66
      bool c_and_shell_quote_compat = false;
    c284:	e1a04003 	mov	r4, r3
    c288:	eafffde7 	b	ba2c <quotearg_buffer_restyled+0x2a8>
              START_ESC ();
    c28c:	e3a03000 	mov	r3, #0
              c = esc;
    c290:	e3a01076 	mov	r1, #118	@ 0x76
      bool c_and_shell_quote_compat = false;
    c294:	e1a04003 	mov	r4, r3
    c298:	eafffde3 	b	ba2c <quotearg_buffer_restyled+0x2a8>
      switch (c)
    c29c:	e241205c 	sub	r2, r1, #92	@ 0x5c
    c2a0:	e3a03001 	mov	r3, #1
    c2a4:	e6ef2072 	uxtb	r2, r2
    c2a8:	e1a03213 	lsl	r3, r3, r2
    c2ac:	e3d32156 	bics	r2, r3, #-2147483627	@ 0x80000015
    c2b0:	1afffdc9 	bne	b9dc <quotearg_buffer_restyled+0x258>
    c2b4:	e3130014 	tst	r3, #20
    c2b8:	1a00004e 	bne	c3f8 <quotearg_buffer_restyled+0xc74>
          if (quoting_style == shell_always_quoting_style)
    c2bc:	e35a0002 	cmp	sl, #2
    c2c0:	1a000044 	bne	c3d8 <quotearg_buffer_restyled+0xc54>
              if (elide_outer_quotes)
    c2c4:	e59d3008 	ldr	r3, [sp, #8]
    c2c8:	e3530000 	cmp	r3, #0
    c2cc:	1afffe0b 	bne	bb00 <quotearg_buffer_restyled+0x37c>
                  && i + 1 < argsize && '0' <= arg[i + 1] && arg[i + 1] <= '9')
    c2d0:	e59d0014 	ldr	r0, [sp, #20]
    c2d4:	e2855001 	add	r5, r5, #1
      bool c_and_shell_quote_compat = false;
    c2d8:	e3a04000 	mov	r4, #0
      c = arg[i];
    c2dc:	e3a0105c 	mov	r1, #92	@ 0x5c
    c2e0:	eafffef5 	b	bebc <quotearg_buffer_restyled+0x738>
      switch (c)
    c2e4:	e241207b 	sub	r2, r1, #123	@ 0x7b
    c2e8:	e6ef2072 	uxtb	r2, r2
    c2ec:	e3520003 	cmp	r2, #3
    c2f0:	8afffdaa 	bhi	b9a0 <quotearg_buffer_restyled+0x21c>
    c2f4:	e241307c 	sub	r3, r1, #124	@ 0x7c
    c2f8:	e3530002 	cmp	r3, #2
    c2fc:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    c300:	eafffe09 	b	bb2c <quotearg_buffer_restyled+0x3a8>
    c304:	0000bae0 	.word	0x0000bae0
    c308:	0000bb2c 	.word	0x0000bb2c
    c30c:	0000bb44 	.word	0x0000bb44
    c310:	e351007a 	cmp	r1, #122	@ 0x7a
    c314:	8a000076 	bhi	c4f4 <quotearg_buffer_restyled+0xd70>
    c318:	e351005b 	cmp	r1, #91	@ 0x5b
    c31c:	8a000025 	bhi	c3b8 <quotearg_buffer_restyled+0xc34>
    c320:	e351003e 	cmp	r1, #62	@ 0x3e
    c324:	8a000113 	bhi	c778 <quotearg_buffer_restyled+0xff4>
    c328:	e2412024 	sub	r2, r1, #36	@ 0x24
    c32c:	e3a03001 	mov	r3, #1
    c330:	e6ef2072 	uxtb	r2, r2
    c334:	e1a03213 	lsl	r3, r3, r2
    c338:	e59d203c 	ldr	r2, [sp, #60]	@ 0x3c
    c33c:	e0132002 	ands	r2, r3, r2
    c340:	1a000113 	bne	c794 <quotearg_buffer_restyled+0x1010>
    c344:	e3a00075 	mov	r0, #117	@ 0x75
    c348:	e3400780 	movt	r0, #1920	@ 0x780
    c34c:	e0133000 	ands	r3, r3, r0
    c350:	1a000065 	bne	c4ec <quotearg_buffer_restyled+0xd68>
          c_and_shell_quote_compat = true;
    c354:	e1a04007 	mov	r4, r7
          encountered_single_quote = true;
    c358:	e58d702c 	str	r7, [sp, #44]	@ 0x2c
      c = arg[i];
    c35c:	e3a01027 	mov	r1, #39	@ 0x27
      switch (c)
    c360:	e1a07003 	mov	r7, r3
    c364:	eafffd9c 	b	b9dc <quotearg_buffer_restyled+0x258>
    c368:	e351003f 	cmp	r1, #63	@ 0x3f
    c36c:	1a000126 	bne	c80c <quotearg_buffer_restyled+0x1088>
          switch (quoting_style)
    c370:	e35a0002 	cmp	sl, #2
    c374:	0a000056 	beq	c4d4 <quotearg_buffer_restyled+0xd50>
    c378:	e35a0005 	cmp	sl, #5
    c37c:	1a00000a 	bne	c3ac <quotearg_buffer_restyled+0xc28>
              if ((flags & QA_SPLIT_TRIGRAPHS)
    c380:	e59d3094 	ldr	r3, [sp, #148]	@ 0x94
    c384:	e2134004 	ands	r4, r3, #4
    c388:	0a000008 	beq	c3b0 <quotearg_buffer_restyled+0xc2c>
                  && i + 2 < argsize && arg[i + 1] == '?')
    c38c:	e59d3000 	ldr	r3, [sp]
    c390:	e2852002 	add	r2, r5, #2
    c394:	e1520003 	cmp	r2, r3
    c398:	2a000003 	bcs	c3ac <quotearg_buffer_restyled+0xc28>
    c39c:	e59d3020 	ldr	r3, [sp, #32]
    c3a0:	e5d31001 	ldrb	r1, [r3, #1]
    c3a4:	e351003f 	cmp	r1, #63	@ 0x3f
    c3a8:	0a000198 	beq	ca10 <quotearg_buffer_restyled+0x128c>
      bool c_and_shell_quote_compat = false;
    c3ac:	e3a04000 	mov	r4, #0
      c = arg[i];
    c3b0:	e3a0103f 	mov	r1, #63	@ 0x3f
    c3b4:	eafffd88 	b	b9dc <quotearg_buffer_restyled+0x258>
      switch (c)
    c3b8:	e241205c 	sub	r2, r1, #92	@ 0x5c
    c3bc:	e3a03001 	mov	r3, #1
    c3c0:	e6ef2072 	uxtb	r2, r2
    c3c4:	e1a03213 	lsl	r3, r3, r2
    c3c8:	e3d32156 	bics	r2, r3, #-2147483627	@ 0x80000015
    c3cc:	1a0000f0 	bne	c794 <quotearg_buffer_restyled+0x1010>
    c3d0:	e3130014 	tst	r3, #20
    c3d4:	1a000044 	bne	c4ec <quotearg_buffer_restyled+0xd68>
          if (backslash_escapes && elide_outer_quotes && quote_string_len)
    c3d8:	e59d3018 	ldr	r3, [sp, #24]
    c3dc:	e59d2008 	ldr	r2, [sp, #8]
    c3e0:	e0137002 	ands	r7, r3, r2
    c3e4:	0a000055 	beq	c540 <quotearg_buffer_restyled+0xdbc>
    c3e8:	e59d301c 	ldr	r3, [sp, #28]
    c3ec:	e3530000 	cmp	r3, #0
    c3f0:	0afffdc5 	beq	bb0c <quotearg_buffer_restyled+0x388>
    c3f4:	eaffffb5 	b	c2d0 <quotearg_buffer_restyled+0xb4c>
      switch (c)
    c3f8:	e1a04007 	mov	r4, r7
    c3fc:	eafffdb8 	b	bae4 <quotearg_buffer_restyled+0x360>
    c400:	e351007a 	cmp	r1, #122	@ 0x7a
    c404:	8a000148 	bhi	c92c <quotearg_buffer_restyled+0x11a8>
    c408:	e351005b 	cmp	r1, #91	@ 0x5b
    c40c:	8a000043 	bhi	c520 <quotearg_buffer_restyled+0xd9c>
    c410:	e351003e 	cmp	r1, #62	@ 0x3e
    c414:	8a00014f 	bhi	c958 <quotearg_buffer_restyled+0x11d4>
    c418:	e2412024 	sub	r2, r1, #36	@ 0x24
    c41c:	e3a03001 	mov	r3, #1
    c420:	e6ef2072 	uxtb	r2, r2
    c424:	e1a03213 	lsl	r3, r3, r2
    c428:	e59d203c 	ldr	r2, [sp, #60]	@ 0x3c
    c42c:	e1130002 	tst	r3, r2
    c430:	1a00014e 	bne	c970 <quotearg_buffer_restyled+0x11ec>
    c434:	e3a02075 	mov	r2, #117	@ 0x75
    c438:	e3402780 	movt	r2, #1920	@ 0x780
    c43c:	e1130002 	tst	r3, r2
    c440:	1afffdc1 	bne	bb4c <quotearg_buffer_restyled+0x3c8>
          c_and_shell_quote_compat = true;
    c444:	e1a04007 	mov	r4, r7
      c = arg[i];
    c448:	e3a01027 	mov	r1, #39	@ 0x27
          encountered_single_quote = true;
    c44c:	e58d702c 	str	r7, [sp, #44]	@ 0x2c
    c450:	eafffd61 	b	b9dc <quotearg_buffer_restyled+0x258>
  if (len == 0 && quoting_style == shell_always_quoting_style
    c454:	e24a3002 	sub	r3, sl, #2
    c458:	e16f3f13 	clz	r3, r3
    c45c:	e1a032a3 	lsr	r3, r3, #5
    c460:	e35b0000 	cmp	fp, #0
    c464:	13a02000 	movne	r2, #0
    c468:	02032001 	andeq	r2, r3, #1
    c46c:	e3520000 	cmp	r2, #0
    c470:	0a0000ea 	beq	c820 <quotearg_buffer_restyled+0x109c>
      && elide_outer_quotes)
    c474:	e59d3008 	ldr	r3, [sp, #8]
    c478:	e3530000 	cmp	r3, #0
    c47c:	1afffd9e 	bne	bafc <quotearg_buffer_restyled+0x378>
      && encountered_single_quote)
    c480:	e59d302c 	ldr	r3, [sp, #44]	@ 0x2c
    c484:	e3530000 	cmp	r3, #0
    c488:	0a0001f6 	beq	cc68 <quotearg_buffer_restyled+0x14e4>
      if (all_c_and_shell_quote_compat)
    c48c:	e59d300c 	ldr	r3, [sp, #12]
    c490:	e3530000 	cmp	r3, #0
    c494:	1a0001e1 	bne	cc20 <quotearg_buffer_restyled+0x149c>
      else if (! buffersize && orig_buffersize)
    c498:	e59d2034 	ldr	r2, [sp, #52]	@ 0x34
    c49c:	e16f3f16 	clz	r3, r6
    c4a0:	e1a032a3 	lsr	r3, r3, #5
    c4a4:	e3520000 	cmp	r2, #0
    c4a8:	03a03000 	moveq	r3, #0
    c4ac:	e3530000 	cmp	r3, #0
    c4b0:	0a0001dd 	beq	cc2c <quotearg_buffer_restyled+0x14a8>
          buffersize = orig_buffersize;
    c4b4:	e59d6034 	ldr	r6, [sp, #52]	@ 0x34
      else if (! buffersize && orig_buffersize)
    c4b8:	e58d302c 	str	r3, [sp, #44]	@ 0x2c
    c4bc:	eafffdf7 	b	bca0 <quotearg_buffer_restyled+0x51c>
          if (! (argsize == SIZE_MAX ? arg[1] == '\0' : argsize == 1))
    c4c0:	e59d3004 	ldr	r3, [sp, #4]
    c4c4:	e5d33001 	ldrb	r3, [r3, #1]
    c4c8:	e3530000 	cmp	r3, #0
    c4cc:	1afffd9e 	bne	bb4c <quotearg_buffer_restyled+0x3c8>
    c4d0:	eafffd9b 	b	bb44 <quotearg_buffer_restyled+0x3c0>
              if (elide_outer_quotes)
    c4d4:	e59d3008 	ldr	r3, [sp, #8]
    c4d8:	e3530000 	cmp	r3, #0
    c4dc:	1afffd87 	bne	bb00 <quotearg_buffer_restyled+0x37c>
      bool c_and_shell_quote_compat = false;
    c4e0:	e1a04003 	mov	r4, r3
      bool escaping = false;
    c4e4:	e1a00003 	mov	r0, r3
    c4e8:	eafffe6e 	b	bea8 <quotearg_buffer_restyled+0x724>
      switch (c)
    c4ec:	e1a07002 	mov	r7, r2
          if (quoting_style == shell_always_quoting_style
    c4f0:	eafffd95 	b	bb4c <quotearg_buffer_restyled+0x3c8>
      switch (c)
    c4f4:	e241207b 	sub	r2, r1, #123	@ 0x7b
    c4f8:	e6ef2072 	uxtb	r2, r2
    c4fc:	e3520003 	cmp	r2, #3
    c500:	8afffd25 	bhi	b99c <quotearg_buffer_restyled+0x218>
    c504:	e241307c 	sub	r3, r1, #124	@ 0x7c
    c508:	e3530002 	cmp	r3, #2
    c50c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    c510:	eafffd84 	b	bb28 <quotearg_buffer_restyled+0x3a4>
    c514:	0000c010 	.word	0x0000c010
    c518:	0000bb28 	.word	0x0000bb28
    c51c:	0000c218 	.word	0x0000c218
    c520:	e241205c 	sub	r2, r1, #92	@ 0x5c
    c524:	e3a03001 	mov	r3, #1
    c528:	e6ef2072 	uxtb	r2, r2
    c52c:	e1a03213 	lsl	r3, r3, r2
    c530:	e3d32156 	bics	r2, r3, #-2147483627	@ 0x80000015
    c534:	1a00010d 	bne	c970 <quotearg_buffer_restyled+0x11ec>
    c538:	e3130014 	tst	r3, #20
    c53c:	1afffd82 	bne	bb4c <quotearg_buffer_restyled+0x3c8>
          if (backslash_escapes)
    c540:	e59d3018 	ldr	r3, [sp, #24]
    c544:	e3530000 	cmp	r3, #0
    c548:	0afffd7f 	beq	bb4c <quotearg_buffer_restyled+0x3c8>
      bool c_and_shell_quote_compat = false;
    c54c:	e3a04000 	mov	r4, #0
              c = esc;
    c550:	e3a0105c 	mov	r1, #92	@ 0x5c
    c554:	eafffd4b 	b	ba88 <quotearg_buffer_restyled+0x304>
                if (argsize == SIZE_MAX)
    c558:	e59d3000 	ldr	r3, [sp]
    c55c:	e3730001 	cmn	r3, #1
    c560:	e3a03000 	mov	r3, #0
    c564:	e58d3060 	str	r3, [sp, #96]	@ 0x60
    c568:	e58d3064 	str	r3, [sp, #100]	@ 0x64
    c56c:	1a000004 	bne	c584 <quotearg_buffer_restyled+0xe00>
                  argsize = strlen (arg);
    c570:	e59d0004 	ldr	r0, [sp, #4]
    c574:	e58d1024 	str	r1, [sp, #36]	@ 0x24
    c578:	fa004fc0 	blx	20480 <strlen>
    c57c:	e59d1024 	ldr	r1, [sp, #36]	@ 0x24
    c580:	e58d0000 	str	r0, [sp]
    c584:	e58db050 	str	fp, [sp, #80]	@ 0x50
      switch (c)
    c588:	e3a02000 	mov	r2, #0
    c58c:	e58d6024 	str	r6, [sp, #36]	@ 0x24
    c590:	e89d0840 	ldm	sp, {r6, fp}
    c594:	e58d8044 	str	r8, [sp, #68]	@ 0x44
    c598:	e1a08002 	mov	r8, r2
    c59c:	e58d1048 	str	r1, [sp, #72]	@ 0x48
    c5a0:	e58d704c 	str	r7, [sp, #76]	@ 0x4c
                    size_t bytes = mbrtoc32 (&w, &arg[i + m],
    c5a4:	e0857008 	add	r7, r5, r8
    c5a8:	e28d3060 	add	r3, sp, #96	@ 0x60
    c5ac:	e0462007 	sub	r2, r6, r7
    c5b0:	e08b1007 	add	r1, fp, r7
    c5b4:	e28d005c 	add	r0, sp, #92	@ 0x5c
    c5b8:	eb0008c2 	bl	e8c8 <mbrtoc32>
                    if (bytes == 0)
    c5bc:	e3500000 	cmp	r0, #0
    c5c0:	0a000014 	beq	c618 <quotearg_buffer_restyled+0xe94>
                    else if (bytes == (size_t) -1)
    c5c4:	e3700001 	cmn	r0, #1
    c5c8:	0a000140 	beq	cad0 <quotearg_buffer_restyled+0x134c>
                    else if (bytes == (size_t) -2)
    c5cc:	e3700002 	cmn	r0, #2
    c5d0:	0a000146 	beq	caf0 <quotearg_buffer_restyled+0x136c>
                        if (bytes == (size_t) -3)
    c5d4:	e3700003 	cmn	r0, #3
    c5d8:	0a000006 	beq	c5f8 <quotearg_buffer_restyled+0xe74>
                        if ('[' == 0x5b && elide_outer_quotes
    c5dc:	e59d3008 	ldr	r3, [sp, #8]
    c5e0:	e35a0002 	cmp	sl, #2
    c5e4:	13a03000 	movne	r3, #0
    c5e8:	02033001 	andeq	r3, r3, #1
    c5ec:	e3530000 	cmp	r3, #0
    c5f0:	1a00006c 	bne	c7a8 <quotearg_buffer_restyled+0x1024>
                        m += bytes;
    c5f4:	e0888000 	add	r8, r8, r0
                        if (! c32isprint (w))
    c5f8:	e59d005c 	ldr	r0, [sp, #92]	@ 0x5c
    c5fc:	eb00086e 	bl	e7bc <c32isprint>
                          printable = false;
    c600:	e3500000 	cmp	r0, #0
                    if (mbsinit (&mbstate))
    c604:	e28d0060 	add	r0, sp, #96	@ 0x60
                          printable = false;
    c608:	03a04000 	moveq	r4, #0
                    if (mbsinit (&mbstate))
    c60c:	eb0028e8 	bl	169b4 <mbsinit>
    c610:	e3500000 	cmp	r0, #0
    c614:	0affffe2 	beq	c5a4 <quotearg_buffer_restyled+0xe20>
            if (1 < m || (backslash_escapes && ! printable))
    c618:	e28d1048 	add	r1, sp, #72	@ 0x48
    c61c:	e59d3018 	ldr	r3, [sp, #24]
    c620:	e8910882 	ldm	r1, {r1, r7, fp}
    c624:	e1a02008 	mov	r2, r8
    c628:	e224c001 	eor	ip, r4, #1
    c62c:	e59d8044 	ldr	r8, [sp, #68]	@ 0x44
    c630:	e00cc003 	and	ip, ip, r3
    c634:	e59d6024 	ldr	r6, [sp, #36]	@ 0x24
    c638:	e3520001 	cmp	r2, #1
    c63c:	9afffce4 	bls	b9d4 <quotearg_buffer_restyled+0x250>
                size_t ilim = i + m;
    c640:	e59d3020 	ldr	r3, [sp, #32]
    c644:	e082e005 	add	lr, r2, r5
                        START_ESC ();
    c648:	e58d4020 	str	r4, [sp, #32]
      bool escaping = false;
    c64c:	e3a02000 	mov	r2, #0
                        START_ESC ();
    c650:	e58d909c 	str	r9, [sp, #156]	@ 0x9c
                    END_ESC ();
    c654:	e3a08027 	mov	r8, #39	@ 0x27
                        START_ESC ();
    c658:	e59d4010 	ldr	r4, [sp, #16]
    c65c:	e59d9014 	ldr	r9, [sp, #20]
    c660:	ea00002b 	b	c714 <quotearg_buffer_restyled+0xf90>
    c664:	e59d0008 	ldr	r0, [sp, #8]
              START_ESC ();
    c668:	e24a2002 	sub	r2, sl, #2
    c66c:	e16f2f12 	clz	r2, r2
    c670:	e1a022a2 	lsr	r2, r2, #5
                        START_ESC ();
    c674:	e3500000 	cmp	r0, #0
    c678:	1a000093 	bne	c8cc <quotearg_buffer_restyled+0x1148>
    c67c:	e2290001 	eor	r0, r9, #1
    c680:	e0122000 	ands	r2, r2, r0
    c684:	0a00000a 	beq	c6b4 <quotearg_buffer_restyled+0xf30>
    c688:	e28b0001 	add	r0, fp, #1
    c68c:	e156000b 	cmp	r6, fp
    c690:	87c4800b 	strbhi	r8, [r4, fp]
    c694:	e1560000 	cmp	r6, r0
    c698:	83a09024 	movhi	r9, #36	@ 0x24
    c69c:	87c49000 	strbhi	r9, [r4, r0]
    c6a0:	e28b0002 	add	r0, fp, #2
    c6a4:	e1a09002 	mov	r9, r2
    c6a8:	e28bb003 	add	fp, fp, #3
    c6ac:	e1560000 	cmp	r6, r0
    c6b0:	87c48000 	strbhi	r8, [r4, r0]
    c6b4:	e156000b 	cmp	r6, fp
                    if (ilim <= i + 1)
    c6b8:	e2855001 	add	r5, r5, #1
                        START_ESC ();
    c6bc:	83a0205c 	movhi	r2, #92	@ 0x5c
    c6c0:	87c4200b 	strbhi	r2, [r4, fp]
    c6c4:	e28b2001 	add	r2, fp, #1
                        STORE ('0' + (c >> 6));
    c6c8:	e1560002 	cmp	r6, r2
    c6cc:	81a00321 	lsrhi	r0, r1, #6
    c6d0:	82800030 	addhi	r0, r0, #48	@ 0x30
    c6d4:	87c40002 	strbhi	r0, [r4, r2]
    c6d8:	e28b2002 	add	r2, fp, #2
                        STORE ('0' + ((c >> 3) & 7));
    c6dc:	e1560002 	cmp	r6, r2
    c6e0:	e28bb003 	add	fp, fp, #3
    c6e4:	87e201d1 	ubfxhi	r0, r1, #3, #3
                        c = '0' + (c & 7);
    c6e8:	e2011007 	and	r1, r1, #7
                        STORE ('0' + ((c >> 3) & 7));
    c6ec:	82800030 	addhi	r0, r0, #48	@ 0x30
                        c = '0' + (c & 7);
    c6f0:	e2811030 	add	r1, r1, #48	@ 0x30
                        STORE ('0' + ((c >> 3) & 7));
    c6f4:	87c40002 	strbhi	r0, [r4, r2]
                    if (ilim <= i + 1)
    c6f8:	e155000e 	cmp	r5, lr
    c6fc:	2a00007a 	bcs	c8ec <quotearg_buffer_restyled+0x1168>
                        START_ESC ();
    c700:	e1a0200c 	mov	r2, ip
                    STORE (c);
    c704:	e156000b 	cmp	r6, fp
    c708:	87c4100b 	strbhi	r1, [r4, fp]
    c70c:	e28bb001 	add	fp, fp, #1
                    c = arg[++i];
    c710:	e5f31001 	ldrb	r1, [r3, #1]!
                    if (backslash_escapes && ! printable)
    c714:	e35c0000 	cmp	ip, #0
    c718:	1affffd1 	bne	c664 <quotearg_buffer_restyled+0xee0>
                    else if (is_right_quote)
    c71c:	e3570000 	cmp	r7, #0
                    END_ESC ();
    c720:	e2227001 	eor	r7, r2, #1
    c724:	e0077009 	and	r7, r7, r9
    c728:	e6ef7077 	uxtb	r7, r7
                    else if (is_right_quote)
    c72c:	0a000003 	beq	c740 <quotearg_buffer_restyled+0xfbc>
                        STORE ('\\');
    c730:	e156000b 	cmp	r6, fp
    c734:	83a0005c 	movhi	r0, #92	@ 0x5c
    c738:	87c4000b 	strbhi	r0, [r4, fp]
    c73c:	e28bb001 	add	fp, fp, #1
                    if (ilim <= i + 1)
    c740:	e2855001 	add	r5, r5, #1
    c744:	e155000e 	cmp	r5, lr
    c748:	2a000062 	bcs	c8d8 <quotearg_buffer_restyled+0x1154>
                    END_ESC ();
    c74c:	e3570000 	cmp	r7, #0
    c750:	0affffeb 	beq	c704 <quotearg_buffer_restyled+0xf80>
    c754:	e156000b 	cmp	r6, fp
    c758:	e28b0001 	add	r0, fp, #1
    c75c:	87c4800b 	strbhi	r8, [r4, fp]
    c760:	e3a07000 	mov	r7, #0
    c764:	e1560000 	cmp	r6, r0
    c768:	e28bb002 	add	fp, fp, #2
    c76c:	e1a09007 	mov	r9, r7
    c770:	87c48000 	strbhi	r8, [r4, r0]
    c774:	eaffffe2 	b	c704 <quotearg_buffer_restyled+0xf80>
      switch (c)
    c778:	e351003f 	cmp	r1, #63	@ 0x3f
    c77c:	03a07000 	moveq	r7, #0
    c780:	0afffefc 	beq	c378 <quotearg_buffer_restyled+0xbf4>
    c784:	e351005b 	cmp	r1, #91	@ 0x5b
    c788:	0afffe20 	beq	c010 <quotearg_buffer_restyled+0x88c>
    c78c:	e3510040 	cmp	r1, #64	@ 0x40
    c790:	0afffc81 	beq	b99c <quotearg_buffer_restyled+0x218>
    c794:	e3a03000 	mov	r3, #0
      if (! (((backslash_escapes && quoting_style != shell_always_quoting_style)
    c798:	e1a04007 	mov	r4, r7
    c79c:	e3a00000 	mov	r0, #0
    c7a0:	e1a07003 	mov	r7, r3
    c7a4:	eafffc91 	b	b9f0 <quotearg_buffer_restyled+0x26c>
                            for (j = 1; j < bytes; j++)
    c7a8:	e3500001 	cmp	r0, #1
                        m += bytes;
    c7ac:	02888001 	addeq	r8, r8, #1
                            for (j = 1; j < bytes; j++)
    c7b0:	0affff90 	beq	c5f8 <quotearg_buffer_restyled+0xe74>
    c7b4:	e2872001 	add	r2, r7, #1
    c7b8:	e08b1000 	add	r1, fp, r0
    c7bc:	e08b2002 	add	r2, fp, r2
    c7c0:	e0811007 	add	r1, r1, r7
    c7c4:	e3a0c115 	mov	ip, #1073741829	@ 0x40000005
    c7c8:	ea000003 	b	c7dc <quotearg_buffer_restyled+0x1058>
    c7cc:	e353005a 	cmp	r3, #90	@ 0x5a
    c7d0:	8a00000b 	bhi	c804 <quotearg_buffer_restyled+0x1080>
    c7d4:	e1520001 	cmp	r2, r1
    c7d8:	0affff85 	beq	c5f4 <quotearg_buffer_restyled+0xe70>
                              switch (arg[i + m + j])
    c7dc:	e4d23001 	ldrb	r3, [r2], #1
    c7e0:	e353005c 	cmp	r3, #92	@ 0x5c
    c7e4:	9afffff8 	bls	c7cc <quotearg_buffer_restyled+0x1048>
    c7e8:	e243305e 	sub	r3, r3, #94	@ 0x5e
    c7ec:	e6ef3073 	uxtb	r3, r3
    c7f0:	e353001e 	cmp	r3, #30
    c7f4:	8afffff6 	bhi	c7d4 <quotearg_buffer_restyled+0x1050>
    c7f8:	e1a0333c 	lsr	r3, ip, r3
    c7fc:	e3130001 	tst	r3, #1
    c800:	0afffff3 	beq	c7d4 <quotearg_buffer_restyled+0x1050>
    c804:	e59d6024 	ldr	r6, [sp, #36]	@ 0x24
    c808:	eafffcbb 	b	bafc <quotearg_buffer_restyled+0x378>
      switch (c)
    c80c:	e351005b 	cmp	r1, #91	@ 0x5b
    c810:	0afffef8 	beq	c3f8 <quotearg_buffer_restyled+0xc74>
    c814:	e3510040 	cmp	r1, #64	@ 0x40
    c818:	1afffc6f 	bne	b9dc <quotearg_buffer_restyled+0x258>
    c81c:	eafffc5f 	b	b9a0 <quotearg_buffer_restyled+0x21c>
  if (quoting_style == shell_always_quoting_style && ! elide_outer_quotes
    c820:	e59d2008 	ldr	r2, [sp, #8]
    c824:	e2222001 	eor	r2, r2, #1
    c828:	e0121003 	ands	r1, r2, r3
    c82c:	e6ef2072 	uxtb	r2, r2
    c830:	0a0000c3 	beq	cb44 <quotearg_buffer_restyled+0x13c0>
      && encountered_single_quote)
    c834:	e59d302c 	ldr	r3, [sp, #44]	@ 0x2c
    c838:	e3530000 	cmp	r3, #0
    c83c:	0a0000ff 	beq	cc40 <quotearg_buffer_restyled+0x14bc>
      if (all_c_and_shell_quote_compat)
    c840:	e59d300c 	ldr	r3, [sp, #12]
    c844:	e3530000 	cmp	r3, #0
    c848:	1a0000f4 	bne	cc20 <quotearg_buffer_restyled+0x149c>
      else if (! buffersize && orig_buffersize)
    c84c:	e59d2034 	ldr	r2, [sp, #52]	@ 0x34
    c850:	e16f3f16 	clz	r3, r6
    c854:	e1a032a3 	lsr	r3, r3, #5
    c858:	e3520000 	cmp	r2, #0
    c85c:	03a03000 	moveq	r3, #0
    c860:	e3530000 	cmp	r3, #0
    c864:	0a0000f9 	beq	cc50 <quotearg_buffer_restyled+0x14cc>
    c868:	e59d200c 	ldr	r2, [sp, #12]
    c86c:	e59d1034 	ldr	r1, [sp, #52]	@ 0x34
      if (!elide_outer_quotes)
    c870:	e59d000c 	ldr	r0, [sp, #12]
      quoting_style = shell_always_quoting_style;
    c874:	e3a0a002 	mov	sl, #2
    c878:	e59d6034 	ldr	r6, [sp, #52]	@ 0x34
    c87c:	e3a0b000 	mov	fp, #0
      if (!elide_outer_quotes)
    c880:	e3500000 	cmp	r0, #0
      quote_string = "'";
    c884:	e3080db0 	movw	r0, #36272	@ 0x8db0
    c888:	e3400002 	movt	r0, #2
    c88c:	058d200c 	streq	r2, [sp, #12]
    c890:	e58d0028 	str	r0, [sp, #40]	@ 0x28
      quote_string_len = 1;
    c894:	e3a00001 	mov	r0, #1
    c898:	e58d001c 	str	r0, [sp, #28]
    c89c:	058d302c 	streq	r3, [sp, #44]	@ 0x2c
    c8a0:	058d1034 	streq	r1, [sp, #52]	@ 0x34
      if (!elide_outer_quotes)
    c8a4:	0afffcfd 	beq	bca0 <quotearg_buffer_restyled+0x51c>
    c8a8:	e59d000c 	ldr	r0, [sp, #12]
    c8ac:	e58d302c 	str	r3, [sp, #44]	@ 0x2c
    c8b0:	e58d1034 	str	r1, [sp, #52]	@ 0x34
    c8b4:	e58d0008 	str	r0, [sp, #8]
    c8b8:	e58d200c 	str	r2, [sp, #12]
    c8bc:	eafffbf2 	b	b88c <quotearg_buffer_restyled+0x108>
    c8c0:	e59dc018 	ldr	ip, [sp, #24]
    c8c4:	e3a04000 	mov	r4, #0
    c8c8:	eaffff5c 	b	c640 <quotearg_buffer_restyled+0xebc>
    c8cc:	e59d909c 	ldr	r9, [sp, #156]	@ 0x9c
    c8d0:	e58d2018 	str	r2, [sp, #24]
    c8d4:	eafffc89 	b	bb00 <quotearg_buffer_restyled+0x37c>
    c8d8:	e58d9014 	str	r9, [sp, #20]
    c8dc:	e1a00007 	mov	r0, r7
    c8e0:	e59d4020 	ldr	r4, [sp, #32]
    c8e4:	e59d909c 	ldr	r9, [sp, #156]	@ 0x9c
    c8e8:	eafffd73 	b	bebc <quotearg_buffer_restyled+0x738>
    c8ec:	e58d9014 	str	r9, [sp, #20]
    c8f0:	e59d4020 	ldr	r4, [sp, #32]
    c8f4:	e59d909c 	ldr	r9, [sp, #156]	@ 0x9c
    c8f8:	eafffc68 	b	baa0 <quotearg_buffer_restyled+0x31c>
              if (quoting_style != shell_always_quoting_style
    c8fc:	e3580000 	cmp	r8, #0
    c900:	1afffde7 	bne	c0a4 <quotearg_buffer_restyled+0x920>
    c904:	e1a07000 	mov	r7, r0
              START_ESC ();
    c908:	e1a0b003 	mov	fp, r3
    c90c:	e1a00004 	mov	r0, r4
              c = '0';
    c910:	e3a01030 	mov	r1, #48	@ 0x30
      bool c_and_shell_quote_compat = false;
    c914:	e3a04000 	mov	r4, #0
    c918:	eafffc3e 	b	ba18 <quotearg_buffer_restyled+0x294>
    c91c:	e3a04000 	mov	r4, #0
              c = '0';
    c920:	e3a01030 	mov	r1, #48	@ 0x30
              START_ESC ();
    c924:	e58d0014 	str	r0, [sp, #20]
    c928:	eafffd5e 	b	bea8 <quotearg_buffer_restyled+0x724>
      switch (c)
    c92c:	e241207b 	sub	r2, r1, #123	@ 0x7b
    c930:	e6ef2072 	uxtb	r2, r2
    c934:	e3520003 	cmp	r2, #3
    c938:	8afffc18 	bhi	b9a0 <quotearg_buffer_restyled+0x21c>
    c93c:	e241307c 	sub	r3, r1, #124	@ 0x7c
    c940:	e3530002 	cmp	r3, #2
    c944:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    c948:	eafffc77 	b	bb2c <quotearg_buffer_restyled+0x3a8>
    c94c:	0000bb4c 	.word	0x0000bb4c
    c950:	0000bb2c 	.word	0x0000bb2c
    c954:	0000bb44 	.word	0x0000bb44
    c958:	e351003f 	cmp	r1, #63	@ 0x3f
    c95c:	0afffe85 	beq	c378 <quotearg_buffer_restyled+0xbf4>
    c960:	e351005b 	cmp	r1, #91	@ 0x5b
    c964:	0a00009c 	beq	cbdc <quotearg_buffer_restyled+0x1458>
    c968:	e3510040 	cmp	r1, #64	@ 0x40
    c96c:	0afffc0b 	beq	b9a0 <quotearg_buffer_restyled+0x21c>
    c970:	e1a03007 	mov	r3, r7
    c974:	eaffff87 	b	c798 <quotearg_buffer_restyled+0x1014>
    c978:	00029e51 	.word	0x00029e51
      quote_string = "\"";
    c97c:	e3082dbc 	movw	r2, #36284	@ 0x8dbc
    c980:	e3a03001 	mov	r3, #1
    c984:	e3402002 	movt	r2, #2
    c988:	e1a0b003 	mov	fp, r3
    c98c:	e58d300c 	str	r3, [sp, #12]
    c990:	e58d2028 	str	r2, [sp, #40]	@ 0x28
    c994:	e58d6034 	str	r6, [sp, #52]	@ 0x34
    c998:	e58d602c 	str	r6, [sp, #44]	@ 0x2c
    c99c:	e58d6014 	str	r6, [sp, #20]
    c9a0:	e58d6008 	str	r6, [sp, #8]
      backslash_escapes = true;
    c9a4:	e58d3018 	str	r3, [sp, #24]
      quote_string_len = 1;
    c9a8:	e58d301c 	str	r3, [sp, #28]
    c9ac:	eafffbb6 	b	b88c <quotearg_buffer_restyled+0x108>
                  STORE ('0');
    c9b0:	e1560003 	cmp	r6, r3
    c9b4:	859d1010 	ldrhi	r1, [sp, #16]
    c9b8:	83a02030 	movhi	r2, #48	@ 0x30
    c9bc:	87c12003 	strbhi	r2, [r1, r3]
    c9c0:	e28b3002 	add	r3, fp, #2
                  STORE ('0');
    c9c4:	e1560003 	cmp	r6, r3
    c9c8:	859d1010 	ldrhi	r1, [sp, #16]
    c9cc:	83a02030 	movhi	r2, #48	@ 0x30
    c9d0:	87c12003 	strbhi	r2, [r1, r3]
    c9d4:	e28b3003 	add	r3, fp, #3
    c9d8:	eafffdba 	b	c0c8 <quotearg_buffer_restyled+0x944>
          for (quote_string = left_quote; *quote_string; quote_string++)
    c9dc:	e5d93000 	ldrb	r3, [r9]
    c9e0:	e3530000 	cmp	r3, #0
    c9e4:	0a00009d 	beq	cc60 <quotearg_buffer_restyled+0x14dc>
    c9e8:	e59db038 	ldr	fp, [sp, #56]	@ 0x38
    c9ec:	e1a02009 	mov	r2, r9
    c9f0:	e59d1010 	ldr	r1, [sp, #16]
            STORE (*quote_string);
    c9f4:	e156000b 	cmp	r6, fp
    c9f8:	87c1300b 	strbhi	r3, [r1, fp]
    c9fc:	e28bb001 	add	fp, fp, #1
          for (quote_string = left_quote; *quote_string; quote_string++)
    ca00:	e5f23001 	ldrb	r3, [r2, #1]!
    ca04:	e3530000 	cmp	r3, #0
    ca08:	1afffff9 	bne	c9f4 <quotearg_buffer_restyled+0x1270>
    ca0c:	eafffb92 	b	b85c <quotearg_buffer_restyled+0xd8>
                switch (arg[i + 2])
    ca10:	e59d3004 	ldr	r3, [sp, #4]
    ca14:	e7d33002 	ldrb	r3, [r3, r2]
    ca18:	e2434021 	sub	r4, r3, #33	@ 0x21
    ca1c:	e6ef4074 	uxtb	r4, r4
    ca20:	e354001d 	cmp	r4, #29
    ca24:	8afffc48 	bhi	bb4c <quotearg_buffer_restyled+0x3c8>
    ca28:	e59d0054 	ldr	r0, [sp, #84]	@ 0x54
    ca2c:	e1a04430 	lsr	r4, r0, r4
    ca30:	e2144001 	ands	r4, r4, #1
    ca34:	0afffbe8 	beq	b9dc <quotearg_buffer_restyled+0x258>
                    if (elide_outer_quotes)
    ca38:	e59d0008 	ldr	r0, [sp, #8]
    ca3c:	e3500000 	cmp	r0, #0
    ca40:	1afffc31 	bne	bb0c <quotearg_buffer_restyled+0x388>
                    STORE ('?');
    ca44:	e156000b 	cmp	r6, fp
                    i += 2;
    ca48:	e1a05002 	mov	r5, r2
                    STORE ('?');
    ca4c:	859d0010 	ldrhi	r0, [sp, #16]
    ca50:	87c0100b 	strbhi	r1, [r0, fp]
    ca54:	e28b1001 	add	r1, fp, #1
                    STORE ('"');
    ca58:	e1560001 	cmp	r6, r1
    ca5c:	859dc010 	ldrhi	ip, [sp, #16]
    ca60:	83a00022 	movhi	r0, #34	@ 0x22
    ca64:	87cc0001 	strbhi	r0, [ip, r1]
    ca68:	e28b1002 	add	r1, fp, #2
                    STORE ('"');
    ca6c:	e1560001 	cmp	r6, r1
    ca70:	859dc010 	ldrhi	ip, [sp, #16]
    ca74:	83a00022 	movhi	r0, #34	@ 0x22
    ca78:	87cc0001 	strbhi	r0, [ip, r1]
    ca7c:	e28b1003 	add	r1, fp, #3
                    STORE ('?');
    ca80:	e1560001 	cmp	r6, r1
    ca84:	e28bb004 	add	fp, fp, #4
    ca88:	859dc010 	ldrhi	ip, [sp, #16]
    ca8c:	83a0003f 	movhi	r0, #63	@ 0x3f
    ca90:	87cc0001 	strbhi	r0, [ip, r1]
                    c = arg[i + 2];
    ca94:	e1a01003 	mov	r1, r3
    ca98:	eafffc2b 	b	bb4c <quotearg_buffer_restyled+0x3c8>
      quote_string = "\"";
    ca9c:	e3082dbc 	movw	r2, #36284	@ 0x8dbc
    caa0:	e3a03001 	mov	r3, #1
    caa4:	e3a0b000 	mov	fp, #0
    caa8:	e3402002 	movt	r2, #2
    caac:	e58d300c 	str	r3, [sp, #12]
    cab0:	e58db02c 	str	fp, [sp, #44]	@ 0x2c
    cab4:	e58d2028 	str	r2, [sp, #40]	@ 0x28
    cab8:	e58db014 	str	fp, [sp, #20]
    cabc:	e58db034 	str	fp, [sp, #52]	@ 0x34
    cac0:	e58d3008 	str	r3, [sp, #8]
      backslash_escapes = true;
    cac4:	e58d3018 	str	r3, [sp, #24]
      quote_string_len = 1;
    cac8:	e58d301c 	str	r3, [sp, #28]
    cacc:	eafffb6e 	b	b88c <quotearg_buffer_restyled+0x108>
    cad0:	e28d1048 	add	r1, sp, #72	@ 0x48
    cad4:	e1a02008 	mov	r2, r8
    cad8:	e8910882 	ldm	r1, {r1, r7, fp}
                        printable = false;
    cadc:	e3a04000 	mov	r4, #0
    cae0:	e59d8044 	ldr	r8, [sp, #68]	@ 0x44
    cae4:	e59d6024 	ldr	r6, [sp, #36]	@ 0x24
    cae8:	e59dc018 	ldr	ip, [sp, #24]
    caec:	eafffed1 	b	c638 <quotearg_buffer_restyled+0xeb4>
                        while (i + m < argsize && arg[i + m])
    caf0:	e59d0000 	ldr	r0, [sp]
    caf4:	e1a03007 	mov	r3, r7
    caf8:	e28d1048 	add	r1, sp, #72	@ 0x48
    cafc:	e1a02008 	mov	r2, r8
    cb00:	e8910882 	ldm	r1, {r1, r7, fp}
    cb04:	e1530000 	cmp	r3, r0
    cb08:	e59d8044 	ldr	r8, [sp, #68]	@ 0x44
    cb0c:	e59d6024 	ldr	r6, [sp, #36]	@ 0x24
    cb10:	2a000022 	bcs	cba0 <quotearg_buffer_restyled+0x141c>
    cb14:	e59d0004 	ldr	r0, [sp, #4]
    cb18:	e59dc000 	ldr	ip, [sp]
    cb1c:	ea000003 	b	cb30 <quotearg_buffer_restyled+0x13ac>
                          m++;
    cb20:	e2822001 	add	r2, r2, #1
                        while (i + m < argsize && arg[i + m])
    cb24:	e0853002 	add	r3, r5, r2
    cb28:	e153000c 	cmp	r3, ip
    cb2c:	2a00001b 	bcs	cba0 <quotearg_buffer_restyled+0x141c>
    cb30:	e7d04003 	ldrb	r4, [r0, r3]
    cb34:	e3540000 	cmp	r4, #0
    cb38:	1afffff8 	bne	cb20 <quotearg_buffer_restyled+0x139c>
    cb3c:	e59dc018 	ldr	ip, [sp, #24]
    cb40:	eafffebc 	b	c638 <quotearg_buffer_restyled+0xeb4>
    cb44:	e59da010 	ldr	sl, [sp, #16]
    cb48:	e1a03006 	mov	r3, r6
  if (quote_string && !elide_outer_quotes)
    cb4c:	e59d1028 	ldr	r1, [sp, #40]	@ 0x28
    cb50:	e3510000 	cmp	r1, #0
    cb54:	03a02000 	moveq	r2, #0
    cb58:	12022001 	andne	r2, r2, #1
    cb5c:	e3520000 	cmp	r2, #0
    cb60:	0a000008 	beq	cb88 <quotearg_buffer_restyled+0x1404>
    for (; *quote_string; quote_string++)
    cb64:	e5d12000 	ldrb	r2, [r1]
    cb68:	e3520000 	cmp	r2, #0
    cb6c:	0a000005 	beq	cb88 <quotearg_buffer_restyled+0x1404>
      STORE (*quote_string);
    cb70:	e153000b 	cmp	r3, fp
    cb74:	87ca200b 	strbhi	r2, [sl, fp]
    cb78:	e28bb001 	add	fp, fp, #1
    for (; *quote_string; quote_string++)
    cb7c:	e5f12001 	ldrb	r2, [r1, #1]!
    cb80:	e3520000 	cmp	r2, #0
    cb84:	1afffff9 	bne	cb70 <quotearg_buffer_restyled+0x13ec>
  if (len < buffersize)
    cb88:	e153000b 	cmp	r3, fp
                                   quoting_style,
                                   flags & ~QA_ELIDE_OUTER_QUOTES, NULL,
                                   left_quote, right_quote);
}
    cb8c:	e1a0000b 	mov	r0, fp
    buffer[len] = '\0';
    cb90:	83a03000 	movhi	r3, #0
    cb94:	87ca300b 	strbhi	r3, [sl, fp]
}
    cb98:	e28dd06c 	add	sp, sp, #108	@ 0x6c
    cb9c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cba0:	e59dc018 	ldr	ip, [sp, #24]
                        printable = false;
    cba4:	e3a04000 	mov	r4, #0
    cba8:	eafffea2 	b	c638 <quotearg_buffer_restyled+0xeb4>
  switch (quoting_style)
    cbac:	e59d3008 	ldr	r3, [sp, #8]
    cbb0:	e3a02001 	mov	r2, #1
    cbb4:	e58d6034 	str	r6, [sp, #52]	@ 0x34
    cbb8:	e58d300c 	str	r3, [sp, #12]
    cbbc:	e3a03000 	mov	r3, #0
    cbc0:	e1a01003 	mov	r1, r3
    cbc4:	e58d3014 	str	r3, [sp, #20]
    cbc8:	e58d3018 	str	r3, [sp, #24]
    cbcc:	eaffff27 	b	c870 <quotearg_buffer_restyled+0x10ec>
    quoting_style = shell_escape_always_quoting_style;
    cbd0:	e35a0002 	cmp	sl, #2
    cbd4:	03a0a004 	moveq	sl, #4
    cbd8:	eafffbcb 	b	bb0c <quotearg_buffer_restyled+0x388>
      switch (c)
    cbdc:	e59d4008 	ldr	r4, [sp, #8]
    cbe0:	eafffb7d 	b	b9dc <quotearg_buffer_restyled+0x258>
      quote_string = "'";
    cbe4:	e3081db0 	movw	r1, #36272	@ 0x8db0
    cbe8:	e3a03000 	mov	r3, #0
    cbec:	e3a02001 	mov	r2, #1
    cbf0:	e3401002 	movt	r1, #2
    cbf4:	e1a0b003 	mov	fp, r3
      quoting_style = shell_always_quoting_style;
    cbf8:	e3a0a002 	mov	sl, #2
    cbfc:	e58d302c 	str	r3, [sp, #44]	@ 0x2c
    cc00:	e58d200c 	str	r2, [sp, #12]
      quote_string = "'";
    cc04:	e58d1028 	str	r1, [sp, #40]	@ 0x28
    cc08:	e58d3014 	str	r3, [sp, #20]
    cc0c:	e58d3034 	str	r3, [sp, #52]	@ 0x34
    cc10:	e58d2008 	str	r2, [sp, #8]
    cc14:	e58d3018 	str	r3, [sp, #24]
      quote_string_len = 1;
    cc18:	e58d201c 	str	r2, [sp, #28]
    cc1c:	eafffb1a 	b	b88c <quotearg_buffer_restyled+0x108>
        return quotearg_buffer_restyled (buffer, orig_buffersize, arg, argsize,
    cc20:	e59d6034 	ldr	r6, [sp, #52]	@ 0x34
    cc24:	e3a0a005 	mov	sl, #5
    cc28:	eafffae7 	b	b7cc <quotearg_buffer_restyled+0x48>
      else if (! buffersize && orig_buffersize)
    cc2c:	e59da010 	ldr	sl, [sp, #16]
    cc30:	e1a03006 	mov	r3, r6
    cc34:	e59d202c 	ldr	r2, [sp, #44]	@ 0x2c
    cc38:	e59db00c 	ldr	fp, [sp, #12]
    cc3c:	eaffffc2 	b	cb4c <quotearg_buffer_restyled+0x13c8>
    cc40:	e59da010 	ldr	sl, [sp, #16]
    cc44:	e1a03006 	mov	r3, r6
    cc48:	e1a02001 	mov	r2, r1
    cc4c:	eaffffbe 	b	cb4c <quotearg_buffer_restyled+0x13c8>
    cc50:	e59da010 	ldr	sl, [sp, #16]
    cc54:	e1a03006 	mov	r3, r6
    cc58:	e59d202c 	ldr	r2, [sp, #44]	@ 0x2c
    cc5c:	eaffffba 	b	cb4c <quotearg_buffer_restyled+0x13c8>
          for (quote_string = left_quote; *quote_string; quote_string++)
    cc60:	e59db038 	ldr	fp, [sp, #56]	@ 0x38
    cc64:	eafffafc 	b	b85c <quotearg_buffer_restyled+0xd8>
      && encountered_single_quote)
    cc68:	e59da010 	ldr	sl, [sp, #16]
    cc6c:	e1a03006 	mov	r3, r6
    cc70:	e59db02c 	ldr	fp, [sp, #44]	@ 0x2c
    cc74:	eaffffb4 	b	cb4c <quotearg_buffer_restyled+0x13c8>
      abort ();
    cc78:	eb0026a3 	bl	1670c <abort>

0000cc7c <quotearg_n_options>:
   less than MIN (INT_MAX, IDX_MAX).  The type of N is signed
   to allow for future extensions (using negative values).  */
static char *
quotearg_n_options (int n, char const *arg, size_t argsize,
                    struct quoting_options const *options)
{
    cc7c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cc80:	e24dd034 	sub	sp, sp, #52	@ 0x34
    cc84:	e1a05000 	mov	r5, r0
    cc88:	e1a04003 	mov	r4, r3
    cc8c:	e1a09002 	mov	r9, r2
  int e = errno;

  struct slotvec *sv = slotvec;
    cc90:	e30b7024 	movw	r7, #45092	@ 0xb024
{
    cc94:	e58d101c 	str	r1, [sp, #28]
  struct slotvec *sv = slotvec;
    cc98:	e3407002 	movt	r7, #2
  int e = errno;
    cc9c:	eb003adc 	bl	1b814 <__errno>
    cca0:	e5903000 	ldr	r3, [r0]

  int nslots_max = MIN (INT_MAX, IDX_MAX);
  if (! (0 <= n && n < nslots_max))
    cca4:	e375010a 	cmn	r5, #-2147483646	@ 0x80000002
  struct slotvec *sv = slotvec;
    cca8:	e5976000 	ldr	r6, [r7]
  int e = errno;
    ccac:	e58d3020 	str	r3, [sp, #32]
  if (! (0 <= n && n < nslots_max))
    ccb0:	8a00005a 	bhi	ce20 <quotearg_n_options+0x1a4>
    abort ();

  if (nslots <= n)
    ccb4:	e5972004 	ldr	r2, [r7, #4]
    ccb8:	e1520005 	cmp	r2, r5
    ccbc:	ca000016 	bgt	cd1c <quotearg_n_options+0xa0>
    {
      bool preallocated = (sv == &slotvec0);
      idx_t new_nslots = nslots;

      slotvec = sv = xpalloc (preallocated ? NULL : sv, &new_nslots,
    ccc0:	e287a008 	add	sl, r7, #8
      idx_t new_nslots = nslots;
    ccc4:	e58d202c 	str	r2, [sp, #44]	@ 0x2c
      slotvec = sv = xpalloc (preallocated ? NULL : sv, &new_nslots,
    ccc8:	e156000a 	cmp	r6, sl
                              n - nslots + 1, nslots_max, sizeof *sv);
    cccc:	e0452002 	sub	r2, r5, r2
      slotvec = sv = xpalloc (preallocated ? NULL : sv, &new_nslots,
    ccd0:	e2822001 	add	r2, r2, #1
    ccd4:	0a000046 	beq	cdf4 <quotearg_n_options+0x178>
    ccd8:	e3a03008 	mov	r3, #8
    ccdc:	e1a00006 	mov	r0, r6
    cce0:	e58d3000 	str	r3, [sp]
    cce4:	e28d102c 	add	r1, sp, #44	@ 0x2c
    cce8:	e3e03102 	mvn	r3, #-2147483648	@ 0x80000000
    ccec:	eb000533 	bl	e1c0 <xpalloc>
    ccf0:	e1a06000 	mov	r6, r0
    ccf4:	e5870000 	str	r0, [r7]
      if (preallocated)
        *sv = slotvec0;
      memset (sv + nslots, 0, (new_nslots - nslots) * sizeof *sv);
    ccf8:	e5970004 	ldr	r0, [r7, #4]
    ccfc:	e3a01000 	mov	r1, #0
    cd00:	e59d202c 	ldr	r2, [sp, #44]	@ 0x2c
    cd04:	e0422000 	sub	r2, r2, r0
    cd08:	e0860180 	add	r0, r6, r0, lsl #3
    cd0c:	e1a02182 	lsl	r2, r2, #3
    cd10:	eb003666 	bl	1a6b0 <memset>
      nslots = new_nslots;
    cd14:	e59d302c 	ldr	r3, [sp, #44]	@ 0x2c
    cd18:	e5873004 	str	r3, [r7, #4]

  {
    size_t size = sv[n].size;
    char *val = sv[n].val;
    /* Elide embedded null bytes since we don't return a size.  */
    int flags = options->flags | QA_ELIDE_NULL_BYTES;
    cd1c:	e5943004 	ldr	r3, [r4, #4]
    size_t size = sv[n].size;
    cd20:	e086b185 	add	fp, r6, r5, lsl #3
    cd24:	e7961185 	ldr	r1, [r6, r5, lsl #3]
    size_t qsize = quotearg_buffer_restyled (val, size, arg, argsize,
                                             options->style, flags,
                                             options->quote_these_too,
    cd28:	e284a008 	add	sl, r4, #8
    char *val = sv[n].val;
    cd2c:	e59b7004 	ldr	r7, [fp, #4]
    int flags = options->flags | QA_ELIDE_NULL_BYTES;
    cd30:	e3838001 	orr	r8, r3, #1
    size_t qsize = quotearg_buffer_restyled (val, size, arg, argsize,
    cd34:	e59d201c 	ldr	r2, [sp, #28]
    cd38:	e58d8004 	str	r8, [sp, #4]
    cd3c:	e594302c 	ldr	r3, [r4, #44]	@ 0x2c
    cd40:	e1a00007 	mov	r0, r7
    cd44:	e58d1024 	str	r1, [sp, #36]	@ 0x24
    cd48:	e58d3010 	str	r3, [sp, #16]
    cd4c:	e5943028 	ldr	r3, [r4, #40]	@ 0x28
    cd50:	e58d300c 	str	r3, [sp, #12]
    cd54:	e5d43000 	ldrb	r3, [r4]
    cd58:	e58da008 	str	sl, [sp, #8]
    cd5c:	e58d3000 	str	r3, [sp]
    cd60:	e1a03009 	mov	r3, r9
    cd64:	ebfffa86 	bl	b784 <quotearg_buffer_restyled>
                                             options->left_quote,
                                             options->right_quote);

    if (size <= qsize)
    cd68:	e59d1024 	ldr	r1, [sp, #36]	@ 0x24
    cd6c:	e1510000 	cmp	r1, r0
    cd70:	8a000019 	bhi	cddc <quotearg_n_options+0x160>
      {
        sv[n].size = size = qsize + 1;
        if (val != slot0)
    cd74:	e30b33e8 	movw	r3, #46056	@ 0xb3e8
        sv[n].size = size = qsize + 1;
    cd78:	e2801001 	add	r1, r0, #1
        if (val != slot0)
    cd7c:	e3403002 	movt	r3, #2
        sv[n].size = size = qsize + 1;
    cd80:	e7861185 	str	r1, [r6, r5, lsl #3]
        if (val != slot0)
    cd84:	e1570003 	cmp	r7, r3
    cd88:	0a000003 	beq	cd9c <quotearg_n_options+0x120>
          free (val);
    cd8c:	e1a00007 	mov	r0, r7
    cd90:	e58d1024 	str	r1, [sp, #36]	@ 0x24
    cd94:	ebfff5af 	bl	a458 <rpl_free>
    cd98:	e59d1024 	ldr	r1, [sp, #36]	@ 0x24
        sv[n].val = val = xcharalloc (size);
    cd9c:	e1a00001 	mov	r0, r1
    cda0:	e58d1024 	str	r1, [sp, #36]	@ 0x24
    cda4:	eb000486 	bl	dfc4 <xcharalloc>
    cda8:	e58b0004 	str	r0, [fp, #4]
        quotearg_buffer_restyled (val, size, arg, argsize, options->style,
    cdac:	e1a03009 	mov	r3, r9
    cdb0:	e98d0500 	stmib	sp, {r8, sl}
        sv[n].val = val = xcharalloc (size);
    cdb4:	e1a07000 	mov	r7, r0
        quotearg_buffer_restyled (val, size, arg, argsize, options->style,
    cdb8:	e594c02c 	ldr	ip, [r4, #44]	@ 0x2c
    cdbc:	e59d201c 	ldr	r2, [sp, #28]
    cdc0:	e59d1024 	ldr	r1, [sp, #36]	@ 0x24
    cdc4:	e58dc010 	str	ip, [sp, #16]
    cdc8:	e594c028 	ldr	ip, [r4, #40]	@ 0x28
    cdcc:	e58dc00c 	str	ip, [sp, #12]
    cdd0:	e5d4c000 	ldrb	ip, [r4]
    cdd4:	e58dc000 	str	ip, [sp]
    cdd8:	ebfffa69 	bl	b784 <quotearg_buffer_restyled>
                                  flags, options->quote_these_too,
                                  options->left_quote,
                                  options->right_quote);
      }

    errno = e;
    cddc:	eb003a8c 	bl	1b814 <__errno>
    cde0:	e59d3020 	ldr	r3, [sp, #32]
    cde4:	e5803000 	str	r3, [r0]
    return val;
  }
}
    cde8:	e1a00007 	mov	r0, r7
    cdec:	e28dd034 	add	sp, sp, #52	@ 0x34
    cdf0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
      slotvec = sv = xpalloc (preallocated ? NULL : sv, &new_nslots,
    cdf4:	e3a03008 	mov	r3, #8
    cdf8:	e28d102c 	add	r1, sp, #44	@ 0x2c
    cdfc:	e58d3000 	str	r3, [sp]
    ce00:	e3a00000 	mov	r0, #0
    ce04:	e3e03102 	mvn	r3, #-2147483648	@ 0x80000000
    ce08:	eb0004ec 	bl	e1c0 <xpalloc>
    ce0c:	e1a06000 	mov	r6, r0
    ce10:	e5870000 	str	r0, [r7]
        *sv = slotvec0;
    ce14:	e89a0003 	ldm	sl, {r0, r1}
    ce18:	e8860003 	stm	r6, {r0, r1}
    ce1c:	eaffffb5 	b	ccf8 <quotearg_n_options+0x7c>
    abort ();
    ce20:	eb002639 	bl	1670c <abort>

0000ce24 <clone_quoting_options>:
{
    ce24:	e92d4070 	push	{r4, r5, r6, lr}
    ce28:	e1a04000 	mov	r4, r0
  int e = errno;
    ce2c:	eb003a78 	bl	1b814 <__errno>
  struct quoting_options *p = xmemdup (o ? o : &default_quoting_options,
    ce30:	e3540000 	cmp	r4, #0
    ce34:	e3a01030 	mov	r1, #48	@ 0x30
    ce38:	e59f3024 	ldr	r3, [pc, #36]	@ ce64 <clone_quoting_options+0x40>
  int e = errno;
    ce3c:	e5905000 	ldr	r5, [r0]
  struct quoting_options *p = xmemdup (o ? o : &default_quoting_options,
    ce40:	11a00004 	movne	r0, r4
    ce44:	01a00003 	moveq	r0, r3
    ce48:	eb000524 	bl	e2e0 <xmemdup>
    ce4c:	e1a04000 	mov	r4, r0
  errno = e;
    ce50:	eb003a6f 	bl	1b814 <__errno>
    ce54:	e1a03000 	mov	r3, r0
}
    ce58:	e1a00004 	mov	r0, r4
  errno = e;
    ce5c:	e5835000 	str	r5, [r3]
}
    ce60:	e8bd8070 	pop	{r4, r5, r6, pc}
    ce64:	0002b4e8 	.word	0x0002b4e8

0000ce68 <get_quoting_style>:
  return (o ? o : &default_quoting_options)->style;
    ce68:	e59f300c 	ldr	r3, [pc, #12]	@ ce7c <get_quoting_style+0x14>
    ce6c:	e3500000 	cmp	r0, #0
    ce70:	11a03000 	movne	r3, r0
}
    ce74:	e5d30000 	ldrb	r0, [r3]
    ce78:	e12fff1e 	bx	lr
    ce7c:	0002b4e8 	.word	0x0002b4e8

0000ce80 <set_quoting_style>:
  (o ? o : &default_quoting_options)->style = s;
    ce80:	e59f300c 	ldr	r3, [pc, #12]	@ ce94 <set_quoting_style+0x14>
    ce84:	e3500000 	cmp	r0, #0
    ce88:	11a03000 	movne	r3, r0
    ce8c:	e5c31000 	strb	r1, [r3]
}
    ce90:	e12fff1e 	bx	lr
    ce94:	0002b4e8 	.word	0x0002b4e8

0000ce98 <set_char_quoting>:
    (o ? o : &default_quoting_options)->quote_these_too + uc / INT_BITS;
    ce98:	e59f3034 	ldr	r3, [pc, #52]	@ ced4 <set_char_quoting+0x3c>
    ce9c:	e3500000 	cmp	r0, #0
    cea0:	11a03000 	movne	r3, r0
{
    cea4:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
    (o ? o : &default_quoting_options)->quote_these_too + uc / INT_BITS;
    cea8:	e1a0e2a1 	lsr	lr, r1, #5
  int shift = uc % INT_BITS;
    ceac:	e201101f 	and	r1, r1, #31
    (o ? o : &default_quoting_options)->quote_these_too + uc / INT_BITS;
    ceb0:	e2833008 	add	r3, r3, #8
  int r = (*p >> shift) & 1;
    ceb4:	e793c10e 	ldr	ip, [r3, lr, lsl #2]
  *p ^= ((i & 1) ^ r) << shift;
    ceb8:	e2022001 	and	r2, r2, #1
  int r = (*p >> shift) & 1;
    cebc:	e1a0013c 	lsr	r0, ip, r1
    cec0:	e2000001 	and	r0, r0, #1
  *p ^= ((i & 1) ^ r) << shift;
    cec4:	e0222000 	eor	r2, r2, r0
    cec8:	e02cc112 	eor	ip, ip, r2, lsl r1
    cecc:	e783c10e 	str	ip, [r3, lr, lsl #2]
}
    ced0:	e49df004 	pop	{pc}		@ (ldr pc, [sp], #4)
    ced4:	0002b4e8 	.word	0x0002b4e8

0000ced8 <set_quoting_flags>:
    o = &default_quoting_options;
    ced8:	e59f3010 	ldr	r3, [pc, #16]	@ cef0 <set_quoting_flags+0x18>
    cedc:	e3500000 	cmp	r0, #0
    cee0:	11a03000 	movne	r3, r0
  r = o->flags;
    cee4:	e5930004 	ldr	r0, [r3, #4]
  o->flags = i;
    cee8:	e5831004 	str	r1, [r3, #4]
}
    ceec:	e12fff1e 	bx	lr
    cef0:	0002b4e8 	.word	0x0002b4e8

0000cef4 <set_custom_quoting>:
    o = &default_quoting_options;
    cef4:	e59f302c 	ldr	r3, [pc, #44]	@ cf28 <set_custom_quoting+0x34>
    cef8:	e3500000 	cmp	r0, #0
    cefc:	11a03000 	movne	r3, r0
  if (!left_quote || !right_quote)
    cf00:	e3520000 	cmp	r2, #0
    cf04:	13510000 	cmpne	r1, #0
  o->style = custom_quoting_style;
    cf08:	e3a0c00a 	mov	ip, #10
    cf0c:	e5c3c000 	strb	ip, [r3]
  if (!left_quote || !right_quote)
    cf10:	0a000002 	beq	cf20 <set_custom_quoting+0x2c>
  o->left_quote = left_quote;
    cf14:	e5831028 	str	r1, [r3, #40]	@ 0x28
  o->right_quote = right_quote;
    cf18:	e583202c 	str	r2, [r3, #44]	@ 0x2c
    cf1c:	e12fff1e 	bx	lr
{
    cf20:	e92d4010 	push	{r4, lr}
    abort ();
    cf24:	eb0025f8 	bl	1670c <abort>
    cf28:	0002b4e8 	.word	0x0002b4e8

0000cf2c <quotearg_buffer>:
{
    cf2c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    cf30:	e24dd018 	sub	sp, sp, #24
    cf34:	e59d4030 	ldr	r4, [sp, #48]	@ 0x30
    cf38:	e1a08003 	mov	r8, r3
    cf3c:	e1a05000 	mov	r5, r0
    cf40:	e1a06001 	mov	r6, r1
  struct quoting_options const *p = o ? o : &default_quoting_options;
    cf44:	e59f3068 	ldr	r3, [pc, #104]	@ cfb4 <quotearg_buffer+0x88>
{
    cf48:	e1a07002 	mov	r7, r2
  struct quoting_options const *p = o ? o : &default_quoting_options;
    cf4c:	e3540000 	cmp	r4, #0
    cf50:	01a04003 	moveq	r4, r3
  int e = errno;
    cf54:	eb003a2e 	bl	1b814 <__errno>
  size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,
    cf58:	e594c02c 	ldr	ip, [r4, #44]	@ 0x2c
    cf5c:	e1a03008 	mov	r3, r8
  int e = errno;
    cf60:	e5908000 	ldr	r8, [r0]
  size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,
    cf64:	e1a02007 	mov	r2, r7
    cf68:	e1a01006 	mov	r1, r6
    cf6c:	e1a00005 	mov	r0, r5
    cf70:	e58dc010 	str	ip, [sp, #16]
    cf74:	e594c028 	ldr	ip, [r4, #40]	@ 0x28
    cf78:	e58dc00c 	str	ip, [sp, #12]
                                       p->style, p->flags, p->quote_these_too,
    cf7c:	e284c008 	add	ip, r4, #8
  size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,
    cf80:	e58dc008 	str	ip, [sp, #8]
    cf84:	e594c004 	ldr	ip, [r4, #4]
    cf88:	e58dc004 	str	ip, [sp, #4]
    cf8c:	e5d4c000 	ldrb	ip, [r4]
    cf90:	e58dc000 	str	ip, [sp]
    cf94:	ebfff9fa 	bl	b784 <quotearg_buffer_restyled>
    cf98:	e1a04000 	mov	r4, r0
  errno = e;
    cf9c:	eb003a1c 	bl	1b814 <__errno>
    cfa0:	e1a03000 	mov	r3, r0
}
    cfa4:	e1a00004 	mov	r0, r4
  errno = e;
    cfa8:	e5838000 	str	r8, [r3]
}
    cfac:	e28dd018 	add	sp, sp, #24
    cfb0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    cfb4:	0002b4e8 	.word	0x0002b4e8

0000cfb8 <quotearg_alloc_mem>:
{
    cfb8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  struct quoting_options const *p = o ? o : &default_quoting_options;
    cfbc:	e3530000 	cmp	r3, #0
    cfc0:	e59f40b8 	ldr	r4, [pc, #184]	@ d080 <quotearg_alloc_mem+0xc8>
{
    cfc4:	e24dd024 	sub	sp, sp, #36	@ 0x24
  struct quoting_options const *p = o ? o : &default_quoting_options;
    cfc8:	11a04003 	movne	r4, r3
{
    cfcc:	e1a05002 	mov	r5, r2
    cfd0:	e1a08001 	mov	r8, r1
    cfd4:	e1a07000 	mov	r7, r0
  int e = errno;
    cfd8:	eb003a0d 	bl	1b814 <__errno>
  size_t bufsize = quotearg_buffer_restyled (0, 0, arg, argsize, p->style,
    cfdc:	e594302c 	ldr	r3, [r4, #44]	@ 0x2c
                                             flags, p->quote_these_too,
    cfe0:	e284a008 	add	sl, r4, #8
  int flags = p->flags | (size ? 0 : QA_ELIDE_NULL_BYTES);
    cfe4:	e5946004 	ldr	r6, [r4, #4]
  size_t bufsize = quotearg_buffer_restyled (0, 0, arg, argsize, p->style,
    cfe8:	e3a01000 	mov	r1, #0
  int e = errno;
    cfec:	e590b000 	ldr	fp, [r0]
  size_t bufsize = quotearg_buffer_restyled (0, 0, arg, argsize, p->style,
    cff0:	e1a02007 	mov	r2, r7
    cff4:	e58d3010 	str	r3, [sp, #16]
    cff8:	e1a00001 	mov	r0, r1
    cffc:	e5943028 	ldr	r3, [r4, #40]	@ 0x28
  int flags = p->flags | (size ? 0 : QA_ELIDE_NULL_BYTES);
    d000:	e3550000 	cmp	r5, #0
    d004:	03866001 	orreq	r6, r6, #1
  size_t bufsize = quotearg_buffer_restyled (0, 0, arg, argsize, p->style,
    d008:	e58d6004 	str	r6, [sp, #4]
    d00c:	e58da008 	str	sl, [sp, #8]
    d010:	e58d300c 	str	r3, [sp, #12]
    d014:	e5d43000 	ldrb	r3, [r4]
    d018:	e58d3000 	str	r3, [sp]
    d01c:	e1a03008 	mov	r3, r8
    d020:	ebfff9d7 	bl	b784 <quotearg_buffer_restyled>
    d024:	e2801001 	add	r1, r0, #1
    d028:	e1a09000 	mov	r9, r0
  char *buf = xcharalloc (bufsize);
    d02c:	e1a00001 	mov	r0, r1
    d030:	e58d101c 	str	r1, [sp, #28]
    d034:	eb0003e2 	bl	dfc4 <xcharalloc>
  quotearg_buffer_restyled (buf, bufsize, arg, argsize, p->style, flags,
    d038:	e594c02c 	ldr	ip, [r4, #44]	@ 0x2c
    d03c:	e1a02007 	mov	r2, r7
    d040:	e59d101c 	ldr	r1, [sp, #28]
    d044:	e1a03008 	mov	r3, r8
  char *buf = xcharalloc (bufsize);
    d048:	e1a07000 	mov	r7, r0
  quotearg_buffer_restyled (buf, bufsize, arg, argsize, p->style, flags,
    d04c:	e58dc010 	str	ip, [sp, #16]
    d050:	e594c028 	ldr	ip, [r4, #40]	@ 0x28
    d054:	e98d1440 	stmib	sp, {r6, sl, ip}
    d058:	e5d4c000 	ldrb	ip, [r4]
    d05c:	e58dc000 	str	ip, [sp]
    d060:	ebfff9c7 	bl	b784 <quotearg_buffer_restyled>
  errno = e;
    d064:	eb0039ea 	bl	1b814 <__errno>
  if (size)
    d068:	e3550000 	cmp	r5, #0
  errno = e;
    d06c:	e580b000 	str	fp, [r0]
}
    d070:	e1a00007 	mov	r0, r7
    *size = bufsize - 1;
    d074:	15859000 	strne	r9, [r5]
}
    d078:	e28dd024 	add	sp, sp, #36	@ 0x24
    d07c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d080:	0002b4e8 	.word	0x0002b4e8

0000d084 <quotearg_alloc>:
{
    d084:	e1a03002 	mov	r3, r2
  return quotearg_alloc_mem (arg, argsize, NULL, o);
    d088:	e3a02000 	mov	r2, #0
    d08c:	eaffffc9 	b	cfb8 <quotearg_alloc_mem>

0000d090 <quotearg_free>:
{
    d090:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  struct slotvec *sv = slotvec;
    d094:	e30b5024 	movw	r5, #45092	@ 0xb024
    d098:	e3405002 	movt	r5, #2
  for (i = 1; i < nslots; i++)
    d09c:	e5953004 	ldr	r3, [r5, #4]
  struct slotvec *sv = slotvec;
    d0a0:	e5957000 	ldr	r7, [r5]
  for (i = 1; i < nslots; i++)
    d0a4:	e3530001 	cmp	r3, #1
    d0a8:	da000007 	ble	d0cc <quotearg_free+0x3c>
    d0ac:	e3a04001 	mov	r4, #1
    d0b0:	e2876004 	add	r6, r7, #4
    free (sv[i].val);
    d0b4:	e7960184 	ldr	r0, [r6, r4, lsl #3]
  for (i = 1; i < nslots; i++)
    d0b8:	e2844001 	add	r4, r4, #1
    free (sv[i].val);
    d0bc:	ebfff4e5 	bl	a458 <rpl_free>
  for (i = 1; i < nslots; i++)
    d0c0:	e5953004 	ldr	r3, [r5, #4]
    d0c4:	e1530004 	cmp	r3, r4
    d0c8:	cafffff9 	bgt	d0b4 <quotearg_free+0x24>
  if (sv[0].val != slot0)
    d0cc:	e5970004 	ldr	r0, [r7, #4]
    d0d0:	e30b43e8 	movw	r4, #46056	@ 0xb3e8
    d0d4:	e3404002 	movt	r4, #2
    d0d8:	e1500004 	cmp	r0, r4
    d0dc:	0a000003 	beq	d0f0 <quotearg_free+0x60>
      free (sv[0].val);
    d0e0:	ebfff4dc 	bl	a458 <rpl_free>
      slotvec0.size = sizeof slot0;
    d0e4:	e3a03c01 	mov	r3, #256	@ 0x100
      slotvec0.val = slot0;
    d0e8:	e585400c 	str	r4, [r5, #12]
      slotvec0.size = sizeof slot0;
    d0ec:	e5853008 	str	r3, [r5, #8]
  if (sv != &slotvec0)
    d0f0:	e59f401c 	ldr	r4, [pc, #28]	@ d114 <quotearg_free+0x84>
    d0f4:	e1570004 	cmp	r7, r4
    d0f8:	0a000002 	beq	d108 <quotearg_free+0x78>
      free (sv);
    d0fc:	e1a00007 	mov	r0, r7
    d100:	ebfff4d4 	bl	a458 <rpl_free>
      slotvec = &slotvec0;
    d104:	e5854000 	str	r4, [r5]
  nslots = 1;
    d108:	e3a03001 	mov	r3, #1
    d10c:	e5853004 	str	r3, [r5, #4]
}
    d110:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    d114:	0002b02c 	.word	0x0002b02c

0000d118 <quotearg_n>:

char *
quotearg_n (int n, char const *arg)
{
  return quotearg_n_options (n, arg, SIZE_MAX, &default_quoting_options);
    d118:	e59f3004 	ldr	r3, [pc, #4]	@ d124 <quotearg_n+0xc>
    d11c:	e3e02000 	mvn	r2, #0
    d120:	eafffed5 	b	cc7c <quotearg_n_options>
    d124:	0002b4e8 	.word	0x0002b4e8

0000d128 <quotearg_n_mem>:
}

char *
quotearg_n_mem (int n, char const *arg, size_t argsize)
{
  return quotearg_n_options (n, arg, argsize, &default_quoting_options);
    d128:	e59f3000 	ldr	r3, [pc]	@ d130 <quotearg_n_mem+0x8>
    d12c:	eafffed2 	b	cc7c <quotearg_n_options>
    d130:	0002b4e8 	.word	0x0002b4e8

0000d134 <quotearg>:
}

char *
quotearg (char const *arg)
{
    d134:	e1a01000 	mov	r1, r0
  return quotearg_n_options (n, arg, SIZE_MAX, &default_quoting_options);
    d138:	e59f3008 	ldr	r3, [pc, #8]	@ d148 <quotearg+0x14>
    d13c:	e3e02000 	mvn	r2, #0
    d140:	e3a00000 	mov	r0, #0
    d144:	eafffecc 	b	cc7c <quotearg_n_options>
    d148:	0002b4e8 	.word	0x0002b4e8

0000d14c <quotearg_mem>:
  return quotearg_n (0, arg);
}

char *
quotearg_mem (char const *arg, size_t argsize)
{
    d14c:	e1a02001 	mov	r2, r1
  return quotearg_n_options (n, arg, argsize, &default_quoting_options);
    d150:	e59f3008 	ldr	r3, [pc, #8]	@ d160 <quotearg_mem+0x14>
    d154:	e1a01000 	mov	r1, r0
    d158:	e3a00000 	mov	r0, #0
    d15c:	eafffec6 	b	cc7c <quotearg_n_options>
    d160:	0002b4e8 	.word	0x0002b4e8

0000d164 <quotearg_n_style>:
  return quotearg_n_mem (0, arg, argsize);
}

char *
quotearg_n_style (int n, enum quoting_style s, char const *arg)
{
    d164:	e92d4070 	push	{r4, r5, r6, lr}
    d168:	e1a06002 	mov	r6, r2
    d16c:	e24dd060 	sub	sp, sp, #96	@ 0x60
  struct quoting_options o = { literal_quoting_style, 0, { 0 }, NULL, NULL };
    d170:	e3a02030 	mov	r2, #48	@ 0x30
{
    d174:	e1a04001 	mov	r4, r1
    d178:	e1a05000 	mov	r5, r0
  struct quoting_options o = { literal_quoting_style, 0, { 0 }, NULL, NULL };
    d17c:	e3a01000 	mov	r1, #0
    d180:	e08d0002 	add	r0, sp, r2
    d184:	eb003549 	bl	1a6b0 <memset>
  if (style == custom_quoting_style)
    d188:	e354000a 	cmp	r4, #10
    d18c:	0a00000f 	beq	d1d0 <quotearg_n_style+0x6c>
  return o;
    d190:	e28dc030 	add	ip, sp, #48	@ 0x30
    d194:	e5cd4030 	strb	r4, [sp, #48]	@ 0x30
    d198:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
    d19c:	e1a0e00d 	mov	lr, sp
    d1a0:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
    d1a4:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
    d1a8:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
    d1ac:	e89c000f 	ldm	ip, {r0, r1, r2, r3}
    d1b0:	e88e000f 	stm	lr, {r0, r1, r2, r3}
  struct quoting_options const o = quoting_options_from_style (s);
  return quotearg_n_options (n, arg, SIZE_MAX, &o);
    d1b4:	e1a0300d 	mov	r3, sp
    d1b8:	e3e02000 	mvn	r2, #0
    d1bc:	e1a01006 	mov	r1, r6
    d1c0:	e1a00005 	mov	r0, r5
    d1c4:	ebfffeac 	bl	cc7c <quotearg_n_options>
}
    d1c8:	e28dd060 	add	sp, sp, #96	@ 0x60
    d1cc:	e8bd8070 	pop	{r4, r5, r6, pc}
    abort ();
    d1d0:	eb00254d 	bl	1670c <abort>

0000d1d4 <quotearg_n_style_mem>:

char *
quotearg_n_style_mem (int n, enum quoting_style s,
                      char const *arg, size_t argsize)
{
    d1d4:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    d1d8:	e1a06002 	mov	r6, r2
    d1dc:	e24dd064 	sub	sp, sp, #100	@ 0x64
  struct quoting_options o = { literal_quoting_style, 0, { 0 }, NULL, NULL };
    d1e0:	e3a02030 	mov	r2, #48	@ 0x30
{
    d1e4:	e1a04001 	mov	r4, r1
    d1e8:	e1a05000 	mov	r5, r0
  struct quoting_options o = { literal_quoting_style, 0, { 0 }, NULL, NULL };
    d1ec:	e3a01000 	mov	r1, #0
    d1f0:	e08d0002 	add	r0, sp, r2
{
    d1f4:	e1a07003 	mov	r7, r3
  struct quoting_options o = { literal_quoting_style, 0, { 0 }, NULL, NULL };
    d1f8:	eb00352c 	bl	1a6b0 <memset>
  if (style == custom_quoting_style)
    d1fc:	e354000a 	cmp	r4, #10
    d200:	0a00000f 	beq	d244 <quotearg_n_style_mem+0x70>
  return o;
    d204:	e28dc030 	add	ip, sp, #48	@ 0x30
    d208:	e5cd4030 	strb	r4, [sp, #48]	@ 0x30
    d20c:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
    d210:	e1a0e00d 	mov	lr, sp
    d214:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
    d218:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
    d21c:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
    d220:	e89c000f 	ldm	ip, {r0, r1, r2, r3}
    d224:	e88e000f 	stm	lr, {r0, r1, r2, r3}
  struct quoting_options const o = quoting_options_from_style (s);
  return quotearg_n_options (n, arg, argsize, &o);
    d228:	e1a0300d 	mov	r3, sp
    d22c:	e1a02007 	mov	r2, r7
    d230:	e1a01006 	mov	r1, r6
    d234:	e1a00005 	mov	r0, r5
    d238:	ebfffe8f 	bl	cc7c <quotearg_n_options>
}
    d23c:	e28dd064 	add	sp, sp, #100	@ 0x64
    d240:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    abort ();
    d244:	eb002530 	bl	1670c <abort>

0000d248 <quotearg_style>:

char *
quotearg_style (enum quoting_style s, char const *arg)
{
    d248:	e92d4030 	push	{r4, r5, lr}
  struct quoting_options o = { literal_quoting_style, 0, { 0 }, NULL, NULL };
    d24c:	e3a02030 	mov	r2, #48	@ 0x30
{
    d250:	e24dd064 	sub	sp, sp, #100	@ 0x64
    d254:	e1a04000 	mov	r4, r0
    d258:	e1a05001 	mov	r5, r1
  struct quoting_options o = { literal_quoting_style, 0, { 0 }, NULL, NULL };
    d25c:	e08d0002 	add	r0, sp, r2
    d260:	e3a01000 	mov	r1, #0
    d264:	eb003511 	bl	1a6b0 <memset>
  if (style == custom_quoting_style)
    d268:	e354000a 	cmp	r4, #10
    d26c:	0a00000f 	beq	d2b0 <quotearg_style+0x68>
  return o;
    d270:	e28dc030 	add	ip, sp, #48	@ 0x30
    d274:	e5cd4030 	strb	r4, [sp, #48]	@ 0x30
    d278:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
    d27c:	e1a0e00d 	mov	lr, sp
    d280:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
    d284:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
    d288:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
    d28c:	e89c000f 	ldm	ip, {r0, r1, r2, r3}
    d290:	e88e000f 	stm	lr, {r0, r1, r2, r3}
  return quotearg_n_options (n, arg, SIZE_MAX, &o);
    d294:	e1a0300d 	mov	r3, sp
    d298:	e3e02000 	mvn	r2, #0
    d29c:	e1a01005 	mov	r1, r5
    d2a0:	e3a00000 	mov	r0, #0
    d2a4:	ebfffe74 	bl	cc7c <quotearg_n_options>
  return quotearg_n_style (0, s, arg);
}
    d2a8:	e28dd064 	add	sp, sp, #100	@ 0x64
    d2ac:	e8bd8030 	pop	{r4, r5, pc}
    abort ();
    d2b0:	eb002515 	bl	1670c <abort>

0000d2b4 <quotearg_style_mem>:

char *
quotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)
{
    d2b4:	e92d4070 	push	{r4, r5, r6, lr}
    d2b8:	e1a06002 	mov	r6, r2
    d2bc:	e24dd060 	sub	sp, sp, #96	@ 0x60
  struct quoting_options o = { literal_quoting_style, 0, { 0 }, NULL, NULL };
    d2c0:	e3a02030 	mov	r2, #48	@ 0x30
{
    d2c4:	e1a04000 	mov	r4, r0
    d2c8:	e1a05001 	mov	r5, r1
  struct quoting_options o = { literal_quoting_style, 0, { 0 }, NULL, NULL };
    d2cc:	e08d0002 	add	r0, sp, r2
    d2d0:	e3a01000 	mov	r1, #0
    d2d4:	eb0034f5 	bl	1a6b0 <memset>
  if (style == custom_quoting_style)
    d2d8:	e354000a 	cmp	r4, #10
    d2dc:	0a00000f 	beq	d320 <quotearg_style_mem+0x6c>
  return o;
    d2e0:	e28dc030 	add	ip, sp, #48	@ 0x30
    d2e4:	e5cd4030 	strb	r4, [sp, #48]	@ 0x30
    d2e8:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
    d2ec:	e1a0e00d 	mov	lr, sp
    d2f0:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
    d2f4:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
    d2f8:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
    d2fc:	e89c000f 	ldm	ip, {r0, r1, r2, r3}
    d300:	e88e000f 	stm	lr, {r0, r1, r2, r3}
  return quotearg_n_options (n, arg, argsize, &o);
    d304:	e1a0300d 	mov	r3, sp
    d308:	e1a02006 	mov	r2, r6
    d30c:	e1a01005 	mov	r1, r5
    d310:	e3a00000 	mov	r0, #0
    d314:	ebfffe58 	bl	cc7c <quotearg_n_options>
  return quotearg_n_style_mem (0, s, arg, argsize);
}
    d318:	e28dd060 	add	sp, sp, #96	@ 0x60
    d31c:	e8bd8070 	pop	{r4, r5, r6, pc}
    abort ();
    d320:	eb0024f9 	bl	1670c <abort>

0000d324 <quotearg_char_mem>:

char *
quotearg_char_mem (char const *arg, size_t argsize, char ch)
{
    d324:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    (o ? o : &default_quoting_options)->quote_these_too + uc / INT_BITS;
    d328:	e1a062a2 	lsr	r6, r2, #5
  struct quoting_options options;
  options = default_quoting_options;
    d32c:	e59fe05c 	ldr	lr, [pc, #92]	@ d390 <quotearg_char_mem+0x6c>
  int shift = uc % INT_BITS;
    d330:	e202401f 	and	r4, r2, #31
{
    d334:	e1a07000 	mov	r7, r0
    d338:	e1a08001 	mov	r8, r1
    d33c:	e24dd030 	sub	sp, sp, #48	@ 0x30
  options = default_quoting_options;
    d340:	e1a0c00d 	mov	ip, sp
  unsigned int *p =
    d344:	e28d5008 	add	r5, sp, #8
  options = default_quoting_options;
    d348:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
    d34c:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
    d350:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
    d354:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
    d358:	e89e000f 	ldm	lr, {r0, r1, r2, r3}
    d35c:	e88c000f 	stm	ip, {r0, r1, r2, r3}
  set_char_quoting (&options, ch, 1);
  return quotearg_n_options (0, arg, argsize, &options);
    d360:	e1a02008 	mov	r2, r8
  int r = (*p >> shift) & 1;
    d364:	e795c106 	ldr	ip, [r5, r6, lsl #2]
  return quotearg_n_options (0, arg, argsize, &options);
    d368:	e1a01007 	mov	r1, r7
    d36c:	e1a0300d 	mov	r3, sp
    d370:	e3a00000 	mov	r0, #0
  *p ^= ((i & 1) ^ r) << shift;
    d374:	e1e0e43c 	mvn	lr, ip, lsr r4
    d378:	e20ee001 	and	lr, lr, #1
    d37c:	e02cc41e 	eor	ip, ip, lr, lsl r4
    d380:	e785c106 	str	ip, [r5, r6, lsl #2]
  return quotearg_n_options (0, arg, argsize, &options);
    d384:	ebfffe3c 	bl	cc7c <quotearg_n_options>
}
    d388:	e28dd030 	add	sp, sp, #48	@ 0x30
    d38c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    d390:	0002b4e8 	.word	0x0002b4e8

0000d394 <quotearg_char>:

char *
quotearg_char (char const *arg, char ch)
{
    d394:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    (o ? o : &default_quoting_options)->quote_these_too + uc / INT_BITS;
    d398:	e1a062a1 	lsr	r6, r1, #5
  options = default_quoting_options;
    d39c:	e59fe058 	ldr	lr, [pc, #88]	@ d3fc <quotearg_char+0x68>
  int shift = uc % INT_BITS;
    d3a0:	e201401f 	and	r4, r1, #31
{
    d3a4:	e1a07000 	mov	r7, r0
    d3a8:	e24dd034 	sub	sp, sp, #52	@ 0x34
  options = default_quoting_options;
    d3ac:	e1a0c00d 	mov	ip, sp
  unsigned int *p =
    d3b0:	e28d5008 	add	r5, sp, #8
  options = default_quoting_options;
    d3b4:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
    d3b8:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
    d3bc:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
    d3c0:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
    d3c4:	e89e000f 	ldm	lr, {r0, r1, r2, r3}
    d3c8:	e88c000f 	stm	ip, {r0, r1, r2, r3}
  return quotearg_n_options (0, arg, argsize, &options);
    d3cc:	e1a01007 	mov	r1, r7
  int r = (*p >> shift) & 1;
    d3d0:	e795c106 	ldr	ip, [r5, r6, lsl #2]
  return quotearg_n_options (0, arg, argsize, &options);
    d3d4:	e1a0300d 	mov	r3, sp
    d3d8:	e3e02000 	mvn	r2, #0
    d3dc:	e3a00000 	mov	r0, #0
  *p ^= ((i & 1) ^ r) << shift;
    d3e0:	e1e0e43c 	mvn	lr, ip, lsr r4
    d3e4:	e20ee001 	and	lr, lr, #1
    d3e8:	e02cc41e 	eor	ip, ip, lr, lsl r4
    d3ec:	e785c106 	str	ip, [r5, r6, lsl #2]
  return quotearg_n_options (0, arg, argsize, &options);
    d3f0:	ebfffe21 	bl	cc7c <quotearg_n_options>
  return quotearg_char_mem (arg, SIZE_MAX, ch);
}
    d3f4:	e28dd034 	add	sp, sp, #52	@ 0x34
    d3f8:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    d3fc:	0002b4e8 	.word	0x0002b4e8

0000d400 <quotearg_colon>:

char *
quotearg_colon (char const *arg)
{
    d400:	e92d4010 	push	{r4, lr}
    d404:	e1a04000 	mov	r4, r0
  options = default_quoting_options;
    d408:	e59fe04c 	ldr	lr, [pc, #76]	@ d45c <quotearg_colon+0x5c>
{
    d40c:	e24dd030 	sub	sp, sp, #48	@ 0x30
  options = default_quoting_options;
    d410:	e1a0c00d 	mov	ip, sp
    d414:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
    d418:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
  int r = (*p >> shift) & 1;
    d41c:	e1a02003 	mov	r2, r3
  *p ^= ((i & 1) ^ r) << shift;
    d420:	e1e03003 	mvn	r3, r3
    d424:	e2033301 	and	r3, r3, #67108864	@ 0x4000000
    d428:	e0233002 	eor	r3, r3, r2
    d42c:	e58d300c 	str	r3, [sp, #12]
  options = default_quoting_options;
    d430:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
    d434:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
    d438:	e89e000f 	ldm	lr, {r0, r1, r2, r3}
    d43c:	e88c000f 	stm	ip, {r0, r1, r2, r3}
  return quotearg_n_options (0, arg, argsize, &options);
    d440:	e1a0300d 	mov	r3, sp
    d444:	e3e02000 	mvn	r2, #0
    d448:	e1a01004 	mov	r1, r4
    d44c:	e3a00000 	mov	r0, #0
    d450:	ebfffe09 	bl	cc7c <quotearg_n_options>
  return quotearg_char (arg, ':');
}
    d454:	e28dd030 	add	sp, sp, #48	@ 0x30
    d458:	e8bd8010 	pop	{r4, pc}
    d45c:	0002b4e8 	.word	0x0002b4e8

0000d460 <quotearg_colon_mem>:

char *
quotearg_colon_mem (char const *arg, size_t argsize)
{
    d460:	e92d4030 	push	{r4, r5, lr}
    d464:	e1a04000 	mov	r4, r0
  options = default_quoting_options;
    d468:	e59fe050 	ldr	lr, [pc, #80]	@ d4c0 <quotearg_colon_mem+0x60>
{
    d46c:	e1a05001 	mov	r5, r1
    d470:	e24dd034 	sub	sp, sp, #52	@ 0x34
  options = default_quoting_options;
    d474:	e1a0c00d 	mov	ip, sp
    d478:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
    d47c:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
  int r = (*p >> shift) & 1;
    d480:	e1a02003 	mov	r2, r3
  *p ^= ((i & 1) ^ r) << shift;
    d484:	e1e03003 	mvn	r3, r3
    d488:	e2033301 	and	r3, r3, #67108864	@ 0x4000000
    d48c:	e0233002 	eor	r3, r3, r2
    d490:	e58d300c 	str	r3, [sp, #12]
  options = default_quoting_options;
    d494:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
    d498:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
    d49c:	e89e000f 	ldm	lr, {r0, r1, r2, r3}
    d4a0:	e88c000f 	stm	ip, {r0, r1, r2, r3}
  return quotearg_n_options (0, arg, argsize, &options);
    d4a4:	e1a0300d 	mov	r3, sp
    d4a8:	e1a02005 	mov	r2, r5
    d4ac:	e1a01004 	mov	r1, r4
    d4b0:	e3a00000 	mov	r0, #0
    d4b4:	ebfffdf0 	bl	cc7c <quotearg_n_options>
  return quotearg_char_mem (arg, argsize, ':');
}
    d4b8:	e28dd034 	add	sp, sp, #52	@ 0x34
    d4bc:	e8bd8030 	pop	{r4, r5, pc}
    d4c0:	0002b4e8 	.word	0x0002b4e8

0000d4c4 <quotearg_n_style_colon>:

char *
quotearg_n_style_colon (int n, enum quoting_style s, char const *arg)
{
    d4c4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    d4c8:	e24dd060 	sub	sp, sp, #96	@ 0x60
    d4cc:	e1a04001 	mov	r4, r1
    d4d0:	e1a07002 	mov	r7, r2
    d4d4:	e1a06000 	mov	r6, r0
  struct quoting_options o = { literal_quoting_style, 0, { 0 }, NULL, NULL };
    d4d8:	e3a02030 	mov	r2, #48	@ 0x30
    d4dc:	e3a01000 	mov	r1, #0
    d4e0:	e1a0000d 	mov	r0, sp
    d4e4:	eb003471 	bl	1a6b0 <memset>
  if (style == custom_quoting_style)
    d4e8:	e354000a 	cmp	r4, #10
    d4ec:	0a000019 	beq	d558 <quotearg_n_style_colon+0x94>
  return o;
    d4f0:	e1a0c00d 	mov	ip, sp
    d4f4:	e5cd4000 	strb	r4, [sp]
    d4f8:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
    d4fc:	e28de030 	add	lr, sp, #48	@ 0x30
  struct quoting_options options;
  options = quoting_options_from_style (s);
    d500:	e1a0500e 	mov	r5, lr
    d504:	e1a0400d 	mov	r4, sp
  *p ^= ((i & 1) ^ r) << shift;
    d508:	e3a08301 	mov	r8, #67108864	@ 0x4000000
  return o;
    d50c:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
    d510:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
    d514:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
    d518:	e89c000f 	ldm	ip, {r0, r1, r2, r3}
    d51c:	e88e000f 	stm	lr, {r0, r1, r2, r3}
  options = quoting_options_from_style (s);
    d520:	e8b5000f 	ldm	r5!, {r0, r1, r2, r3}
    d524:	e8a4000f 	stmia	r4!, {r0, r1, r2, r3}
    d528:	e8b5000f 	ldm	r5!, {r0, r1, r2, r3}
    d52c:	e8a4000f 	stmia	r4!, {r0, r1, r2, r3}
    d530:	e89e000f 	ldm	lr, {r0, r1, r2, r3}
    d534:	e88c000f 	stm	ip, {r0, r1, r2, r3}
  set_char_quoting (&options, ':', 1);
  return quotearg_n_options (n, arg, SIZE_MAX, &options);
    d538:	e1a0300d 	mov	r3, sp
    d53c:	e3e02000 	mvn	r2, #0
    d540:	e1a01007 	mov	r1, r7
    d544:	e1a00006 	mov	r0, r6
  *p ^= ((i & 1) ^ r) << shift;
    d548:	e58d800c 	str	r8, [sp, #12]
  return quotearg_n_options (n, arg, SIZE_MAX, &options);
    d54c:	ebfffdca 	bl	cc7c <quotearg_n_options>
}
    d550:	e28dd060 	add	sp, sp, #96	@ 0x60
    d554:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    abort ();
    d558:	eb00246b 	bl	1670c <abort>

0000d55c <quotearg_n_custom>:

char *
quotearg_n_custom (int n, char const *left_quote,
                   char const *right_quote, char const *arg)
{
    d55c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  if (!left_quote || !right_quote)
    d560:	e3520000 	cmp	r2, #0
    d564:	13510000 	cmpne	r1, #0
char *
quotearg_n_custom_mem (int n, char const *left_quote,
                       char const *right_quote,
                       char const *arg, size_t argsize)
{
  struct quoting_options o = default_quoting_options;
    d568:	e59fe060 	ldr	lr, [pc, #96]	@ d5d0 <quotearg_n_custom+0x74>
{
    d56c:	e1a06000 	mov	r6, r0
    d570:	e1a07003 	mov	r7, r3
  if (!left_quote || !right_quote)
    d574:	e1a05001 	mov	r5, r1
    d578:	e1a04002 	mov	r4, r2
{
    d57c:	e24dd030 	sub	sp, sp, #48	@ 0x30
  struct quoting_options o = default_quoting_options;
    d580:	e1a0c00d 	mov	ip, sp
  o->style = custom_quoting_style;
    d584:	e3a0800a 	mov	r8, #10
  struct quoting_options o = default_quoting_options;
    d588:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
    d58c:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
  o->style = custom_quoting_style;
    d590:	e5cd8000 	strb	r8, [sp]
  struct quoting_options o = default_quoting_options;
    d594:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
    d598:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
    d59c:	e89e000f 	ldm	lr, {r0, r1, r2, r3}
    d5a0:	e88c000f 	stm	ip, {r0, r1, r2, r3}
  if (!left_quote || !right_quote)
    d5a4:	0a000008 	beq	d5cc <quotearg_n_custom+0x70>
  set_custom_quoting (&o, left_quote, right_quote);
  return quotearg_n_options (n, arg, argsize, &o);
    d5a8:	e1a0300d 	mov	r3, sp
    d5ac:	e1a01007 	mov	r1, r7
    d5b0:	e1a00006 	mov	r0, r6
    d5b4:	e3e02000 	mvn	r2, #0
  o->left_quote = left_quote;
    d5b8:	e58d5028 	str	r5, [sp, #40]	@ 0x28
  o->right_quote = right_quote;
    d5bc:	e58d402c 	str	r4, [sp, #44]	@ 0x2c
  return quotearg_n_options (n, arg, argsize, &o);
    d5c0:	ebfffdad 	bl	cc7c <quotearg_n_options>
}
    d5c4:	e28dd030 	add	sp, sp, #48	@ 0x30
    d5c8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    abort ();
    d5cc:	eb00244e 	bl	1670c <abort>
    d5d0:	0002b4e8 	.word	0x0002b4e8

0000d5d4 <quotearg_n_custom_mem>:
{
    d5d4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  if (!left_quote || !right_quote)
    d5d8:	e3520000 	cmp	r2, #0
    d5dc:	13510000 	cmpne	r1, #0
  struct quoting_options o = default_quoting_options;
    d5e0:	e59fe060 	ldr	lr, [pc, #96]	@ d648 <quotearg_n_custom_mem+0x74>
{
    d5e4:	e1a06000 	mov	r6, r0
    d5e8:	e1a07003 	mov	r7, r3
  if (!left_quote || !right_quote)
    d5ec:	e1a05001 	mov	r5, r1
    d5f0:	e1a04002 	mov	r4, r2
{
    d5f4:	e24dd030 	sub	sp, sp, #48	@ 0x30
  struct quoting_options o = default_quoting_options;
    d5f8:	e1a0c00d 	mov	ip, sp
  o->style = custom_quoting_style;
    d5fc:	e3a0800a 	mov	r8, #10
  struct quoting_options o = default_quoting_options;
    d600:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
    d604:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
  o->style = custom_quoting_style;
    d608:	e5cd8000 	strb	r8, [sp]
  struct quoting_options o = default_quoting_options;
    d60c:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
    d610:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
    d614:	e89e000f 	ldm	lr, {r0, r1, r2, r3}
    d618:	e88c000f 	stm	ip, {r0, r1, r2, r3}
  if (!left_quote || !right_quote)
    d61c:	0a000008 	beq	d644 <quotearg_n_custom_mem+0x70>
  return quotearg_n_options (n, arg, argsize, &o);
    d620:	e59d2048 	ldr	r2, [sp, #72]	@ 0x48
    d624:	e1a0300d 	mov	r3, sp
    d628:	e1a01007 	mov	r1, r7
    d62c:	e1a00006 	mov	r0, r6
  o->left_quote = left_quote;
    d630:	e58d5028 	str	r5, [sp, #40]	@ 0x28
  o->right_quote = right_quote;
    d634:	e58d402c 	str	r4, [sp, #44]	@ 0x2c
  return quotearg_n_options (n, arg, argsize, &o);
    d638:	ebfffd8f 	bl	cc7c <quotearg_n_options>
}
    d63c:	e28dd030 	add	sp, sp, #48	@ 0x30
    d640:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    abort ();
    d644:	eb002430 	bl	1670c <abort>
    d648:	0002b4e8 	.word	0x0002b4e8

0000d64c <quotearg_custom>:

char *
quotearg_custom (char const *left_quote, char const *right_quote,
                 char const *arg)
{
    d64c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  if (!left_quote || !right_quote)
    d650:	e3510000 	cmp	r1, #0
    d654:	13500000 	cmpne	r0, #0
  struct quoting_options o = default_quoting_options;
    d658:	e59fe064 	ldr	lr, [pc, #100]	@ d6c4 <quotearg_custom+0x78>
{
    d65c:	e1a06002 	mov	r6, r2
  if (!left_quote || !right_quote)
    d660:	e1a05000 	mov	r5, r0
    d664:	e1a04001 	mov	r4, r1
{
    d668:	e24dd030 	sub	sp, sp, #48	@ 0x30
  o->style = custom_quoting_style;
    d66c:	e3a0800a 	mov	r8, #10
  struct quoting_options o = default_quoting_options;
    d670:	e1a0c00d 	mov	ip, sp
  if (!left_quote || !right_quote)
    d674:	03a07001 	moveq	r7, #1
  struct quoting_options o = default_quoting_options;
    d678:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
  if (!left_quote || !right_quote)
    d67c:	13a07000 	movne	r7, #0
  struct quoting_options o = default_quoting_options;
    d680:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
  o->style = custom_quoting_style;
    d684:	e5cd8000 	strb	r8, [sp]
  struct quoting_options o = default_quoting_options;
    d688:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
    d68c:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
    d690:	e89e000f 	ldm	lr, {r0, r1, r2, r3}
    d694:	e88c000f 	stm	ip, {r0, r1, r2, r3}
  if (!left_quote || !right_quote)
    d698:	0a000008 	beq	d6c0 <quotearg_custom+0x74>
  return quotearg_n_options (n, arg, argsize, &o);
    d69c:	e1a0300d 	mov	r3, sp
    d6a0:	e1a01006 	mov	r1, r6
    d6a4:	e1a00007 	mov	r0, r7
    d6a8:	e3e02000 	mvn	r2, #0
  o->left_quote = left_quote;
    d6ac:	e58d5028 	str	r5, [sp, #40]	@ 0x28
  o->right_quote = right_quote;
    d6b0:	e58d402c 	str	r4, [sp, #44]	@ 0x2c
  return quotearg_n_options (n, arg, argsize, &o);
    d6b4:	ebfffd70 	bl	cc7c <quotearg_n_options>
  return quotearg_n_custom (0, left_quote, right_quote, arg);
}
    d6b8:	e28dd030 	add	sp, sp, #48	@ 0x30
    d6bc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    abort ();
    d6c0:	eb002411 	bl	1670c <abort>
    d6c4:	0002b4e8 	.word	0x0002b4e8

0000d6c8 <quotearg_custom_mem>:

char *
quotearg_custom_mem (char const *left_quote, char const *right_quote,
                     char const *arg, size_t argsize)
{
    d6c8:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
  if (!left_quote || !right_quote)
    d6cc:	e3510000 	cmp	r1, #0
    d6d0:	13500000 	cmpne	r0, #0
  struct quoting_options o = default_quoting_options;
    d6d4:	e59fe068 	ldr	lr, [pc, #104]	@ d744 <quotearg_custom_mem+0x7c>
{
    d6d8:	e1a06002 	mov	r6, r2
    d6dc:	e1a07003 	mov	r7, r3
  if (!left_quote || !right_quote)
    d6e0:	e1a05000 	mov	r5, r0
    d6e4:	e1a04001 	mov	r4, r1
{
    d6e8:	e24dd034 	sub	sp, sp, #52	@ 0x34
  struct quoting_options o = default_quoting_options;
    d6ec:	e1a0c00d 	mov	ip, sp
  o->style = custom_quoting_style;
    d6f0:	e3a0900a 	mov	r9, #10
  struct quoting_options o = default_quoting_options;
    d6f4:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
  if (!left_quote || !right_quote)
    d6f8:	03a08001 	moveq	r8, #1
    d6fc:	13a08000 	movne	r8, #0
  struct quoting_options o = default_quoting_options;
    d700:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
  o->style = custom_quoting_style;
    d704:	e5cd9000 	strb	r9, [sp]
  struct quoting_options o = default_quoting_options;
    d708:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
    d70c:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
    d710:	e89e000f 	ldm	lr, {r0, r1, r2, r3}
    d714:	e88c000f 	stm	ip, {r0, r1, r2, r3}
  if (!left_quote || !right_quote)
    d718:	0a000008 	beq	d740 <quotearg_custom_mem+0x78>
  return quotearg_n_options (n, arg, argsize, &o);
    d71c:	e1a0300d 	mov	r3, sp
    d720:	e1a02007 	mov	r2, r7
    d724:	e1a01006 	mov	r1, r6
    d728:	e1a00008 	mov	r0, r8
  o->left_quote = left_quote;
    d72c:	e58d5028 	str	r5, [sp, #40]	@ 0x28
  o->right_quote = right_quote;
    d730:	e58d402c 	str	r4, [sp, #44]	@ 0x2c
  return quotearg_n_options (n, arg, argsize, &o);
    d734:	ebfffd50 	bl	cc7c <quotearg_n_options>
  return quotearg_n_custom_mem (0, left_quote, right_quote, arg,
                                argsize);
}
    d738:	e28dd034 	add	sp, sp, #52	@ 0x34
    d73c:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
    abort ();
    d740:	eb0023f1 	bl	1670c <abort>
    d744:	0002b4e8 	.word	0x0002b4e8

0000d748 <quote_n_mem>:
  };

char const *
quote_n_mem (int n, char const *arg, size_t argsize)
{
  return quotearg_n_options (n, arg, argsize, &quote_quoting_options);
    d748:	e59f3000 	ldr	r3, [pc]	@ d750 <quote_n_mem+0x8>
    d74c:	eafffd4a 	b	cc7c <quotearg_n_options>
    d750:	0002b034 	.word	0x0002b034

0000d754 <quote_mem>:
}

char const *
quote_mem (char const *arg, size_t argsize)
{
    d754:	e1a02001 	mov	r2, r1
  return quotearg_n_options (n, arg, argsize, &quote_quoting_options);
    d758:	e59f3008 	ldr	r3, [pc, #8]	@ d768 <quote_mem+0x14>
    d75c:	e1a01000 	mov	r1, r0
    d760:	e3a00000 	mov	r0, #0
    d764:	eafffd44 	b	cc7c <quotearg_n_options>
    d768:	0002b034 	.word	0x0002b034

0000d76c <quote_n>:
    d76c:	e59f3004 	ldr	r3, [pc, #4]	@ d778 <quote_n+0xc>
    d770:	e3e02000 	mvn	r2, #0
    d774:	eafffd40 	b	cc7c <quotearg_n_options>
    d778:	0002b034 	.word	0x0002b034

0000d77c <quote>:
  return quote_n_mem (n, arg, SIZE_MAX);
}

char const *
quote (char const *arg)
{
    d77c:	e1a01000 	mov	r1, r0
  return quotearg_n_options (n, arg, argsize, &quote_quoting_options);
    d780:	e59f3008 	ldr	r3, [pc, #8]	@ d790 <quote+0x14>
    d784:	e3e02000 	mvn	r2, #0
    d788:	e3a00000 	mov	r0, #0
    d78c:	eafffd3a 	b	cc7c <quotearg_n_options>
    d790:	0002b034 	.word	0x0002b034

0000d794 <save_token>:

/* Finalize (in the obstack_finish sense) the current token
   and record its pointer and length.  */
static void
save_token (struct Tokens *t)
{
    d794:	e92d4070 	push	{r4, r5, r6, lr}
    d798:	e1a04000 	mov	r4, r0
  /* Don't count the trailing NUL byte in the length.  */
  size_t len = obstack_object_size (&t->o_data) - 1;
    d79c:	e5903018 	ldr	r3, [r0, #24]
    d7a0:	e5906014 	ldr	r6, [r0, #20]
  char const *s = obstack_finish (&t->o_data);
    d7a4:	e590c01c 	ldr	ip, [r0, #28]
    d7a8:	e1530006 	cmp	r3, r6
  size_t len = obstack_object_size (&t->o_data) - 1;
    d7ac:	e0435006 	sub	r5, r3, r6
  char const *s = obstack_finish (&t->o_data);
    d7b0:	05d02034 	ldrbeq	r2, [r0, #52]	@ 0x34
  size_t len = obstack_object_size (&t->o_data) - 1;
    d7b4:	e2455001 	sub	r5, r5, #1
  char const *s = obstack_finish (&t->o_data);
    d7b8:	03822002 	orreq	r2, r2, #2
    d7bc:	05c02034 	strbeq	r2, [r0, #52]	@ 0x34
    d7c0:	e5902024 	ldr	r2, [r0, #36]	@ 0x24
    d7c4:	e0833002 	add	r3, r3, r2
    d7c8:	e1c33002 	bic	r3, r3, r2
    d7cc:	e5902010 	ldr	r2, [r0, #16]
  obstack_ptr_grow (&t->o_tok, s);
    d7d0:	e1c004d4 	ldrd	r0, [r0, #68]	@ 0x44
  char const *s = obstack_finish (&t->o_data);
    d7d4:	e043e002 	sub	lr, r3, r2
    d7d8:	e04c2002 	sub	r2, ip, r2
    d7dc:	e15e0002 	cmp	lr, r2
  obstack_ptr_grow (&t->o_tok, s);
    d7e0:	e0411000 	sub	r1, r1, r0
  char const *s = obstack_finish (&t->o_data);
    d7e4:	81a0300c 	movhi	r3, ip
  obstack_ptr_grow (&t->o_tok, s);
    d7e8:	e3510003 	cmp	r1, #3
  char const *s = obstack_finish (&t->o_data);
    d7ec:	e5843014 	str	r3, [r4, #20]
    d7f0:	e5843018 	str	r3, [r4, #24]
  obstack_ptr_grow (&t->o_tok, s);
    d7f4:	9a000010 	bls	d83c <save_token+0xa8>
    d7f8:	e5806000 	str	r6, [r0]
  obstack_grow (&t->o_tok_len, &len, sizeof len);
    d7fc:	e5941070 	ldr	r1, [r4, #112]	@ 0x70
    d800:	e5942074 	ldr	r2, [r4, #116]	@ 0x74
  obstack_ptr_grow (&t->o_tok, s);
    d804:	e5943044 	ldr	r3, [r4, #68]	@ 0x44
  obstack_grow (&t->o_tok_len, &len, sizeof len);
    d808:	e0422001 	sub	r2, r2, r1
    d80c:	e3520003 	cmp	r2, #3
  obstack_ptr_grow (&t->o_tok, s);
    d810:	e2833004 	add	r3, r3, #4
    d814:	e5843044 	str	r3, [r4, #68]	@ 0x44
  obstack_grow (&t->o_tok_len, &len, sizeof len);
    d818:	9a00000c 	bls	d850 <save_token+0xbc>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    d81c:	e5815000 	str	r5, [r1]
    d820:	e5942070 	ldr	r2, [r4, #112]	@ 0x70
  t->n_tok++;
    d824:	e5943000 	ldr	r3, [r4]
  obstack_grow (&t->o_tok_len, &len, sizeof len);
    d828:	e2822004 	add	r2, r2, #4
  t->n_tok++;
    d82c:	e2833001 	add	r3, r3, #1
  obstack_grow (&t->o_tok_len, &len, sizeof len);
    d830:	e5842070 	str	r2, [r4, #112]	@ 0x70
  t->n_tok++;
    d834:	e5843000 	str	r3, [r4]
}
    d838:	e8bd8070 	pop	{r4, r5, r6, pc}
  obstack_ptr_grow (&t->o_tok, s);
    d83c:	e2840038 	add	r0, r4, #56	@ 0x38
    d840:	e3a01004 	mov	r1, #4
    d844:	eb000497 	bl	eaa8 <_obstack_newchunk>
    d848:	e5940044 	ldr	r0, [r4, #68]	@ 0x44
    d84c:	eaffffe9 	b	d7f8 <save_token+0x64>
  obstack_grow (&t->o_tok_len, &len, sizeof len);
    d850:	e3a01004 	mov	r1, #4
    d854:	e2840064 	add	r0, r4, #100	@ 0x64
    d858:	eb000492 	bl	eaa8 <_obstack_newchunk>
    d85c:	e5941070 	ldr	r1, [r4, #112]	@ 0x70
    d860:	eaffffed 	b	d81c <save_token+0x88>

0000d864 <readtokens0_init>:
{
    d864:	e92d40f0 	push	{r4, r5, r6, r7, lr}
  obstack_init (&t->o_data);
    d868:	e30e7614 	movw	r7, #58900	@ 0xe614
    d86c:	e30a6458 	movw	r6, #42072	@ 0xa458
  t->n_tok = 0;
    d870:	e3a05000 	mov	r5, #0
{
    d874:	e24dd00c 	sub	sp, sp, #12
  obstack_init (&t->o_data);
    d878:	e3407000 	movt	r7, #0
    d87c:	e3406000 	movt	r6, #0
{
    d880:	e1a04000 	mov	r4, r0
  t->n_tok = 0;
    d884:	e5805000 	str	r5, [r0]
  obstack_init (&t->o_data);
    d888:	e1a03007 	mov	r3, r7
  t->tok = NULL;
    d88c:	e5805004 	str	r5, [r0, #4]
  obstack_init (&t->o_data);
    d890:	e1a02005 	mov	r2, r5
  t->tok = NULL;
    d894:	e5805008 	str	r5, [r0, #8]
  obstack_init (&t->o_data);
    d898:	e1a01005 	mov	r1, r5
    d89c:	e58d6000 	str	r6, [sp]
    d8a0:	e280000c 	add	r0, r0, #12
    d8a4:	eb00046f 	bl	ea68 <_obstack_begin>
  obstack_init (&t->o_tok);
    d8a8:	e1a03007 	mov	r3, r7
    d8ac:	e1a02005 	mov	r2, r5
    d8b0:	e1a01005 	mov	r1, r5
    d8b4:	e2840038 	add	r0, r4, #56	@ 0x38
    d8b8:	e58d6000 	str	r6, [sp]
    d8bc:	eb000469 	bl	ea68 <_obstack_begin>
  obstack_init (&t->o_tok_len);
    d8c0:	e1a03007 	mov	r3, r7
    d8c4:	e1a02005 	mov	r2, r5
    d8c8:	e1a01005 	mov	r1, r5
    d8cc:	e2840064 	add	r0, r4, #100	@ 0x64
    d8d0:	e58d6000 	str	r6, [sp]
    d8d4:	eb000463 	bl	ea68 <_obstack_begin>
}
    d8d8:	e28dd00c 	add	sp, sp, #12
    d8dc:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

0000d8e0 <readtokens0_free>:
{
    d8e0:	e92d4010 	push	{r4, lr}
  obstack_free (&t->o_data, NULL);
    d8e4:	e3a01000 	mov	r1, #0
{
    d8e8:	e1a04000 	mov	r4, r0
  obstack_free (&t->o_data, NULL);
    d8ec:	e280000c 	add	r0, r0, #12
    d8f0:	eb0004cb 	bl	ec24 <_obstack_free>
  obstack_free (&t->o_tok, NULL);
    d8f4:	e2840038 	add	r0, r4, #56	@ 0x38
    d8f8:	e3a01000 	mov	r1, #0
    d8fc:	eb0004c8 	bl	ec24 <_obstack_free>
  obstack_free (&t->o_tok_len, NULL);
    d900:	e2840064 	add	r0, r4, #100	@ 0x64
    d904:	e3a01000 	mov	r1, #0
}
    d908:	e8bd4010 	pop	{r4, lr}
  obstack_free (&t->o_tok_len, NULL);
    d90c:	ea0004c4 	b	ec24 <_obstack_free>

0000d910 <readtokens0>:
   The final NUL is optional.  Always append a NULL pointer to the
   resulting list of token pointers, but that pointer isn't counted
   via t->n_tok.  Return true if successful.  */
bool
readtokens0 (FILE *in, struct Tokens *t)
{
    d910:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    d914:	e1a05001 	mov	r5, r1
    d918:	e1a06000 	mov	r6, r0
            }

          break;
        }

      obstack_1grow (&t->o_data, c);
    d91c:	e281700c 	add	r7, r1, #12
    d920:	ea000004 	b	d938 <readtokens0+0x28>
      if (c == '\0')
    d924:	e3540000 	cmp	r4, #0
      obstack_1grow (&t->o_data, c);
    d928:	e2832001 	add	r2, r3, #1
    d92c:	e5852018 	str	r2, [r5, #24]
    d930:	e5c34000 	strb	r4, [r3]
      if (c == '\0')
    d934:	0a000047 	beq	da58 <readtokens0+0x148>
      int c = fgetc (in);
    d938:	e1a00006 	mov	r0, r6
    d93c:	eb002a09 	bl	18168 <fgetc>
      if (c == EOF)
    d940:	e3700001 	cmn	r0, #1
          size_t len = obstack_object_size (&t->o_data);
    d944:	e5953018 	ldr	r3, [r5, #24]
      int c = fgetc (in);
    d948:	e1a04000 	mov	r4, r0
      if (c == EOF)
    d94c:	0a000007 	beq	d970 <readtokens0+0x60>
      obstack_1grow (&t->o_data, c);
    d950:	e595201c 	ldr	r2, [r5, #28]
    d954:	e1520003 	cmp	r2, r3
    d958:	1afffff1 	bne	d924 <readtokens0+0x14>
    d95c:	e3a01001 	mov	r1, #1
    d960:	e1a00007 	mov	r0, r7
    d964:	eb00044f 	bl	eaa8 <_obstack_newchunk>
              obstack_1grow (&t->o_data, '\0');
    d968:	e5953018 	ldr	r3, [r5, #24]
    d96c:	eaffffec 	b	d924 <readtokens0+0x14>
          if (len)
    d970:	e5952014 	ldr	r2, [r5, #20]
    d974:	e1530002 	cmp	r3, r2
    d978:	0a000008 	beq	d9a0 <readtokens0+0x90>
              obstack_1grow (&t->o_data, '\0');
    d97c:	e595201c 	ldr	r2, [r5, #28]
    d980:	e1530002 	cmp	r3, r2
    d984:	0a00003b 	beq	da78 <readtokens0+0x168>
    d988:	e2831001 	add	r1, r3, #1
    d98c:	e3a02000 	mov	r2, #0
    d990:	e5851018 	str	r1, [r5, #24]
              save_token (t);
    d994:	e1a00005 	mov	r0, r5
              obstack_1grow (&t->o_data, '\0');
    d998:	e5c32000 	strb	r2, [r3]
              save_token (t);
    d99c:	ebffff7c 	bl	d794 <save_token>
        save_token (t);
    }

  /* Add a NULL pointer at the end, in case the caller (like du)
     requires an argv-style array of strings.  */
  obstack_ptr_grow (&t->o_tok, NULL);
    d9a0:	e1c524d4 	ldrd	r2, [r5, #68]	@ 0x44
    d9a4:	e0433002 	sub	r3, r3, r2
    d9a8:	e3530003 	cmp	r3, #3
    d9ac:	9a00002c 	bls	da64 <readtokens0+0x154>
    d9b0:	e3a03000 	mov	r3, #0
    d9b4:	e5823000 	str	r3, [r2]

  t->tok = obstack_finish (&t->o_tok);
    d9b8:	e1c524d0 	ldrd	r2, [r5, #64]	@ 0x40
    d9bc:	e595c048 	ldr	ip, [r5, #72]	@ 0x48
  t->tok_len = obstack_finish (&t->o_tok_len);
    d9c0:	e595006c 	ldr	r0, [r5, #108]	@ 0x6c
  obstack_ptr_grow (&t->o_tok, NULL);
    d9c4:	e2833004 	add	r3, r3, #4
  t->tok = obstack_finish (&t->o_tok);
    d9c8:	e5852004 	str	r2, [r5, #4]
    d9cc:	e1530002 	cmp	r3, r2
    d9d0:	e5952050 	ldr	r2, [r5, #80]	@ 0x50
    d9d4:	05d51060 	ldrbeq	r1, [r5, #96]	@ 0x60
  t->tok_len = obstack_finish (&t->o_tok_len);
    d9d8:	e5850008 	str	r0, [r5, #8]
  t->tok = obstack_finish (&t->o_tok);
    d9dc:	e0833002 	add	r3, r3, r2
    d9e0:	03811002 	orreq	r1, r1, #2
    d9e4:	e1c33002 	bic	r3, r3, r2
    d9e8:	05c51060 	strbeq	r1, [r5, #96]	@ 0x60
    d9ec:	e595103c 	ldr	r1, [r5, #60]	@ 0x3c
  t->tok_len = obstack_finish (&t->o_tok_len);
    d9f0:	e5952070 	ldr	r2, [r5, #112]	@ 0x70
  t->tok = obstack_finish (&t->o_tok);
    d9f4:	e043e001 	sub	lr, r3, r1
    d9f8:	e04c1001 	sub	r1, ip, r1
    d9fc:	e15e0001 	cmp	lr, r1
  t->tok_len = obstack_finish (&t->o_tok_len);
    da00:	e5951068 	ldr	r1, [r5, #104]	@ 0x68
  t->tok = obstack_finish (&t->o_tok);
    da04:	81a0300c 	movhi	r3, ip
  t->tok_len = obstack_finish (&t->o_tok_len);
    da08:	e1520000 	cmp	r2, r0
  t->tok = obstack_finish (&t->o_tok);
    da0c:	e5853040 	str	r3, [r5, #64]	@ 0x40
    da10:	e5853044 	str	r3, [r5, #68]	@ 0x44
  t->tok_len = obstack_finish (&t->o_tok_len);
    da14:	05d5308c 	ldrbeq	r3, [r5, #140]	@ 0x8c
    da18:	e595007c 	ldr	r0, [r5, #124]	@ 0x7c
    da1c:	03833002 	orreq	r3, r3, #2
    da20:	05c5308c 	strbeq	r3, [r5, #140]	@ 0x8c
    da24:	e0823000 	add	r3, r2, r0
    da28:	e5952074 	ldr	r2, [r5, #116]	@ 0x74
    da2c:	e1c33000 	bic	r3, r3, r0
    da30:	e0430001 	sub	r0, r3, r1
    da34:	e0421001 	sub	r1, r2, r1
    da38:	e1500001 	cmp	r0, r1
    da3c:	81a03002 	movhi	r3, r2
    da40:	e585306c 	str	r3, [r5, #108]	@ 0x6c
    da44:	e5853070 	str	r3, [r5, #112]	@ 0x70
  return ! ferror (in);
    da48:	e1d600bc 	ldrh	r0, [r6, #12]
    da4c:	e2200040 	eor	r0, r0, #64	@ 0x40
}
    da50:	e7e00350 	ubfx	r0, r0, #6, #1
    da54:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        save_token (t);
    da58:	e1a00005 	mov	r0, r5
    da5c:	ebffff4c 	bl	d794 <save_token>
    da60:	eaffffb4 	b	d938 <readtokens0+0x28>
  obstack_ptr_grow (&t->o_tok, NULL);
    da64:	e3a01004 	mov	r1, #4
    da68:	e2850038 	add	r0, r5, #56	@ 0x38
    da6c:	eb00040d 	bl	eaa8 <_obstack_newchunk>
    da70:	e5952044 	ldr	r2, [r5, #68]	@ 0x44
    da74:	eaffffcd 	b	d9b0 <readtokens0+0xa0>
              obstack_1grow (&t->o_data, '\0');
    da78:	e3a01001 	mov	r1, #1
    da7c:	e285000c 	add	r0, r5, #12
    da80:	eb000408 	bl	eaa8 <_obstack_newchunk>
    da84:	e5953018 	ldr	r3, [r5, #24]
    da88:	eaffffbe 	b	d988 <readtokens0+0x78>

0000da8c <safe_read>:
/* Read(write) up to COUNT bytes at BUF from(to) descriptor FD, retrying if
   interrupted.  Return the actual number of bytes read(written), zero for EOF,
   or SAFE_READ_ERROR(SAFE_WRITE_ERROR) upon error.  */
size_t
safe_rw (int fd, void const *buf, size_t count)
{
    da8c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}

      if (0 <= result)
        return result;
      else if (IS_EINTR (errno))
        continue;
      else if (errno == EINVAL && SYS_BUFSIZE_MAX < count)
    da90:	e3a06000 	mov	r6, #0
{
    da94:	e1a08000 	mov	r8, r0
    da98:	e1a07001 	mov	r7, r1
    da9c:	e1a05002 	mov	r5, r2
      else if (errno == EINVAL && SYS_BUFSIZE_MAX < count)
    daa0:	e3476ff0 	movt	r6, #32752	@ 0x7ff0
#if __POSIX_VISIBLE >= 200809 || __XSI_VISIBLE >= 500
__ssp_redirect0(ssize_t, pread, (int __fd, void *__buf, size_t __len, off_t __off), \
    (__fd, __buf, __len, __off));
#endif

__ssp_redirect0(_READ_WRITE_RETURN_TYPE, read, \
    daa4:	e1a02005 	mov	r2, r5
    daa8:	e1a01007 	mov	r1, r7
    daac:	e1a00008 	mov	r0, r8
    dab0:	eb004776 	bl	1f890 <read>
      if (0 <= result)
    dab4:	e2504000 	subs	r4, r0, #0
    dab8:	aa00000d 	bge	daf4 <safe_read+0x68>
      else if (IS_EINTR (errno))
    dabc:	eb003754 	bl	1b814 <__errno>
    dac0:	e5903000 	ldr	r3, [r0]
    dac4:	e3530004 	cmp	r3, #4
    dac8:	0afffff5 	beq	daa4 <safe_read+0x18>
      else if (errno == EINVAL && SYS_BUFSIZE_MAX < count)
    dacc:	eb003750 	bl	1b814 <__errno>
    dad0:	e5903000 	ldr	r3, [r0]
    dad4:	e1550006 	cmp	r5, r6
        count = SYS_BUFSIZE_MAX;
    dad8:	e1a05006 	mov	r5, r6
      else if (errno == EINVAL && SYS_BUFSIZE_MAX < count)
    dadc:	e2433016 	sub	r3, r3, #22
    dae0:	e16f3f13 	clz	r3, r3
    dae4:	e1a032a3 	lsr	r3, r3, #5
    dae8:	93a03000 	movls	r3, #0
    daec:	e3530000 	cmp	r3, #0
    daf0:	1affffeb 	bne	daa4 <safe_read+0x18>
      else
        return result;
    }
}
    daf4:	e1a00004 	mov	r0, r4
    daf8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

0000dafc <rpl_stat>:
   at least this implementation provides the ability to emulate fchdir
   correctly.  */

int
rpl_stat (char const *name, struct stat *buf)
{
    dafc:	e92d4070 	push	{r4, r5, r6, lr}
    db00:	e1a05000 	mov	r5, r0
    db04:	e1a06001 	mov	r6, r1
  return stat (filename, buf);
    db08:	eb0046db 	bl	1f67c <stat>

    return -1;
  }
#else
  int result = orig_stat (name, buf);
  if (result == 0)
    db0c:	e2504000 	subs	r4, r0, #0
    db10:	1a000009 	bne	db3c <rpl_stat+0x40>
    {
# if REPLACE_FUNC_STAT_FILE
      /* Solaris 9 mistakenly succeeds when given a non-directory with a
         trailing slash.  */
      if (!S_ISDIR (buf->st_mode))
    db14:	e5963004 	ldr	r3, [r6, #4]
    db18:	e2033a0f 	and	r3, r3, #61440	@ 0xf000
    db1c:	e3530901 	cmp	r3, #16384	@ 0x4000
    db20:	0a000005 	beq	db3c <rpl_stat+0x40>
        {
          size_t len = strlen (name);
    db24:	e1a00005 	mov	r0, r5
    db28:	fa004a54 	blx	20480 <strlen>
          if (ISSLASH (name[len - 1]))
    db2c:	e0850000 	add	r0, r5, r0
    db30:	e5503001 	ldrb	r3, [r0, #-1]
    db34:	e353002f 	cmp	r3, #47	@ 0x2f
    db38:	0a000001 	beq	db44 <rpl_stat+0x48>
# endif /* REPLACE_FUNC_STAT_FILE */
      result = stat_time_normalize (result, buf);
    }
  return result;
#endif
}
    db3c:	e1a00004 	mov	r0, r4
    db40:	e8bd8070 	pop	{r4, r5, r6, pc}
              errno = ENOTDIR;
    db44:	eb003732 	bl	1b814 <__errno>
    db48:	e3a03014 	mov	r3, #20
              return -1;
    db4c:	e3e04000 	mvn	r4, #0
              errno = ENOTDIR;
    db50:	e5803000 	str	r3, [r0]
              return -1;
    db54:	eafffff8 	b	db3c <rpl_stat+0x40>

0000db58 <version_etc_arn>:
version_etc_arn (FILE *stream,
                 const char *command_name, const char *package,
                 const char *version,
                 const char * const * authors, size_t n_authors)
{
  if (command_name)
    db58:	e3510000 	cmp	r1, #0
{
    db5c:	e92d4070 	push	{r4, r5, r6, lr}
    db60:	e24dd020 	sub	sp, sp, #32
    db64:	e1a04000 	mov	r4, r0
    db68:	e59d6030 	ldr	r6, [sp, #48]	@ 0x30
    db6c:	e59d5034 	ldr	r5, [sp, #52]	@ 0x34
  if (command_name)
    db70:	0a000036 	beq	dc50 <version_etc_arn+0xf8>
    fprintf (stream, "%s (%s) %s\n", command_name, package, version);
    db74:	e58d3000 	str	r3, [sp]
    db78:	e1a03002 	mov	r3, r2
    db7c:	e1a02001 	mov	r2, r1
    db80:	e3081e34 	movw	r1, #36404	@ 0x8e34
    db84:	e3401002 	movt	r1, #2
    db88:	eb002ae5 	bl	18724 <fprintf>
#endif

  /* TRANSLATORS: Translate "(C)" to the copyright symbol
     (C-in-a-circle), if this symbol is available in the user's
     locale.  Otherwise, do not translate "(C)"; leave it as-is.  */
  fprintf (stream, version_etc_copyright, _("(C)"), COPYRIGHT_YEAR);
    db8c:	e3082e48 	movw	r2, #36424	@ 0x8e48
    db90:	e3091cf0 	movw	r1, #40176	@ 0x9cf0
    db94:	e30037e7 	movw	r3, #2023	@ 0x7e7
    db98:	e3402002 	movt	r2, #2
    db9c:	e3401002 	movt	r1, #2
    dba0:	e1a00004 	mov	r0, r4
    dba4:	eb002ade 	bl	18724 <fprintf>

  fputs ("\n", stream);
    dba8:	e1a01004 	mov	r1, r4
    dbac:	e3a0000a 	mov	r0, #10
    dbb0:	eb0031bd 	bl	1a2ac <fputc_unlocked>

  /* TRANSLATORS: The %s placeholder is the web address of the GPL license.  */
  fprintf (stream, _("\
    dbb4:	e3082e4c 	movw	r2, #36428	@ 0x8e4c
    dbb8:	e3081e70 	movw	r1, #36464	@ 0x8e70
    dbbc:	e3402002 	movt	r2, #2
    dbc0:	e3401002 	movt	r1, #2
    dbc4:	e1a00004 	mov	r0, r4
    dbc8:	eb002ad5 	bl	18724 <fprintf>
This is free software: you are free to change and redistribute it.\n\
There is NO WARRANTY, to the extent permitted by law.\n\
"),
           "https://gnu.org/licenses/gpl.html");

  fputs ("\n", stream);
    dbcc:	e1a01004 	mov	r1, r4
    dbd0:	e3a0000a 	mov	r0, #10
    dbd4:	eb0031b4 	bl	1a2ac <fputc_unlocked>

  switch (n_authors)
    dbd8:	e3550009 	cmp	r5, #9
    dbdc:	979ff105 	ldrls	pc, [pc, r5, lsl #2]
    dbe0:	ea00007b 	b	ddd4 <version_etc_arn+0x27c>
    dbe4:	0000dc48 	.word	0x0000dc48
    dbe8:	0000dcac 	.word	0x0000dcac
    dbec:	0000dcc8 	.word	0x0000dcc8
    dbf0:	0000dce4 	.word	0x0000dce4
    dbf4:	0000dd08 	.word	0x0000dd08
    dbf8:	0000dd34 	.word	0x0000dd34
    dbfc:	0000dd64 	.word	0x0000dd64
    dc00:	0000dd98 	.word	0x0000dd98
    dc04:	0000dc0c 	.word	0x0000dc0c
    dc08:	0000dc60 	.word	0x0000dc60
      break;
    case 8:
      /* TRANSLATORS: Each %s denotes an author name.
         You can use line breaks, estimating that each author name occupies
         ca. 16 screen columns and that a screen line has ca. 80 columns.  */
      fprintf (stream, _("\
    dc0c:	e1c621d4 	ldrd	r2, [r6, #20]
    dc10:	e1a00004 	mov	r0, r4
    dc14:	e596101c 	ldr	r1, [r6, #28]
    dc18:	e58d3010 	str	r3, [sp, #16]
    dc1c:	e58d1014 	str	r1, [sp, #20]
    dc20:	e5963010 	ldr	r3, [r6, #16]
    dc24:	e596c00c 	ldr	ip, [r6, #12]
    dc28:	e58d200c 	str	r2, [sp, #12]
    dc2c:	e58d3008 	str	r3, [sp, #8]
    dc30:	e5961008 	ldr	r1, [r6, #8]
    dc34:	e1c620d0 	ldrd	r2, [r6]
    dc38:	e88d1002 	stm	sp, {r1, ip}
    dc3c:	e3081ff8 	movw	r1, #36856	@ 0x8ff8
    dc40:	e3401002 	movt	r1, #2
    dc44:	eb002ab6 	bl	18724 <fprintf>
Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n"),
                authors[0], authors[1], authors[2], authors[3], authors[4],
                authors[5], authors[6], authors[7], authors[8]);
      break;
    }
}
    dc48:	e28dd020 	add	sp, sp, #32
    dc4c:	e8bd8070 	pop	{r4, r5, r6, pc}
    fprintf (stream, "%s %s\n", package, version);
    dc50:	e3081e40 	movw	r1, #36416	@ 0x8e40
    dc54:	e3401002 	movt	r1, #2
    dc58:	eb002ab1 	bl	18724 <fprintf>
    dc5c:	eaffffca 	b	db8c <version_etc_arn+0x34>
      fprintf (stream, _("\
    dc60:	e5962020 	ldr	r2, [r6, #32]
    dc64:	e1a00004 	mov	r0, r4
    dc68:	e596301c 	ldr	r3, [r6, #28]
    dc6c:	e5961018 	ldr	r1, [r6, #24]
    dc70:	e58d2018 	str	r2, [sp, #24]
    dc74:	e58d3014 	str	r3, [sp, #20]
    dc78:	e1c621d0 	ldrd	r2, [r6, #16]
    dc7c:	e58d1010 	str	r1, [sp, #16]
    dc80:	e3091028 	movw	r1, #36904	@ 0x9028
    dc84:	e3401002 	movt	r1, #2
    dc88:	e58d300c 	str	r3, [sp, #12]
    dc8c:	e596300c 	ldr	r3, [r6, #12]
    dc90:	e596c008 	ldr	ip, [r6, #8]
    dc94:	e58d2008 	str	r2, [sp, #8]
    dc98:	e58d3004 	str	r3, [sp, #4]
    dc9c:	e1c620d0 	ldrd	r2, [r6]
    dca0:	e58dc000 	str	ip, [sp]
    dca4:	eb002a9e 	bl	18724 <fprintf>
      break;
    dca8:	eaffffe6 	b	dc48 <version_etc_arn+0xf0>
      fprintf (stream, _("Written by %s.\n"), authors[0]);
    dcac:	e3081f1c 	movw	r1, #36636	@ 0x8f1c
    dcb0:	e5962000 	ldr	r2, [r6]
    dcb4:	e3401002 	movt	r1, #2
    dcb8:	e1a00004 	mov	r0, r4
}
    dcbc:	e28dd020 	add	sp, sp, #32
    dcc0:	e8bd4070 	pop	{r4, r5, r6, lr}
      fprintf (stream, _("Written by %s.\n"), authors[0]);
    dcc4:	ea002a96 	b	18724 <fprintf>
      fprintf (stream, _("Written by %s and %s.\n"), authors[0], authors[1]);
    dcc8:	e3081f2c 	movw	r1, #36652	@ 0x8f2c
    dccc:	e1c620d0 	ldrd	r2, [r6]
    dcd0:	e3401002 	movt	r1, #2
    dcd4:	e1a00004 	mov	r0, r4
}
    dcd8:	e28dd020 	add	sp, sp, #32
    dcdc:	e8bd4070 	pop	{r4, r5, r6, lr}
      fprintf (stream, _("Written by %s and %s.\n"), authors[0], authors[1]);
    dce0:	ea002a8f 	b	18724 <fprintf>
      fprintf (stream, _("Written by %s, %s, and %s.\n"),
    dce4:	e596c008 	ldr	ip, [r6, #8]
    dce8:	e3081f44 	movw	r1, #36676	@ 0x8f44
    dcec:	e1c620d0 	ldrd	r2, [r6]
    dcf0:	e3401002 	movt	r1, #2
    dcf4:	e1a00004 	mov	r0, r4
    dcf8:	e58dc030 	str	ip, [sp, #48]	@ 0x30
}
    dcfc:	e28dd020 	add	sp, sp, #32
    dd00:	e8bd4070 	pop	{r4, r5, r6, lr}
      fprintf (stream, _("Written by %s, %s, and %s.\n"),
    dd04:	ea002a86 	b	18724 <fprintf>
      fprintf (stream, _("Written by %s, %s, %s,\nand %s.\n"),
    dd08:	e5961008 	ldr	r1, [r6, #8]
    dd0c:	e1a00004 	mov	r0, r4
    dd10:	e596c00c 	ldr	ip, [r6, #12]
    dd14:	e1c620d0 	ldrd	r2, [r6]
    dd18:	e58d1030 	str	r1, [sp, #48]	@ 0x30
    dd1c:	e3081f60 	movw	r1, #36704	@ 0x8f60
    dd20:	e3401002 	movt	r1, #2
    dd24:	e58dc034 	str	ip, [sp, #52]	@ 0x34
}
    dd28:	e28dd020 	add	sp, sp, #32
    dd2c:	e8bd4070 	pop	{r4, r5, r6, lr}
      fprintf (stream, _("Written by %s, %s, %s,\nand %s.\n"),
    dd30:	ea002a7b 	b	18724 <fprintf>
      fprintf (stream, _("Written by %s, %s, %s,\n%s, and %s.\n"),
    dd34:	e5962010 	ldr	r2, [r6, #16]
    dd38:	e3081f80 	movw	r1, #36736	@ 0x8f80
    dd3c:	e596300c 	ldr	r3, [r6, #12]
    dd40:	e1a00004 	mov	r0, r4
    dd44:	e596c008 	ldr	ip, [r6, #8]
    dd48:	e3401002 	movt	r1, #2
    dd4c:	e58d2008 	str	r2, [sp, #8]
    dd50:	e58d3004 	str	r3, [sp, #4]
    dd54:	e1c620d0 	ldrd	r2, [r6]
    dd58:	e58dc000 	str	ip, [sp]
    dd5c:	eb002a70 	bl	18724 <fprintf>
      break;
    dd60:	eaffffb8 	b	dc48 <version_etc_arn+0xf0>
      fprintf (stream, _("Written by %s, %s, %s,\n%s, %s, and %s.\n"),
    dd64:	e5962014 	ldr	r2, [r6, #20]
    dd68:	e1a00004 	mov	r0, r4
    dd6c:	e5963010 	ldr	r3, [r6, #16]
    dd70:	e596c00c 	ldr	ip, [r6, #12]
    dd74:	e58d200c 	str	r2, [sp, #12]
    dd78:	e58d3008 	str	r3, [sp, #8]
    dd7c:	e5961008 	ldr	r1, [r6, #8]
    dd80:	e1c620d0 	ldrd	r2, [r6]
    dd84:	e88d1002 	stm	sp, {r1, ip}
    dd88:	e3081fa4 	movw	r1, #36772	@ 0x8fa4
    dd8c:	e3401002 	movt	r1, #2
    dd90:	eb002a63 	bl	18724 <fprintf>
      break;
    dd94:	eaffffab 	b	dc48 <version_etc_arn+0xf0>
      fprintf (stream, _("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n"),
    dd98:	e1c621d0 	ldrd	r2, [r6, #16]
    dd9c:	e1a00004 	mov	r0, r4
    dda0:	e5961018 	ldr	r1, [r6, #24]
    dda4:	e58d300c 	str	r3, [sp, #12]
    dda8:	e58d1010 	str	r1, [sp, #16]
    ddac:	e3081fcc 	movw	r1, #36812	@ 0x8fcc
    ddb0:	e596300c 	ldr	r3, [r6, #12]
    ddb4:	e3401002 	movt	r1, #2
    ddb8:	e596c008 	ldr	ip, [r6, #8]
    ddbc:	e58d2008 	str	r2, [sp, #8]
    ddc0:	e58d3004 	str	r3, [sp, #4]
    ddc4:	e1c620d0 	ldrd	r2, [r6]
    ddc8:	e58dc000 	str	ip, [sp]
    ddcc:	eb002a54 	bl	18724 <fprintf>
      break;
    ddd0:	eaffff9c 	b	dc48 <version_etc_arn+0xf0>
      fprintf (stream, _("\
    ddd4:	e5962020 	ldr	r2, [r6, #32]
    ddd8:	e1a00004 	mov	r0, r4
    dddc:	e596301c 	ldr	r3, [r6, #28]
    dde0:	e5961018 	ldr	r1, [r6, #24]
    dde4:	e58d2018 	str	r2, [sp, #24]
    dde8:	e58d3014 	str	r3, [sp, #20]
    ddec:	e1c621d0 	ldrd	r2, [r6, #16]
    ddf0:	e58d1010 	str	r1, [sp, #16]
    ddf4:	e309105c 	movw	r1, #36956	@ 0x905c
    ddf8:	e3401002 	movt	r1, #2
    ddfc:	e58d300c 	str	r3, [sp, #12]
    de00:	e596300c 	ldr	r3, [r6, #12]
    de04:	e596c008 	ldr	ip, [r6, #8]
    de08:	e58d2008 	str	r2, [sp, #8]
    de0c:	e58d3004 	str	r3, [sp, #4]
    de10:	e1c620d0 	ldrd	r2, [r6]
    de14:	e58dc000 	str	ip, [sp]
    de18:	eb002a41 	bl	18724 <fprintf>
}
    de1c:	eaffff89 	b	dc48 <version_etc_arn+0xf0>

0000de20 <version_etc_ar>:
   Author names are given in the NULL-terminated array AUTHORS. */
void
version_etc_ar (FILE *stream,
                const char *command_name, const char *package,
                const char *version, const char * const * authors)
{
    de20:	e92d4030 	push	{r4, r5, lr}
    de24:	e24dd00c 	sub	sp, sp, #12
    de28:	e59d5018 	ldr	r5, [sp, #24]
  size_t n_authors;

  for (n_authors = 0; authors[n_authors]; n_authors++)
    de2c:	e595c000 	ldr	ip, [r5]
    de30:	e35c0000 	cmp	ip, #0
    de34:	0a000005 	beq	de50 <version_etc_ar+0x30>
    de38:	e1a0e005 	mov	lr, r5
    de3c:	e3a0c000 	mov	ip, #0
    de40:	e5be4004 	ldr	r4, [lr, #4]!
    de44:	e28cc001 	add	ip, ip, #1
    de48:	e3540000 	cmp	r4, #0
    de4c:	1afffffb 	bne	de40 <version_etc_ar+0x20>
    ;
  version_etc_arn (stream, command_name, package, version, authors, n_authors);
    de50:	e88d1020 	stm	sp, {r5, ip}
    de54:	ebffff3f 	bl	db58 <version_etc_arn>
}
    de58:	e28dd00c 	add	sp, sp, #12
    de5c:	e8bd8030 	pop	{r4, r5, pc}

0000de60 <version_etc_va>:
   Author names are given in the NULL-terminated va_list AUTHORS. */
void
version_etc_va (FILE *stream,
                const char *command_name, const char *package,
                const char *version, va_list authors)
{
    de60:	e92d4070 	push	{r4, r5, r6, lr}
    de64:	e24dd030 	sub	sp, sp, #48	@ 0x30
    de68:	e59d5040 	ldr	r5, [sp, #64]	@ 0x40
  size_t n_authors;
  const char *authtab[10];

  for (n_authors = 0;
       n_authors < 10
         && (authtab[n_authors] = va_arg (authors, const char *)) != NULL;
    de6c:	e28d6008 	add	r6, sp, #8
    de70:	e1a04006 	mov	r4, r6
  for (n_authors = 0;
    de74:	e3a0c000 	mov	ip, #0
         && (authtab[n_authors] = va_arg (authors, const char *)) != NULL;
    de78:	e495e004 	ldr	lr, [r5], #4
    de7c:	e35e0000 	cmp	lr, #0
    de80:	e484e004 	str	lr, [r4], #4
    de84:	0a000002 	beq	de94 <version_etc_va+0x34>
       n_authors++)
    de88:	e28cc001 	add	ip, ip, #1
         && (authtab[n_authors] = va_arg (authors, const char *)) != NULL;
    de8c:	e35c000a 	cmp	ip, #10
    de90:	1afffff8 	bne	de78 <version_etc_va+0x18>
    ;
  version_etc_arn (stream, command_name, package, version,
    de94:	e88d1040 	stm	sp, {r6, ip}
    de98:	ebffff2e 	bl	db58 <version_etc_arn>
                   authtab, n_authors);
}
    de9c:	e28dd030 	add	sp, sp, #48	@ 0x30
    dea0:	e8bd8070 	pop	{r4, r5, r6, pc}

0000dea4 <version_etc>:
   NULL argument at the end.  */
void
version_etc (FILE *stream,
             const char *command_name, const char *package,
             const char *version, /* const char *author1, ...*/ ...)
{
    dea4:	e52d3004 	push	{r3}		@ (str r3, [sp, #-4]!)
    dea8:	e92d4030 	push	{r4, r5, lr}
    deac:	e24dd038 	sub	sp, sp, #56	@ 0x38
  va_list authors;

  va_start (authors, version);
    deb0:	e28d3048 	add	r3, sp, #72	@ 0x48
    deb4:	e28d5010 	add	r5, sp, #16
    deb8:	e1a04003 	mov	r4, r3
    debc:	e1a0e005 	mov	lr, r5
    dec0:	e58d300c 	str	r3, [sp, #12]
  for (n_authors = 0;
    dec4:	e3a03000 	mov	r3, #0
         && (authtab[n_authors] = va_arg (authors, const char *)) != NULL;
    dec8:	e494c004 	ldr	ip, [r4], #4
    decc:	e35c0000 	cmp	ip, #0
    ded0:	e48ec004 	str	ip, [lr], #4
    ded4:	0a000002 	beq	dee4 <version_etc+0x40>
       n_authors++)
    ded8:	e2833001 	add	r3, r3, #1
         && (authtab[n_authors] = va_arg (authors, const char *)) != NULL;
    dedc:	e353000a 	cmp	r3, #10
    dee0:	1afffff8 	bne	dec8 <version_etc+0x24>
  version_etc_arn (stream, command_name, package, version,
    dee4:	e58d3004 	str	r3, [sp, #4]
    dee8:	e58d5000 	str	r5, [sp]
    deec:	e59d3044 	ldr	r3, [sp, #68]	@ 0x44
    def0:	ebffff18 	bl	db58 <version_etc_arn>
  version_etc_va (stream, command_name, package, version, authors);
  va_end (authors);
}
    def4:	e28dd038 	add	sp, sp, #56	@ 0x38
    def8:	e8bd4030 	pop	{r4, r5, lr}
    defc:	e28dd004 	add	sp, sp, #4
    df00:	e12fff1e 	bx	lr

0000df04 <emit_bug_reporting_address>:

void
emit_bug_reporting_address (void)
{
  fputs ("\n", stdout);
    df04:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
{
    df08:	e92d4010 	push	{r4, lr}
  fputs ("\n", stdout);
    df0c:	e3403002 	movt	r3, #2
    df10:	e3a0000a 	mov	r0, #10
    df14:	e5933000 	ldr	r3, [r3]
    df18:	e5931008 	ldr	r1, [r3, #8]
    df1c:	eb0030e2 	bl	1a2ac <fputc_unlocked>
  /* TRANSLATORS: The placeholder indicates the bug-reporting address
     for this package.  Please add _another line_ saying
     "Report translation bugs to <...>\n" with the address for translation
     bugs (typically your translation team's web or email address).  */
  printf (_("Report bugs to: %s\n"), PACKAGE_BUGREPORT);
    df20:	e3091098 	movw	r1, #37016	@ 0x9098
    df24:	e30900b0 	movw	r0, #37040	@ 0x90b0
    df28:	e3401002 	movt	r1, #2
    df2c:	e3400002 	movt	r0, #2
    df30:	eb002c0d 	bl	18f6c <printf>
#ifdef PACKAGE_PACKAGER_BUG_REPORTS
  printf (_("Report %s bugs to: %s\n"), PACKAGE_PACKAGER,
          PACKAGE_PACKAGER_BUG_REPORTS);
#endif
#ifdef PACKAGE_URL
  printf (_("%s home page: <%s>\n"), PACKAGE_NAME, PACKAGE_URL);
    df34:	e3082820 	movw	r2, #34848	@ 0x8820
    df38:	e3081848 	movw	r1, #34888	@ 0x8848
    df3c:	e30900c4 	movw	r0, #37060	@ 0x90c4
    df40:	e3401002 	movt	r1, #2
    df44:	e3402002 	movt	r2, #2
    df48:	e3400002 	movt	r0, #2
    df4c:	eb002c06 	bl	18f6c <printf>
#else
  printf (_("%s home page: <%s>\n"),
          PACKAGE_NAME, "https://www.gnu.org/software/" PACKAGE "/");
#endif
  printf (_("General help using GNU software: <%s>\n"),
    df50:	e30910d8 	movw	r1, #37080	@ 0x90d8
    df54:	e30900f8 	movw	r0, #37112	@ 0x90f8
          "https://www.gnu.org/gethelp/");
}
    df58:	e8bd4010 	pop	{r4, lr}
  printf (_("General help using GNU software: <%s>\n"),
    df5c:	e3401002 	movt	r1, #2
    df60:	e3400002 	movt	r0, #2
    df64:	ea002c00 	b	18f6c <printf>

0000df68 <xnrealloc>:

XALLOC_INLINE void *xnrealloc (void *p, size_t n, size_t s)
  _GL_ATTRIBUTE_ALLOC_SIZE ((2, 3));
XALLOC_INLINE void *
xnrealloc (void *p, size_t n, size_t s)
{
    df68:	e92d4070 	push	{r4, r5, r6, lr}
    df6c:	e1a04000 	mov	r4, r0
    df70:	e1a06001 	mov	r6, r1
    df74:	e1a05002 	mov	r5, r2
   objects each of S bytes, with error checking.  */

void *
xreallocarray (void *p, size_t n, size_t s)
{
  void *r = reallocarray (p, n, s);
    df78:	eb00035a 	bl	ece8 <rpl_reallocarray>
  if (!r && (!p || (n && s)))
    df7c:	e3500000 	cmp	r0, #0
    df80:	18bd8070 	popne	{r4, r5, r6, pc}
    df84:	e3540000 	cmp	r4, #0
    df88:	0a000002 	beq	df98 <xnrealloc+0x30>
    df8c:	e3560000 	cmp	r6, #0
    df90:	13550000 	cmpne	r5, #0
    df94:	08bd8070 	popeq	{r4, r5, r6, pc}
    xalloc_die ();
    df98:	eb0000f5 	bl	e374 <xalloc_die>

0000df9c <xmalloc>:
{
    df9c:	e92d4010 	push	{r4, lr}
  return nonnull (malloc (s));
    dfa0:	eb00019b 	bl	e614 <rpl_malloc>
  if (!p)
    dfa4:	e3500000 	cmp	r0, #0
    dfa8:	18bd8010 	popne	{r4, pc}
    xalloc_die ();
    dfac:	eb0000f0 	bl	e374 <xalloc_die>

0000dfb0 <ximalloc>:
{
    dfb0:	e92d4010 	push	{r4, lr}
IALLOC_INLINE
_GL_ATTRIBUTE_MALLOC /*_GL_ATTRIBUTE_DEALLOC_FREE*/
void *
imalloc (idx_t s)
{
  return s <= SIZE_MAX ? malloc (s) : _gl_alloc_nomem ();
    dfb4:	eb000196 	bl	e614 <rpl_malloc>
  if (!p)
    dfb8:	e3500000 	cmp	r0, #0
    dfbc:	18bd8010 	popne	{r4, pc}
    xalloc_die ();
    dfc0:	eb0000eb 	bl	e374 <xalloc_die>

0000dfc4 <xcharalloc>:
  return XNMALLOC (n, char);
    dfc4:	eafffff4 	b	df9c <xmalloc>

0000dfc8 <xrealloc>:
{
    dfc8:	e92d4070 	push	{r4, r5, r6, lr}
    dfcc:	e1a05000 	mov	r5, r0
    dfd0:	e1a04001 	mov	r4, r1
  void *r = realloc (p, s);
    dfd4:	eb00019a 	bl	e644 <rpl_realloc>
  if (!r && (!p || s))
    dfd8:	e3500000 	cmp	r0, #0
    dfdc:	18bd8070 	popne	{r4, r5, r6, pc}
    dfe0:	e2541000 	subs	r1, r4, #0
    dfe4:	13a01001 	movne	r1, #1
    dfe8:	e3550000 	cmp	r5, #0
    dfec:	03811001 	orreq	r1, r1, #1
    dff0:	e3510000 	cmp	r1, #0
    dff4:	08bd8070 	popeq	{r4, r5, r6, pc}
    xalloc_die ();
    dff8:	eb0000dd 	bl	e374 <xalloc_die>

0000dffc <xirealloc>:
void *
irealloc (void *p, idx_t s)
{
  /* Work around GNU realloc glitch by treating a zero size as if it
     were 1, so that returning NULL is equivalent to failing.  */
  return s <= SIZE_MAX ? realloc (p, s | !s) : _gl_alloc_nomem ();
    dffc:	e3510000 	cmp	r1, #0
    e000:	03811001 	orreq	r1, r1, #1
{
    e004:	e92d4010 	push	{r4, lr}
    e008:	eb00018d 	bl	e644 <rpl_realloc>
  if (!p)
    e00c:	e3500000 	cmp	r0, #0
    e010:	18bd8010 	popne	{r4, pc}
    xalloc_die ();
    e014:	eb0000d6 	bl	e374 <xalloc_die>

0000e018 <xreallocarray>:
{
    e018:	e92d4070 	push	{r4, r5, r6, lr}
    e01c:	e1a04000 	mov	r4, r0
    e020:	e1a06001 	mov	r6, r1
    e024:	e1a05002 	mov	r5, r2
  void *r = reallocarray (p, n, s);
    e028:	eb00032e 	bl	ece8 <rpl_reallocarray>
  if (!r && (!p || (n && s)))
    e02c:	e3500000 	cmp	r0, #0
    e030:	18bd8070 	popne	{r4, r5, r6, pc}
    e034:	e3540000 	cmp	r4, #0
    e038:	0a000002 	beq	e048 <xreallocarray+0x30>
    e03c:	e3560000 	cmp	r6, #0
    e040:	13550000 	cmpne	r5, #0
    e044:	08bd8070 	popeq	{r4, r5, r6, pc}
    xalloc_die ();
    e048:	eb0000c9 	bl	e374 <xalloc_die>

0000e04c <xireallocarray>:
IALLOC_INLINE void *
ireallocarray (void *p, idx_t n, idx_t s)
{
  /* Work around GNU reallocarray glitch by treating a zero size as if
     it were 1, so that returning NULL is equivalent to failing.  */
  if (n == 0 || s == 0)
    e04c:	e3520000 	cmp	r2, #0
    e050:	13510000 	cmpne	r1, #0
  return r;
}

void *
xireallocarray (void *p, idx_t n, idx_t s)
{
    e054:	e92d4010 	push	{r4, lr}
    e058:	03a02001 	moveq	r2, #1
    e05c:	01a01002 	moveq	r1, r2
    n = s = 1;
  return (n <= SIZE_MAX && s <= SIZE_MAX
          ? reallocarray (p, n, s)
          : _gl_alloc_nomem ());
    e060:	eb000320 	bl	ece8 <rpl_reallocarray>
  if (!p)
    e064:	e3500000 	cmp	r0, #0
    e068:	18bd8010 	popne	{r4, pc}
    xalloc_die ();
    e06c:	eb0000c0 	bl	e374 <xalloc_die>

0000e070 <xnmalloc>:
/* Allocate an array of N objects, each with S bytes of memory,
   dynamically, with error checking.  S must be nonzero.  */

void *
xnmalloc (size_t n, size_t s)
{
    e070:	e1a02001 	mov	r2, r1
    e074:	e92d4010 	push	{r4, lr}
  void *r = reallocarray (p, n, s);
    e078:	e1a01000 	mov	r1, r0
    e07c:	e3a00000 	mov	r0, #0
    e080:	eb000318 	bl	ece8 <rpl_reallocarray>
  if (!r && (!p || (n && s)))
    e084:	e3500000 	cmp	r0, #0
    e088:	18bd8010 	popne	{r4, pc}
    xalloc_die ();
    e08c:	eb0000b8 	bl	e374 <xalloc_die>

0000e090 <xinmalloc>:
  if (n == 0 || s == 0)
    e090:	e3510000 	cmp	r1, #0
    e094:	13500000 	cmpne	r0, #0
  return xreallocarray (NULL, n, s);
}

void *
xinmalloc (idx_t n, idx_t s)
{
    e098:	e92d4010 	push	{r4, lr}
    e09c:	03a02001 	moveq	r2, #1
    e0a0:	11a02001 	movne	r2, r1
    e0a4:	01a01002 	moveq	r1, r2
          : _gl_alloc_nomem ());
    e0a8:	11a01000 	movne	r1, r0
    e0ac:	e3a00000 	mov	r0, #0
    e0b0:	eb00030c 	bl	ece8 <rpl_reallocarray>
  if (!p)
    e0b4:	e3500000 	cmp	r0, #0
    e0b8:	18bd8010 	popne	{r4, pc}
    xalloc_die ();
    e0bc:	eb0000ac 	bl	e374 <xalloc_die>

0000e0c0 <x2realloc>:
void *
x2nrealloc (void *p, size_t *pn, size_t s)
{
  size_t n = *pn;

  if (! p)
    e0c0:	e3500000 	cmp	r0, #0
{
    e0c4:	e92d4070 	push	{r4, r5, r6, lr}
  size_t n = *pn;
    e0c8:	e5914000 	ldr	r4, [r1]
{
    e0cc:	e1a05001 	mov	r5, r1
  if (! p)
    e0d0:	0a00000d 	beq	e10c <x2realloc+0x4c>
        }
    }
  else
    {
      /* Set N = floor (1.5 * N) + 1 to make progress even if N == 0.  */
      if (ckd_add (&n, n, (n >> 1) + 1))
    e0d4:	e1a030a4 	lsr	r3, r4, #1
    e0d8:	e2833001 	add	r3, r3, #1
    e0dc:	e0944003 	adds	r4, r4, r3
    e0e0:	2a000008 	bcs	e108 <x2realloc+0x48>
  void *r = reallocarray (p, n, s);
    e0e4:	e3a02001 	mov	r2, #1
    e0e8:	e1a01004 	mov	r1, r4
    e0ec:	eb0002fd 	bl	ece8 <rpl_reallocarray>
  if (!r && (!p || (n && s)))
    e0f0:	e3500000 	cmp	r0, #0
    e0f4:	0a000001 	beq	e100 <x2realloc+0x40>
        xalloc_die ();
    }

  p = xreallocarray (p, n, s);
  *pn = n;
    e0f8:	e5854000 	str	r4, [r5]
}
    e0fc:	e8bd8070 	pop	{r4, r5, r6, pc}
  if (!r && (!p || (n && s)))
    e100:	e3540000 	cmp	r4, #0
    e104:	0afffffb 	beq	e0f8 <x2realloc+0x38>
        xalloc_die ();
    e108:	eb000099 	bl	e374 <xalloc_die>
          n += !n;
    e10c:	e3540000 	cmp	r4, #0
  void *r = reallocarray (p, n, s);
    e110:	e3a02001 	mov	r2, #1
          n += !n;
    e114:	03a04040 	moveq	r4, #64	@ 0x40
  void *r = reallocarray (p, n, s);
    e118:	e1a01004 	mov	r1, r4
    e11c:	eb0002f1 	bl	ece8 <rpl_reallocarray>
  if (!r && (!p || (n && s)))
    e120:	e3500000 	cmp	r0, #0
    e124:	0afffff7 	beq	e108 <x2realloc+0x48>
  *pn = n;
    e128:	e5854000 	str	r4, [r5]
}
    e12c:	e8bd8070 	pop	{r4, r5, r6, pc}

0000e130 <x2nrealloc>:
  if (! p)
    e130:	e3500000 	cmp	r0, #0
{
    e134:	e92d4070 	push	{r4, r5, r6, lr}
  size_t n = *pn;
    e138:	e5914000 	ldr	r4, [r1]
{
    e13c:	e1a05001 	mov	r5, r1
    e140:	e1a06002 	mov	r6, r2
  if (! p)
    e144:	0a00000d 	beq	e180 <x2nrealloc+0x50>
      if (ckd_add (&n, n, (n >> 1) + 1))
    e148:	e1a030a4 	lsr	r3, r4, #1
    e14c:	e2833001 	add	r3, r3, #1
    e150:	e0944003 	adds	r4, r4, r3
    e154:	2a000008 	bcs	e17c <x2nrealloc+0x4c>
  void *r = reallocarray (p, n, s);
    e158:	e1a01004 	mov	r1, r4
    e15c:	eb0002e1 	bl	ece8 <rpl_reallocarray>
  if (!r && (!p || (n && s)))
    e160:	e3500000 	cmp	r0, #0
    e164:	0a000001 	beq	e170 <x2nrealloc+0x40>
  *pn = n;
    e168:	e5854000 	str	r4, [r5]
  return p;
}
    e16c:	e8bd8070 	pop	{r4, r5, r6, pc}
  if (!r && (!p || (n && s)))
    e170:	e3540000 	cmp	r4, #0
    e174:	13560000 	cmpne	r6, #0
    e178:	0afffffa 	beq	e168 <x2nrealloc+0x38>
        xalloc_die ();
    e17c:	eb00007c 	bl	e374 <xalloc_die>
      if (! n)
    e180:	e3540000 	cmp	r4, #0
    e184:	1a000005 	bne	e1a0 <x2nrealloc+0x70>
          n = DEFAULT_MXFAST / s;
    e188:	e1a01002 	mov	r1, r2
    e18c:	e3a00040 	mov	r0, #64	@ 0x40
    e190:	eb001ff2 	bl	16160 <__udivsi3>
          n += !n;
    e194:	e3560040 	cmp	r6, #64	@ 0x40
    e198:	91a04000 	movls	r4, r0
    e19c:	82804001 	addhi	r4, r0, #1
  void *r = reallocarray (p, n, s);
    e1a0:	e1a02006 	mov	r2, r6
    e1a4:	e1a01004 	mov	r1, r4
    e1a8:	e3a00000 	mov	r0, #0
    e1ac:	eb0002cd 	bl	ece8 <rpl_reallocarray>
  if (!r && (!p || (n && s)))
    e1b0:	e3500000 	cmp	r0, #0
    e1b4:	0afffff0 	beq	e17c <x2nrealloc+0x4c>
  *pn = n;
    e1b8:	e5854000 	str	r4, [r5]
}
    e1bc:	e8bd8070 	pop	{r4, r5, r6, pc}

0000e1c0 <xpalloc>:
   Thus, to grow an array A without saving its old contents, do
   { free (A); A = xpalloc (NULL, &AITEMS, ...); }.  */

void *
xpalloc (void *pa, idx_t *pn, idx_t n_incr_min, ptrdiff_t n_max, idx_t s)
{
    e1c0:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e1c4:	e1a06001 	mov	r6, r1
  idx_t n0 = *pn;
    e1c8:	e5918000 	ldr	r8, [r1]
{
    e1cc:	e1a05000 	mov	r5, r0
    e1d0:	e1a0a002 	mov	sl, r2
    e1d4:	e1a09003 	mov	r9, r3
    e1d8:	e59d7028 	ldr	r7, [sp, #40]	@ 0x28
     DEFAULT_MXFAST bytes.  Otherwise, grow it by about 50%.
     Adjust the growth according to three constraints: N_INCR_MIN,
     N_MAX, and what the C language can represent safely.  */

  idx_t n;
  if (ckd_add (&n, n0, n0 >> 1))
    e1dc:	e1a040c8 	asr	r4, r8, #1
    e1e0:	e0944008 	adds	r4, r4, r8
    n = IDX_MAX;
    e1e4:	63e04102 	mvnvs	r4, #-2147483648	@ 0x80000000
  if (0 <= n_max && n_max < n)
    e1e8:	e3530000 	cmp	r3, #0
    e1ec:	ba000001 	blt	e1f8 <xpalloc+0x38>
    e1f0:	e1540003 	cmp	r4, r3
    e1f4:	a1a04003 	movge	r4, r3
  idx_t nbytes;
#else
  size_t nbytes;
#endif
  idx_t adjusted_nbytes
    = (ckd_mul (&nbytes, n, s)
    e1f8:	e0c31794 	smull	r1, r3, r4, r7
    e1fc:	e1530fc1 	cmp	r3, r1, asr #31
    e200:	1a000026 	bne	e2a0 <xpalloc+0xe0>
       ? MIN (IDX_MAX, SIZE_MAX)
       : nbytes < DEFAULT_MXFAST ? DEFAULT_MXFAST : 0);
    e204:	e351003f 	cmp	r1, #63	@ 0x3f
    = (ckd_mul (&nbytes, n, s)
    e208:	e1a0b001 	mov	fp, r1
       : nbytes < DEFAULT_MXFAST ? DEFAULT_MXFAST : 0);
    e20c:	da000015 	ble	e268 <xpalloc+0xa8>
    {
      n = adjusted_nbytes / s;
      nbytes = adjusted_nbytes - adjusted_nbytes % s;
    }

  if (! pa)
    e210:	e3550000 	cmp	r5, #0
    *pn = 0;
  if (n - n0 < n_incr_min
    e214:	e0443008 	sub	r3, r4, r8
    *pn = 0;
    e218:	05865000 	streq	r5, [r6]
  if (n - n0 < n_incr_min
    e21c:	e153000a 	cmp	r3, sl
    e220:	aa000009 	bge	e24c <xpalloc+0x8c>
      && (ckd_add (&n, n0, n_incr_min)
    e224:	e098200a 	adds	r2, r8, sl
    e228:	e1a04002 	mov	r4, r2
    e22c:	6a00001a 	bvs	e29c <xpalloc+0xdc>
          || (0 <= n_max && n_max < n)
    e230:	e3590000 	cmp	r9, #0
    e234:	a1520009 	cmpge	r2, r9
    e238:	ca000017 	bgt	e29c <xpalloc+0xdc>
          || ckd_mul (&nbytes, n, s)))
    e23c:	e0c23792 	smull	r3, r2, r2, r7
    e240:	e1520fc3 	cmp	r2, r3, asr #31
    e244:	e1a0b003 	mov	fp, r3
    e248:	1a000013 	bne	e29c <xpalloc+0xdc>
  void *r = realloc (p, s);
    e24c:	e1a0100b 	mov	r1, fp
    e250:	e1a00005 	mov	r0, r5
    e254:	eb0000fa 	bl	e644 <rpl_realloc>
  if (!r && (!p || s))
    e258:	e3500000 	cmp	r0, #0
    e25c:	0a000008 	beq	e284 <xpalloc+0xc4>
    xalloc_die ();
  pa = xrealloc (pa, nbytes);
  *pn = n;
    e260:	e5864000 	str	r4, [r6]
  return pa;
}
    e264:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
       : nbytes < DEFAULT_MXFAST ? DEFAULT_MXFAST : 0);
    e268:	e3a0b040 	mov	fp, #64	@ 0x40
      n = adjusted_nbytes / s;
    e26c:	e1a0000b 	mov	r0, fp
    e270:	e1a01007 	mov	r1, r7
    e274:	eb0020c4 	bl	1658c <__aeabi_idivmod>
      nbytes = adjusted_nbytes - adjusted_nbytes % s;
    e278:	e04bb001 	sub	fp, fp, r1
      n = adjusted_nbytes / s;
    e27c:	e1a04000 	mov	r4, r0
      nbytes = adjusted_nbytes - adjusted_nbytes % s;
    e280:	eaffffe2 	b	e210 <xpalloc+0x50>
  if (!r && (!p || s))
    e284:	e25b1000 	subs	r1, fp, #0
    e288:	13a01001 	movne	r1, #1
    e28c:	e3550000 	cmp	r5, #0
    e290:	03811001 	orreq	r1, r1, #1
    e294:	e3510000 	cmp	r1, #0
    e298:	0afffff0 	beq	e260 <xpalloc+0xa0>
    xalloc_die ();
    e29c:	eb000034 	bl	e374 <xalloc_die>
       : nbytes < DEFAULT_MXFAST ? DEFAULT_MXFAST : 0);
    e2a0:	e3e0b102 	mvn	fp, #-2147483648	@ 0x80000000
    e2a4:	eafffff0 	b	e26c <xpalloc+0xac>

0000e2a8 <xcalloc>:
/* Allocate zeroed memory for N elements of S bytes, with error
   checking.  S must be nonzero.  */

void *
xcalloc (size_t n, size_t s)
{
    e2a8:	e92d4010 	push	{r4, lr}
  return nonnull (calloc (n, s));
    e2ac:	eb00003b 	bl	e3a0 <rpl_calloc>
  if (!p)
    e2b0:	e3500000 	cmp	r0, #0
    e2b4:	18bd8010 	popne	{r4, pc}
    xalloc_die ();
    e2b8:	eb00002d 	bl	e374 <xalloc_die>

0000e2bc <xzalloc>:
  return xcalloc (s, 1);
    e2bc:	e3a01001 	mov	r1, #1
    e2c0:	eafffff8 	b	e2a8 <xcalloc>

0000e2c4 <xicalloc>:
}

void *
xicalloc (idx_t n, idx_t s)
{
    e2c4:	e92d4010 	push	{r4, lr}
  return calloc (n, s);
    e2c8:	eb000034 	bl	e3a0 <rpl_calloc>
  if (!p)
    e2cc:	e3500000 	cmp	r0, #0
    e2d0:	18bd8010 	popne	{r4, pc}
    xalloc_die ();
    e2d4:	eb000026 	bl	e374 <xalloc_die>

0000e2d8 <xizalloc>:
  return xicalloc (s, 1);
    e2d8:	e3a01001 	mov	r1, #1
    e2dc:	eafffff8 	b	e2c4 <xicalloc>

0000e2e0 <xmemdup>:
   for xnmemdup (P, N, S), since xmemdup (P, N * S) works without any
   need for an arithmetic overflow check.  */

void *
xmemdup (void const *p, size_t s)
{
    e2e0:	e92d4070 	push	{r4, r5, r6, lr}
    e2e4:	e1a04001 	mov	r4, r1
    e2e8:	e1a05000 	mov	r5, r0
  return memcpy (xmalloc (s), p, s);
    e2ec:	e1a00001 	mov	r0, r1
    e2f0:	ebffff29 	bl	df9c <xmalloc>
    e2f4:	e1a02004 	mov	r2, r4
    e2f8:	e1a01005 	mov	r1, r5
}
    e2fc:	e8bd4070 	pop	{r4, r5, r6, lr}
    e300:	ea0046de 	b	1fe80 <memcpy>

0000e304 <ximemdup>:

void *
ximemdup (void const *p, idx_t s)
{
    e304:	e92d4070 	push	{r4, r5, r6, lr}
    e308:	e1a04001 	mov	r4, r1
    e30c:	e1a05000 	mov	r5, r0
  return memcpy (ximalloc (s), p, s);
    e310:	e1a00001 	mov	r0, r1
    e314:	ebffff25 	bl	dfb0 <ximalloc>
    e318:	e1a02004 	mov	r2, r4
    e31c:	e1a01005 	mov	r1, r5
}
    e320:	e8bd4070 	pop	{r4, r5, r6, lr}
    e324:	ea0046d5 	b	1fe80 <memcpy>

0000e328 <ximemdup0>:
/* Clone an object P of size S, with error checking.  Append
   a terminating NUL byte.  */

char *
ximemdup0 (void const *p, idx_t s)
{
    e328:	e92d4070 	push	{r4, r5, r6, lr}
    e32c:	e1a05000 	mov	r5, r0
  char *result = ximalloc (s + 1);
    e330:	e2810001 	add	r0, r1, #1
{
    e334:	e1a04001 	mov	r4, r1
  char *result = ximalloc (s + 1);
    e338:	ebffff1c 	bl	dfb0 <ximalloc>
  result[s] = 0;
    e33c:	e3a02000 	mov	r2, #0
    e340:	e1a01005 	mov	r1, r5
    e344:	e7c02004 	strb	r2, [r0, r4]
    e348:	e1a02004 	mov	r2, r4
  return memcpy (result, p, s);
}
    e34c:	e8bd4070 	pop	{r4, r5, r6, lr}
    e350:	ea0046ca 	b	1fe80 <memcpy>

0000e354 <xstrdup>:

/* Clone STRING.  */

char *
xstrdup (char const *string)
{
    e354:	e92d4010 	push	{r4, lr}
    e358:	e1a04000 	mov	r4, r0
  return xmemdup (string, strlen (string) + 1);
    e35c:	fa004847 	blx	20480 <strlen>
    e360:	e1a01000 	mov	r1, r0
    e364:	e1a00004 	mov	r0, r4
    e368:	e2811001 	add	r1, r1, #1
}
    e36c:	e8bd4010 	pop	{r4, lr}
  return xmemdup (string, strlen (string) + 1);
    e370:	eaffffda 	b	e2e0 <xmemdup>

0000e374 <xalloc_die>:
#define _(msgid) gettext (msgid)

void
xalloc_die (void)
{
  error (exit_failure, 0, "%s", _("memory exhausted"));
    e374:	e30b1014 	movw	r1, #45076	@ 0xb014
    e378:	e3093120 	movw	r3, #37152	@ 0x9120
    e37c:	e3401002 	movt	r1, #2
    e380:	e3082bfc 	movw	r2, #35836	@ 0x8bfc
    e384:	e5910000 	ldr	r0, [r1]
    e388:	e3403002 	movt	r3, #2
    e38c:	e3402002 	movt	r2, #2
    e390:	e3a01000 	mov	r1, #0
{
    e394:	e92d4010 	push	{r4, lr}
  error (exit_failure, 0, "%s", _("memory exhausted"));
    e398:	ebffef63 	bl	a12c <error>

  /* _Noreturn cannot be given to error, since it may return if
     its first argument is 0.  To help compilers understand the
     xalloc_die does not return, call abort.  Also, the abort is a
     safety feature if exit_failure is 0 (which shouldn't happen).  */
  abort ();
    e39c:	eb0020da 	bl	1670c <abort>

0000e3a0 <rpl_calloc>:
   even if N or S is zero.  */

void *
rpl_calloc (size_t n, size_t s)
{
  if (n == 0 || s == 0)
    e3a0:	e3510000 	cmp	r1, #0
    e3a4:	13500000 	cmpne	r0, #0
    e3a8:	03a03001 	moveq	r3, #1
    e3ac:	13a03000 	movne	r3, #0
    n = s = 1;
    e3b0:	e3530000 	cmp	r3, #0
    e3b4:	13a01001 	movne	r1, #1
    e3b8:	13a00001 	movne	r0, #1

  if (xalloc_oversized (n, s))
    e3bc:	e0832190 	umull	r2, r3, r0, r1
    e3c0:	e2533000 	subs	r3, r3, #0
    e3c4:	13a03001 	movne	r3, #1
    e3c8:	e3520000 	cmp	r2, #0
    e3cc:	ba000002 	blt	e3dc <rpl_calloc+0x3c>
    e3d0:	e3530000 	cmp	r3, #0
    e3d4:	1a000000 	bne	e3dc <rpl_calloc+0x3c>
    {
      errno = ENOMEM;
      return NULL;
    }

  void *result = calloc (n, s);
    e3d8:	ea004266 	b	1ed78 <calloc>
{
    e3dc:	e92d4010 	push	{r4, lr}
      errno = ENOMEM;
    e3e0:	eb00350b 	bl	1b814 <__errno>
    e3e4:	e3a0300c 	mov	r3, #12
    e3e8:	e5803000 	str	r3, [r0]
  if (result == NULL)
    errno = ENOMEM;
#endif

  return result;
}
    e3ec:	e3a00000 	mov	r0, #0
    e3f0:	e8bd8010 	pop	{r4, pc}

0000e3f4 <rpl_fopen>:
#include <sys/types.h>
#include <sys/stat.h>

FILE *
rpl_fopen (const char *filename, const char *mode)
{
    e3f4:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    e3f8:	e1a06001 	mov	r6, r1
    const char *p = mode;
#if GNULIB_FOPEN_GNU
    char *q = fdopen_mode_buf;
#endif

    for (; *p != '\0'; p++)
    e3fc:	e5d13000 	ldrb	r3, [r1]
{
    e400:	e24dd058 	sub	sp, sp, #88	@ 0x58
    e404:	e1a09000 	mov	r9, r0
    for (; *p != '\0'; p++)
    e408:	e3530000 	cmp	r3, #0
    e40c:	0a00006c 	beq	e5c4 <rpl_fopen+0x1d0>
      {
        switch (*p)
    e410:	e353002b 	cmp	r3, #43	@ 0x2b
  open_flags_gnu = false;
    e414:	e3a07000 	mov	r7, #0
    const char *p = mode;
    e418:	e1a0a001 	mov	sl, r1
    char *q = fdopen_mode_buf;
    e41c:	e28d4004 	add	r4, sp, #4
  open_flags = 0;
    e420:	e1a05007 	mov	r5, r7
  open_direction = 0;
    e424:	e1a08007 	mov	r8, r7
        switch (*p)
    e428:	0a000042 	beq	e538 <rpl_fopen+0x144>
    e42c:	e2433061 	sub	r3, r3, #97	@ 0x61
    e430:	e6ef2073 	uxtb	r2, r3
    e434:	e3520017 	cmp	r2, #23
    e438:	8a00001a 	bhi	e4a8 <rpl_fopen+0xb4>
    e43c:	e3530017 	cmp	r3, #23
    e440:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    e444:	ea000017 	b	e4a8 <rpl_fopen+0xb4>
    e448:	0000e570 	.word	0x0000e570
    e44c:	0000e5b0 	.word	0x0000e5b0
    e450:	0000e4a8 	.word	0x0000e4a8
    e454:	0000e4a8 	.word	0x0000e4a8
    e458:	0000e5a4 	.word	0x0000e5a4
    e45c:	0000e4a8 	.word	0x0000e4a8
    e460:	0000e4a8 	.word	0x0000e4a8
    e464:	0000e4a8 	.word	0x0000e4a8
    e468:	0000e4a8 	.word	0x0000e4a8
    e46c:	0000e4a8 	.word	0x0000e4a8
    e470:	0000e4a8 	.word	0x0000e4a8
    e474:	0000e4a8 	.word	0x0000e4a8
    e478:	0000e4a8 	.word	0x0000e4a8
    e47c:	0000e4a8 	.word	0x0000e4a8
    e480:	0000e4a8 	.word	0x0000e4a8
    e484:	0000e4a8 	.word	0x0000e4a8
    e488:	0000e4a8 	.word	0x0000e4a8
    e48c:	0000e588 	.word	0x0000e588
    e490:	0000e4a8 	.word	0x0000e4a8
    e494:	0000e4a8 	.word	0x0000e4a8
    e498:	0000e4a8 	.word	0x0000e4a8
    e49c:	0000e4a8 	.word	0x0000e4a8
    e4a0:	0000e550 	.word	0x0000e550
    e4a4:	0000e51c 	.word	0x0000e51c
          }
#if GNULIB_FOPEN_GNU
        /* The rest of the mode string can be a platform-dependent extension.
           Copy it unmodified.  */
        {
          size_t len = strlen (p);
    e4a8:	e1a0000a 	mov	r0, sl
    e4ac:	fa0047f3 	blx	20480 <strlen>
          if (len > fdopen_mode_buf + BUF_SIZE - q)
            len = fdopen_mode_buf + BUF_SIZE - q;
          memcpy (q, p, len);
    e4b0:	e1a0100a 	mov	r1, sl
          if (len > fdopen_mode_buf + BUF_SIZE - q)
    e4b4:	e28da054 	add	sl, sp, #84	@ 0x54
    e4b8:	e04aa004 	sub	sl, sl, r4
          memcpy (q, p, len);
    e4bc:	e3a03051 	mov	r3, #81	@ 0x51
          if (len > fdopen_mode_buf + BUF_SIZE - q)
    e4c0:	e15a0000 	cmp	sl, r0
    e4c4:	21a0a000 	movcs	sl, r0
          memcpy (q, p, len);
    e4c8:	e1a00004 	mov	r0, r4
          q += len;
    e4cc:	e084400a 	add	r4, r4, sl
          memcpy (q, p, len);
    e4d0:	e1a0200a 	mov	r2, sl
    e4d4:	eb0034f1 	bl	1b8a0 <__memcpy_chk>
      }
  }
#endif

#if GNULIB_FOPEN_GNU
  if (open_flags_gnu)
    e4d8:	e3570000 	cmp	r7, #0
    *q = '\0';
    e4dc:	e3a07000 	mov	r7, #0
    e4e0:	e5c47000 	strb	r7, [r4]
  if (open_flags_gnu)
    e4e4:	0a000037 	beq	e5c8 <rpl_fopen+0x1d4>
    {
      int fd;
      FILE *fp;

      fd = open (filename, open_direction | open_flags,
    e4e8:	e1881005 	orr	r1, r8, r5
    e4ec:	e1a00009 	mov	r0, r9
    e4f0:	e30021b6 	movw	r2, #438	@ 0x1b6
    e4f4:	eb003530 	bl	1b9bc <open>
                 S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
      if (fd < 0)
    e4f8:	e2504000 	subs	r4, r0, #0
    e4fc:	ba000003 	blt	e510 <rpl_fopen+0x11c>
        return NULL;

      fp = fdopen (fd, fdopen_mode_buf);
    e500:	e28d1004 	add	r1, sp, #4
    e504:	eb00262b 	bl	17db8 <fdopen>
      if (fp == NULL)
    e508:	e2507000 	subs	r7, r0, #0
    e50c:	0a000038 	beq	e5f4 <rpl_fopen+0x200>
  /* open_direction is sometimes used, sometimes unused.
     Silence gcc's warning about this situation.  */
  (void) open_direction;

  return orig_fopen (filename, mode);
}
    e510:	e1a00007 	mov	r0, r7
    e514:	e28dd058 	add	sp, sp, #88	@ 0x58
    e518:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
            open_flags |= O_EXCL;
    e51c:	e3855b02 	orr	r5, r5, #2048	@ 0x800
            open_flags_gnu = true;
    e520:	e3a07001 	mov	r7, #1
    for (; *p != '\0'; p++)
    e524:	e5fa3001 	ldrb	r3, [sl, #1]!
    e528:	e3530000 	cmp	r3, #0
    e52c:	0affffe9 	beq	e4d8 <rpl_fopen+0xe4>
        switch (*p)
    e530:	e353002b 	cmp	r3, #43	@ 0x2b
    e534:	1affffbc 	bne	e42c <rpl_fopen+0x38>
            if (q < fdopen_mode_buf + BUF_SIZE)
    e538:	e28d2054 	add	r2, sp, #84	@ 0x54
    e53c:	e1540002 	cmp	r4, r2
            open_direction = O_RDWR;
    e540:	33a08002 	movcc	r8, #2
              *q++ = *p;
    e544:	34c43001 	strbcc	r3, [r4], #1
            open_direction = O_RDWR;
    e548:	23a08002 	movcs	r8, #2
    e54c:	eafffff4 	b	e524 <rpl_fopen+0x130>
            if (q < fdopen_mode_buf + BUF_SIZE)
    e550:	e28d3054 	add	r3, sp, #84	@ 0x54
            open_flags |= O_CREAT | O_TRUNC;
    e554:	e3855c06 	orr	r5, r5, #1536	@ 0x600
            if (q < fdopen_mode_buf + BUF_SIZE)
    e558:	e1540003 	cmp	r4, r3
    e55c:	2a000007 	bcs	e580 <rpl_fopen+0x18c>
              *q++ = *p;
    e560:	e3a03077 	mov	r3, #119	@ 0x77
            open_direction = O_WRONLY;
    e564:	e3a08001 	mov	r8, #1
              *q++ = *p;
    e568:	e4c43001 	strb	r3, [r4], #1
    e56c:	eaffffec 	b	e524 <rpl_fopen+0x130>
            if (q < fdopen_mode_buf + BUF_SIZE)
    e570:	e28d3054 	add	r3, sp, #84	@ 0x54
            open_flags |= O_CREAT | O_APPEND;
    e574:	e3855f82 	orr	r5, r5, #520	@ 0x208
            if (q < fdopen_mode_buf + BUF_SIZE)
    e578:	e1540003 	cmp	r4, r3
    e57c:	3a000018 	bcc	e5e4 <rpl_fopen+0x1f0>
            open_direction = O_WRONLY;
    e580:	e3a08001 	mov	r8, #1
    e584:	eaffffe6 	b	e524 <rpl_fopen+0x130>
            if (q < fdopen_mode_buf + BUF_SIZE)
    e588:	e28d3054 	add	r3, sp, #84	@ 0x54
    e58c:	e1540003 	cmp	r4, r3
            open_direction = O_RDONLY;
    e590:	23a08000 	movcs	r8, #0
              *q++ = *p;
    e594:	33a03072 	movcc	r3, #114	@ 0x72
            open_direction = O_RDONLY;
    e598:	33a08000 	movcc	r8, #0
              *q++ = *p;
    e59c:	34c43001 	strbcc	r3, [r4], #1
    e5a0:	eaffffdf 	b	e524 <rpl_fopen+0x130>
            open_flags |= O_CLOEXEC;
    e5a4:	e3855701 	orr	r5, r5, #262144	@ 0x40000
            open_flags_gnu = true;
    e5a8:	e3a07001 	mov	r7, #1
            continue;
    e5ac:	eaffffdc 	b	e524 <rpl_fopen+0x130>
            if (q < fdopen_mode_buf + BUF_SIZE)
    e5b0:	e28d3054 	add	r3, sp, #84	@ 0x54
    e5b4:	e1540003 	cmp	r4, r3
              *q++ = *p;
    e5b8:	33a03062 	movcc	r3, #98	@ 0x62
    e5bc:	34c43001 	strbcc	r3, [r4], #1
    e5c0:	eaffffd7 	b	e524 <rpl_fopen+0x130>
    *q = '\0';
    e5c4:	e5cd3004 	strb	r3, [sp, #4]
  return fopen (filename, mode);
    e5c8:	e1a01006 	mov	r1, r6
    e5cc:	e1a00009 	mov	r0, r9
    e5d0:	eb002841 	bl	186dc <fopen>
    e5d4:	e1a07000 	mov	r7, r0
}
    e5d8:	e1a00007 	mov	r0, r7
    e5dc:	e28dd058 	add	sp, sp, #88	@ 0x58
    e5e0:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
              *q++ = *p;
    e5e4:	e3a03061 	mov	r3, #97	@ 0x61
            open_direction = O_WRONLY;
    e5e8:	e3a08001 	mov	r8, #1
              *q++ = *p;
    e5ec:	e4c43001 	strb	r3, [r4], #1
    e5f0:	eaffffcb 	b	e524 <rpl_fopen+0x130>
          int saved_errno = errno;
    e5f4:	eb003486 	bl	1b814 <__errno>
    e5f8:	e1a03000 	mov	r3, r0
          close (fd);
    e5fc:	e1a00004 	mov	r0, r4
          int saved_errno = errno;
    e600:	e5934000 	ldr	r4, [r3]
          close (fd);
    e604:	eb004445 	bl	1f720 <close>
          errno = saved_errno;
    e608:	eb003481 	bl	1b814 <__errno>
    e60c:	e5804000 	str	r4, [r0]
    e610:	eaffffbe 	b	e510 <rpl_fopen+0x11c>

0000e614 <rpl_malloc>:
/* Allocate an N-byte block of memory from the heap, even if N is 0.  */

void *
rpl_malloc (size_t n)
{
  if (n == 0)
    e614:	e3500001 	cmp	r0, #1
    e618:	33a00001 	movcc	r0, #1
    n = 1;

  if (xalloc_oversized (n, 1))
    e61c:	e3500000 	cmp	r0, #0
    e620:	ba000000 	blt	e628 <rpl_malloc+0x14>
    {
      errno = ENOMEM;
      return NULL;
    }

  void *result = malloc (n);
    e624:	ea003984 	b	1cc3c <malloc>
{
    e628:	e92d4010 	push	{r4, lr}
      errno = ENOMEM;
    e62c:	eb003478 	bl	1b814 <__errno>
    e630:	e3a0200c 	mov	r2, #12
    e634:	e1a03000 	mov	r3, r0
    e638:	e5832000 	str	r2, [r3]
  if (result == NULL)
    errno = ENOMEM;
#endif

  return result;
}
    e63c:	e3a00000 	mov	r0, #0
    e640:	e8bd8010 	pop	{r4, pc}

0000e644 <rpl_realloc>:
   free P and return NULL.  */

void *
rpl_realloc (void *p, size_t n)
{
  if (p == NULL)
    e644:	e3500000 	cmp	r0, #0
    e648:	0a000005 	beq	e664 <rpl_realloc+0x20>
    return malloc (n);

  if (n == 0)
    e64c:	e3510000 	cmp	r1, #0
{
    e650:	e92d4010 	push	{r4, lr}
  if (n == 0)
    e654:	0a000004 	beq	e66c <rpl_realloc+0x28>
    {
      free (p);
      return NULL;
    }

  if (xalloc_oversized (n, 1))
    e658:	ba000006 	blt	e678 <rpl_realloc+0x34>
  if (result == NULL)
    errno = ENOMEM;
#endif

  return result;
}
    e65c:	e8bd4010 	pop	{r4, lr}
  void *result = realloc (p, n);
    e660:	ea0041e2 	b	1edf0 <realloc>
    return malloc (n);
    e664:	e1a00001 	mov	r0, r1
    e668:	eaffffe9 	b	e614 <rpl_malloc>
      free (p);
    e66c:	ebffef79 	bl	a458 <rpl_free>
}
    e670:	e3a00000 	mov	r0, #0
    e674:	e8bd8010 	pop	{r4, pc}
      errno = ENOMEM;
    e678:	eb003465 	bl	1b814 <__errno>
    e67c:	e3a0300c 	mov	r3, #12
    e680:	e5803000 	str	r3, [r0]
      return NULL;
    e684:	eafffff9 	b	e670 <rpl_realloc+0x2c>

0000e688 <rpl_vfprintf>:
/* Print formatted output to the stream FP.
   Return string length of formatted string.  On error, return a negative
   value.  */
int
vfprintf (FILE *fp, const char *format, va_list args)
{
    e688:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    e68c:	e24dde7d 	sub	sp, sp, #2000	@ 0x7d0
    e690:	e24dd00c 	sub	sp, sp, #12
    e694:	e1a03002 	mov	r3, r2
  char buf[2000];
  char *output;
  size_t len;
  size_t lenbuf = sizeof (buf);

  output = vasnprintf (buf, &lenbuf, format, args);
    e698:	e28d7008 	add	r7, sp, #8
  size_t lenbuf = sizeof (buf);
    e69c:	e3a0ce7d 	mov	ip, #2000	@ 0x7d0
  output = vasnprintf (buf, &lenbuf, format, args);
    e6a0:	e1a02001 	mov	r2, r1
{
    e6a4:	e1a06000 	mov	r6, r0
  output = vasnprintf (buf, &lenbuf, format, args);
    e6a8:	e2471004 	sub	r1, r7, #4
    e6ac:	e1a00007 	mov	r0, r7
  size_t lenbuf = sizeof (buf);
    e6b0:	e58dc004 	str	ip, [sp, #4]
  output = vasnprintf (buf, &lenbuf, format, args);
    e6b4:	eb000819 	bl	10720 <rpl_vasnprintf>
  len = lenbuf;

  if (!output)
    e6b8:	e2505000 	subs	r5, r0, #0
  len = lenbuf;
    e6bc:	e59d4004 	ldr	r4, [sp, #4]
  if (!output)
    e6c0:	0a000015 	beq	e71c <rpl_vfprintf+0x94>
    {
      fseterr (fp);
      return -1;
    }

  if (fwrite (output, 1, len, fp) < len)
    e6c4:	e1a03006 	mov	r3, r6
    e6c8:	e1a02004 	mov	r2, r4
    e6cc:	e3a01001 	mov	r1, #1
    e6d0:	eb0029cd 	bl	18e0c <fwrite>
    e6d4:	e1500004 	cmp	r0, r4
    e6d8:	3a000009 	bcc	e704 <rpl_vfprintf+0x7c>
      if (output != buf)
        free (output);
      return -1;
    }

  if (output != buf)
    e6dc:	e1550007 	cmp	r5, r7
    e6e0:	0a000001 	beq	e6ec <rpl_vfprintf+0x64>
    free (output);
    e6e4:	e1a00005 	mov	r0, r5
    e6e8:	ebffef5a 	bl	a458 <rpl_free>

  if (len > INT_MAX)
    e6ec:	e3540000 	cmp	r4, #0
    e6f0:	e1a00004 	mov	r0, r4
    e6f4:	ba00000b 	blt	e728 <rpl_vfprintf+0xa0>
      fseterr (fp);
      return -1;
    }

  return len;
}
    e6f8:	e28dde7d 	add	sp, sp, #2000	@ 0x7d0
    e6fc:	e28dd00c 	add	sp, sp, #12
    e700:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
      if (output != buf)
    e704:	e1550007 	cmp	r5, r7
    e708:	0a000001 	beq	e714 <rpl_vfprintf+0x8c>
        free (output);
    e70c:	e1a00005 	mov	r0, r5
    e710:	ebffef50 	bl	a458 <rpl_free>
      return -1;
    e714:	e3e00000 	mvn	r0, #0
    e718:	eafffff6 	b	e6f8 <rpl_vfprintf+0x70>
      fseterr (fp);
    e71c:	e1a00006 	mov	r0, r6
    e720:	eb00003f 	bl	e824 <fseterr>
      return -1;
    e724:	eafffffa 	b	e714 <rpl_vfprintf+0x8c>
      errno = EOVERFLOW;
    e728:	eb003439 	bl	1b814 <__errno>
    e72c:	e3a0208b 	mov	r2, #139	@ 0x8b
    e730:	e1a03000 	mov	r3, r0
    e734:	e5832000 	str	r2, [r3]
      fseterr (fp);
    e738:	e1a00006 	mov	r0, r6
    e73c:	eb000038 	bl	e824 <fseterr>
      return -1;
    e740:	eafffff3 	b	e714 <rpl_vfprintf+0x8c>

0000e744 <c_strcasecmp>:
{
  register const unsigned char *p1 = (const unsigned char *) s1;
  register const unsigned char *p2 = (const unsigned char *) s2;
  unsigned char c1, c2;

  if (p1 == p2)
    e744:	e1500001 	cmp	r0, r1
    e748:	0a000019 	beq	e7b4 <c_strcasecmp+0x70>
    e74c:	e240c001 	sub	ip, r0, #1
    e750:	e2411001 	sub	r1, r1, #1
{
    e754:	e92d4010 	push	{r4, lr}
    e758:	ea000006 	b	e778 <c_strcasecmp+0x34>
}

C_CTYPE_INLINE int
c_tolower (int c)
{
  switch (c)
    e75c:	e3540019 	cmp	r4, #25
    {
    _C_CTYPE_UPPER:
      return c - 'A' + 'a';
    e760:	e2830020 	add	r0, r3, #32
    e764:	9282e020 	addls	lr, r2, #32
    return 0;

  do
    {
      c1 = c_tolower (*p1);
    e768:	e6ef3070 	uxtb	r3, r0
      c2 = c_tolower (*p2);
    e76c:	96ef207e 	uxtbls	r2, lr
        break;

      ++p1;
      ++p2;
    }
  while (c1 == c2);
    e770:	e1530002 	cmp	r3, r2
    e774:	1a00000c 	bne	e7ac <c_strcasecmp+0x68>
      c1 = c_tolower (*p1);
    e778:	e5fc3001 	ldrb	r3, [ip, #1]!
      c2 = c_tolower (*p2);
    e77c:	e5f12001 	ldrb	r2, [r1, #1]!
  switch (c)
    e780:	e2430041 	sub	r0, r3, #65	@ 0x41
    e784:	e3500019 	cmp	r0, #25
    e788:	e2424041 	sub	r4, r2, #65	@ 0x41
    e78c:	e1a0e002 	mov	lr, r2
      c1 = c_tolower (*p1);
    e790:	e1a00003 	mov	r0, r3
    e794:	9afffff0 	bls	e75c <c_strcasecmp+0x18>
    e798:	e3540019 	cmp	r4, #25
      return c - 'A' + 'a';
    e79c:	9282e020 	addls	lr, r2, #32
      c2 = c_tolower (*p2);
    e7a0:	96ef207e 	uxtbls	r2, lr
      if (c1 == '\0')
    e7a4:	e3530000 	cmp	r3, #0
    e7a8:	1afffff0 	bne	e770 <c_strcasecmp+0x2c>

  if (UCHAR_MAX <= INT_MAX)
    return c1 - c2;
    e7ac:	e040000e 	sub	r0, r0, lr
  else
    /* On machines where 'char' and 'int' are types of the same size, the
       difference of two 'unsigned char' values - including the sign bit -
       doesn't fit in an 'int'.  */
    return _GL_CMP (c1, c2);
}
    e7b0:	e8bd8010 	pop	{r4, pc}
    return 0;
    e7b4:	e3a00000 	mov	r0, #0
}
    e7b8:	e12fff1e 	bx	lr

0000e7bc <c32isprint>:
  static_assert (sizeof (char32_t) == sizeof (wchar_t));

# if GL_CHAR32_T_IS_UNICODE && GL_CHAR32_T_VS_WCHAR_T_NEEDS_CONVERSION
  return UCS_FUNC (wc);
# else
  return WCHAR_FUNC (wc);
    e7bc:	ea0020ad 	b	16a78 <iswprint>

0000e7c0 <close_stream>:
   that writes to STREAM -- just let the internal stream state record
   the failure.  That's what the ferror test is checking below.  */

int
close_stream (FILE *stream)
{
    e7c0:	e92d4070 	push	{r4, r5, r6, lr}
    e7c4:	e1d040bc 	ldrh	r4, [r0, #12]

_ELIDABLE_INLINE int
__flbf (FILE *__fp) { return (__fp->_flags & __SLBF) != 0; }

_ELIDABLE_INLINE size_t
__fpending (FILE *__fp) { return __fp->_p - __fp->_bf._base; }
    e7c8:	e5906000 	ldr	r6, [r0]
    e7cc:	e2044040 	and	r4, r4, #64	@ 0x40
    e7d0:	e5905010 	ldr	r5, [r0, #16]
  const bool some_pending = (__fpending (stream) != 0);
  const bool prev_fail = (ferror (stream) != 0);
  const bool fclose_fail = (fclose (stream) != 0);
    e7d4:	ebffeec7 	bl	a2f8 <rpl_fclose>
     fclose failed with EBADF.  That can happen when a program like cp
     is invoked like this 'cp a b >&-' (i.e., with standard output
     closed) and doesn't generate any output (hence no previous error
     and nothing to be flushed).  */

  if (prev_fail || (fclose_fail && (some_pending || errno != EBADF)))
    e7d8:	e3540000 	cmp	r4, #0
  const bool fclose_fail = (fclose (stream) != 0);
    e7dc:	e1a04000 	mov	r4, r0
  if (prev_fail || (fclose_fail && (some_pending || errno != EBADF)))
    e7e0:	1a000009 	bne	e80c <close_stream+0x4c>
    e7e4:	e3500000 	cmp	r0, #0
    e7e8:	0a000005 	beq	e804 <close_stream+0x44>
    e7ec:	e1560005 	cmp	r6, r5
    e7f0:	1a000009 	bne	e81c <close_stream+0x5c>
    e7f4:	eb003406 	bl	1b814 <__errno>
    e7f8:	e5904000 	ldr	r4, [r0]
    e7fc:	e2544009 	subs	r4, r4, #9
    e800:	13e04000 	mvnne	r4, #0
        errno = 0;
      return EOF;
    }

  return 0;
}
    e804:	e1a00004 	mov	r0, r4
    e808:	e8bd8070 	pop	{r4, r5, r6, pc}
      if (! fclose_fail)
    e80c:	e3500000 	cmp	r0, #0
    e810:	1a000001 	bne	e81c <close_stream+0x5c>
        errno = 0;
    e814:	eb0033fe 	bl	1b814 <__errno>
    e818:	e5804000 	str	r4, [r0]
      return EOF;
    e81c:	e3e04000 	mvn	r4, #0
    e820:	eafffff7 	b	e804 <close_stream+0x44>

0000e824 <fseterr>:
#if defined _IO_EOF_SEEN || defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1
  /* GNU libc, BeOS, Haiku, Linux libc5 */
  fp->_flags |= _IO_ERR_SEEN;
#elif defined __sferror || defined __DragonFly__ || defined __ANDROID__
  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */
  fp_->_flags |= __SERR;
    e824:	e1d030bc 	ldrh	r3, [r0, #12]
    e828:	e3833040 	orr	r3, r3, #64	@ 0x40
    e82c:	e1c030bc 	strh	r3, [r0, #12]
    }
  errno = saved_errno;
#else
 #error "Please port gnulib fseterr.c to your platform! Look at the definitions of ferror and clearerr on your system, then report this to bug-gnulib."
#endif
}
    e830:	e12fff1e 	bx	lr

0000e834 <hard_locale>:
#include <stdlib.h>
#include <string.h>

bool
hard_locale (int category)
{
    e834:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
    e838:	e24ddf43 	sub	sp, sp, #268	@ 0x10c
  char locale[SETLOCALE_NULL_MAX];

  if (setlocale_null_r (category, locale, sizeof (locale)))
    e83c:	e3002101 	movw	r2, #257	@ 0x101
    e840:	e28d1004 	add	r1, sp, #4
    e844:	eb000132 	bl	ed14 <setlocale_null_r>
    e848:	e3500000 	cmp	r0, #0
    return false;
    e84c:	13a00000 	movne	r0, #0
  if (setlocale_null_r (category, locale, sizeof (locale)))
    e850:	1a000008 	bne	e878 <hard_locale+0x44>

  if (!(strcmp (locale, "C") == 0 || strcmp (locale, "POSIX") == 0))
    e854:	e1dd30b4 	ldrh	r3, [sp, #4]
    e858:	e3530043 	cmp	r3, #67	@ 0x43
    e85c:	0a000005 	beq	e878 <hard_locale+0x44>
    e860:	e59d2004 	ldr	r2, [sp, #4]
    e864:	e3043f50 	movw	r3, #20304	@ 0x4f50
    e868:	e3443953 	movt	r3, #18771	@ 0x4953
    e86c:	e1520003 	cmp	r2, r3
    e870:	0a000002 	beq	e880 <hard_locale+0x4c>
    e874:	e3a00001 	mov	r0, #1
  if (MB_CUR_MAX > 1)
    return true;
#endif

  return false;
}
    e878:	e28ddf43 	add	sp, sp, #268	@ 0x10c
    e87c:	e49df004 	pop	{pc}		@ (ldr pc, [sp], #4)
  if (!(strcmp (locale, "C") == 0 || strcmp (locale, "POSIX") == 0))
    e880:	e1dd30b8 	ldrh	r3, [sp, #8]
    e884:	e3530058 	cmp	r3, #88	@ 0x58
    e888:	1afffff9 	bne	e874 <hard_locale+0x40>
    e88c:	eafffff9 	b	e878 <hard_locale+0x44>

0000e890 <locale_charset>:
#if HAVE_LANGINFO_CODESET || defined WINDOWS_NATIVE || defined OS2

# if HAVE_LANGINFO_CODESET

  /* Most systems support nl_langinfo (CODESET) nowadays.  */
  codeset = nl_langinfo (CODESET);
    e890:	e3a00000 	mov	r0, #0
{
    e894:	e92d4010 	push	{r4, lr}
  codeset = nl_langinfo (CODESET);
    e898:	eb000031 	bl	e964 <rpl_nl_langinfo>
        codeset = resultbuf;
      }
    }
#  endif

  if (codeset == NULL)
    e89c:	e3500000 	cmp	r0, #0
    e8a0:	0a000005 	beq	e8bc <locale_charset+0x2c>
        codeset = "UTF-8";
# else
        /* Don't return an empty string.  GNU libc and GNU libiconv interpret
           the empty string as denoting "the locale's character encoding",
           thus GNU libiconv would call this function a second time.  */
        if (codeset[0] == '\0')
    e8a4:	e5d02000 	ldrb	r2, [r0]
          codeset = "ASCII";
    e8a8:	e3093140 	movw	r3, #37184	@ 0x9140
    e8ac:	e3403002 	movt	r3, #2
    e8b0:	e3520000 	cmp	r2, #0
    e8b4:	01a00003 	moveq	r0, r3
    e8b8:	e8bd8010 	pop	{r4, pc}
    e8bc:	e3090140 	movw	r0, #37184	@ 0x9140
    e8c0:	e3400002 	movt	r0, #2
  if (strcmp (codeset, "UTF-8") == 0 && MB_CUR_MAX_L (uselocale (NULL)) <= 1)
    codeset = "ASCII";
#endif

  return codeset;
}
    e8c4:	e8bd8010 	pop	{r4, pc}

0000e8c8 <mbrtoc32>:
mbrtoc32 (char32_t *pwc, const char *s, size_t n, mbstate_t *ps)
# undef mbrtoc32
{
  /* It's simpler to handle the case s == NULL upfront, than to worry about
     this case later, before every test of pwc and n.  */
  if (s == NULL)
    e8c8:	e3510000 	cmp	r1, #0
{
    e8cc:	e92d4030 	push	{r4, r5, lr}
    e8d0:	e1a0c003 	mov	ip, r3
    e8d4:	e24dd00c 	sub	sp, sp, #12
  if (s == NULL)
    e8d8:	0a000010 	beq	e920 <mbrtoc32+0x58>
          ret = (size_t) -1;
          errno = EILSEQ;
        }
    }
#  endif
  if (ret < (size_t) -2 && pwc != NULL)
    e8dc:	e2505000 	subs	r5, r0, #0
    ps = &internal_state;
    e8e0:	e30b3518 	movw	r3, #46360	@ 0xb518
  if (ret < (size_t) -2 && pwc != NULL)
    e8e4:	13a05001 	movne	r5, #1
  size_t ret = mbrtowc (&wc, s, n, ps);
    e8e8:	e35c0000 	cmp	ip, #0
    ps = &internal_state;
    e8ec:	e3403002 	movt	r3, #2
    e8f0:	e1a04000 	mov	r4, r0
  size_t ret = mbrtowc (&wc, s, n, ps);
    e8f4:	11a0300c 	movne	r3, ip
    e8f8:	e28d0004 	add	r0, sp, #4
    e8fc:	ebfff2d7 	bl	b460 <rpl_mbrtowc>
  if (ret < (size_t) -2 && pwc != NULL)
    e900:	e3700003 	cmn	r0, #3
    e904:	83a03000 	movhi	r3, #0
    e908:	93a03001 	movls	r3, #1
    e90c:	e1150003 	tst	r5, r3
    *pwc = wc;
    e910:	159d3004 	ldrne	r3, [sp, #4]
    e914:	15843000 	strne	r3, [r4]
  return ret;

# endif
}
    e918:	e28dd00c 	add	sp, sp, #12
    e91c:	e8bd8030 	pop	{r4, r5, pc}
  if (ps == NULL)
    e920:	e3530000 	cmp	r3, #0
    e924:	0a000006 	beq	e944 <mbrtoc32+0x7c>
  size_t ret = mbrtowc (&wc, s, n, ps);
    e928:	e3081d5c 	movw	r1, #36188	@ 0x8d5c
    e92c:	e3a02001 	mov	r2, #1
    e930:	e3401002 	movt	r1, #2
    e934:	e28d0004 	add	r0, sp, #4
    e938:	ebfff2c8 	bl	b460 <rpl_mbrtowc>
}
    e93c:	e28dd00c 	add	sp, sp, #12
    e940:	e8bd8030 	pop	{r4, r5, pc}
  size_t ret = mbrtowc (&wc, s, n, ps);
    e944:	e30b3518 	movw	r3, #46360	@ 0xb518
    e948:	e3081d5c 	movw	r1, #36188	@ 0x8d5c
    e94c:	e3403002 	movt	r3, #2
    e950:	e3a02001 	mov	r2, #1
    e954:	e3401002 	movt	r1, #2
    e958:	e28d0004 	add	r0, sp, #4
    e95c:	ebfff2bf 	bl	b460 <rpl_mbrtowc>
  if (ret < (size_t) -2 && pwc != NULL)
    e960:	eaffffec 	b	e918 <mbrtoc32+0x50>

0000e964 <rpl_nl_langinfo>:
# endif

char *
rpl_nl_langinfo (nl_item item)
{
  switch (item)
    e964:	e2403d9f 	sub	r3, r0, #10176	@ 0x27c0
    e968:	e2432018 	sub	r2, r3, #24
    e96c:	e352000b 	cmp	r2, #11
    case ALTMON_10:
    case ALTMON_11:
    case ALTMON_12:
      /* We don't ship the appropriate localizations with gnulib.  Therefore,
         treat ALTMON_i like MON_i.  */
      item = item - ALTMON_1 + MON_1;
    e970:	92430003 	subls	r0, r3, #3
      return (char *) "^[nN]";
# endif
    default:
      break;
    }
  return nl_langinfo_with_lock (item);
    e974:	ea0032fb 	b	1b568 <nl_langinfo>

0000e978 <print_and_abort>:
     like this and the translation should be reused instead of creating
     a very similar string which requires a separate translation.  */
#  ifdef _LIBC
  (void) __fxprintf (NULL, "%s\n", _("memory exhausted"));
#  else
  fprintf (stderr, "%s\n", _("memory exhausted"));
    e978:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
    e97c:	e3092120 	movw	r2, #37152	@ 0x9120
    e980:	e3403002 	movt	r3, #2
    e984:	e3081e3c 	movw	r1, #36412	@ 0x8e3c
    e988:	e5933000 	ldr	r3, [r3]
    e98c:	e3402002 	movt	r2, #2
    e990:	e3401002 	movt	r1, #2
{
    e994:	e92d4010 	push	{r4, lr}
  fprintf (stderr, "%s\n", _("memory exhausted"));
    e998:	e593000c 	ldr	r0, [r3, #12]
    e99c:	eb002760 	bl	18724 <fprintf>
#  endif
  exit (obstack_exit_failure);
    e9a0:	e30b3014 	movw	r3, #45076	@ 0xb014
    e9a4:	e3403002 	movt	r3, #2
    e9a8:	e5930000 	ldr	r0, [r3]
    e9ac:	eb001f7a 	bl	1679c <exit>

0000e9b0 <_obstack_begin_worker>:
{
    e9b0:	e92d4070 	push	{r4, r5, r6, lr}
  if (alignment == 0)
    e9b4:	e2525000 	subs	r5, r2, #0
  if (h->use_extra_arg)
    e9b8:	e5d02028 	ldrb	r2, [r0, #40]	@ 0x28
  h->alignment_mask = alignment - 1;
    e9bc:	12456001 	subne	r6, r5, #1
    e9c0:	03a06007 	moveq	r6, #7
      size = 4096 - extra;
    e9c4:	e3003fe8 	movw	r3, #4072	@ 0xfe8
    alignment = DEFAULT_ALIGNMENT;
    e9c8:	03a05008 	moveq	r5, #8
      size = 4096 - extra;
    e9cc:	e3510000 	cmp	r1, #0
    e9d0:	01a01003 	moveq	r1, r3
  if (h->use_extra_arg)
    e9d4:	e3120001 	tst	r2, #1
    e9d8:	e590301c 	ldr	r3, [r0, #28]
{
    e9dc:	e1a04000 	mov	r4, r0
  h->alignment_mask = alignment - 1;
    e9e0:	e5806018 	str	r6, [r0, #24]
  h->chunk_size = size;
    e9e4:	e5801000 	str	r1, [r0]
  if (h->use_extra_arg)
    e9e8:	0a000016 	beq	ea48 <_obstack_begin_worker+0x98>
    return h->chunkfun.extra (h->extra_arg, size);
    e9ec:	e5900024 	ldr	r0, [r0, #36]	@ 0x24
    e9f0:	e12fff33 	blx	r3
    e9f4:	e1a03000 	mov	r3, r0
  if (!chunk)
    e9f8:	e3530000 	cmp	r3, #0
  chunk = h->chunk = call_chunkfun (h, h->chunk_size);
    e9fc:	e5843004 	str	r3, [r4, #4]
  if (!chunk)
    ea00:	0a000014 	beq	ea58 <_obstack_begin_worker+0xa8>
  h->next_free = h->object_base = __PTR_ALIGN ((char *) chunk, chunk->contents,
    ea04:	e2832008 	add	r2, r3, #8
  h->chunk_limit = chunk->limit = (char *) chunk + h->chunk_size;
    ea08:	e5940000 	ldr	r0, [r4]
  h->next_free = h->object_base = __PTR_ALIGN ((char *) chunk, chunk->contents,
    ea0c:	e2651000 	rsb	r1, r5, #0
    ea10:	e0822006 	add	r2, r2, r6
    ea14:	e0022001 	and	r2, r2, r1
  h->maybe_empty_object = 0;
    ea18:	e5d41028 	ldrb	r1, [r4, #40]	@ 0x28
  h->next_free = h->object_base = __PTR_ALIGN ((char *) chunk, chunk->contents,
    ea1c:	e5842008 	str	r2, [r4, #8]
  chunk->prev = 0;
    ea20:	e3a0c000 	mov	ip, #0
  h->next_free = h->object_base = __PTR_ALIGN ((char *) chunk, chunk->contents,
    ea24:	e584200c 	str	r2, [r4, #12]
  h->chunk_limit = chunk->limit = (char *) chunk + h->chunk_size;
    ea28:	e0832000 	add	r2, r3, r0
    ea2c:	e5832000 	str	r2, [r3]
}
    ea30:	e3a00001 	mov	r0, #1
  h->chunk_limit = chunk->limit = (char *) chunk + h->chunk_size;
    ea34:	e5842010 	str	r2, [r4, #16]
  h->maybe_empty_object = 0;
    ea38:	e3c12006 	bic	r2, r1, #6
  chunk->prev = 0;
    ea3c:	e583c004 	str	ip, [r3, #4]
  h->maybe_empty_object = 0;
    ea40:	e5c42028 	strb	r2, [r4, #40]	@ 0x28
}
    ea44:	e8bd8070 	pop	{r4, r5, r6, pc}
    return h->chunkfun.plain (size);
    ea48:	e1a00001 	mov	r0, r1
    ea4c:	e12fff33 	blx	r3
    ea50:	e1a03000 	mov	r3, r0
    ea54:	eaffffe7 	b	e9f8 <_obstack_begin_worker+0x48>
    (*obstack_alloc_failed_handler) ();
    ea58:	e30b3064 	movw	r3, #45156	@ 0xb064
    ea5c:	e3403002 	movt	r3, #2
    ea60:	e5933000 	ldr	r3, [r3]
    ea64:	e12fff33 	blx	r3

0000ea68 <_obstack_begin>:
  h->chunkfun.plain = chunkfun;
    ea68:	e580301c 	str	r3, [r0, #28]
  h->use_extra_arg = 0;
    ea6c:	e5d03028 	ldrb	r3, [r0, #40]	@ 0x28
    ea70:	e3c33001 	bic	r3, r3, #1
    ea74:	e5c03028 	strb	r3, [r0, #40]	@ 0x28
{
    ea78:	e59d3000 	ldr	r3, [sp]
  h->freefun.plain = freefun;
    ea7c:	e5803020 	str	r3, [r0, #32]
  return _obstack_begin_worker (h, size, alignment);
    ea80:	eaffffca 	b	e9b0 <_obstack_begin_worker>

0000ea84 <_obstack_begin_1>:
  h->chunkfun.extra = chunkfun;
    ea84:	e580301c 	str	r3, [r0, #28]
  h->use_extra_arg = 1;
    ea88:	e5d03028 	ldrb	r3, [r0, #40]	@ 0x28
    ea8c:	e3833001 	orr	r3, r3, #1
    ea90:	e5c03028 	strb	r3, [r0, #40]	@ 0x28
{
    ea94:	e59d3000 	ldr	r3, [sp]
  h->freefun.extra = freefun;
    ea98:	e5803020 	str	r3, [r0, #32]
{
    ea9c:	e59d3004 	ldr	r3, [sp, #4]
  h->extra_arg = arg;
    eaa0:	e5803024 	str	r3, [r0, #36]	@ 0x24
  return _obstack_begin_worker (h, size, alignment);
    eaa4:	eaffffc1 	b	e9b0 <_obstack_begin_worker>

0000eaa8 <_obstack_newchunk>:
  size_t obj_size = h->next_free - h->object_base;
    eaa8:	e5902008 	ldr	r2, [r0, #8]
{
    eaac:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    eab0:	e1a04000 	mov	r4, r0
  size_t obj_size = h->next_free - h->object_base;
    eab4:	e590500c 	ldr	r5, [r0, #12]
    eab8:	e5903018 	ldr	r3, [r0, #24]
    eabc:	e0455002 	sub	r5, r5, r2
  if (new_size < h->chunk_size)
    eac0:	e590c000 	ldr	ip, [r0]
    eac4:	e0951001 	adds	r1, r5, r1
  struct _obstack_chunk *old_chunk = h->chunk;
    eac8:	e5907004 	ldr	r7, [r0, #4]
  size_t sum1 = obj_size + length;
    eacc:	23a00001 	movcs	r0, #1
    ead0:	33a00000 	movcc	r0, #0
  size_t sum2 = sum1 + h->alignment_mask;
    ead4:	e0933001 	adds	r3, r3, r1
  if (obj_size <= sum1 && sum1 <= sum2)
    ead8:	e2200001 	eor	r0, r0, #1
  size_t new_size = sum2 + (obj_size >> 3) + 100;
    eadc:	e08311a5 	add	r1, r3, r5, lsr #3
    eae0:	23a02001 	movcs	r2, #1
    eae4:	33a02000 	movcc	r2, #0
  if (new_size < h->chunk_size)
    eae8:	e153000c 	cmp	r3, ip
  size_t new_size = sum2 + (obj_size >> 3) + 100;
    eaec:	e2811064 	add	r1, r1, #100	@ 0x64
  if (new_size < h->chunk_size)
    eaf0:	31a0300c 	movcc	r3, ip
  if (obj_size <= sum1 && sum1 <= sum2)
    eaf4:	e2222001 	eor	r2, r2, #1
  if (new_size < h->chunk_size)
    eaf8:	e1510003 	cmp	r1, r3
    eafc:	21a06001 	movcs	r6, r1
    eb00:	31a06003 	movcc	r6, r3
  if (obj_size <= sum1 && sum1 <= sum2)
    eb04:	e1100002 	tst	r0, r2
    eb08:	0a000037 	beq	ebec <_obstack_newchunk+0x144>
  if (h->use_extra_arg)
    eb0c:	e5d43028 	ldrb	r3, [r4, #40]	@ 0x28
    eb10:	e594201c 	ldr	r2, [r4, #28]
    eb14:	e3130001 	tst	r3, #1
    eb18:	1a000022 	bne	eba8 <_obstack_newchunk+0x100>
    return h->chunkfun.plain (size);
    eb1c:	e1a00006 	mov	r0, r6
    eb20:	e12fff32 	blx	r2
    eb24:	e1a08000 	mov	r8, r0
  if (!new_chunk)
    eb28:	e3580000 	cmp	r8, #0
    eb2c:	0a00002e 	beq	ebec <_obstack_newchunk+0x144>
    __PTR_ALIGN ((char *) new_chunk, new_chunk->contents, h->alignment_mask);
    eb30:	e5943018 	ldr	r3, [r4, #24]
  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;
    eb34:	e0881006 	add	r1, r8, r6
    eb38:	e1a06008 	mov	r6, r8
  h->chunk = new_chunk;
    eb3c:	e5848004 	str	r8, [r4, #4]
  new_chunk->prev = old_chunk;
    eb40:	e5887004 	str	r7, [r8, #4]
    eb44:	e1a02005 	mov	r2, r5
  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;
    eb48:	e5841010 	str	r1, [r4, #16]
    eb4c:	e4861008 	str	r1, [r6], #8
    __PTR_ALIGN ((char *) new_chunk, new_chunk->contents, h->alignment_mask);
    eb50:	e0866003 	add	r6, r6, r3
    eb54:	e1c66003 	bic	r6, r6, r3
    eb58:	e5941008 	ldr	r1, [r4, #8]
    eb5c:	e1a00006 	mov	r0, r6
    eb60:	eb0044c6 	bl	1fe80 <memcpy>
  if (!h->maybe_empty_object
    eb64:	e5d42028 	ldrb	r2, [r4, #40]	@ 0x28
    eb68:	e3120002 	tst	r2, #2
    eb6c:	1a000006 	bne	eb8c <_obstack_newchunk+0xe4>
          == __PTR_ALIGN ((char *) old_chunk, old_chunk->contents,
    eb70:	e5941018 	ldr	r1, [r4, #24]
    eb74:	e2873008 	add	r3, r7, #8
      && (h->object_base
    eb78:	e5940008 	ldr	r0, [r4, #8]
          == __PTR_ALIGN ((char *) old_chunk, old_chunk->contents,
    eb7c:	e0833001 	add	r3, r3, r1
    eb80:	e1c33001 	bic	r3, r3, r1
      && (h->object_base
    eb84:	e1500003 	cmp	r0, r3
    eb88:	0a00000b 	beq	ebbc <_obstack_newchunk+0x114>
  h->maybe_empty_object = 0;
    eb8c:	e5d43028 	ldrb	r3, [r4, #40]	@ 0x28
  h->next_free = h->object_base + obj_size;
    eb90:	e0865005 	add	r5, r6, r5
  h->object_base = object_base;
    eb94:	e5846008 	str	r6, [r4, #8]
  h->next_free = h->object_base + obj_size;
    eb98:	e584500c 	str	r5, [r4, #12]
  h->maybe_empty_object = 0;
    eb9c:	e3c33002 	bic	r3, r3, #2
    eba0:	e5c43028 	strb	r3, [r4, #40]	@ 0x28
}
    eba4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    return h->chunkfun.extra (h->extra_arg, size);
    eba8:	e5940024 	ldr	r0, [r4, #36]	@ 0x24
    ebac:	e1a01006 	mov	r1, r6
    ebb0:	e12fff32 	blx	r2
    ebb4:	e1a08000 	mov	r8, r0
    ebb8:	eaffffda 	b	eb28 <_obstack_newchunk+0x80>
      new_chunk->prev = old_chunk->prev;
    ebbc:	e5973004 	ldr	r3, [r7, #4]
  if (h->use_extra_arg)
    ebc0:	e3120001 	tst	r2, #1
      new_chunk->prev = old_chunk->prev;
    ebc4:	e5883004 	str	r3, [r8, #4]
  if (h->use_extra_arg)
    ebc8:	e5943020 	ldr	r3, [r4, #32]
    ebcc:	0a000003 	beq	ebe0 <_obstack_newchunk+0x138>
    h->freefun.extra (h->extra_arg, old_chunk);
    ebd0:	e5940024 	ldr	r0, [r4, #36]	@ 0x24
    ebd4:	e1a01007 	mov	r1, r7
    ebd8:	e12fff33 	blx	r3
    ebdc:	eaffffea 	b	eb8c <_obstack_newchunk+0xe4>
    h->freefun.plain (old_chunk);
    ebe0:	e1a00007 	mov	r0, r7
    ebe4:	e12fff33 	blx	r3
    ebe8:	eaffffe7 	b	eb8c <_obstack_newchunk+0xe4>
    (*obstack_alloc_failed_handler)();
    ebec:	e30b3064 	movw	r3, #45156	@ 0xb064
    ebf0:	e3403002 	movt	r3, #2
    ebf4:	e5933000 	ldr	r3, [r3]
    ebf8:	e12fff33 	blx	r3

0000ebfc <_obstack_allocated_p>:
      plp = lp->prev;
    ebfc:	e5900004 	ldr	r0, [r0, #4]
  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))
    ec00:	e3500000 	cmp	r0, #0
    ec04:	012fff1e 	bxeq	lr
    ec08:	e1510000 	cmp	r1, r0
    ec0c:	9afffffa 	bls	ebfc <_obstack_allocated_p>
    ec10:	e5903000 	ldr	r3, [r0]
    ec14:	e1530001 	cmp	r3, r1
    ec18:	3afffff7 	bcc	ebfc <_obstack_allocated_p>
    ec1c:	e3a00001 	mov	r0, #1
}
    ec20:	e12fff1e 	bx	lr

0000ec24 <_obstack_free>:
{
    ec24:	e92d4070 	push	{r4, r5, r6, lr}
    ec28:	e1a06001 	mov	r6, r1
  lp = h->chunk;
    ec2c:	e5901004 	ldr	r1, [r0, #4]
  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))
    ec30:	e3510000 	cmp	r1, #0
    ec34:	11a04000 	movne	r4, r0
    ec38:	1a000008 	bne	ec60 <_obstack_free+0x3c>
    ec3c:	ea000019 	b	eca8 <_obstack_free+0x84>
    h->freefun.extra (h->extra_arg, old_chunk);
    ec40:	e5940024 	ldr	r0, [r4, #36]	@ 0x24
    ec44:	e12fff33 	blx	r3
      h->maybe_empty_object = 1;
    ec48:	e5d43028 	ldrb	r3, [r4, #40]	@ 0x28
  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))
    ec4c:	e3550000 	cmp	r5, #0
      h->maybe_empty_object = 1;
    ec50:	e3833002 	orr	r3, r3, #2
    ec54:	e5c43028 	strb	r3, [r4, #40]	@ 0x28
  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))
    ec58:	0a000012 	beq	eca8 <_obstack_free+0x84>
    ec5c:	e1a01005 	mov	r1, r5
    ec60:	e1560001 	cmp	r6, r1
    ec64:	9a000002 	bls	ec74 <_obstack_free+0x50>
    ec68:	e5913000 	ldr	r3, [r1]
    ec6c:	e1530006 	cmp	r3, r6
    ec70:	2a000007 	bcs	ec94 <_obstack_free+0x70>
  if (h->use_extra_arg)
    ec74:	e5d42028 	ldrb	r2, [r4, #40]	@ 0x28
      plp = lp->prev;
    ec78:	e5915004 	ldr	r5, [r1, #4]
  if (h->use_extra_arg)
    ec7c:	e5943020 	ldr	r3, [r4, #32]
    ec80:	e3120001 	tst	r2, #1
    ec84:	1affffed 	bne	ec40 <_obstack_free+0x1c>
    h->freefun.plain (old_chunk);
    ec88:	e1a00001 	mov	r0, r1
    ec8c:	e12fff33 	blx	r3
    ec90:	eaffffec 	b	ec48 <_obstack_free+0x24>
      h->object_base = h->next_free = (char *) (obj);
    ec94:	e584600c 	str	r6, [r4, #12]
    ec98:	e5846008 	str	r6, [r4, #8]
      h->chunk_limit = lp->limit;
    ec9c:	e5843010 	str	r3, [r4, #16]
      h->chunk = lp;
    eca0:	e5841004 	str	r1, [r4, #4]
}
    eca4:	e8bd8070 	pop	{r4, r5, r6, pc}
  else if (obj != 0)
    eca8:	e3560000 	cmp	r6, #0
    ecac:	08bd8070 	popeq	{r4, r5, r6, pc}
    abort ();
    ecb0:	eb001e95 	bl	1670c <abort>

0000ecb4 <_obstack_memory_used>:
  for (lp = h->chunk; lp != 0; lp = lp->prev)
    ecb4:	e5903004 	ldr	r3, [r0, #4]
    ecb8:	e3530000 	cmp	r3, #0
    ecbc:	0a000007 	beq	ece0 <_obstack_memory_used+0x2c>
  _OBSTACK_SIZE_T nbytes = 0;
    ecc0:	e3a00000 	mov	r0, #0
      nbytes += lp->limit - (char *) lp;
    ecc4:	e5932000 	ldr	r2, [r3]
    ecc8:	e0422003 	sub	r2, r2, r3
  for (lp = h->chunk; lp != 0; lp = lp->prev)
    eccc:	e5933004 	ldr	r3, [r3, #4]
      nbytes += lp->limit - (char *) lp;
    ecd0:	e0800002 	add	r0, r0, r2
  for (lp = h->chunk; lp != 0; lp = lp->prev)
    ecd4:	e3530000 	cmp	r3, #0
    ecd8:	1afffff9 	bne	ecc4 <_obstack_memory_used+0x10>
    ecdc:	e12fff1e 	bx	lr
  _OBSTACK_SIZE_T nbytes = 0;
    ece0:	e1a00003 	mov	r0, r3
}
    ece4:	e12fff1e 	bx	lr

0000ece8 <rpl_reallocarray>:

void *
reallocarray (void *ptr, size_t nmemb, size_t size)
{
  size_t nbytes;
  if (ckd_mul (&nbytes, nmemb, size))
    ece8:	e0821291 	umull	r1, r2, r1, r2
    ecec:	e3520000 	cmp	r2, #0
    ecf0:	1a000000 	bne	ecf8 <rpl_reallocarray+0x10>
      errno = ENOMEM;
      return NULL;
    }

  /* Rely on the semantics of GNU realloc.  */
  return realloc (ptr, nbytes);
    ecf4:	eafffe52 	b	e644 <rpl_realloc>
{
    ecf8:	e92d4010 	push	{r4, lr}
      errno = ENOMEM;
    ecfc:	eb0032c4 	bl	1b814 <__errno>
    ed00:	e3a0200c 	mov	r2, #12
    ed04:	e1a03000 	mov	r3, r0
    ed08:	e5832000 	str	r2, [r3]
}
    ed0c:	e3a00000 	mov	r0, #0
    ed10:	e8bd8010 	pop	{r4, pc}

0000ed14 <setlocale_null_r>:

#endif

int
setlocale_null_r (int category, char *buf, size_t bufsize)
{
    ed14:	e92d4070 	push	{r4, r5, r6, lr}
    ed18:	e1a06001 	mov	r6, r1
  const char *result = setlocale (category, NULL);
    ed1c:	e3a01000 	mov	r1, #0
{
    ed20:	e1a04002 	mov	r4, r2
  const char *result = setlocale (category, NULL);
    ed24:	eb0030ed 	bl	1b0e0 <setlocale>
  if (result == NULL)
    ed28:	e2505000 	subs	r5, r0, #0
    ed2c:	0a000013 	beq	ed80 <setlocale_null_r+0x6c>
      size_t length = strlen (result);
    ed30:	fa0045d2 	blx	20480 <strlen>
      if (length < bufsize)
    ed34:	e1540000 	cmp	r4, r0
    ed38:	9a000005 	bls	ed54 <setlocale_null_r+0x40>
    ed3c:	e2802001 	add	r2, r0, #1
    ed40:	e1a01005 	mov	r1, r5
    ed44:	e1a00006 	mov	r0, r6
    ed48:	eb00444c 	bl	1fe80 <memcpy>
          return 0;
    ed4c:	e3a00000 	mov	r0, #0
    ed50:	e8bd8070 	pop	{r4, r5, r6, pc}
          if (bufsize > 0)
    ed54:	e3540000 	cmp	r4, #0
    ed58:	0a000006 	beq	ed78 <setlocale_null_r+0x64>
              memcpy (buf, result, bufsize - 1);
    ed5c:	e2444001 	sub	r4, r4, #1
    ed60:	e1a01005 	mov	r1, r5
    ed64:	e1a02004 	mov	r2, r4
    ed68:	e1a00006 	mov	r0, r6
    ed6c:	eb004443 	bl	1fe80 <memcpy>
              buf[bufsize - 1] = '\0';
    ed70:	e3a03000 	mov	r3, #0
    ed74:	e7c63004 	strb	r3, [r6, r4]
          return ERANGE;
    ed78:	e3a00022 	mov	r0, #34	@ 0x22

  return setlocale_null_with_lock (category, buf, bufsize);

# endif
#endif
}
    ed7c:	e8bd8070 	pop	{r4, r5, r6, pc}
      if (bufsize > 0)
    ed80:	e3540000 	cmp	r4, #0
      return EINVAL;
    ed84:	e3a00016 	mov	r0, #22
        buf[0] = '\0';
    ed88:	15c65000 	strbne	r5, [r6]
    ed8c:	e8bd8070 	pop	{r4, r5, r6, pc}

0000ed90 <setlocale_null>:
  const char *result = setlocale (category, NULL);
    ed90:	e3a01000 	mov	r1, #0
    ed94:	ea0030d1 	b	1b0e0 <setlocale>

0000ed98 <is_borderline>:
/* Tests whether a string of digits consists of exactly PRECISION zeroes and
   a single '1' digit.  */
static int
is_borderline (const char *digits, size_t precision)
{
  for (; precision > 0; precision--, digits++)
    ed98:	e3510000 	cmp	r1, #0
    ed9c:	0a000008 	beq	edc4 <is_borderline+0x2c>
    eda0:	e0801001 	add	r1, r0, r1
    eda4:	ea000001 	b	edb0 <is_borderline+0x18>
    eda8:	e1500001 	cmp	r0, r1
    edac:	0a000004 	beq	edc4 <is_borderline+0x2c>
    if (*digits != '0')
    edb0:	e4d03001 	ldrb	r3, [r0], #1
    edb4:	e3530030 	cmp	r3, #48	@ 0x30
    edb8:	0afffffa 	beq	eda8 <is_borderline+0x10>
      return 0;
    edbc:	e3a00000 	mov	r0, #0
  if (*digits != '1')
    return 0;
  digits++;
  return *digits == '\0';
}
    edc0:	e12fff1e 	bx	lr
  if (*digits != '1')
    edc4:	e5d03000 	ldrb	r3, [r0]
    edc8:	e3530031 	cmp	r3, #49	@ 0x31
    edcc:	1afffffa 	bne	edbc <is_borderline+0x24>
  return *digits == '\0';
    edd0:	e5d00001 	ldrb	r0, [r0, #1]
    edd4:	e16f0f10 	clz	r0, r0
    edd8:	e1a002a0 	lsr	r0, r0, #5
    eddc:	e12fff1e 	bx	lr

0000ede0 <multiply>:
{
    ede0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ede4:	e24dd024 	sub	sp, sp, #36	@ 0x24
    ede8:	e28dc010 	add	ip, sp, #16
      p2 = src2.limbs;
    edec:	e1500002 	cmp	r0, r2
    edf0:	91a08000 	movls	r8, r0
    edf4:	e1a05000 	mov	r5, r0
{
    edf8:	e88c000c 	stm	ip, {r2, r3}
    edfc:	e1a03002 	mov	r3, r2
    ee00:	e59d9014 	ldr	r9, [sp, #20]
      p2 = src2.limbs;
    ee04:	81a08003 	movhi	r8, r3
    ee08:	e1a06001 	mov	r6, r1
    ee0c:	81a05000 	movhi	r5, r0
    ee10:	81a06001 	movhi	r6, r1
    ee14:	91a05003 	movls	r5, r3
    ee18:	e1a02009 	mov	r2, r9
    ee1c:	91a09001 	movls	r9, r1
    ee20:	91a06002 	movls	r6, r2
  if (len1 == 0)
    ee24:	e3580000 	cmp	r8, #0
{
    ee28:	e28de020 	add	lr, sp, #32
    ee2c:	e90e0003 	stmdb	lr, {r0, r1}
  if (len1 == 0)
    ee30:	1a000009 	bne	ee5c <multiply+0x7c>
      dest->nlimbs = 0;
    ee34:	e59d3048 	ldr	r3, [sp, #72]	@ 0x48
      dest->limbs = (mp_limb_t *) malloc (1);
    ee38:	e3a00001 	mov	r0, #1
      dest->nlimbs = 0;
    ee3c:	e5838000 	str	r8, [r3]
      dest->limbs = (mp_limb_t *) malloc (1);
    ee40:	ebfffdf3 	bl	e614 <rpl_malloc>
    ee44:	e1a07000 	mov	r7, r0
    ee48:	e59d3048 	ldr	r3, [sp, #72]	@ 0x48
    ee4c:	e5837004 	str	r7, [r3, #4]
}
    ee50:	e1a00007 	mov	r0, r7
    ee54:	e28dd024 	add	sp, sp, #36	@ 0x24
    ee58:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
      dlen = len1 + len2;
    ee5c:	e0884005 	add	r4, r8, r5
      dp = (mp_limb_t *) malloc (dlen * sizeof (mp_limb_t));
    ee60:	e1a03104 	lsl	r3, r4, #2
    ee64:	e1a00003 	mov	r0, r3
    ee68:	e58d300c 	str	r3, [sp, #12]
    ee6c:	ebfffde8 	bl	e614 <rpl_malloc>
      if (dp == NULL)
    ee70:	e2507000 	subs	r7, r0, #0
    ee74:	0afffff5 	beq	ee50 <multiply+0x70>
      for (k = len2; k > 0; )
    ee78:	e3550000 	cmp	r5, #0
    ee7c:	0a000033 	beq	ef50 <multiply+0x170>
        dp[--k] = 0;
    ee80:	e1a0b105 	lsl	fp, r5, #2
    ee84:	e3a01000 	mov	r1, #0
    ee88:	e1a0200b 	mov	r2, fp
    ee8c:	eb002e07 	bl	1a6b0 <memset>
      for (i = 0; i < len1; i++)
    ee90:	e0893108 	add	r3, r9, r8, lsl #2
    ee94:	e1a0c009 	mov	ip, r9
    ee98:	e087a00b 	add	sl, r7, fp
    ee9c:	e88d00c8 	stm	sp, {r3, r6, r7}
    eea0:	e086900b 	add	r9, r6, fp
          mp_twolimb_t carry = 0;
    eea4:	e3a08000 	mov	r8, #0
    eea8:	e1a07004 	mov	r7, r4
          for (j = 0; j < len2; j++)
    eeac:	e3550000 	cmp	r5, #0
          mp_limb_t digit1 = p1[i];
    eeb0:	e49c6004 	ldr	r6, [ip], #4
          for (j = 0; j < len2; j++)
    eeb4:	0a00001f 	beq	ef38 <multiply+0x158>
    eeb8:	e59d0004 	ldr	r0, [sp, #4]
    eebc:	e04ae00b 	sub	lr, sl, fp
          mp_twolimb_t carry = 0;
    eec0:	e3a01000 	mov	r1, #0
    eec4:	e1a03006 	mov	r3, r6
              mp_limb_t digit2 = p2[j];
    eec8:	e4904004 	ldr	r4, [r0], #4
              carry += dp[i + j];
    eecc:	e1a06008 	mov	r6, r8
    eed0:	e59e2000 	ldr	r2, [lr]
    eed4:	e0a62394 	umlal	r2, r6, r4, r3
    eed8:	e0922001 	adds	r2, r2, r1
              carry = carry >> GMP_LIMB_BITS;
    eedc:	e2a61000 	adc	r1, r6, #0
          for (j = 0; j < len2; j++)
    eee0:	e1590000 	cmp	r9, r0
              dp[i + j] = (mp_limb_t) carry;
    eee4:	e48e2004 	str	r2, [lr], #4
          for (j = 0; j < len2; j++)
    eee8:	1afffff6 	bne	eec8 <multiply+0xe8>
      for (i = 0; i < len1; i++)
    eeec:	e59d3000 	ldr	r3, [sp]
          dp[i + len2] = (mp_limb_t) carry;
    eef0:	e48a1004 	str	r1, [sl], #4
      for (i = 0; i < len1; i++)
    eef4:	e153000c 	cmp	r3, ip
    eef8:	1affffeb 	bne	eeac <multiply+0xcc>
      while (dlen > 0 && dp[dlen - 1] == 0)
    eefc:	e1a04007 	mov	r4, r7
    ef00:	e59d7008 	ldr	r7, [sp, #8]
    ef04:	e3540000 	cmp	r4, #0
    ef08:	0a000007 	beq	ef2c <multiply+0x14c>
    ef0c:	e59d300c 	ldr	r3, [sp, #12]
    ef10:	e0873003 	add	r3, r7, r3
    ef14:	ea000001 	b	ef20 <multiply+0x140>
    ef18:	e2544001 	subs	r4, r4, #1
    ef1c:	0a000002 	beq	ef2c <multiply+0x14c>
    ef20:	e5332004 	ldr	r2, [r3, #-4]!
    ef24:	e3520000 	cmp	r2, #0
    ef28:	0afffffa 	beq	ef18 <multiply+0x138>
      dest->nlimbs = dlen;
    ef2c:	e59d3048 	ldr	r3, [sp, #72]	@ 0x48
    ef30:	e5834000 	str	r4, [r3]
      dest->limbs = dp;
    ef34:	eaffffc3 	b	ee48 <multiply+0x68>
      for (i = 0; i < len1; i++)
    ef38:	e59d3000 	ldr	r3, [sp]
          for (j = 0; j < len2; j++)
    ef3c:	e1a01005 	mov	r1, r5
          dp[i + len2] = (mp_limb_t) carry;
    ef40:	e48a1004 	str	r1, [sl], #4
      for (i = 0; i < len1; i++)
    ef44:	e153000c 	cmp	r3, ip
    ef48:	1affffd7 	bne	eeac <multiply+0xcc>
    ef4c:	eaffffea 	b	eefc <multiply+0x11c>
    ef50:	e1a0b005 	mov	fp, r5
    ef54:	eaffffcd 	b	ee90 <multiply+0xb0>

0000ef58 <decimal_point_char>:
{
    ef58:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
  sprintf (pointbuf, "%#.0f", 1.0);
    ef5c:	e3091148 	movw	r1, #37192	@ 0x9148
{
    ef60:	e24dd00c 	sub	sp, sp, #12
  sprintf (pointbuf, "%#.0f", 1.0);
    ef64:	e3a03000 	mov	r3, #0
    ef68:	e3a02000 	mov	r2, #0
    ef6c:	e3433ff0 	movt	r3, #16368	@ 0x3ff0
    ef70:	e3401002 	movt	r1, #2
    ef74:	e1a0000d 	mov	r0, sp
    ef78:	eb0029c4 	bl	19690 <sprintf>
  return (point[0] != '\0' ? point[0] : '.');
    ef7c:	e5dd0001 	ldrb	r0, [sp, #1]
    ef80:	e3500000 	cmp	r0, #0
}
    ef84:	03a0002e 	moveq	r0, #46	@ 0x2e
    ef88:	e28dd00c 	add	sp, sp, #12
    ef8c:	e49df004 	pop	{pc}		@ (ldr pc, [sp], #4)

0000ef90 <floorlog10l>:
{
    ef90:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
    ef94:	e24dd00c 	sub	sp, sp, #12
  y = frexpl (x, &exp);
    ef98:	e28d0004 	add	r0, sp, #4
    ef9c:	eb0045b3 	bl	20670 <frexpl>
  if (!(y >= 0.0L && y < 1.0L))
    efa0:	eeb50bc0 	vcmpe.f64	d0, #0.0
    efa4:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    efa8:	ba00006b 	blt	f15c <floorlog10l+0x1cc>
    efac:	ed9f7b6b 	vldr	d7, [pc, #428]	@ f160 <floorlog10l+0x1d0>
    efb0:	eeb40bc7 	vcmpe.f64	d0, d7
    efb4:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    efb8:	5a000067 	bpl	f15c <floorlog10l+0x1cc>
  if (y == 0.0L)
    efbc:	eeb50b40 	vcmp.f64	d0, #0.0
    efc0:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    efc4:	0a000062 	beq	f154 <floorlog10l+0x1c4>
  if (y < 0.5L)
    efc8:	ed9f7b66 	vldr	d7, [pc, #408]	@ f168 <floorlog10l+0x1d8>
    efcc:	e59d3004 	ldr	r3, [sp, #4]
    efd0:	eeb40bc7 	vcmpe.f64	d0, d7
    efd4:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    efd8:	5a000029 	bpl	f084 <floorlog10l+0xf4>
      while (y < (1.0L / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))
    efdc:	ed9f7b63 	vldr	d7, [pc, #396]	@ f170 <floorlog10l+0x1e0>
    efe0:	eeb40bc7 	vcmpe.f64	d0, d7
    efe4:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    efe8:	5a000008 	bpl	f010 <floorlog10l+0x80>
          y *= 1.0L * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));
    efec:	ed9f6b61 	vldr	d6, [pc, #388]	@ f178 <floorlog10l+0x1e8>
    eff0:	e2433020 	sub	r3, r3, #32
    eff4:	ee200b06 	vmul.f64	d0, d0, d6
      while (y < (1.0L / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))
    eff8:	e1a02003 	mov	r2, r3
    effc:	e2433020 	sub	r3, r3, #32
    f000:	eeb40bc7 	vcmpe.f64	d0, d7
    f004:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    f008:	4afffff9 	bmi	eff4 <floorlog10l+0x64>
          exp -= GMP_LIMB_BITS;
    f00c:	e1a03002 	mov	r3, r2
      if (y < (1.0L / (1 << 16)))
    f010:	ed9f7b5a 	vldr	d7, [pc, #360]	@ f180 <floorlog10l+0x1f0>
    f014:	eeb40bc7 	vcmpe.f64	d0, d7
    f018:	eef1fa10 	vmrs	APSR_nzcv, fpscr
          exp -= 16;
    f01c:	42433010 	submi	r3, r3, #16
          y *= 1.0L * (1 << 16);
    f020:	4d9f7b58 	vldrmi	d7, [pc, #352]	@ f188 <floorlog10l+0x1f8>
    f024:	4e200b07 	vmulmi.f64	d0, d0, d7
      if (y < (1.0L / (1 << 8)))
    f028:	ed9f7b58 	vldr	d7, [pc, #352]	@ f190 <floorlog10l+0x200>
    f02c:	eeb40bc7 	vcmpe.f64	d0, d7
    f030:	eef1fa10 	vmrs	APSR_nzcv, fpscr
          exp -= 8;
    f034:	42433008 	submi	r3, r3, #8
          y *= 1.0L * (1 << 8);
    f038:	4d9f7b56 	vldrmi	d7, [pc, #344]	@ f198 <floorlog10l+0x208>
    f03c:	4e200b07 	vmulmi.f64	d0, d0, d7
      if (y < (1.0L / (1 << 4)))
    f040:	ed9f7b56 	vldr	d7, [pc, #344]	@ f1a0 <floorlog10l+0x210>
    f044:	eeb40bc7 	vcmpe.f64	d0, d7
    f048:	eef1fa10 	vmrs	APSR_nzcv, fpscr
          exp -= 4;
    f04c:	42433004 	submi	r3, r3, #4
          y *= 1.0L * (1 << 4);
    f050:	4d9f7b54 	vldrmi	d7, [pc, #336]	@ f1a8 <floorlog10l+0x218>
    f054:	4e200b07 	vmulmi.f64	d0, d0, d7
      if (y < (1.0L / (1 << 2)))
    f058:	ed9f7b54 	vldr	d7, [pc, #336]	@ f1b0 <floorlog10l+0x220>
    f05c:	eeb40bc7 	vcmpe.f64	d0, d7
    f060:	eef1fa10 	vmrs	APSR_nzcv, fpscr
          exp -= 2;
    f064:	42433002 	submi	r3, r3, #2
          y *= 1.0L * (1 << 2);
    f068:	4d9f7b52 	vldrmi	d7, [pc, #328]	@ f1b8 <floorlog10l+0x228>
    f06c:	4e200b07 	vmulmi.f64	d0, d0, d7
      if (y < (1.0L / (1 << 1)))
    f070:	ed9f7b3c 	vldr	d7, [pc, #240]	@ f168 <floorlog10l+0x1d8>
    f074:	eeb40bc7 	vcmpe.f64	d0, d7
    f078:	eef1fa10 	vmrs	APSR_nzcv, fpscr
          y *= 1.0L * (1 << 1);
    f07c:	4e300b00 	vaddmi.f64	d0, d0, d0
          exp -= 1;
    f080:	42433001 	submi	r3, r3, #1
  if (z < 0.70710678118654752444)
    f084:	ed9f6b4d 	vldr	d6, [pc, #308]	@ f1c0 <floorlog10l+0x230>
  l = exp;
    f088:	ee073a90 	vmov	s15, r3
  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));
    f08c:	ed9f1b47 	vldr	d1, [pc, #284]	@ f1b0 <floorlog10l+0x220>
  l = exp;
    f090:	eeb87be7 	vcvt.f64.s32	d7, s15
  if (z < 0.70710678118654752444)
    f094:	eeb40bc6 	vcmpe.f64	d0, d6
    f098:	eef1fa10 	vmrs	APSR_nzcv, fpscr
  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));
    f09c:	ed9f3b49 	vldr	d3, [pc, #292]	@ f1c8 <floorlog10l+0x238>
      z *= 1.4142135623730950488;
    f0a0:	4d9f5b4a 	vldrmi	d5, [pc, #296]	@ f1d0 <floorlog10l+0x240>
      l -= 0.5;
    f0a4:	4d9f6b2f 	vldrmi	d6, [pc, #188]	@ f168 <floorlog10l+0x1d8>
  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));
    f0a8:	ed9f4b2e 	vldr	d4, [pc, #184]	@ f168 <floorlog10l+0x1d8>
  l *= 0.30102999566398119523;
    f0ac:	ed9f2b49 	vldr	d2, [pc, #292]	@ f1d8 <floorlog10l+0x248>
      z *= 1.4142135623730950488;
    f0b0:	4e200b05 	vmulmi.f64	d0, d0, d5
      l -= 0.5;
    f0b4:	4e377b46 	vsubmi.f64	d7, d7, d6
  if (z < 0.8408964152537145431)
    f0b8:	ed9f6b48 	vldr	d6, [pc, #288]	@ f1e0 <floorlog10l+0x250>
    f0bc:	eeb40bc6 	vcmpe.f64	d0, d6
    f0c0:	eef1fa10 	vmrs	APSR_nzcv, fpscr
      z *= 1.1892071150027210667;
    f0c4:	4d9f5b47 	vldrmi	d5, [pc, #284]	@ f1e8 <floorlog10l+0x258>
      l -= 0.25;
    f0c8:	4d9f6b38 	vldrmi	d6, [pc, #224]	@ f1b0 <floorlog10l+0x220>
      z *= 1.1892071150027210667;
    f0cc:	4e200b05 	vmulmi.f64	d0, d0, d5
      l -= 0.25;
    f0d0:	4e377b46 	vsubmi.f64	d7, d7, d6
  if (z < 0.91700404320467123175)
    f0d4:	ed9f6b45 	vldr	d6, [pc, #276]	@ f1f0 <floorlog10l+0x260>
    f0d8:	eeb40bc6 	vcmpe.f64	d0, d6
    f0dc:	eef1fa10 	vmrs	APSR_nzcv, fpscr
      z *= 1.0905077326652576592;
    f0e0:	4d9f5b44 	vldrmi	d5, [pc, #272]	@ f1f8 <floorlog10l+0x268>
      l -= 0.125;
    f0e4:	4d9f6b45 	vldrmi	d6, [pc, #276]	@ f200 <floorlog10l+0x270>
      z *= 1.0905077326652576592;
    f0e8:	4e200b05 	vmulmi.f64	d0, d0, d5
      l -= 0.125;
    f0ec:	4e377b46 	vsubmi.f64	d7, d7, d6
  if (z < 0.9576032806985736469)
    f0f0:	ed9f6b44 	vldr	d6, [pc, #272]	@ f208 <floorlog10l+0x278>
    f0f4:	eeb40bc6 	vcmpe.f64	d0, d6
    f0f8:	eef1fa10 	vmrs	APSR_nzcv, fpscr
      z *= 1.0442737824274138403;
    f0fc:	4d9f5b43 	vldrmi	d5, [pc, #268]	@ f210 <floorlog10l+0x280>
      l -= 0.0625;
    f100:	4d9f6b26 	vldrmi	d6, [pc, #152]	@ f1a0 <floorlog10l+0x210>
      z *= 1.0442737824274138403;
    f104:	4e200b05 	vmulmi.f64	d0, d0, d5
      l -= 0.0625;
    f108:	4e377b46 	vsubmi.f64	d7, d7, d6
  z = 1 - z;
    f10c:	ed9f6b13 	vldr	d6, [pc, #76]	@ f160 <floorlog10l+0x1d0>
  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));
    f110:	ed9f5b40 	vldr	d5, [pc, #256]	@ f218 <floorlog10l+0x288>
  z = 1 - z;
    f114:	ee360b40 	vsub.f64	d0, d6, d0
  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));
    f118:	ee003b01 	vmla.f64	d3, d0, d1
    f11c:	ee205b05 	vmul.f64	d5, d0, d5
    f120:	ee034b00 	vmla.f64	d4, d3, d0
    f124:	ee046b00 	vmla.f64	d6, d4, d0
    f128:	ee067b45 	vmls.f64	d7, d6, d5
  l *= 0.30102999566398119523;
    f12c:	ee277b02 	vmul.f64	d7, d7, d2
  return (int) l + (l < 0 ? -1 : 0);
    f130:	eefd6bc7 	vcvt.s32.f64	s13, d7
    f134:	eeb57bc0 	vcmpe.f64	d7, #0.0
    f138:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    f13c:	43a03001 	movmi	r3, #1
    f140:	53a03000 	movpl	r3, #0
    f144:	ee160a90 	vmov	r0, s13
    f148:	e0400003 	sub	r0, r0, r3
}
    f14c:	e28dd00c 	add	sp, sp, #12
    f150:	e49df004 	pop	{pc}		@ (ldr pc, [sp], #4)
    return INT_MIN;
    f154:	e3a00102 	mov	r0, #-2147483648	@ 0x80000000
    f158:	eafffffb 	b	f14c <floorlog10l+0x1bc>
    abort ();
    f15c:	eb001d6a 	bl	1670c <abort>
    f160:	00000000 	.word	0x00000000
    f164:	3ff00000 	.word	0x3ff00000
    f168:	00000000 	.word	0x00000000
    f16c:	3fe00000 	.word	0x3fe00000
    f170:	00000000 	.word	0x00000000
    f174:	3df00000 	.word	0x3df00000
    f178:	00000000 	.word	0x00000000
    f17c:	41f00000 	.word	0x41f00000
    f180:	00000000 	.word	0x00000000
    f184:	3ef00000 	.word	0x3ef00000
    f188:	00000000 	.word	0x00000000
    f18c:	40f00000 	.word	0x40f00000
    f190:	00000000 	.word	0x00000000
    f194:	3f700000 	.word	0x3f700000
    f198:	00000000 	.word	0x00000000
    f19c:	40700000 	.word	0x40700000
    f1a0:	00000000 	.word	0x00000000
    f1a4:	3fb00000 	.word	0x3fb00000
    f1a8:	00000000 	.word	0x00000000
    f1ac:	40300000 	.word	0x40300000
    f1b0:	00000000 	.word	0x00000000
    f1b4:	3fd00000 	.word	0x3fd00000
    f1b8:	00000000 	.word	0x00000000
    f1bc:	40100000 	.word	0x40100000
    f1c0:	667f3bcd 	.word	0x667f3bcd
    f1c4:	3fe6a09e 	.word	0x3fe6a09e
    f1c8:	55555555 	.word	0x55555555
    f1cc:	3fd55555 	.word	0x3fd55555
    f1d0:	667f3bcd 	.word	0x667f3bcd
    f1d4:	3ff6a09e 	.word	0x3ff6a09e
    f1d8:	509f79ff 	.word	0x509f79ff
    f1dc:	3fd34413 	.word	0x3fd34413
    f1e0:	995ad3ad 	.word	0x995ad3ad
    f1e4:	3feae89f 	.word	0x3feae89f
    f1e8:	0a31b715 	.word	0x0a31b715
    f1ec:	3ff306fe 	.word	0x3ff306fe
    f1f0:	dcfba487 	.word	0xdcfba487
    f1f4:	3fed5818 	.word	0x3fed5818
    f1f8:	3c7d517b 	.word	0x3c7d517b
    f1fc:	3ff172b8 	.word	0x3ff172b8
    f200:	00000000 	.word	0x00000000
    f204:	3fc00000 	.word	0x3fc00000
    f208:	a2a490da 	.word	0xa2a490da
    f20c:	3feea4af 	.word	0x3feea4af
    f210:	6cf9890f 	.word	0x6cf9890f
    f214:	3ff0b558 	.word	0x3ff0b558
    f218:	652b82fe 	.word	0x652b82fe
    f21c:	3ff71547 	.word	0x3ff71547

0000f220 <floorlog10>:
{
    f220:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
    f224:	e24dd00c 	sub	sp, sp, #12
  y = frexp (x, &exp);
    f228:	e28d0004 	add	r0, sp, #4
    f22c:	eb0044ed 	bl	205e8 <frexp>
  if (!(y >= 0.0 && y < 1.0))
    f230:	eeb50bc0 	vcmpe.f64	d0, #0.0
    f234:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    f238:	ba00006b 	blt	f3ec <floorlog10+0x1cc>
    f23c:	ed9f7b6b 	vldr	d7, [pc, #428]	@ f3f0 <floorlog10+0x1d0>
    f240:	eeb40bc7 	vcmpe.f64	d0, d7
    f244:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    f248:	5a000067 	bpl	f3ec <floorlog10+0x1cc>
  if (y == 0.0)
    f24c:	eeb50b40 	vcmp.f64	d0, #0.0
    f250:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    f254:	0a000062 	beq	f3e4 <floorlog10+0x1c4>
  if (y < 0.5)
    f258:	ed9f7b66 	vldr	d7, [pc, #408]	@ f3f8 <floorlog10+0x1d8>
    f25c:	e59d3004 	ldr	r3, [sp, #4]
    f260:	eeb40bc7 	vcmpe.f64	d0, d7
    f264:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    f268:	5a000029 	bpl	f314 <floorlog10+0xf4>
      while (y < (1.0 / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))
    f26c:	ed9f7b63 	vldr	d7, [pc, #396]	@ f400 <floorlog10+0x1e0>
    f270:	eeb40bc7 	vcmpe.f64	d0, d7
    f274:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    f278:	5a000008 	bpl	f2a0 <floorlog10+0x80>
          y *= 1.0 * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));
    f27c:	ed9f6b61 	vldr	d6, [pc, #388]	@ f408 <floorlog10+0x1e8>
    f280:	e2433020 	sub	r3, r3, #32
    f284:	ee200b06 	vmul.f64	d0, d0, d6
      while (y < (1.0 / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))
    f288:	e1a02003 	mov	r2, r3
    f28c:	e2433020 	sub	r3, r3, #32
    f290:	eeb40bc7 	vcmpe.f64	d0, d7
    f294:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    f298:	4afffff9 	bmi	f284 <floorlog10+0x64>
          exp -= GMP_LIMB_BITS;
    f29c:	e1a03002 	mov	r3, r2
      if (y < (1.0 / (1 << 16)))
    f2a0:	ed9f7b5a 	vldr	d7, [pc, #360]	@ f410 <floorlog10+0x1f0>
    f2a4:	eeb40bc7 	vcmpe.f64	d0, d7
    f2a8:	eef1fa10 	vmrs	APSR_nzcv, fpscr
          exp -= 16;
    f2ac:	42433010 	submi	r3, r3, #16
          y *= 1.0 * (1 << 16);
    f2b0:	4d9f7b58 	vldrmi	d7, [pc, #352]	@ f418 <floorlog10+0x1f8>
    f2b4:	4e200b07 	vmulmi.f64	d0, d0, d7
      if (y < (1.0 / (1 << 8)))
    f2b8:	ed9f7b58 	vldr	d7, [pc, #352]	@ f420 <floorlog10+0x200>
    f2bc:	eeb40bc7 	vcmpe.f64	d0, d7
    f2c0:	eef1fa10 	vmrs	APSR_nzcv, fpscr
          exp -= 8;
    f2c4:	42433008 	submi	r3, r3, #8
          y *= 1.0 * (1 << 8);
    f2c8:	4d9f7b56 	vldrmi	d7, [pc, #344]	@ f428 <floorlog10+0x208>
    f2cc:	4e200b07 	vmulmi.f64	d0, d0, d7
      if (y < (1.0 / (1 << 4)))
    f2d0:	ed9f7b56 	vldr	d7, [pc, #344]	@ f430 <floorlog10+0x210>
    f2d4:	eeb40bc7 	vcmpe.f64	d0, d7
    f2d8:	eef1fa10 	vmrs	APSR_nzcv, fpscr
          exp -= 4;
    f2dc:	42433004 	submi	r3, r3, #4
          y *= 1.0 * (1 << 4);
    f2e0:	4d9f7b54 	vldrmi	d7, [pc, #336]	@ f438 <floorlog10+0x218>
    f2e4:	4e200b07 	vmulmi.f64	d0, d0, d7
      if (y < (1.0 / (1 << 2)))
    f2e8:	ed9f7b54 	vldr	d7, [pc, #336]	@ f440 <floorlog10+0x220>
    f2ec:	eeb40bc7 	vcmpe.f64	d0, d7
    f2f0:	eef1fa10 	vmrs	APSR_nzcv, fpscr
          exp -= 2;
    f2f4:	42433002 	submi	r3, r3, #2
          y *= 1.0 * (1 << 2);
    f2f8:	4d9f7b52 	vldrmi	d7, [pc, #328]	@ f448 <floorlog10+0x228>
    f2fc:	4e200b07 	vmulmi.f64	d0, d0, d7
      if (y < (1.0 / (1 << 1)))
    f300:	ed9f7b3c 	vldr	d7, [pc, #240]	@ f3f8 <floorlog10+0x1d8>
    f304:	eeb40bc7 	vcmpe.f64	d0, d7
    f308:	eef1fa10 	vmrs	APSR_nzcv, fpscr
          y *= 1.0 * (1 << 1);
    f30c:	4e300b00 	vaddmi.f64	d0, d0, d0
          exp -= 1;
    f310:	42433001 	submi	r3, r3, #1
  if (z < 0.70710678118654752444)
    f314:	ed9f6b4d 	vldr	d6, [pc, #308]	@ f450 <floorlog10+0x230>
  l = exp;
    f318:	ee073a90 	vmov	s15, r3
  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));
    f31c:	ed9f1b47 	vldr	d1, [pc, #284]	@ f440 <floorlog10+0x220>
  l = exp;
    f320:	eeb87be7 	vcvt.f64.s32	d7, s15
  if (z < 0.70710678118654752444)
    f324:	eeb40bc6 	vcmpe.f64	d0, d6
    f328:	eef1fa10 	vmrs	APSR_nzcv, fpscr
  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));
    f32c:	ed9f3b49 	vldr	d3, [pc, #292]	@ f458 <floorlog10+0x238>
      z *= 1.4142135623730950488;
    f330:	4d9f5b4a 	vldrmi	d5, [pc, #296]	@ f460 <floorlog10+0x240>
      l -= 0.5;
    f334:	4d9f6b2f 	vldrmi	d6, [pc, #188]	@ f3f8 <floorlog10+0x1d8>
  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));
    f338:	ed9f4b2e 	vldr	d4, [pc, #184]	@ f3f8 <floorlog10+0x1d8>
  l *= 0.30102999566398119523;
    f33c:	ed9f2b49 	vldr	d2, [pc, #292]	@ f468 <floorlog10+0x248>
      z *= 1.4142135623730950488;
    f340:	4e200b05 	vmulmi.f64	d0, d0, d5
      l -= 0.5;
    f344:	4e377b46 	vsubmi.f64	d7, d7, d6
  if (z < 0.8408964152537145431)
    f348:	ed9f6b48 	vldr	d6, [pc, #288]	@ f470 <floorlog10+0x250>
    f34c:	eeb40bc6 	vcmpe.f64	d0, d6
    f350:	eef1fa10 	vmrs	APSR_nzcv, fpscr
      z *= 1.1892071150027210667;
    f354:	4d9f5b47 	vldrmi	d5, [pc, #284]	@ f478 <floorlog10+0x258>
      l -= 0.25;
    f358:	4d9f6b38 	vldrmi	d6, [pc, #224]	@ f440 <floorlog10+0x220>
      z *= 1.1892071150027210667;
    f35c:	4e200b05 	vmulmi.f64	d0, d0, d5
      l -= 0.25;
    f360:	4e377b46 	vsubmi.f64	d7, d7, d6
  if (z < 0.91700404320467123175)
    f364:	ed9f6b45 	vldr	d6, [pc, #276]	@ f480 <floorlog10+0x260>
    f368:	eeb40bc6 	vcmpe.f64	d0, d6
    f36c:	eef1fa10 	vmrs	APSR_nzcv, fpscr
      z *= 1.0905077326652576592;
    f370:	4d9f5b44 	vldrmi	d5, [pc, #272]	@ f488 <floorlog10+0x268>
      l -= 0.125;
    f374:	4d9f6b45 	vldrmi	d6, [pc, #276]	@ f490 <floorlog10+0x270>
      z *= 1.0905077326652576592;
    f378:	4e200b05 	vmulmi.f64	d0, d0, d5
      l -= 0.125;
    f37c:	4e377b46 	vsubmi.f64	d7, d7, d6
  if (z < 0.9576032806985736469)
    f380:	ed9f6b44 	vldr	d6, [pc, #272]	@ f498 <floorlog10+0x278>
    f384:	eeb40bc6 	vcmpe.f64	d0, d6
    f388:	eef1fa10 	vmrs	APSR_nzcv, fpscr
      z *= 1.0442737824274138403;
    f38c:	4d9f5b43 	vldrmi	d5, [pc, #268]	@ f4a0 <floorlog10+0x280>
      l -= 0.0625;
    f390:	4d9f6b26 	vldrmi	d6, [pc, #152]	@ f430 <floorlog10+0x210>
      z *= 1.0442737824274138403;
    f394:	4e200b05 	vmulmi.f64	d0, d0, d5
      l -= 0.0625;
    f398:	4e377b46 	vsubmi.f64	d7, d7, d6
  z = 1 - z;
    f39c:	ed9f6b13 	vldr	d6, [pc, #76]	@ f3f0 <floorlog10+0x1d0>
  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));
    f3a0:	ed9f5b40 	vldr	d5, [pc, #256]	@ f4a8 <floorlog10+0x288>
  z = 1 - z;
    f3a4:	ee360b40 	vsub.f64	d0, d6, d0
  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));
    f3a8:	ee003b01 	vmla.f64	d3, d0, d1
    f3ac:	ee205b05 	vmul.f64	d5, d0, d5
    f3b0:	ee034b00 	vmla.f64	d4, d3, d0
    f3b4:	ee046b00 	vmla.f64	d6, d4, d0
    f3b8:	ee067b45 	vmls.f64	d7, d6, d5
  l *= 0.30102999566398119523;
    f3bc:	ee277b02 	vmul.f64	d7, d7, d2
  return (int) l + (l < 0 ? -1 : 0);
    f3c0:	eefd6bc7 	vcvt.s32.f64	s13, d7
    f3c4:	eeb57bc0 	vcmpe.f64	d7, #0.0
    f3c8:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    f3cc:	43a03001 	movmi	r3, #1
    f3d0:	53a03000 	movpl	r3, #0
    f3d4:	ee160a90 	vmov	r0, s13
    f3d8:	e0400003 	sub	r0, r0, r3
}
    f3dc:	e28dd00c 	add	sp, sp, #12
    f3e0:	e49df004 	pop	{pc}		@ (ldr pc, [sp], #4)
    return INT_MIN;
    f3e4:	e3a00102 	mov	r0, #-2147483648	@ 0x80000000
    f3e8:	eafffffb 	b	f3dc <floorlog10+0x1bc>
    abort ();
    f3ec:	eb001cc6 	bl	1670c <abort>
    f3f0:	00000000 	.word	0x00000000
    f3f4:	3ff00000 	.word	0x3ff00000
    f3f8:	00000000 	.word	0x00000000
    f3fc:	3fe00000 	.word	0x3fe00000
    f400:	00000000 	.word	0x00000000
    f404:	3df00000 	.word	0x3df00000
    f408:	00000000 	.word	0x00000000
    f40c:	41f00000 	.word	0x41f00000
    f410:	00000000 	.word	0x00000000
    f414:	3ef00000 	.word	0x3ef00000
    f418:	00000000 	.word	0x00000000
    f41c:	40f00000 	.word	0x40f00000
    f420:	00000000 	.word	0x00000000
    f424:	3f700000 	.word	0x3f700000
    f428:	00000000 	.word	0x00000000
    f42c:	40700000 	.word	0x40700000
    f430:	00000000 	.word	0x00000000
    f434:	3fb00000 	.word	0x3fb00000
    f438:	00000000 	.word	0x00000000
    f43c:	40300000 	.word	0x40300000
    f440:	00000000 	.word	0x00000000
    f444:	3fd00000 	.word	0x3fd00000
    f448:	00000000 	.word	0x00000000
    f44c:	40100000 	.word	0x40100000
    f450:	667f3bcd 	.word	0x667f3bcd
    f454:	3fe6a09e 	.word	0x3fe6a09e
    f458:	55555555 	.word	0x55555555
    f45c:	3fd55555 	.word	0x3fd55555
    f460:	667f3bcd 	.word	0x667f3bcd
    f464:	3ff6a09e 	.word	0x3ff6a09e
    f468:	509f79ff 	.word	0x509f79ff
    f46c:	3fd34413 	.word	0x3fd34413
    f470:	995ad3ad 	.word	0x995ad3ad
    f474:	3feae89f 	.word	0x3feae89f
    f478:	0a31b715 	.word	0x0a31b715
    f47c:	3ff306fe 	.word	0x3ff306fe
    f480:	dcfba487 	.word	0xdcfba487
    f484:	3fed5818 	.word	0x3fed5818
    f488:	3c7d517b 	.word	0x3c7d517b
    f48c:	3ff172b8 	.word	0x3ff172b8
    f490:	00000000 	.word	0x00000000
    f494:	3fc00000 	.word	0x3fc00000
    f498:	a2a490da 	.word	0xa2a490da
    f49c:	3feea4af 	.word	0x3feea4af
    f4a0:	6cf9890f 	.word	0x6cf9890f
    f4a4:	3ff0b558 	.word	0x3ff0b558
    f4a8:	652b82fe 	.word	0x652b82fe
    f4ac:	3ff71547 	.word	0x3ff71547

0000f4b0 <decode_double>:
{
    f4b0:	e92d4070 	push	{r4, r5, r6, lr}
    f4b4:	e1a06000 	mov	r6, r0
    f4b8:	ed2d8b02 	vpush	{d8}
  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));
    f4bc:	e3a00008 	mov	r0, #8
{
    f4c0:	e24dd008 	sub	sp, sp, #8
    f4c4:	e1a05001 	mov	r5, r1
    f4c8:	eeb08b40 	vmov.f64	d8, d0
  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));
    f4cc:	ebfffc50 	bl	e614 <rpl_malloc>
  if (m.limbs == NULL)
    f4d0:	e2504000 	subs	r4, r0, #0
    f4d4:	0a000047 	beq	f5f8 <decode_double+0x148>
  y = frexp (x, &exp);
    f4d8:	e28d0004 	add	r0, sp, #4
    f4dc:	eeb00b48 	vmov.f64	d0, d8
    f4e0:	eb004440 	bl	205e8 <frexp>
  if (!(y >= 0.0 && y < 1.0))
    f4e4:	eeb50bc0 	vcmpe.f64	d0, #0.0
    f4e8:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    f4ec:	ba000047 	blt	f610 <decode_double+0x160>
    f4f0:	ed9f5b48 	vldr	d5, [pc, #288]	@ f618 <decode_double+0x168>
    f4f4:	eeb40bc5 	vcmpe.f64	d0, d5
    f4f8:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    f4fc:	5a000043 	bpl	f610 <decode_double+0x160>
      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % (GMP_LIMB_BITS / 2));
    f500:	ed9f7b46 	vldr	d7, [pc, #280]	@ f620 <decode_double+0x170>
    f504:	ee207b07 	vmul.f64	d7, d0, d7
      hi = (int) y;
    f508:	eebd6bc7 	vcvt.s32.f64	s12, d7
      y -= hi;
    f50c:	eeb84b46 	vcvt.f64.u32	d4, s12
    f510:	ee377b44 	vsub.f64	d7, d7, d4
      if (!(y >= 0.0 && y < 1.0))
    f514:	eeb57bc0 	vcmpe.f64	d7, #0.0
    f518:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    f51c:	ba00003b 	blt	f610 <decode_double+0x160>
    f520:	eeb47bc5 	vcmpe.f64	d7, d5
    f524:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    f528:	5a000038 	bpl	f610 <decode_double+0x160>
      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);
    f52c:	ed9f4b3d 	vldr	d4, [pc, #244]	@ f628 <decode_double+0x178>
    f530:	ee277b04 	vmul.f64	d7, d7, d4
      lo = (int) y;
    f534:	eefd6bc7 	vcvt.s32.f64	s13, d7
      y -= lo;
    f538:	eeb83b66 	vcvt.f64.u32	d3, s13
    f53c:	ee377b43 	vsub.f64	d7, d7, d3
      if (!(y >= 0.0 && y < 1.0))
    f540:	eeb57bc0 	vcmpe.f64	d7, #0.0
    f544:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    f548:	ba000030 	blt	f610 <decode_double+0x160>
    f54c:	eeb47bc5 	vcmpe.f64	d7, d5
    f550:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    f554:	5a00002d 	bpl	f610 <decode_double+0x160>
      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);
    f558:	ee277b04 	vmul.f64	d7, d7, d4
      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;
    f55c:	ee162a10 	vmov	r2, s12
    f560:	ee163a90 	vmov	r3, s13
    f564:	e1832802 	orr	r2, r3, r2, lsl #16
      hi = (int) y;
    f568:	eebd6bc7 	vcvt.s32.f64	s12, d7
      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;
    f56c:	e5842004 	str	r2, [r4, #4]
      y -= hi;
    f570:	eeb83b46 	vcvt.f64.u32	d3, s12
    f574:	ee377b43 	vsub.f64	d7, d7, d3
      if (!(y >= 0.0 && y < 1.0))
    f578:	eeb57bc0 	vcmpe.f64	d7, #0.0
    f57c:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    f580:	ba000022 	blt	f610 <decode_double+0x160>
    f584:	eeb47bc5 	vcmpe.f64	d7, d5
    f588:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    f58c:	5a00001f 	bpl	f610 <decode_double+0x160>
      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);
    f590:	ee277b04 	vmul.f64	d7, d7, d4
      lo = (int) y;
    f594:	eefd6bc7 	vcvt.s32.f64	s13, d7
      y -= lo;
    f598:	eeb85b66 	vcvt.f64.u32	d5, s13
    f59c:	ee377b45 	vsub.f64	d7, d7, d5
      if (!(y >= 0.0 && y < 1.0))
    f5a0:	eeb57bc0 	vcmpe.f64	d7, #0.0
    f5a4:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    f5a8:	ba000018 	blt	f610 <decode_double+0x160>
    f5ac:	ed9f5b19 	vldr	d5, [pc, #100]	@ f618 <decode_double+0x168>
    f5b0:	eeb47bc5 	vcmpe.f64	d7, d5
    f5b4:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    f5b8:	5a000014 	bpl	f610 <decode_double+0x160>
      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;
    f5bc:	ee163a90 	vmov	r3, s13
    f5c0:	ee161a10 	vmov	r1, s12
  if (!(y == 0.0))
    f5c4:	eeb57b40 	vcmp.f64	d7, #0.0
      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;
    f5c8:	e1833801 	orr	r3, r3, r1, lsl #16
  if (!(y == 0.0))
    f5cc:	eef1fa10 	vmrs	APSR_nzcv, fpscr
      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;
    f5d0:	e5843000 	str	r3, [r4]
  if (!(y == 0.0))
    f5d4:	1a00000d 	bne	f610 <decode_double+0x160>
  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)
    f5d8:	e3520000 	cmp	r2, #0
    f5dc:	1a000009 	bne	f608 <decode_double+0x158>
    f5e0:	e2533000 	subs	r3, r3, #0
    f5e4:	13a03001 	movne	r3, #1
  *ep = exp - DBL_MANT_BIT;
    f5e8:	e59d2004 	ldr	r2, [sp, #4]
  *mp = m;
    f5ec:	e8850018 	stm	r5, {r3, r4}
  *ep = exp - DBL_MANT_BIT;
    f5f0:	e2423035 	sub	r3, r2, #53	@ 0x35
    f5f4:	e5863000 	str	r3, [r6]
}
    f5f8:	e1a00004 	mov	r0, r4
    f5fc:	e28dd008 	add	sp, sp, #8
    f600:	ecbd8b02 	vpop	{d8}
    f604:	e8bd8070 	pop	{r4, r5, r6, pc}
  m.nlimbs = (DBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;
    f608:	e3a03002 	mov	r3, #2
    f60c:	eafffff5 	b	f5e8 <decode_double+0x138>
    abort ();
    f610:	eb001c3d 	bl	1670c <abort>
    f614:	e320f000 	nop	{0}
    f618:	00000000 	.word	0x00000000
    f61c:	3ff00000 	.word	0x3ff00000
    f620:	00000000 	.word	0x00000000
    f624:	40400000 	.word	0x40400000
    f628:	00000000 	.word	0x00000000
    f62c:	40f00000 	.word	0x40f00000

0000f630 <divide>:
{
    f630:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  roomptr = (mp_limb_t *) malloc ((a_len + 2) * sizeof (mp_limb_t));
    f634:	e2805002 	add	r5, r0, #2
{
    f638:	e24dd03c 	sub	sp, sp, #60	@ 0x3c
  roomptr = (mp_limb_t *) malloc ((a_len + 2) * sizeof (mp_limb_t));
    f63c:	e1a05105 	lsl	r5, r5, #2
{
    f640:	e28dc038 	add	ip, sp, #56	@ 0x38
    f644:	e90c0003 	stmdb	ip, {r0, r1}
  size_t a_len = a.nlimbs;
    f648:	e1a09000 	mov	r9, r0
{
    f64c:	e28d1028 	add	r1, sp, #40	@ 0x28
  roomptr = (mp_limb_t *) malloc ((a_len + 2) * sizeof (mp_limb_t));
    f650:	e1a00005 	mov	r0, r5
  const mp_limb_t *a_ptr = a.limbs;
    f654:	e59d8034 	ldr	r8, [sp, #52]	@ 0x34
  size_t b_len = b.nlimbs;
    f658:	e1a04002 	mov	r4, r2
{
    f65c:	e881000c 	stm	r1, {r2, r3}
  const mp_limb_t *b_ptr = b.limbs;
    f660:	e58d3000 	str	r3, [sp]
  roomptr = (mp_limb_t *) malloc ((a_len + 2) * sizeof (mp_limb_t));
    f664:	ebfffbea 	bl	e614 <rpl_malloc>
  if (roomptr == NULL)
    f668:	e2507000 	subs	r7, r0, #0
    f66c:	0a00014e 	beq	fbac <divide+0x57c>
  while (a_len > 0 && a_ptr[a_len - 1] == 0)
    f670:	e3590000 	cmp	r9, #0
    f674:	12453008 	subne	r3, r5, #8
    f678:	10883003 	addne	r3, r8, r3
    f67c:	1a000002 	bne	f68c <divide+0x5c>
    f680:	ea000004 	b	f698 <divide+0x68>
    f684:	e2599001 	subs	r9, r9, #1
    f688:	0a000002 	beq	f698 <divide+0x68>
    f68c:	e5332004 	ldr	r2, [r3, #-4]!
    f690:	e3520000 	cmp	r2, #0
    f694:	0afffffa 	beq	f684 <divide+0x54>
      if (b_len == 0)
    f698:	e3540000 	cmp	r4, #0
    f69c:	0a000144 	beq	fbb4 <divide+0x584>
    f6a0:	e59d3000 	ldr	r3, [sp]
    f6a4:	e0833104 	add	r3, r3, r4, lsl #2
    f6a8:	ea000001 	b	f6b4 <divide+0x84>
    f6ac:	e2544001 	subs	r4, r4, #1
    f6b0:	0a00013f 	beq	fbb4 <divide+0x584>
      if (b_ptr[b_len - 1] == 0)
    f6b4:	e1a05003 	mov	r5, r3
    f6b8:	e5336004 	ldr	r6, [r3, #-4]!
    f6bc:	e3560000 	cmp	r6, #0
    f6c0:	0afffff9 	beq	f6ac <divide+0x7c>
  if (a_len < b_len)
    f6c4:	e1590004 	cmp	r9, r4
    f6c8:	2a00002c 	bcs	f780 <divide+0x150>
      memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));
    f6cc:	e1a05109 	lsl	r5, r9, #2
    f6d0:	e1a01008 	mov	r1, r8
    f6d4:	e1a00007 	mov	r0, r7
    f6d8:	e1a02005 	mov	r2, r5
      q_ptr = roomptr + a_len;
    f6dc:	e0878005 	add	r8, r7, r5
      q_len = 0;
    f6e0:	e3a05000 	mov	r5, #0
    f6e4:	eb0041e5 	bl	1fe80 <memcpy>
  if (r_len > b_len)
    f6e8:	e1a03104 	lsl	r3, r4, #2
  mp_limb_t *tmp_roomptr = NULL;
    f6ec:	e1a02005 	mov	r2, r5
    f6f0:	e58d3010 	str	r3, [sp, #16]
    f6f4:	e59d3010 	ldr	r3, [sp, #16]
    f6f8:	e59d1000 	ldr	r1, [sp]
    f6fc:	e0870003 	add	r0, r7, r3
    f700:	e081e003 	add	lr, r1, r3
    f704:	e1a03004 	mov	r3, r4
    f708:	ea00000c 	b	f740 <divide+0x110>
          | (i < r_len ? r_ptr[i] << 1 : 0);
    f70c:	e1590003 	cmp	r9, r3
    f710:	8a0000ac 	bhi	f9c8 <divide+0x398>
        mp_limb_t b_i = (i < b_len ? b_ptr[i] : 0);
    f714:	e1540003 	cmp	r4, r3
    f718:	9a000015 	bls	f774 <divide+0x144>
    f71c:	e59e6000 	ldr	r6, [lr]
        mp_limb_t r_i =
    f720:	e3a01000 	mov	r1, #0
        if (r_i < b_i)
    f724:	e1510006 	cmp	r1, r6
    f728:	3a00009f 	bcc	f9ac <divide+0x37c>
        if (i == 0)
    f72c:	e3530000 	cmp	r3, #0
    f730:	e24ee004 	sub	lr, lr, #4
    f734:	e2400004 	sub	r0, r0, #4
    f738:	0a0000c2 	beq	fa48 <divide+0x418>
  mp_limb_t *tmp_roomptr = NULL;
    f73c:	e1a0300c 	mov	r3, ip
        mp_limb_t r_i =
    f740:	e243c001 	sub	ip, r3, #1
          (i <= r_len && i > 0 ? r_ptr[i - 1] >> (GMP_LIMB_BITS - 1) : 0)
    f744:	e15c0009 	cmp	ip, r9
    f748:	2affffef 	bcs	f70c <divide+0xdc>
    f74c:	e5101004 	ldr	r1, [r0, #-4]
          | (i < r_len ? r_ptr[i] << 1 : 0);
    f750:	e1590003 	cmp	r9, r3
          (i <= r_len && i > 0 ? r_ptr[i - 1] >> (GMP_LIMB_BITS - 1) : 0)
    f754:	e1a01fa1 	lsr	r1, r1, #31
          | (i < r_len ? r_ptr[i] << 1 : 0);
    f758:	9a000001 	bls	f764 <divide+0x134>
    f75c:	e5906000 	ldr	r6, [r0]
        mp_limb_t r_i =
    f760:	e1811086 	orr	r1, r1, r6, lsl #1
        mp_limb_t b_i = (i < b_len ? b_ptr[i] : 0);
    f764:	e1540003 	cmp	r4, r3
    f768:	8a00007c 	bhi	f960 <divide+0x330>
        if (r_i > b_i)
    f76c:	e3510000 	cmp	r1, #0
    f770:	1a00007d 	bne	f96c <divide+0x33c>
        if (i == 0)
    f774:	e24ee004 	sub	lr, lr, #4
    f778:	e2400004 	sub	r0, r0, #4
    f77c:	eaffffee 	b	f73c <divide+0x10c>
  else if (b_len == 1)
    f780:	e3540001 	cmp	r4, #1
    f784:	0a0000b7 	beq	fa68 <divide+0x438>
        s = __builtin_clz (msd);
    f788:	e16faf16 	clz	sl, r6
          tmp_roomptr = (mp_limb_t *) malloc (b_len * sizeof (mp_limb_t));
    f78c:	e1a03104 	lsl	r3, r4, #2
      if (s > 0)
    f790:	e35a0000 	cmp	sl, #0
          tmp_roomptr = (mp_limb_t *) malloc (b_len * sizeof (mp_limb_t));
    f794:	e58d3010 	str	r3, [sp, #16]
      if (s > 0)
    f798:	1a0000d0 	bne	fae0 <divide+0x4b0>
          memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));
    f79c:	e1a0b109 	lsl	fp, r9, #2
    f7a0:	e1a01008 	mov	r1, r8
    f7a4:	e1a00007 	mov	r0, r7
    f7a8:	e1a0200b 	mov	r2, fp
    f7ac:	eb0041b3 	bl	1fe80 <memcpy>
  mp_limb_t *tmp_roomptr = NULL;
    f7b0:	e1a0200a 	mov	r2, sl
          r_ptr[a_len] = 0;
    f7b4:	e787a109 	str	sl, [r7, r9, lsl #2]
        mp_limb_t b_2msd = b_ptr[b_len - 2]; /* b[n-2] */
    f7b8:	e59d1010 	ldr	r1, [sp, #16]
      q_len = a_len - b_len + 1; /* q will have m-n+1 limbs */
    f7bc:	e0495004 	sub	r5, r9, r4
        mp_limb_t b_2msd = b_ptr[b_len - 2]; /* b[n-2] */
    f7c0:	e59d3000 	ldr	r3, [sp]
    f7c4:	e087b00b 	add	fp, r7, fp
              mp_twolimb_t c3 = /* b[n-2] * q* */
    f7c8:	e58d201c 	str	r2, [sp, #28]
      q_ptr = roomptr + b_len;
    f7cc:	e0878001 	add	r8, r7, r1
              mp_twolimb_t c3 = /* b[n-2] * q* */
    f7d0:	e58d5020 	str	r5, [sp, #32]
        mp_limb_t b_2msd = b_ptr[b_len - 2]; /* b[n-2] */
    f7d4:	e0833001 	add	r3, r3, r1
              mp_twolimb_t c3 = /* b[n-2] * q* */
    f7d8:	e58d8018 	str	r8, [sp, #24]
        mp_limb_t b_2msd = b_ptr[b_len - 2]; /* b[n-2] */
    f7dc:	e513a008 	ldr	sl, [r3, #-8]
        mp_twolimb_t b_msdd = /* b[n-1]*beta+b[n-2] */
    f7e0:	e2473004 	sub	r3, r7, #4
    f7e4:	e0833001 	add	r3, r3, r1
              mp_twolimb_t c3 = /* b[n-2] * q* */
    f7e8:	e58d400c 	str	r4, [sp, #12]
    f7ec:	e58d3004 	str	r3, [sp, #4]
                  mp_limb_t *destptr = r_ptr + j;
    f7f0:	e2613004 	rsb	r3, r1, #4
    f7f4:	e58d3014 	str	r3, [sp, #20]
              mp_twolimb_t c3 = /* b[n-2] * q* */
    f7f8:	e58d7024 	str	r7, [sp, #36]	@ 0x24
    f7fc:	ea000015 	b	f858 <divide+0x228>
                q_star = num / b_msd;
    f800:	e59b0000 	ldr	r0, [fp]
    f804:	e1a02006 	mov	r2, r6
    f808:	e3a03000 	mov	r3, #0
    f80c:	eb001b67 	bl	165b0 <__aeabi_uldivmod>
              mp_twolimb_t c3 = /* b[n-2] * q* */
    f810:	e0831a90 	umull	r1, r3, r0, sl
                ((mp_twolimb_t) c1 << GMP_LIMB_BITS) | r_ptr[j + b_len - 2];
    f814:	e51be004 	ldr	lr, [fp, #-4]
                q_star = num / b_msd;
    f818:	e1a0c000 	mov	ip, r0
              if (c3 > c2)
    f81c:	e15e0001 	cmp	lr, r1
    f820:	e0d24003 	sbcs	r4, r2, r3
    f824:	2a000005 	bcs	f840 <divide+0x210>
                  if (c3 - c2 > b_msdd)
    f828:	e051100e 	subs	r1, r1, lr
    f82c:	e0c33002 	sbc	r3, r3, r2
    f830:	e15a0001 	cmp	sl, r1
    f834:	e0d63003 	sbcs	r3, r6, r3
                  q_star = q_star - 1; /* q* := q* - 1 */
    f838:	2240c001 	subcs	ip, r0, #1
                    q_star = q_star - 1; /* q* := q* - 1 */
    f83c:	3240c002 	subcc	ip, r0, #2
            if (q_star > 0)
    f840:	e35c0000 	cmp	ip, #0
    f844:	1a000016 	bne	f8a4 <divide+0x274>
            if (j == 0)
    f848:	e59d3004 	ldr	r3, [sp, #4]
            q_ptr[j] = q_star;
    f84c:	e58bc004 	str	ip, [fp, #4]
            if (j == 0)
    f850:	e153000b 	cmp	r3, fp
    f854:	0a00005f 	beq	f9d8 <divide+0x3a8>
            if (r_ptr[j + b_len] < b_msd) /* r[j+n] < b[n-1] ? */
    f858:	e41b1004 	ldr	r1, [fp], #-4
    f85c:	e1510006 	cmp	r1, r6
    f860:	3affffe6 	bcc	f800 <divide+0x1d0>
                if (r_ptr[j + b_len] > b_msd
    f864:	8a000073 	bhi	fa38 <divide+0x408>
    f868:	e59b3000 	ldr	r3, [fp]
    f86c:	e0933006 	adds	r3, r3, r6
    f870:	2a000070 	bcs	fa38 <divide+0x408>
              mp_twolimb_t c3 = /* b[n-2] * q* */
    f874:	e3e02000 	mvn	r2, #0
                ((mp_twolimb_t) c1 << GMP_LIMB_BITS) | r_ptr[j + b_len - 2];
    f878:	e51b0004 	ldr	r0, [fp, #-4]
              mp_twolimb_t c3 = /* b[n-2] * q* */
    f87c:	e082129a 	umull	r1, r2, sl, r2
              if (c3 > c2)
    f880:	e1500001 	cmp	r0, r1
    f884:	e0d3c002 	sbcs	ip, r3, r2
    f888:	2a000050 	bcs	f9d0 <divide+0x3a0>
                  if (c3 - c2 > b_msdd)
    f88c:	e0511000 	subs	r1, r1, r0
    f890:	e0c22003 	sbc	r2, r2, r3
    f894:	e15a0001 	cmp	sl, r1
    f898:	e0d62002 	sbcs	r2, r6, r2
                    q_star = q_star - 1; /* q* := q* - 1 */
    f89c:	33e0c002 	mvncc	ip, #2
                  q_star = q_star - 1; /* q* := q* - 1 */
    f8a0:	23e0c001 	mvncs	ip, #1
                        + (mp_twolimb_t) q_star * (mp_twolimb_t) *sourceptr++
    f8a4:	e1a0500c 	mov	r5, ip
    f8a8:	e3a08000 	mov	r8, #0
                  mp_limb_t *destptr = r_ptr + j;
    f8ac:	e59d3014 	ldr	r3, [sp, #20]
                  mp_twolimb_t carry = 0;
    f8b0:	e3a0e000 	mov	lr, #0
                  for (count = b_len; count > 0; count--)
    f8b4:	e59d100c 	ldr	r1, [sp, #12]
                  const mp_limb_t *sourceptr = b_ptr;
    f8b8:	e59d7000 	ldr	r7, [sp]
                  mp_limb_t *destptr = r_ptr + j;
    f8bc:	e083900b 	add	r9, r3, fp
                  mp_twolimb_t carry = 0;
    f8c0:	e58d6008 	str	r6, [sp, #8]
                  mp_limb_t *destptr = r_ptr + j;
    f8c4:	e1a04009 	mov	r4, r9
                        + (mp_twolimb_t) q_star * (mp_twolimb_t) *sourceptr++
    f8c8:	e4976004 	ldr	r6, [r7], #4
                        + (mp_limb_t) ~(*destptr);
    f8cc:	e5940000 	ldr	r0, [r4]
                        + (mp_twolimb_t) q_star * (mp_twolimb_t) *sourceptr++
    f8d0:	e0823596 	umull	r3, r2, r6, r5
                        + (mp_limb_t) ~(*destptr);
    f8d4:	e1e00000 	mvn	r0, r0
                        + (mp_twolimb_t) q_star * (mp_twolimb_t) *sourceptr++
    f8d8:	e0222896 	mla	r2, r6, r8, r2
                      carry =
    f8dc:	e0933000 	adds	r3, r3, r0
    f8e0:	e2a22000 	adc	r2, r2, #0
    f8e4:	e093300e 	adds	r3, r3, lr
                      carry = carry >> GMP_LIMB_BITS; /* <= q* */
    f8e8:	e2a2e000 	adc	lr, r2, #0
                  for (count = b_len; count > 0; count--)
    f8ec:	e2511001 	subs	r1, r1, #1
                      *destptr++ = ~(mp_limb_t) carry;
    f8f0:	e1e03003 	mvn	r3, r3
    f8f4:	e4843004 	str	r3, [r4], #4
                  for (count = b_len; count > 0; count--)
    f8f8:	1afffff2 	bne	f8c8 <divide+0x298>
                if (cr > r_ptr[j + b_len])
    f8fc:	e59b3004 	ldr	r3, [fp, #4]
    f900:	e59d6008 	ldr	r6, [sp, #8]
    f904:	e153000e 	cmp	r3, lr
    f908:	2affffce 	bcs	f848 <divide+0x218>
                      for (count = b_len; count > 0; count--)
    f90c:	e59d300c 	ldr	r3, [sp, #12]
                    q_star = q_star - 1; /* q* := q* - 1 */
    f910:	e24cc001 	sub	ip, ip, #1
                      const mp_limb_t *sourceptr = b_ptr;
    f914:	e59d0000 	ldr	r0, [sp]
    f918:	ea000004 	b	f930 <divide+0x300>
                             ? source1 >= (mp_limb_t) ~source2
    f91c:	e1510002 	cmp	r1, r2
    f920:	83a01000 	movhi	r1, #0
    f924:	93a01001 	movls	r1, #1
                      for (count = b_len; count > 0; count--)
    f928:	e2533001 	subs	r3, r3, #1
    f92c:	0affffc5 	beq	f848 <divide+0x218>
                          mp_limb_t source1 = *sourceptr++;
    f930:	e4902004 	ldr	r2, [r0], #4
                             : source1 > (mp_limb_t) ~source2);
    f934:	e3510000 	cmp	r1, #0
                          mp_limb_t source2 = *destptr;
    f938:	e599e000 	ldr	lr, [r9]
                          *destptr++ = source1 + source2 + carry;
    f93c:	e0821001 	add	r1, r2, r1
    f940:	e081100e 	add	r1, r1, lr
    f944:	e4891004 	str	r1, [r9], #4
                             ? source1 >= (mp_limb_t) ~source2
    f948:	e1e0100e 	mvn	r1, lr
                             : source1 > (mp_limb_t) ~source2);
    f94c:	1afffff2 	bne	f91c <divide+0x2ec>
    f950:	e1510002 	cmp	r1, r2
    f954:	23a01000 	movcs	r1, #0
    f958:	33a01001 	movcc	r1, #1
    f95c:	eafffff1 	b	f928 <divide+0x2f8>
        mp_limb_t b_i = (i < b_len ? b_ptr[i] : 0);
    f960:	e59e6000 	ldr	r6, [lr]
        if (r_i > b_i)
    f964:	e1560001 	cmp	r6, r1
    f968:	2affff6d 	bcs	f724 <divide+0xf4>
      for (i = 0; i < q_len; i++)
    f96c:	e3550000 	cmp	r5, #0
    f970:	01a01008 	moveq	r1, r8
    f974:	03a05001 	moveq	r5, #1
    f978:	0a00002b 	beq	fa2c <divide+0x3fc>
    f97c:	e2481004 	sub	r1, r8, #4
    f980:	e3a00000 	mov	r0, #0
    f984:	ea000003 	b	f998 <divide+0x368>
    f988:	e2803001 	add	r3, r0, #1
    f98c:	e1550003 	cmp	r5, r3
    f990:	0a000023 	beq	fa24 <divide+0x3f4>
    f994:	e1a00003 	mov	r0, r3
        if (++(q_ptr[i]) != 0)
    f998:	e5b13004 	ldr	r3, [r1, #4]!
    f99c:	e2833001 	add	r3, r3, #1
    f9a0:	e3530000 	cmp	r3, #0
    f9a4:	e5813000 	str	r3, [r1]
    f9a8:	0afffff6 	beq	f988 <divide+0x358>
  free (tmp_roomptr);
    f9ac:	e1a00002 	mov	r0, r2
    f9b0:	ebffeaa8 	bl	a458 <rpl_free>
  q->limbs = q_ptr;
    f9b4:	e59d3060 	ldr	r3, [sp, #96]	@ 0x60
  q->nlimbs = q_len;
    f9b8:	e8830120 	stm	r3, {r5, r8}
}
    f9bc:	e1a00007 	mov	r0, r7
    f9c0:	e28dd03c 	add	sp, sp, #60	@ 0x3c
    f9c4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
          (i <= r_len && i > 0 ? r_ptr[i - 1] >> (GMP_LIMB_BITS - 1) : 0)
    f9c8:	e3a01000 	mov	r1, #0
    f9cc:	eaffff62 	b	f75c <divide+0x12c>
                q_star = (mp_limb_t)~(mp_limb_t)0; /* q* = beta-1 */
    f9d0:	e3e0c000 	mvn	ip, #0
    f9d4:	eaffffb2 	b	f8a4 <divide+0x274>
      if (q_ptr[q_len - 1] == 0)
    f9d8:	e59d8018 	ldr	r8, [sp, #24]
    f9dc:	e59d5020 	ldr	r5, [sp, #32]
    f9e0:	e59d201c 	ldr	r2, [sp, #28]
    f9e4:	e59d400c 	ldr	r4, [sp, #12]
    f9e8:	e7983105 	ldr	r3, [r8, r5, lsl #2]
    f9ec:	e59d7024 	ldr	r7, [sp, #36]	@ 0x24
    f9f0:	e3530000 	cmp	r3, #0
    f9f4:	1a000019 	bne	fa60 <divide+0x430>
      while (r_len > 0 && r_ptr[r_len - 1] == 0)
    f9f8:	e1a03008 	mov	r3, r8
                      const mp_limb_t *sourceptr = b_ptr;
    f9fc:	e1a09004 	mov	r9, r4
    fa00:	ea000001 	b	fa0c <divide+0x3dc>
      while (r_len > 0 && r_ptr[r_len - 1] == 0)
    fa04:	e2599001 	subs	r9, r9, #1
    fa08:	0affff39 	beq	f6f4 <divide+0xc4>
    fa0c:	e5331004 	ldr	r1, [r3, #-4]!
    fa10:	e3510000 	cmp	r1, #0
    fa14:	0afffffa 	beq	fa04 <divide+0x3d4>
  if (r_len > b_len)
    fa18:	e1540009 	cmp	r4, r9
    fa1c:	3affffd2 	bcc	f96c <divide+0x33c>
    fa20:	eaffff33 	b	f6f4 <divide+0xc4>
      q_ptr[q_len++] = 1;
    fa24:	e0881105 	add	r1, r8, r5, lsl #2
    fa28:	e2805002 	add	r5, r0, #2
    fa2c:	e3a03001 	mov	r3, #1
    fa30:	e5813000 	str	r3, [r1]
    fa34:	eaffffdc 	b	f9ac <divide+0x37c>
    fa38:	e3e05000 	mvn	r5, #0
    fa3c:	e3a08000 	mov	r8, #0
                q_star = (mp_limb_t)~(mp_limb_t)0; /* q* = beta-1 */
    fa40:	e1a0c005 	mov	ip, r5
    fa44:	eaffff98 	b	f8ac <divide+0x27c>
  if (q_len > 0 && ((q_ptr[0] & 1) != 0))
    fa48:	e3550000 	cmp	r5, #0
    fa4c:	0affffd6 	beq	f9ac <divide+0x37c>
    fa50:	e5983000 	ldr	r3, [r8]
    fa54:	e3130001 	tst	r3, #1
    fa58:	0affffd3 	beq	f9ac <divide+0x37c>
    fa5c:	eaffffc6 	b	f97c <divide+0x34c>
      q_len = a_len - b_len + 1; /* q will have m-n+1 limbs */
    fa60:	e2855001 	add	r5, r5, #1
    fa64:	eaffffe3 	b	f9f8 <divide+0x3c8>
            *--destptr = num / den;
    fa68:	e59d2000 	ldr	r2, [sp]
        const mp_limb_t *sourceptr = a_ptr + a_len;
    fa6c:	e1a03109 	lsl	r3, r9, #2
        for (count = a_len; count > 0; count--)
    fa70:	e1a05009 	mov	r5, r9
        const mp_limb_t *sourceptr = a_ptr + a_len;
    fa74:	e088a003 	add	sl, r8, r3
      q_ptr = roomptr + 1;
    fa78:	e2878004 	add	r8, r7, #4
            *--destptr = num / den;
    fa7c:	e592b000 	ldr	fp, [r2]
        mp_limb_t *destptr = q_ptr + a_len;
    fa80:	e0886003 	add	r6, r8, r3
        mp_limb_t remainder = 0;
    fa84:	e3a01000 	mov	r1, #0
    fa88:	e58d3004 	str	r3, [sp, #4]
            *--destptr = num / den;
    fa8c:	e53a0004 	ldr	r0, [sl, #-4]!
    fa90:	e1a0200b 	mov	r2, fp
    fa94:	e3a03000 	mov	r3, #0
    fa98:	eb001ac4 	bl	165b0 <__aeabi_uldivmod>
        for (count = a_len; count > 0; count--)
    fa9c:	e2555001 	subs	r5, r5, #1
            remainder = num % den;
    faa0:	e1a01002 	mov	r1, r2
            *--destptr = num / den;
    faa4:	e5260004 	str	r0, [r6, #-4]!
        for (count = a_len; count > 0; count--)
    faa8:	1afffff7 	bne	fa8c <divide+0x45c>
        if (remainder > 0)
    faac:	e59d3004 	ldr	r3, [sp, #4]
    fab0:	e3520000 	cmp	r2, #0
            r_ptr[0] = remainder;
    fab4:	15872000 	strne	r2, [r7]
            r_len = 1;
    fab8:	13a01001 	movne	r1, #1
        if (q_ptr[q_len - 1] == 0)
    fabc:	e7973003 	ldr	r3, [r7, r3]
    fac0:	e3530000 	cmp	r3, #0
    fac4:	1a000030 	bne	fb8c <divide+0x55c>
  mp_limb_t *tmp_roomptr = NULL;
    fac8:	e1a02003 	mov	r2, r3
    facc:	e3a03004 	mov	r3, #4
          q_len--;
    fad0:	e2495001 	sub	r5, r9, #1
  if (r_len > b_len)
    fad4:	e58d3010 	str	r3, [sp, #16]
          q_len--;
    fad8:	e1a09001 	mov	r9, r1
    fadc:	eaffff04 	b	f6f4 <divide+0xc4>
          tmp_roomptr = (mp_limb_t *) malloc (b_len * sizeof (mp_limb_t));
    fae0:	e1a00003 	mov	r0, r3
    fae4:	ebfffaca 	bl	e614 <rpl_malloc>
          if (tmp_roomptr == NULL)
    fae8:	e2502000 	subs	r2, r0, #0
    faec:	0a00002c 	beq	fba4 <divide+0x574>
            const mp_limb_t *sourceptr = b_ptr;
    faf0:	e59d6000 	ldr	r6, [sp]
            for (count = b_len; count > 0; count--)
    faf4:	e1a00004 	mov	r0, r4
            mp_limb_t *destptr = tmp_roomptr;
    faf8:	e1a0b002 	mov	fp, r2
            mp_twolimb_t accu = 0;
    fafc:	e3a03000 	mov	r3, #0
    fb00:	e24ac020 	sub	ip, sl, #32
    fb04:	e26ae020 	rsb	lr, sl, #32
    fb08:	e58d2004 	str	r2, [sp, #4]
                accu += (mp_twolimb_t) *sourceptr++ << s;
    fb0c:	e4962004 	ldr	r2, [r6], #4
    fb10:	e1a01c12 	lsl	r1, r2, ip
    fb14:	e1811e32 	orr	r1, r1, r2, lsr lr
    fb18:	e1a02a12 	lsl	r2, r2, sl
    fb1c:	e0922003 	adds	r2, r2, r3
                accu = accu >> GMP_LIMB_BITS;
    fb20:	e2a13000 	adc	r3, r1, #0
            for (count = b_len; count > 0; count--)
    fb24:	e2500001 	subs	r0, r0, #1
                *destptr++ = (mp_limb_t) accu;
    fb28:	e48b2004 	str	r2, [fp], #4
            for (count = b_len; count > 0; count--)
    fb2c:	1afffff6 	bne	fb0c <divide+0x4dc>
            if (accu != 0)
    fb30:	e3931000 	orrs	r1, r3, #0
    fb34:	e59d2004 	ldr	r2, [sp, #4]
    fb38:	1a00001d 	bne	fbb4 <divide+0x584>
          for (count = a_len; count > 0; count--)
    fb3c:	e1a00009 	mov	r0, r9
          mp_limb_t *destptr = r_ptr;
    fb40:	e1a06007 	mov	r6, r7
              accu += (mp_twolimb_t) *sourceptr++ << s;
    fb44:	e4981004 	ldr	r1, [r8], #4
    fb48:	e1a0bc11 	lsl	fp, r1, ip
    fb4c:	e18bbe31 	orr	fp, fp, r1, lsr lr
    fb50:	e1a01a11 	lsl	r1, r1, sl
    fb54:	e0911003 	adds	r1, r1, r3
              accu = accu >> GMP_LIMB_BITS;
    fb58:	e2ab3000 	adc	r3, fp, #0
          for (count = a_len; count > 0; count--)
    fb5c:	e2500001 	subs	r0, r0, #1
              *destptr++ = (mp_limb_t) accu;
    fb60:	e4861004 	str	r1, [r6], #4
          for (count = a_len; count > 0; count--)
    fb64:	1afffff6 	bne	fb44 <divide+0x514>
      if (b_ptr[b_len - 1] == 0)
    fb68:	e59d1000 	ldr	r1, [sp]
        mp_limb_t b_msd = b_ptr[b_len - 1]; /* b[n-1] */
    fb6c:	e0825005 	add	r5, r2, r5
          *destptr++ = (mp_limb_t) accu;
    fb70:	e7873109 	str	r3, [r7, r9, lsl #2]
      if (b_ptr[b_len - 1] == 0)
    fb74:	e3e03003 	mvn	r3, #3
    fb78:	e1a0b109 	lsl	fp, r9, #2
          b_ptr = tmp_roomptr;
    fb7c:	e58d2000 	str	r2, [sp]
      if (b_ptr[b_len - 1] == 0)
    fb80:	e0433001 	sub	r3, r3, r1
        mp_limb_t b_msd = b_ptr[b_len - 1]; /* b[n-1] */
    fb84:	e7956003 	ldr	r6, [r5, r3]
    fb88:	eaffff0a 	b	f7b8 <divide+0x188>
    fb8c:	e3a03004 	mov	r3, #4
        q_len = a_len;
    fb90:	e1a05009 	mov	r5, r9
  mp_limb_t *tmp_roomptr = NULL;
    fb94:	e3a02000 	mov	r2, #0
    fb98:	e1a09001 	mov	r9, r1
    fb9c:	e58d3010 	str	r3, [sp, #16]
    fba0:	eafffed3 	b	f6f4 <divide+0xc4>
              free (roomptr);
    fba4:	e1a00007 	mov	r0, r7
    fba8:	ebffea2a 	bl	a458 <rpl_free>
    return NULL;
    fbac:	e3a07000 	mov	r7, #0
    fbb0:	eaffff81 	b	f9bc <divide+0x38c>
        abort ();
    fbb4:	eb001ad4 	bl	1670c <abort>

0000fbb8 <scale10_round_decimal_decoded>:
{
    fbb8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    fbbc:	e24dd05c 	sub	sp, sp, #92	@ 0x5c
    fbc0:	e59d6080 	ldr	r6, [sp, #128]	@ 0x80
    fbc4:	e28dc030 	add	ip, sp, #48	@ 0x30
    fbc8:	e88c0006 	stm	ip, {r1, r2}
    fbcc:	e58d301c 	str	r3, [sp, #28]
  s = e + n;
    fbd0:	e0808006 	add	r8, r0, r6
    fbd4:	e59d3034 	ldr	r3, [sp, #52]	@ 0x34
  if (s > 0 && n > 0)
    fbd8:	e3580000 	cmp	r8, #0
    fbdc:	c3560000 	cmpgt	r6, #0
    fbe0:	e58d1020 	str	r1, [sp, #32]
    fbe4:	e58d3024 	str	r3, [sp, #36]	@ 0x24
    fbe8:	d3a03000 	movle	r3, #0
    fbec:	c3a03001 	movgt	r3, #1
  extra_zeroes = 0;
    fbf0:	d1a0b003 	movle	fp, r3
  if (s > 0 && n > 0)
    fbf4:	da000004 	ble	fc0c <scale10_round_decimal_decoded+0x54>
      extra_zeroes = (s < n ? s : n);
    fbf8:	e1560008 	cmp	r6, r8
    fbfc:	b1a0b006 	movlt	fp, r6
    fc00:	a1a0b008 	movge	fp, r8
      s -= extra_zeroes;
    fc04:	e048800b 	sub	r8, r8, fp
      n -= extra_zeroes;
    fc08:	e046600b 	sub	r6, r6, fp
  abs_n = (n >= 0 ? n : -n);
    fc0c:	e0267fc6 	eor	r7, r6, r6, asr #31
  pow5_ptr = (mp_limb_t *) malloc (((int)(abs_n * (2.322f / GMP_LIMB_BITS)) + 1
    fc10:	ed9f7ab0 	vldr	s14, [pc, #704]	@ fed8 <scale10_round_decimal_decoded+0x320>
  abs_s = (s >= 0 ? s : -s);
    fc14:	e0283fc8 	eor	r3, r8, r8, asr #31
  abs_n = (n >= 0 ? n : -n);
    fc18:	e0477fc6 	sub	r7, r7, r6, asr #31
  abs_s = (s >= 0 ? s : -s);
    fc1c:	e0433fc8 	sub	r3, r3, r8, asr #31
  pow5_ptr = (mp_limb_t *) malloc (((int)(abs_n * (2.322f / GMP_LIMB_BITS)) + 1
    fc20:	ee077a90 	vmov	s15, r7
                                    + abs_s / GMP_LIMB_BITS + 1)
    fc24:	e1a022a3 	lsr	r2, r3, #5
    fc28:	e58d300c 	str	r3, [sp, #12]
  pow5_ptr = (mp_limb_t *) malloc (((int)(abs_n * (2.322f / GMP_LIMB_BITS)) + 1
    fc2c:	eef87ae7 	vcvt.f32.s32	s15, s15
                                    + abs_s / GMP_LIMB_BITS + 1)
    fc30:	e58d2014 	str	r2, [sp, #20]
    fc34:	e2822002 	add	r2, r2, #2
  pow5_ptr = (mp_limb_t *) malloc (((int)(abs_n * (2.322f / GMP_LIMB_BITS)) + 1
    fc38:	ee677a87 	vmul.f32	s15, s15, s14
    fc3c:	eefd7ae7 	vcvt.s32.f32	s15, s15
    fc40:	ee170a90 	vmov	r0, s15
                                    + abs_s / GMP_LIMB_BITS + 1)
    fc44:	e0800002 	add	r0, r0, r2
  pow5_ptr = (mp_limb_t *) malloc (((int)(abs_n * (2.322f / GMP_LIMB_BITS)) + 1
    fc48:	e1a00100 	lsl	r0, r0, #2
    fc4c:	ebfffa70 	bl	e614 <rpl_malloc>
  if (pow5_ptr == NULL)
    fc50:	e2505000 	subs	r5, r0, #0
    fc54:	e59d300c 	ldr	r3, [sp, #12]
    fc58:	0a000163 	beq	101ec <scale10_round_decimal_decoded+0x634>
  if (abs_n > 0)
    fc5c:	e3560000 	cmp	r6, #0
  pow5_ptr[0] = 1;
    fc60:	e3a04001 	mov	r4, #1
    fc64:	e203901f 	and	r9, r3, #31
    fc68:	e5854000 	str	r4, [r5]
  if (abs_n > 0)
    fc6c:	0a000029 	beq	fd18 <scale10_round_decimal_decoded+0x160>
          mp_limb_t digit1 = small_pow5[n13 + 13 <= abs_n ? 13 : abs_n - n13];
    fc70:	e357000c 	cmp	r7, #12
    fc74:	e3092d20 	movw	r2, #40224	@ 0x9d20
    fc78:	e3402002 	movt	r2, #2
    fc7c:	c3071395 	movwgt	r1, #29589	@ 0x7395
    fc80:	d7921107 	ldrle	r1, [r2, r7, lsl #2]
    fc84:	e082a107 	add	sl, r2, r7, lsl #2
          for (j = 0; j < pow5_len; j++)
    fc88:	c34418c2 	movtgt	r1, #18626	@ 0x48c2
    fc8c:	e58d3028 	str	r3, [sp, #40]	@ 0x28
          mp_limb_t digit1 = small_pow5[n13 + 13 <= abs_n ? 13 : abs_n - n13];
    fc90:	e3072395 	movw	r2, #29589	@ 0x7395
    fc94:	e3a04001 	mov	r4, #1
    fc98:	e3a0000d 	mov	r0, #13
          mp_twolimb_t carry = 0;
    fc9c:	e3a0e000 	mov	lr, #0
          mp_limb_t digit1 = small_pow5[n13 + 13 <= abs_n ? 13 : abs_n - n13];
    fca0:	e34428c2 	movt	r2, #18626	@ 0x48c2
    fca4:	e58d802c 	str	r8, [sp, #44]	@ 0x2c
    fca8:	e58d2018 	str	r2, [sp, #24]
    fcac:	e1a0c104 	lsl	ip, r4, #2
    fcb0:	e58d000c 	str	r0, [sp, #12]
    fcb4:	e1a02005 	mov	r2, r5
          mp_twolimb_t carry = 0;
    fcb8:	e3a03000 	mov	r3, #0
    fcbc:	e085800c 	add	r8, r5, ip
    fcc0:	e1a00001 	mov	r0, r1
    fcc4:	e58dc010 	str	ip, [sp, #16]
              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;
    fcc8:	e592c000 	ldr	ip, [r2]
    fccc:	e1a0100e 	mov	r1, lr
    fcd0:	e0a1309c 	umlal	r3, r1, ip, r0
              pow5_ptr[j] = (mp_limb_t) carry;
    fcd4:	e4823004 	str	r3, [r2], #4
          for (j = 0; j < pow5_len; j++)
    fcd8:	e1520008 	cmp	r2, r8
              carry = carry >> GMP_LIMB_BITS;
    fcdc:	e1a03001 	mov	r3, r1
          for (j = 0; j < pow5_len; j++)
    fce0:	1afffff8 	bne	fcc8 <scale10_round_decimal_decoded+0x110>
          if (carry > 0)
    fce4:	e59d000c 	ldr	r0, [sp, #12]
    fce8:	e3912000 	orrs	r2, r1, #0
    fcec:	e59dc010 	ldr	ip, [sp, #16]
            pow5_ptr[pow5_len++] = (mp_limb_t) carry;
    fcf0:	12844001 	addne	r4, r4, #1
      for (n13 = 0; n13 <= abs_n; n13 += 13)
    fcf4:	e24aa034 	sub	sl, sl, #52	@ 0x34
            pow5_ptr[pow5_len++] = (mp_limb_t) carry;
    fcf8:	1785100c 	strne	r1, [r5, ip]
      for (n13 = 0; n13 <= abs_n; n13 += 13)
    fcfc:	e1570000 	cmp	r7, r0
    fd00:	3a00003a 	bcc	fdf0 <scale10_round_decimal_decoded+0x238>
          mp_limb_t digit1 = small_pow5[n13 + 13 <= abs_n ? 13 : abs_n - n13];
    fd04:	e280000d 	add	r0, r0, #13
    fd08:	e1570000 	cmp	r7, r0
    fd0c:	359a1000 	ldrcc	r1, [sl]
    fd10:	259d1018 	ldrcs	r1, [sp, #24]
    fd14:	eaffffe4 	b	fcac <scale10_round_decimal_decoded+0xf4>
  if (n >= 0 ? s >= 0 : s <= 0)
    fd18:	e3580000 	cmp	r8, #0
    fd1c:	ba000071 	blt	fee8 <scale10_round_decimal_decoded+0x330>
      if (s_bits > 0)
    fd20:	e3590000 	cmp	r9, #0
    fd24:	0a0000fd 	beq	10120 <scale10_round_decimal_decoded+0x568>
    fd28:	e1a0c104 	lsl	ip, r4, #2
          mp_limb_t *ptr = pow5_ptr;
    fd2c:	e1a01005 	mov	r1, r5
          mp_twolimb_t accu = 0;
    fd30:	e3a02000 	mov	r2, #0
    fd34:	e2497020 	sub	r7, r9, #32
    fd38:	e085800c 	add	r8, r5, ip
    fd3c:	e269e020 	rsb	lr, r9, #32
              accu += (mp_twolimb_t) *ptr << s_bits;
    fd40:	e5910000 	ldr	r0, [r1]
    fd44:	e1a0a710 	lsl	sl, r0, r7
    fd48:	e18aae30 	orr	sl, sl, r0, lsr lr
    fd4c:	e1a00910 	lsl	r0, r0, r9
    fd50:	e0900002 	adds	r0, r0, r2
              accu = accu >> GMP_LIMB_BITS;
    fd54:	e2aa2000 	adc	r2, sl, #0
              *ptr++ = (mp_limb_t) accu;
    fd58:	e4810004 	str	r0, [r1], #4
          for (count = pow5_len; count > 0; count--)
    fd5c:	e1580001 	cmp	r8, r1
    fd60:	1afffff6 	bne	fd40 <scale10_round_decimal_decoded+0x188>
          if (accu > 0)
    fd64:	e3921000 	orrs	r1, r2, #0
    fd68:	0a00010a 	beq	10198 <scale10_round_decimal_decoded+0x5e0>
      if (s_limbs > 0)
    fd6c:	e353001f 	cmp	r3, #31
              pow5_len++;
    fd70:	e2844001 	add	r4, r4, #1
              *ptr = (mp_limb_t) accu;
    fd74:	e785200c 	str	r2, [r5, ip]
      if (s_limbs > 0)
    fd78:	da000010 	ble	fdc0 <scale10_round_decimal_decoded+0x208>
    fd7c:	e1a0c104 	lsl	ip, r4, #2
    fd80:	e59d3014 	ldr	r3, [sp, #20]
    fd84:	e085c00c 	add	ip, r5, ip
    fd88:	e0844003 	add	r4, r4, r3
    fd8c:	e0853104 	add	r3, r5, r4, lsl #2
              pow5_ptr[s_limbs + count] = pow5_ptr[count];
    fd90:	e53c2004 	ldr	r2, [ip, #-4]!
          for (count = pow5_len; count > 0;)
    fd94:	e15c0005 	cmp	ip, r5
              pow5_ptr[s_limbs + count] = pow5_ptr[count];
    fd98:	e5232004 	str	r2, [r3, #-4]!
          for (count = pow5_len; count > 0;)
    fd9c:	1afffffb 	bne	fd90 <scale10_round_decimal_decoded+0x1d8>
          for (count = s_limbs; count > 0;)
    fda0:	e59d3014 	ldr	r3, [sp, #20]
    fda4:	e3530000 	cmp	r3, #0
    fda8:	0a000004 	beq	fdc0 <scale10_round_decimal_decoded+0x208>
              pow5_ptr[count] = 0;
    fdac:	e59d3014 	ldr	r3, [sp, #20]
    fdb0:	e3a01000 	mov	r1, #0
    fdb4:	e1a00005 	mov	r0, r5
    fdb8:	e1a02103 	lsl	r2, r3, #2
    fdbc:	eb002a3b 	bl	1a6b0 <memset>
      if (n >= 0)
    fdc0:	e3560000 	cmp	r6, #0
      pow5.limbs = pow5_ptr;
    fdc4:	e1cd43f8 	strd	r4, [sp, #56]	@ 0x38
      if (n >= 0)
    fdc8:	ba0000f5 	blt	101a4 <scale10_round_decimal_decoded+0x5ec>
          z_memory = multiply (m, pow5, &z);
    fdcc:	e28d3040 	add	r3, sp, #64	@ 0x40
    fdd0:	e28d1030 	add	r1, sp, #48	@ 0x30
    fdd4:	e58d3000 	str	r3, [sp]
    fdd8:	e28d3038 	add	r3, sp, #56	@ 0x38
    fddc:	e893000c 	ldm	r3, {r2, r3}
    fde0:	e8910003 	ldm	r1, {r0, r1}
    fde4:	ebfffbfd 	bl	ede0 <multiply>
    fde8:	e1a04000 	mov	r4, r0
    fdec:	ea000060 	b	ff74 <scale10_round_decimal_decoded+0x3bc>
  if (n >= 0 ? s >= 0 : s <= 0)
    fdf0:	e3560000 	cmp	r6, #0
    fdf4:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
    fdf8:	e59d802c 	ldr	r8, [sp, #44]	@ 0x2c
    fdfc:	aa000037 	bge	fee0 <scale10_round_decimal_decoded+0x328>
    fe00:	e3580000 	cmp	r8, #0
    fe04:	ca000007 	bgt	fe28 <scale10_round_decimal_decoded+0x270>
      if (s_bits > 0)
    fe08:	e3590000 	cmp	r9, #0
    fe0c:	0a0000ed 	beq	101c8 <scale10_round_decimal_decoded+0x610>
          for (count = pow5_len; count > 0; count--)
    fe10:	e3540000 	cmp	r4, #0
    fe14:	1affffc3 	bne	fd28 <scale10_round_decimal_decoded+0x170>
      if (s_limbs > 0)
    fe18:	e353001f 	cmp	r3, #31
    fe1c:	daffffe7 	ble	fdc0 <scale10_round_decimal_decoded+0x208>
          for (count = pow5_len; count > 0;)
    fe20:	e59d4014 	ldr	r4, [sp, #20]
    fe24:	eaffffe0 	b	fdac <scale10_round_decimal_decoded+0x1f4>
          num_ptr = (mp_limb_t *) malloc ((m.nlimbs + s_limbs + 1)
    fe28:	e59d3020 	ldr	r3, [sp, #32]
    fe2c:	e59d7014 	ldr	r7, [sp, #20]
      pow5.limbs = pow5_ptr;
    fe30:	e1cd43f8 	strd	r4, [sp, #56]	@ 0x38
          num_ptr = (mp_limb_t *) malloc ((m.nlimbs + s_limbs + 1)
    fe34:	e2836001 	add	r6, r3, #1
    fe38:	e0860007 	add	r0, r6, r7
    fe3c:	e1a00100 	lsl	r0, r0, #2
    fe40:	ebfff9f3 	bl	e614 <rpl_malloc>
          if (num_ptr == NULL)
    fe44:	e2504000 	subs	r4, r0, #0
    fe48:	0a0000e5 	beq	101e4 <scale10_round_decimal_decoded+0x62c>
              for (i = 0; i < s_limbs; i++)
    fe4c:	e3570000 	cmp	r7, #0
            mp_limb_t *destptr = num_ptr;
    fe50:	01a03004 	moveq	r3, r4
              for (i = 0; i < s_limbs; i++)
    fe54:	0a000005 	beq	fe70 <scale10_round_decimal_decoded+0x2b8>
                *destptr++ = 0;
    fe58:	e59d3014 	ldr	r3, [sp, #20]
    fe5c:	e3a01000 	mov	r1, #0
    fe60:	e1a07103 	lsl	r7, r3, #2
    fe64:	e1a02007 	mov	r2, r7
    fe68:	eb002a10 	bl	1a6b0 <memset>
    fe6c:	e0843007 	add	r3, r4, r7
            if (s_bits > 0)
    fe70:	e3590000 	cmp	r9, #0
                for (count = m.nlimbs; count > 0; count--)
    fe74:	e59d2020 	ldr	r2, [sp, #32]
            if (s_bits > 0)
    fe78:	0a0000ad 	beq	10134 <scale10_round_decimal_decoded+0x57c>
                for (count = m.nlimbs; count > 0; count--)
    fe7c:	e3520000 	cmp	r2, #0
    fe80:	0a0000d5 	beq	101dc <scale10_round_decimal_decoded+0x624>
    fe84:	e59da024 	ldr	sl, [sp, #36]	@ 0x24
    fe88:	e1a0c002 	mov	ip, r2
    fe8c:	e1a08003 	mov	r8, r3
                mp_twolimb_t accu = 0;
    fe90:	e3a01000 	mov	r1, #0
    fe94:	e2497020 	sub	r7, r9, #32
    fe98:	e269e020 	rsb	lr, r9, #32
                    accu += (mp_twolimb_t) *sourceptr++ << s_bits;
    fe9c:	e49a2004 	ldr	r2, [sl], #4
    fea0:	e1a00712 	lsl	r0, r2, r7
    fea4:	e1800e32 	orr	r0, r0, r2, lsr lr
    fea8:	e1a02912 	lsl	r2, r2, r9
    feac:	e0922001 	adds	r2, r2, r1
                    accu = accu >> GMP_LIMB_BITS;
    feb0:	e2a01000 	adc	r1, r0, #0
                for (count = m.nlimbs; count > 0; count--)
    feb4:	e25cc001 	subs	ip, ip, #1
                    *destptr++ = (mp_limb_t) accu;
    feb8:	e4882004 	str	r2, [r8], #4
                for (count = m.nlimbs; count > 0; count--)
    febc:	1afffff6 	bne	fe9c <scale10_round_decimal_decoded+0x2e4>
    fec0:	e59d0020 	ldr	r0, [sp, #32]
                if (accu > 0)
    fec4:	e3912000 	orrs	r2, r1, #0
    fec8:	e0832100 	add	r2, r3, r0, lsl #2
                  *destptr++ = (mp_limb_t) accu;
    fecc:	10832106 	addne	r2, r3, r6, lsl #2
    fed0:	17831100 	strne	r1, [r3, r0, lsl #2]
    fed4:	ea00009f 	b	10158 <scale10_round_decimal_decoded+0x5a0>
    fed8:	3d949ba6 	.word	0x3d949ba6
    fedc:	3f8902de 	.word	0x3f8902de
  if (n >= 0 ? s >= 0 : s <= 0)
    fee0:	e3580000 	cmp	r8, #0
    fee4:	aaffffc7 	bge	fe08 <scale10_round_decimal_decoded+0x250>
          tmp_memory = multiply (m, pow5, &numerator);
    fee8:	e28d6048 	add	r6, sp, #72	@ 0x48
    feec:	e28d3038 	add	r3, sp, #56	@ 0x38
    fef0:	e28d1030 	add	r1, sp, #48	@ 0x30
    fef4:	e58d6000 	str	r6, [sp]
      pow5.nlimbs = pow5_len;
    fef8:	e1cd43f8 	strd	r4, [sp, #56]	@ 0x38
          tmp_memory = multiply (m, pow5, &numerator);
    fefc:	e8910003 	ldm	r1, {r0, r1}
    ff00:	e893000c 	ldm	r3, {r2, r3}
    ff04:	ebfffbb5 	bl	ede0 <multiply>
          if (tmp_memory == NULL)
    ff08:	e2507000 	subs	r7, r0, #0
    ff0c:	0a0000b4 	beq	101e4 <scale10_round_decimal_decoded+0x62c>
            for (i = 0; i < s_limbs; i++)
    ff10:	e59d3014 	ldr	r3, [sp, #20]
            mp_limb_t *ptr = pow5_ptr + pow5_len;
    ff14:	e0854104 	add	r4, r5, r4, lsl #2
            for (i = 0; i < s_limbs; i++)
    ff18:	e3530000 	cmp	r3, #0
    ff1c:	0a000004 	beq	ff34 <scale10_round_decimal_decoded+0x37c>
              ptr[i] = 0;
    ff20:	e59d3014 	ldr	r3, [sp, #20]
    ff24:	e3a01000 	mov	r1, #0
    ff28:	e1a00004 	mov	r0, r4
    ff2c:	e1a02103 	lsl	r2, r3, #2
    ff30:	eb0029de 	bl	1a6b0 <memset>
            ptr[s_limbs] = (mp_limb_t) 1 << s_bits;
    ff34:	e59d2014 	ldr	r2, [sp, #20]
    ff38:	e3a03001 	mov	r3, #1
    ff3c:	e1a03913 	lsl	r3, r3, r9
            denominator.limbs = ptr;
    ff40:	e58d4054 	str	r4, [sp, #84]	@ 0x54
            ptr[s_limbs] = (mp_limb_t) 1 << s_bits;
    ff44:	e7843102 	str	r3, [r4, r2, lsl #2]
            denominator.nlimbs = s_limbs + 1;
    ff48:	e2823001 	add	r3, r2, #1
    ff4c:	e58d3050 	str	r3, [sp, #80]	@ 0x50
          z_memory = divide (numerator, denominator, &z);
    ff50:	e28d3040 	add	r3, sp, #64	@ 0x40
    ff54:	e58d3000 	str	r3, [sp]
    ff58:	e28d3058 	add	r3, sp, #88	@ 0x58
    ff5c:	e8960003 	ldm	r6, {r0, r1}
    ff60:	e913000c 	ldmdb	r3, {r2, r3}
    ff64:	ebfffdb1 	bl	f630 <divide>
    ff68:	e1a04000 	mov	r4, r0
          free (tmp_memory);
    ff6c:	e1a00007 	mov	r0, r7
    ff70:	ebffe938 	bl	a458 <rpl_free>
  free (pow5_ptr);
    ff74:	e1a00005 	mov	r0, r5
    ff78:	ebffe936 	bl	a458 <rpl_free>
  free (memory);
    ff7c:	e59d001c 	ldr	r0, [sp, #28]
    ff80:	ebffe934 	bl	a458 <rpl_free>
  if (z_memory == NULL)
    ff84:	e3540000 	cmp	r4, #0
    ff88:	0a000099 	beq	101f4 <scale10_round_decimal_decoded+0x63c>
  digits = convert_to_decimal (z, extra_zeroes);
    ff8c:	e59d8040 	ldr	r8, [sp, #64]	@ 0x40
  size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);
    ff90:	ed1f7a2f 	vldr	s14, [pc, #-188]	@ fedc <scale10_round_decimal_decoded+0x324>
    ff94:	e59d3044 	ldr	r3, [sp, #68]	@ 0x44
    ff98:	ee078a90 	vmov	s15, r8
    ff9c:	e58d3014 	str	r3, [sp, #20]
    ffa0:	eef87a67 	vcvt.f32.u32	s15, s15
    ffa4:	ee677a87 	vmul.f32	s15, s15, s14
    ffa8:	eefc7ae7 	vcvt.u32.f32	s15, s15
    ffac:	ee173a90 	vmov	r3, s15
    ffb0:	e2833001 	add	r3, r3, #1
    ffb4:	e0833183 	add	r3, r3, r3, lsl #3
    ffb8:	e09b3003 	adds	r3, fp, r3
    ffbc:	2a00008e 	bcs	101fc <scale10_round_decimal_decoded+0x644>
/* Sum of two sizes, with overflow check.  */
XSIZE_INLINE size_t ATTRIBUTE_PURE
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : SIZE_MAX);
    ffc0:	e2933001 	adds	r3, r3, #1
  char *c_ptr = (char *) malloc (xsum (xsum (extra_zeroes, c_len), 1));
    ffc4:	31a00003 	movcc	r0, r3
    ffc8:	23e00000 	mvncs	r0, #0
    ffcc:	ebfff990 	bl	e614 <rpl_malloc>
  if (c_ptr != NULL)
    ffd0:	e2505000 	subs	r5, r0, #0
    ffd4:	0a00008c 	beq	1020c <scale10_round_decimal_decoded+0x654>
      for (; extra_zeroes > 0; extra_zeroes--)
    ffd8:	e35b0000 	cmp	fp, #0
    ffdc:	0a000049 	beq	10108 <scale10_round_decimal_decoded+0x550>
        *d_ptr++ = '0';
    ffe0:	e1a0200b 	mov	r2, fp
    ffe4:	e3a01030 	mov	r1, #48	@ 0x30
    ffe8:	e1a00005 	mov	r0, r5
    ffec:	e085b00b 	add	fp, r5, fp
    fff0:	eb0029ae 	bl	1a6b0 <memset>
      while (a_len > 0)
    fff4:	e3580000 	cmp	r8, #0
    fff8:	0a00002f 	beq	100bc <scale10_round_decimal_decoded+0x504>
              *d_ptr++ = '0' + (remainder % 10);
    fffc:	e30caccd 	movw	sl, #52429	@ 0xcccd
   10000:	e28f7e21 	add	r7, pc, #528	@ 0x210
   10004:	e1c760d0 	ldrd	r6, [r7]
   10008:	e28b9009 	add	r9, fp, #9
   1000c:	e34caccc 	movt	sl, #52428	@ 0xcccc
   10010:	e1a03108 	lsl	r3, r8, #2
   10014:	e58d4018 	str	r4, [sp, #24]
   10018:	e58d501c 	str	r5, [sp, #28]
   1001c:	e1a04009 	mov	r4, r9
   10020:	e1a0500a 	mov	r5, sl
   10024:	e58d3010 	str	r3, [sp, #16]
          mp_limb_t *ptr = a_ptr + a_len;
   10028:	e1cd21d0 	ldrd	r2, [sp, #16]
   1002c:	e244b009 	sub	fp, r4, #9
          for (count = a_len; count > 0; count--)
   10030:	e1a09008 	mov	r9, r8
          mp_limb_t remainder = 0;
   10034:	e3a01000 	mov	r1, #0
          mp_limb_t *ptr = a_ptr + a_len;
   10038:	e0830002 	add	r0, r3, r2
   1003c:	e1a0a000 	mov	sl, r0
          mp_limb_t remainder = 0;
   10040:	e58d000c 	str	r0, [sp, #12]
              *ptr = num / 1000000000;
   10044:	e53a0004 	ldr	r0, [sl, #-4]!
   10048:	e1a02006 	mov	r2, r6
   1004c:	e1a03007 	mov	r3, r7
   10050:	eb001956 	bl	165b0 <__aeabi_uldivmod>
          for (count = a_len; count > 0; count--)
   10054:	e2599001 	subs	r9, r9, #1
              remainder = num % 1000000000;
   10058:	e1a01002 	mov	r1, r2
              *ptr = num / 1000000000;
   1005c:	e58a0000 	str	r0, [sl]
          for (count = a_len; count > 0; count--)
   10060:	1afffff7 	bne	10044 <scale10_round_decimal_decoded+0x48c>
   10064:	e59d000c 	ldr	r0, [sp, #12]
              *d_ptr++ = '0' + (remainder % 10);
   10068:	e0823195 	umull	r3, r2, r5, r1
   1006c:	e1a021a2 	lsr	r2, r2, #3
   10070:	e0823102 	add	r3, r2, r2, lsl #2
   10074:	e0413083 	sub	r3, r1, r3, lsl #1
              remainder = remainder / 10;
   10078:	e1a01002 	mov	r1, r2
              *d_ptr++ = '0' + (remainder % 10);
   1007c:	e2833030 	add	r3, r3, #48	@ 0x30
   10080:	e4cb3001 	strb	r3, [fp], #1
          for (count = 9; count > 0; count--)
   10084:	e15b0004 	cmp	fp, r4
   10088:	1afffff6 	bne	10068 <scale10_round_decimal_decoded+0x4b0>
          if (a_ptr[a_len - 1] == 0)
   1008c:	e5103004 	ldr	r3, [r0, #-4]
   10090:	e3530000 	cmp	r3, #0
   10094:	1a000005 	bne	100b0 <scale10_round_decimal_decoded+0x4f8>
      while (a_len > 0)
   10098:	e2588001 	subs	r8, r8, #1
   1009c:	e2844009 	add	r4, r4, #9
   100a0:	0a000004 	beq	100b8 <scale10_round_decimal_decoded+0x500>
   100a4:	e1a03108 	lsl	r3, r8, #2
   100a8:	e58d3010 	str	r3, [sp, #16]
   100ac:	eaffffdd 	b	10028 <scale10_round_decimal_decoded+0x470>
   100b0:	e2844009 	add	r4, r4, #9
   100b4:	eaffffdb 	b	10028 <scale10_round_decimal_decoded+0x470>
   100b8:	e1cd41d8 	ldrd	r4, [sp, #24]
      while (d_ptr > c_ptr && d_ptr[-1] == '0')
   100bc:	e155000b 	cmp	r5, fp
   100c0:	3a000002 	bcc	100d0 <scale10_round_decimal_decoded+0x518>
   100c4:	ea000006 	b	100e4 <scale10_round_decimal_decoded+0x52c>
   100c8:	e155000b 	cmp	r5, fp
   100cc:	0a000010 	beq	10114 <scale10_round_decimal_decoded+0x55c>
   100d0:	e1a0200b 	mov	r2, fp
   100d4:	e57b3001 	ldrb	r3, [fp, #-1]!
   100d8:	e3530030 	cmp	r3, #48	@ 0x30
   100dc:	0afffff9 	beq	100c8 <scale10_round_decimal_decoded+0x510>
   100e0:	e1a0b002 	mov	fp, r2
      if (d_ptr == c_ptr)
   100e4:	e155000b 	cmp	r5, fp
   100e8:	0a000009 	beq	10114 <scale10_round_decimal_decoded+0x55c>
      *d_ptr = '\0';
   100ec:	e3a03000 	mov	r3, #0
   100f0:	e5cb3000 	strb	r3, [fp]
  free (z_memory);
   100f4:	e1a00004 	mov	r0, r4
   100f8:	ebffe8d6 	bl	a458 <rpl_free>
}
   100fc:	e1a00005 	mov	r0, r5
   10100:	e28dd05c 	add	sp, sp, #92	@ 0x5c
   10104:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
      while (a_len > 0)
   10108:	e3580000 	cmp	r8, #0
      char *d_ptr = c_ptr;
   1010c:	e1a0b005 	mov	fp, r5
      while (a_len > 0)
   10110:	1affffb9 	bne	fffc <scale10_round_decimal_decoded+0x444>
        *d_ptr++ = '0';
   10114:	e3a03030 	mov	r3, #48	@ 0x30
   10118:	e4cb3001 	strb	r3, [fp], #1
   1011c:	eafffff2 	b	100ec <scale10_round_decimal_decoded+0x534>
      if (s_limbs > 0)
   10120:	e353001f 	cmp	r3, #31
   10124:	c3a0c004 	movgt	ip, #4
   10128:	caffff14 	bgt	fd80 <scale10_round_decimal_decoded+0x1c8>
      pow5.nlimbs = pow5_len;
   1012c:	e1cd43f8 	strd	r4, [sp, #56]	@ 0x38
      if (n >= 0)
   10130:	eaffff25 	b	fdcc <scale10_round_decimal_decoded+0x214>
                for (count = m.nlimbs; count > 0; count--)
   10134:	e3520000 	cmp	r2, #0
   10138:	0a000027 	beq	101dc <scale10_round_decimal_decoded+0x624>
                  *destptr++ = *sourceptr++;
   1013c:	e59d2020 	ldr	r2, [sp, #32]
   10140:	e1a00003 	mov	r0, r3
   10144:	e59d1024 	ldr	r1, [sp, #36]	@ 0x24
   10148:	e1a06102 	lsl	r6, r2, #2
   1014c:	e1a02006 	mov	r2, r6
   10150:	eb003f4a 	bl	1fe80 <memcpy>
   10154:	e0802006 	add	r2, r0, r6
            numerator.nlimbs = destptr - num_ptr;
   10158:	e0423004 	sub	r3, r2, r4
          z_memory = divide (numerator, pow5, &z);
   1015c:	e28d1058 	add	r1, sp, #88	@ 0x58
            numerator.nlimbs = destptr - num_ptr;
   10160:	e1a03143 	asr	r3, r3, #2
            numerator.limbs = num_ptr;
   10164:	e58d4054 	str	r4, [sp, #84]	@ 0x54
            numerator.nlimbs = destptr - num_ptr;
   10168:	e58d3050 	str	r3, [sp, #80]	@ 0x50
          z_memory = divide (numerator, pow5, &z);
   1016c:	e28d3040 	add	r3, sp, #64	@ 0x40
   10170:	e58d3000 	str	r3, [sp]
   10174:	e28d3038 	add	r3, sp, #56	@ 0x38
   10178:	e893000c 	ldm	r3, {r2, r3}
   1017c:	e9110003 	ldmdb	r1, {r0, r1}
   10180:	ebfffd2a 	bl	f630 <divide>
   10184:	e1a03000 	mov	r3, r0
          free (num_ptr);
   10188:	e1a00004 	mov	r0, r4
          z_memory = divide (numerator, pow5, &z);
   1018c:	e1a04003 	mov	r4, r3
          free (num_ptr);
   10190:	ebffe8b0 	bl	a458 <rpl_free>
   10194:	eaffff76 	b	ff74 <scale10_round_decimal_decoded+0x3bc>
      if (s_limbs > 0)
   10198:	e353001f 	cmp	r3, #31
   1019c:	daffff07 	ble	fdc0 <scale10_round_decimal_decoded+0x208>
   101a0:	eafffef6 	b	fd80 <scale10_round_decimal_decoded+0x1c8>
          z_memory = divide (m, pow5, &z);
   101a4:	e28d3040 	add	r3, sp, #64	@ 0x40
   101a8:	e28d1030 	add	r1, sp, #48	@ 0x30
   101ac:	e58d3000 	str	r3, [sp]
   101b0:	e28d3038 	add	r3, sp, #56	@ 0x38
   101b4:	e893000c 	ldm	r3, {r2, r3}
   101b8:	e8910003 	ldm	r1, {r0, r1}
   101bc:	ebfffd1b 	bl	f630 <divide>
   101c0:	e1a04000 	mov	r4, r0
   101c4:	eaffff6a 	b	ff74 <scale10_round_decimal_decoded+0x3bc>
      if (s_limbs > 0)
   101c8:	e353001f 	cmp	r3, #31
   101cc:	dafffefb 	ble	fdc0 <scale10_round_decimal_decoded+0x208>
          for (count = pow5_len; count > 0;)
   101d0:	e3540000 	cmp	r4, #0
   101d4:	1afffee8 	bne	fd7c <scale10_round_decimal_decoded+0x1c4>
   101d8:	eaffff10 	b	fe20 <scale10_round_decimal_decoded+0x268>
                for (count = m.nlimbs; count > 0; count--)
   101dc:	e1a02003 	mov	r2, r3
   101e0:	eaffffdc 	b	10158 <scale10_round_decimal_decoded+0x5a0>
              free (pow5_ptr);
   101e4:	e1a00005 	mov	r0, r5
   101e8:	ebffe89a 	bl	a458 <rpl_free>
              free (memory);
   101ec:	e59d001c 	ldr	r0, [sp, #28]
   101f0:	ebffe898 	bl	a458 <rpl_free>
      return NULL;
   101f4:	e3a05000 	mov	r5, #0
   101f8:	eaffffbf 	b	100fc <scale10_round_decimal_decoded+0x544>
  char *c_ptr = (char *) malloc (xsum (xsum (extra_zeroes, c_len), 1));
   101fc:	e3e00000 	mvn	r0, #0
   10200:	ebfff903 	bl	e614 <rpl_malloc>
  if (c_ptr != NULL)
   10204:	e2505000 	subs	r5, r0, #0
   10208:	1affff74 	bne	ffe0 <scale10_round_decimal_decoded+0x428>
  char *c_ptr = (char *) malloc (xsum (xsum (extra_zeroes, c_len), 1));
   1020c:	e3a05000 	mov	r5, #0
   10210:	eaffffb7 	b	100f4 <scale10_round_decimal_decoded+0x53c>
   10214:	e320f000 	nop	{0}
   10218:	3b9aca00 	.word	0x3b9aca00
   1021c:	00000000 	.word	0x00000000

00010220 <scale10_round_decimal_long_double>:
{
   10220:	e92d4030 	push	{r4, r5, lr}
   10224:	e1a05000 	mov	r5, r0
   10228:	ed2d8b02 	vpush	{d8}
  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));
   1022c:	e3a00008 	mov	r0, #8
{
   10230:	e24dd01c 	sub	sp, sp, #28
   10234:	eeb08b40 	vmov.f64	d8, d0
  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));
   10238:	ebfff8f5 	bl	e614 <rpl_malloc>
  if (m.limbs == NULL)
   1023c:	e2504000 	subs	r4, r0, #0
   10240:	0a00004a 	beq	10370 <scale10_round_decimal_long_double+0x150>
  y = frexpl (x, &exp);
   10244:	e28d000c 	add	r0, sp, #12
   10248:	eeb00b48 	vmov.f64	d0, d8
   1024c:	eb004107 	bl	20670 <frexpl>
  if (!(y >= 0.0L && y < 1.0L))
   10250:	eeb50bc0 	vcmpe.f64	d0, #0.0
   10254:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   10258:	ba00004a 	blt	10388 <scale10_round_decimal_long_double+0x168>
   1025c:	ed9f5b4b 	vldr	d5, [pc, #300]	@ 10390 <scale10_round_decimal_long_double+0x170>
   10260:	eeb40bc5 	vcmpe.f64	d0, d5
   10264:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   10268:	5a000046 	bpl	10388 <scale10_round_decimal_long_double+0x168>
      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % (GMP_LIMB_BITS / 2));
   1026c:	ed9f7b49 	vldr	d7, [pc, #292]	@ 10398 <scale10_round_decimal_long_double+0x178>
   10270:	ee207b07 	vmul.f64	d7, d0, d7
      hi = (int) y;
   10274:	eebd6bc7 	vcvt.s32.f64	s12, d7
      y -= hi;
   10278:	eeb84b46 	vcvt.f64.u32	d4, s12
   1027c:	ee377b44 	vsub.f64	d7, d7, d4
      if (!(y >= 0.0L && y < 1.0L))
   10280:	eeb57bc0 	vcmpe.f64	d7, #0.0
   10284:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   10288:	ba00003e 	blt	10388 <scale10_round_decimal_long_double+0x168>
   1028c:	eeb47bc5 	vcmpe.f64	d7, d5
   10290:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   10294:	5a00003b 	bpl	10388 <scale10_round_decimal_long_double+0x168>
      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);
   10298:	ed9f4b40 	vldr	d4, [pc, #256]	@ 103a0 <scale10_round_decimal_long_double+0x180>
   1029c:	ee277b04 	vmul.f64	d7, d7, d4
      lo = (int) y;
   102a0:	eefd6bc7 	vcvt.s32.f64	s13, d7
      y -= lo;
   102a4:	eeb83b66 	vcvt.f64.u32	d3, s13
   102a8:	ee377b43 	vsub.f64	d7, d7, d3
      if (!(y >= 0.0L && y < 1.0L))
   102ac:	eeb57bc0 	vcmpe.f64	d7, #0.0
   102b0:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   102b4:	ba000033 	blt	10388 <scale10_round_decimal_long_double+0x168>
   102b8:	eeb47bc5 	vcmpe.f64	d7, d5
   102bc:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   102c0:	5a000030 	bpl	10388 <scale10_round_decimal_long_double+0x168>
      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);
   102c4:	ee277b04 	vmul.f64	d7, d7, d4
      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;
   102c8:	ee162a10 	vmov	r2, s12
   102cc:	ee163a90 	vmov	r3, s13
   102d0:	e1832802 	orr	r2, r3, r2, lsl #16
      hi = (int) y;
   102d4:	eebd6bc7 	vcvt.s32.f64	s12, d7
      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;
   102d8:	e5842004 	str	r2, [r4, #4]
      y -= hi;
   102dc:	eeb83b46 	vcvt.f64.u32	d3, s12
   102e0:	ee377b43 	vsub.f64	d7, d7, d3
      if (!(y >= 0.0L && y < 1.0L))
   102e4:	eeb57bc0 	vcmpe.f64	d7, #0.0
   102e8:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   102ec:	ba000025 	blt	10388 <scale10_round_decimal_long_double+0x168>
   102f0:	eeb47bc5 	vcmpe.f64	d7, d5
   102f4:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   102f8:	5a000022 	bpl	10388 <scale10_round_decimal_long_double+0x168>
      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);
   102fc:	ee277b04 	vmul.f64	d7, d7, d4
      lo = (int) y;
   10300:	eefd6bc7 	vcvt.s32.f64	s13, d7
      y -= lo;
   10304:	eeb85b66 	vcvt.f64.u32	d5, s13
   10308:	ee377b45 	vsub.f64	d7, d7, d5
      if (!(y >= 0.0L && y < 1.0L))
   1030c:	eeb57bc0 	vcmpe.f64	d7, #0.0
   10310:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   10314:	ba00001b 	blt	10388 <scale10_round_decimal_long_double+0x168>
   10318:	ed9f5b1c 	vldr	d5, [pc, #112]	@ 10390 <scale10_round_decimal_long_double+0x170>
   1031c:	eeb47bc5 	vcmpe.f64	d7, d5
   10320:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   10324:	5a000017 	bpl	10388 <scale10_round_decimal_long_double+0x168>
      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;
   10328:	ee163a90 	vmov	r3, s13
  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)
   1032c:	e3520000 	cmp	r2, #0
      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;
   10330:	ee161a10 	vmov	r1, s12
   10334:	e1833801 	orr	r3, r3, r1, lsl #16
   10338:	e5843000 	str	r3, [r4]
  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)
   1033c:	1a00000f 	bne	10380 <scale10_round_decimal_long_double+0x160>
   10340:	e2533000 	subs	r3, r3, #0
   10344:	13a03001 	movne	r3, #1
  *ep = exp - LDBL_MANT_BIT;
   10348:	e59d000c 	ldr	r0, [sp, #12]
    return scale10_round_decimal_decoded (e, m, memory, n);
   1034c:	e28d2018 	add	r2, sp, #24
  *mp = m;
   10350:	e58d3010 	str	r3, [sp, #16]
    return scale10_round_decimal_decoded (e, m, memory, n);
   10354:	e1a03004 	mov	r3, r4
  *mp = m;
   10358:	e58d4014 	str	r4, [sp, #20]
    return scale10_round_decimal_decoded (e, m, memory, n);
   1035c:	e58d5000 	str	r5, [sp]
   10360:	e2400035 	sub	r0, r0, #53	@ 0x35
   10364:	e9120006 	ldmdb	r2, {r1, r2}
   10368:	ebfffe12 	bl	fbb8 <scale10_round_decimal_decoded>
   1036c:	e1a04000 	mov	r4, r0
}
   10370:	e1a00004 	mov	r0, r4
   10374:	e28dd01c 	add	sp, sp, #28
   10378:	ecbd8b02 	vpop	{d8}
   1037c:	e8bd8030 	pop	{r4, r5, pc}
  m.nlimbs = (LDBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;
   10380:	e3a03002 	mov	r3, #2
   10384:	eaffffef 	b	10348 <scale10_round_decimal_long_double+0x128>
    abort ();
   10388:	eb0018df 	bl	1670c <abort>
   1038c:	e320f000 	nop	{0}
   10390:	00000000 	.word	0x00000000
   10394:	3ff00000 	.word	0x3ff00000
   10398:	00000000 	.word	0x00000000
   1039c:	40400000 	.word	0x40400000
   103a0:	00000000 	.word	0x00000000
   103a4:	40f00000 	.word	0x40f00000

000103a8 <scale10_round_decimal_double>:
{
   103a8:	e92d4030 	push	{r4, r5, lr}
   103ac:	e24dd01c 	sub	sp, sp, #28
  void *memory = decode_double (x, &e, &m);
   103b0:	e28d5010 	add	r5, sp, #16
{
   103b4:	e1a04000 	mov	r4, r0
  void *memory = decode_double (x, &e, &m);
   103b8:	e1a01005 	mov	r1, r5
   103bc:	e28d000c 	add	r0, sp, #12
   103c0:	ebfffc3a 	bl	f4b0 <decode_double>
  if (memory != NULL)
   103c4:	e2503000 	subs	r3, r0, #0
   103c8:	0a000004 	beq	103e0 <scale10_round_decimal_double+0x38>
    return scale10_round_decimal_decoded (e, m, memory, n);
   103cc:	e8950006 	ldm	r5, {r1, r2}
   103d0:	e59d000c 	ldr	r0, [sp, #12]
   103d4:	e58d4000 	str	r4, [sp]
   103d8:	ebfffdf6 	bl	fbb8 <scale10_round_decimal_decoded>
   103dc:	e1a03000 	mov	r3, r0
}
   103e0:	e1a00003 	mov	r0, r3
   103e4:	e28dd01c 	add	sp, sp, #28
   103e8:	e8bd8030 	pop	{r4, r5, pc}

000103ec <max_room_needed.isra.0>:
# endif

/* Returns the number of TCHAR_T units needed as temporary space for the result
   of sprintf or SNPRINTF of a single conversion directive.  */
static size_t
MAX_ROOM_NEEDED (const arguments *ap, size_t arg_index, FCHAR_T conversion,
   103ec:	e92d4010 	push	{r4, lr}
                 arg_type type, int flags, size_t width, int has_precision,
                 size_t precision, int pad_ourselves)
{
  size_t tmp_length;

  switch (conversion)
   103f0:	e2422041 	sub	r2, r2, #65	@ 0x41
MAX_ROOM_NEEDED (const arguments *ap, size_t arg_index, FCHAR_T conversion,
   103f4:	e59dc010 	ldr	ip, [sp, #16]
  switch (conversion)
   103f8:	e3520037 	cmp	r2, #55	@ 0x37
   103fc:	979ff102 	ldrls	pc, [pc, r2, lsl #2]
   10400:	ea0000c5 	b	1071c <max_room_needed.isra.0+0x330>
   10404:	0001056c 	.word	0x0001056c
   10408:	0001071c 	.word	0x0001071c
   1040c:	0001071c 	.word	0x0001071c
   10410:	0001071c 	.word	0x0001071c
   10414:	000104e4 	.word	0x000104e4
   10418:	00010580 	.word	0x00010580
   1041c:	000104e4 	.word	0x000104e4
   10420:	0001071c 	.word	0x0001071c
   10424:	0001071c 	.word	0x0001071c
   10428:	0001071c 	.word	0x0001071c
   1042c:	0001071c 	.word	0x0001071c
   10430:	0001071c 	.word	0x0001071c
   10434:	0001071c 	.word	0x0001071c
   10438:	0001071c 	.word	0x0001071c
   1043c:	0001071c 	.word	0x0001071c
   10440:	0001071c 	.word	0x0001071c
   10444:	0001071c 	.word	0x0001071c
   10448:	0001071c 	.word	0x0001071c
   1044c:	0001071c 	.word	0x0001071c
   10450:	0001071c 	.word	0x0001071c
   10454:	0001071c 	.word	0x0001071c
   10458:	0001071c 	.word	0x0001071c
   1045c:	0001071c 	.word	0x0001071c
   10460:	00010594 	.word	0x00010594
   10464:	0001071c 	.word	0x0001071c
   10468:	0001071c 	.word	0x0001071c
   1046c:	0001071c 	.word	0x0001071c
   10470:	0001071c 	.word	0x0001071c
   10474:	0001071c 	.word	0x0001071c
   10478:	0001071c 	.word	0x0001071c
   1047c:	0001071c 	.word	0x0001071c
   10480:	0001071c 	.word	0x0001071c
   10484:	0001056c 	.word	0x0001056c
   10488:	0001061c 	.word	0x0001061c
   1048c:	00010640 	.word	0x00010640
   10490:	00010514 	.word	0x00010514
   10494:	000104e4 	.word	0x000104e4
   10498:	00010580 	.word	0x00010580
   1049c:	000104e4 	.word	0x000104e4
   104a0:	0001071c 	.word	0x0001071c
   104a4:	00010514 	.word	0x00010514
   104a8:	0001071c 	.word	0x0001071c
   104ac:	0001071c 	.word	0x0001071c
   104b0:	0001071c 	.word	0x0001071c
   104b4:	0001071c 	.word	0x0001071c
   104b8:	0001071c 	.word	0x0001071c
   104bc:	0001065c 	.word	0x0001065c
   104c0:	000105c8 	.word	0x000105c8
   104c4:	0001071c 	.word	0x0001071c
   104c8:	0001071c 	.word	0x0001071c
   104cc:	000105dc 	.word	0x000105dc
   104d0:	0001071c 	.word	0x0001071c
   104d4:	00010514 	.word	0x00010514
   104d8:	0001071c 	.word	0x0001071c
   104dc:	0001071c 	.word	0x0001071c
   104e0:	00010594 	.word	0x00010594
   104e4:	e29c300c 	adds	r3, ip, #12
   104e8:	2a000007 	bcs	1050c <max_room_needed.isra.0+0x120>

    default:
      abort ();
    }

  if (!pad_ourselves)
   104ec:	e59d2014 	ldr	r2, [sp, #20]
   104f0:	e3520000 	cmp	r2, #0
   104f4:	1a000002 	bne	10504 <max_room_needed.isra.0+0x118>
         but is certainly
           <= tmp_length + width.  */
      tmp_length = xsum (tmp_length, width);
# else
      /* Padding considers the number of elements, says POSIX.  */
      if (tmp_length < width)
   104f8:	e59d2008 	ldr	r2, [sp, #8]
   104fc:	e1530002 	cmp	r3, r2
   10500:	31a03002 	movcc	r3, r2
  size_t sum = size1 + size2;
   10504:	e2930001 	adds	r0, r3, #1
  return (sum >= size1 ? sum : SIZE_MAX);
   10508:	38bd8010 	popcc	{r4, pc}
   1050c:	e3e00000 	mvn	r0, #0
    }

  tmp_length = xsum (tmp_length, 1); /* account for trailing NUL */

  return tmp_length;
}
   10510:	e8bd8010 	pop	{r4, pc}
      switch (type)
   10514:	e2433009 	sub	r3, r3, #9
   10518:	e3530011 	cmp	r3, #17
   1051c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   10520:	ea000072 	b	106f0 <max_room_needed.isra.0+0x304>
   10524:	000106c4 	.word	0x000106c4
   10528:	000106c4 	.word	0x000106c4
   1052c:	00010708 	.word	0x00010708
   10530:	00010708 	.word	0x00010708
   10534:	00010700 	.word	0x00010700
   10538:	00010700 	.word	0x00010700
   1053c:	000106f0 	.word	0x000106f0
   10540:	000106f0 	.word	0x000106f0
   10544:	000106c4 	.word	0x000106c4
   10548:	000106c4 	.word	0x000106c4
   1054c:	000106f0 	.word	0x000106f0
   10550:	000106f0 	.word	0x000106f0
   10554:	000106f0 	.word	0x000106f0
   10558:	000106f0 	.word	0x000106f0
   1055c:	000106f0 	.word	0x000106f0
   10560:	000106f0 	.word	0x000106f0
   10564:	000106c4 	.word	0x000106c4
   10568:	000106c4 	.word	0x000106c4
      if (tmp_length < precision)
   1056c:	e35c000d 	cmp	ip, #13
   10570:	9a00004e 	bls	106b0 <max_room_needed.isra.0+0x2c4>
  size_t sum = size1 + size2;
   10574:	e29c300c 	adds	r3, ip, #12
  return (sum >= size1 ? sum : SIZE_MAX);
   10578:	3affffdb 	bcc	104ec <max_room_needed.isra.0+0x100>
   1057c:	eaffffe2 	b	1050c <max_room_needed.isra.0+0x120>
   10580:	e37c0f9d 	cmn	ip, #628	@ 0x274
   10584:	e28c3e27 	add	r3, ip, #624	@ 0x270
   10588:	e2833003 	add	r3, r3, #3
   1058c:	9affffd6 	bls	104ec <max_room_needed.isra.0+0x100>
   10590:	eaffffdd 	b	1050c <max_room_needed.isra.0+0x120>
      switch (type)
   10594:	e243300a 	sub	r3, r3, #10
   10598:	e6ef3073 	uxtb	r3, r3
   1059c:	e3530010 	cmp	r3, #16
   105a0:	93092d20 	movwls	r2, #40224	@ 0x9d20
    case 'x': case 'X':
   105a4:	83a03009 	movhi	r3, #9
   105a8:	93402002 	movtls	r2, #2
   105ac:	90822103 	addls	r2, r2, r3, lsl #2
   105b0:	959230c0 	ldrls	r3, [r2, #192]	@ 0xc0
      if (tmp_length < precision)
   105b4:	e15c0003 	cmp	ip, r3
   105b8:	21a0300c 	movcs	r3, ip
   105bc:	e2933002 	adds	r3, r3, #2
   105c0:	3affffc9 	bcc	104ec <max_room_needed.isra.0+0x100>
   105c4:	eaffffd0 	b	1050c <max_room_needed.isra.0+0x120>
  if (!pad_ourselves)
   105c8:	e59d3014 	ldr	r3, [sp, #20]
   105cc:	e3530000 	cmp	r3, #0
   105d0:	0a00002e 	beq	10690 <max_room_needed.isra.0+0x2a4>
   105d4:	e3a0000c 	mov	r0, #12
   105d8:	e8bd8010 	pop	{r4, pc}
      if (type == TYPE_WIDE_STRING)
   105dc:	e3530020 	cmp	r3, #32
   105e0:	0a00004d 	beq	1071c <max_room_needed.isra.0+0x330>
          const char *arg = ap->arg[arg_index].a.a_string;
   105e4:	e5903004 	ldr	r3, [r0, #4]
          if (has_precision)
   105e8:	e59d200c 	ldr	r2, [sp, #12]
          const char *arg = ap->arg[arg_index].a.a_string;
   105ec:	e0833201 	add	r3, r3, r1, lsl #4
          if (has_precision)
   105f0:	e3520000 	cmp	r2, #0
          const char *arg = ap->arg[arg_index].a.a_string;
   105f4:	e5930008 	ldr	r0, [r3, #8]
          if (has_precision)
   105f8:	0a000026 	beq	10698 <max_room_needed.isra.0+0x2ac>
            tmp_length = local_strnlen (arg, precision);
   105fc:	e1a0100c 	mov	r1, ip
   10600:	eb002934 	bl	1aad8 <strnlen>
  if (!pad_ourselves)
   10604:	e59d3014 	ldr	r3, [sp, #20]
   10608:	e3530000 	cmp	r3, #0
            tmp_length = local_strnlen (arg, precision);
   1060c:	e1a03000 	mov	r3, r0
  if (!pad_ourselves)
   10610:	0affffb8 	beq	104f8 <max_room_needed.isra.0+0x10c>
  size_t sum = size1 + size2;
   10614:	e2800001 	add	r0, r0, #1
  return (sum >= size1 ? sum : SIZE_MAX);
   10618:	e8bd8010 	pop	{r4, pc}
      switch (type)
   1061c:	e243300a 	sub	r3, r3, #10
   10620:	e6ef3073 	uxtb	r3, r3
   10624:	e3530010 	cmp	r3, #16
   10628:	93092d20 	movwls	r2, #40224	@ 0x9d20
    case 'b':
   1062c:	83a03021 	movhi	r3, #33	@ 0x21
   10630:	93402002 	movtls	r2, #2
   10634:	90822103 	addls	r2, r2, r3, lsl #2
   10638:	95923038 	ldrls	r3, [r2, #56]	@ 0x38
   1063c:	eaffffdc 	b	105b4 <max_room_needed.isra.0+0x1c8>
      if (type == TYPE_WIDE_CHAR)
   10640:	e353001e 	cmp	r3, #30
   10644:	0a000031 	beq	10710 <max_room_needed.isra.0+0x324>
  if (!pad_ourselves)
   10648:	e59d3014 	ldr	r3, [sp, #20]
   1064c:	e3530000 	cmp	r3, #0
   10650:	1a000024 	bne	106e8 <max_room_needed.isra.0+0x2fc>
        tmp_length = 1;
   10654:	e3a03001 	mov	r3, #1
   10658:	eaffffa6 	b	104f8 <max_room_needed.isra.0+0x10c>
      switch (type)
   1065c:	e243300a 	sub	r3, r3, #10
   10660:	e6ef3073 	uxtb	r3, r3
   10664:	e3530010 	cmp	r3, #16
   10668:	93092d20 	movwls	r2, #40224	@ 0x9d20
    case 'o':
   1066c:	83a0300b 	movhi	r3, #11
   10670:	93402002 	movtls	r2, #2
   10674:	90822103 	addls	r2, r2, r3, lsl #2
   10678:	9592307c 	ldrls	r3, [r2, #124]	@ 0x7c
      if (tmp_length < precision)
   1067c:	e15c0003 	cmp	ip, r3
   10680:	21a0300c 	movcs	r3, ip
   10684:	e2933001 	adds	r3, r3, #1
   10688:	3affff97 	bcc	104ec <max_room_needed.isra.0+0x100>
   1068c:	eaffff9e 	b	1050c <max_room_needed.isra.0+0x120>
      tmp_length =
   10690:	e3a0300b 	mov	r3, #11
   10694:	eaffff97 	b	104f8 <max_room_needed.isra.0+0x10c>
            tmp_length = strlen (arg);
   10698:	fa003f78 	blx	20480 <strlen>
  if (!pad_ourselves)
   1069c:	e59d3014 	ldr	r3, [sp, #20]
   106a0:	e3530000 	cmp	r3, #0
            tmp_length = strlen (arg);
   106a4:	e1a03000 	mov	r3, r0
  if (!pad_ourselves)
   106a8:	0affff92 	beq	104f8 <max_room_needed.isra.0+0x10c>
   106ac:	eaffffd8 	b	10614 <max_room_needed.isra.0+0x228>
   106b0:	e59d3014 	ldr	r3, [sp, #20]
   106b4:	e3530000 	cmp	r3, #0
   106b8:	1a00000e 	bne	106f8 <max_room_needed.isra.0+0x30c>
   106bc:	e3a03019 	mov	r3, #25
   106c0:	eaffff8c 	b	104f8 <max_room_needed.isra.0+0x10c>
          tmp_length =
   106c4:	e3a03014 	mov	r3, #20
      if (tmp_length < precision)
   106c8:	e153000c 	cmp	r3, ip
   106cc:	21a02003 	movcs	r2, r3
   106d0:	31a0200c 	movcc	r2, ip
  size_t sum = size1 + size2;
   106d4:	e1a03082 	lsl	r3, r2, #1
  return (sum >= size1 ? sum : SIZE_MAX);
   106d8:	e1520003 	cmp	r2, r3
  size_t sum = size1 + size2;
   106dc:	92833001 	addls	r3, r3, #1
  return (sum >= size1 ? sum : SIZE_MAX);
   106e0:	9affff81 	bls	104ec <max_room_needed.isra.0+0x100>
   106e4:	eaffff88 	b	1050c <max_room_needed.isra.0+0x120>
   106e8:	e3a00002 	mov	r0, #2
   106ec:	e8bd8010 	pop	{r4, pc}
          tmp_length =
   106f0:	e3a0300a 	mov	r3, #10
   106f4:	eafffff3 	b	106c8 <max_room_needed.isra.0+0x2dc>
   106f8:	e3a0001a 	mov	r0, #26
   106fc:	e8bd8010 	pop	{r4, pc}
          tmp_length =
   10700:	e3a03005 	mov	r3, #5
   10704:	eaffffef 	b	106c8 <max_room_needed.isra.0+0x2dc>
   10708:	e3a03003 	mov	r3, #3
   1070c:	eaffffed 	b	106c8 <max_room_needed.isra.0+0x2dc>
          tmp_length = MB_CUR_MAX;
   10710:	eb002a6e 	bl	1b0d0 <__locale_mb_cur_max>
   10714:	e1a03000 	mov	r3, r0
   10718:	eaffff73 	b	104ec <max_room_needed.isra.0+0x100>
      abort ();
   1071c:	eb0017fa 	bl	1670c <abort>

00010720 <rpl_vasnprintf>:
#endif

DCHAR_T *
VASNPRINTF (DCHAR_T *resultbuf, size_t *lengthp,
            const FCHAR_T *format, va_list args)
{
   10720:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10724:	e1a05003 	mov	r5, r3
   10728:	ed2d8b02 	vpush	{d8}
   1072c:	e28db028 	add	fp, sp, #40	@ 0x28
  DIRECTIVES d;
  arguments a;

  if (PRINTF_PARSE (format, &d, &a) < 0)
   10730:	e24b3e99 	sub	r3, fp, #2448	@ 0x990
{
   10734:	e1a04002 	mov	r4, r2
  if (PRINTF_PARSE (format, &d, &a) < 0)
   10738:	e243300c 	sub	r3, r3, #12
{
   1073c:	e24ddd2b 	sub	sp, sp, #2752	@ 0xac0
  if (PRINTF_PARSE (format, &d, &a) < 0)
   10740:	e24b2ea1 	sub	r2, fp, #2576	@ 0xa10
{
   10744:	e24dd004 	sub	sp, sp, #4
   10748:	e1a08001 	mov	r8, r1
  if (PRINTF_PARSE (format, &d, &a) < 0)
   1074c:	e242200c 	sub	r2, r2, #12
{
   10750:	e50b0a90 	str	r0, [fp, #-2704]	@ 0xfffff570
  if (PRINTF_PARSE (format, &d, &a) < 0)
   10754:	e2431008 	sub	r1, r3, #8
   10758:	e1a00004 	mov	r0, r4
   1075c:	eb0012f7 	bl	15340 <printf_parse>
   10760:	e3500000 	cmp	r0, #0
   10764:	ba00010e 	blt	10ba4 <rpl_vasnprintf+0x484>
  if (d.dir != d.direct_alloc_dir)                                      \
    free (d.dir);                                                       \
  if (a.arg != a.direct_alloc_arg)                                      \
    free (a.arg);

  if (PRINTF_FETCHARGS (args, &a) < 0)
   10768:	e24b1ea1 	sub	r1, fp, #2576	@ 0xa10
   1076c:	e1a00005 	mov	r0, r5
   10770:	e241100c 	sub	r1, r1, #12
   10774:	eb00128d 	bl	151b0 <printf_fetchargs>
   10778:	e3500000 	cmp	r0, #0
   1077c:	ba0008a1 	blt	12a08 <rpl_vasnprintf+0x22e8>
  size_t sum = size1 + size2;
   10780:	e51b299c 	ldr	r2, [fp, #-2460]	@ 0xfffff664
    size_t length;

    /* Allocate a small buffer that will hold a directive passed to
       sprintf or snprintf.  */
    buf_neededlength =
      xsum4 (7, d.max_width_length, d.max_precision_length, 6);
   10784:	e51b3998 	ldr	r3, [fp, #-2456]	@ 0xfffff668
   10788:	e2822007 	add	r2, r2, #7
  return (sum >= size1 ? sum : SIZE_MAX);
   1078c:	e3520006 	cmp	r2, #6
   10790:	9a0000f2 	bls	10b60 <rpl_vasnprintf+0x440>
  size_t sum = size1 + size2;
   10794:	e0933002 	adds	r3, r3, r2
   10798:	2a0000f0 	bcs	10b60 <rpl_vasnprintf+0x440>
   1079c:	e2930006 	adds	r0, r3, #6
   107a0:	2a0000ee 	bcs	10b60 <rpl_vasnprintf+0x440>
#if HAVE_ALLOCA
    if (buf_neededlength < 4000 / sizeof (TCHAR_T))
   107a4:	e3500efa 	cmp	r0, #4000	@ 0xfa0
   107a8:	3a000594 	bcc	11e00 <rpl_vasnprintf+0x16e0>
      }
    else
#endif
      {
        size_t buf_memsize = xtimes (buf_neededlength, sizeof (TCHAR_T));
        if (size_overflow_p (buf_memsize))
   107ac:	e3700001 	cmn	r0, #1
   107b0:	0a0000ea 	beq	10b60 <rpl_vasnprintf+0x440>
          goto out_of_memory_1;
        buf = (TCHAR_T *) malloc (buf_memsize);
   107b4:	ebfff796 	bl	e614 <rpl_malloc>
        if (buf == NULL)
   107b8:	e2503000 	subs	r3, r0, #0
   107bc:	e50b3aa0 	str	r3, [fp, #-2720]	@ 0xfffff560
   107c0:	0a0000e6 	beq	10b60 <rpl_vasnprintf+0x440>
          goto out_of_memory_1;
        buf_malloced = buf;
   107c4:	e50b3aac 	str	r3, [fp, #-2732]	@ 0xfffff554
      }

    result = resultbuf;
    allocated = (resultbuf != NULL ? *lengthp : 0);
   107c8:	e51b3a90 	ldr	r3, [fp, #-2704]	@ 0xfffff570
    length = 0;
   107cc:	e3a0a000 	mov	sl, #0
    result = resultbuf;
   107d0:	e51b5a90 	ldr	r5, [fp, #-2704]	@ 0xfffff570

            if (!(dp->arg_index == ARG_NONE))
              abort ();
            augmented_length = xsum (length, 1);
            ENSURE_ALLOCATION (augmented_length);
            result[length] = '%';
   107d4:	e1a0700a 	mov	r7, sl
    for (cp = format, i = 0, dp = &d.dir[0]; ; cp = dp->dir_end, i++, dp++)
   107d8:	e50baa8c 	str	sl, [fp, #-2700]	@ 0xfffff574
    allocated = (resultbuf != NULL ? *lengthp : 0);
   107dc:	e3530000 	cmp	r3, #0
    for (cp = format, i = 0, dp = &d.dir[0]; ; cp = dp->dir_end, i++, dp++)
   107e0:	e51b39a0 	ldr	r3, [fp, #-2464]	@ 0xfffff660
            result[length] = '%';
   107e4:	e50b5a88 	str	r5, [fp, #-2696]	@ 0xfffff578
    allocated = (resultbuf != NULL ? *lengthp : 0);
   107e8:	15989000 	ldrne	r9, [r8]
            result[length] = '%';
   107ec:	e1a05003 	mov	r5, r3
    allocated = (resultbuf != NULL ? *lengthp : 0);
   107f0:	051b9a90 	ldreq	r9, [fp, #-2704]	@ 0xfffff570
        if (cp != dp->dir_start)
   107f4:	e5956000 	ldr	r6, [r5]
            result[length] = '%';
   107f8:	e50b8ab4 	str	r8, [fp, #-2740]	@ 0xfffff54c
   107fc:	e1a0a009 	mov	sl, r9
        if (cp != dp->dir_start)
   10800:	e1560004 	cmp	r6, r4
   10804:	0a000132 	beq	10cd4 <rpl_vasnprintf+0x5b4>
            size_t n = dp->dir_start - cp;
   10808:	e0466004 	sub	r6, r6, r4
   1080c:	e0973006 	adds	r3, r7, r6
   10810:	e1a08003 	mov	r8, r3
  return (sum >= size1 ? sum : SIZE_MAX);
   10814:	2a000130 	bcs	10cdc <rpl_vasnprintf+0x5bc>
            ENSURE_ALLOCATION (augmented_length);
   10818:	e15a0003 	cmp	sl, r3
   1081c:	2a000012 	bcs	1086c <rpl_vasnprintf+0x14c>
   10820:	e35a0000 	cmp	sl, #0
   10824:	0a0001ee 	beq	10fe4 <rpl_vasnprintf+0x8c4>
   10828:	ba0000f1 	blt	10bf4 <rpl_vasnprintf+0x4d4>
   1082c:	e1a0208a 	lsl	r2, sl, #1
   10830:	e1520003 	cmp	r2, r3
   10834:	21a0a002 	movcs	sl, r2
   10838:	31a0a003 	movcc	sl, r3
   1083c:	e37a0001 	cmn	sl, #1
   10840:	0a0000eb 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   10844:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
   10848:	e51b2a90 	ldr	r2, [fp, #-2704]	@ 0xfffff570
   1084c:	e1530002 	cmp	r3, r2
   10850:	0a000234 	beq	11128 <rpl_vasnprintf+0xa08>
   10854:	e51b0a88 	ldr	r0, [fp, #-2696]	@ 0xfffff578
   10858:	e1a0100a 	mov	r1, sl
   1085c:	ebfff778 	bl	e644 <rpl_realloc>
   10860:	e3500000 	cmp	r0, #0
   10864:	0a0000e2 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   10868:	e50b0a88 	str	r0, [fp, #-2696]	@ 0xfffff578
   1086c:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
   10870:	e1a02006 	mov	r2, r6
   10874:	e1a01004 	mov	r1, r4
   10878:	e0830007 	add	r0, r3, r7
   1087c:	eb003d7f 	bl	1fe80 <memcpy>
        if (i == d.count)
   10880:	e51b39a4 	ldr	r3, [fp, #-2468]	@ 0xfffff65c
   10884:	e51b2a8c 	ldr	r2, [fp, #-2700]	@ 0xfffff574
   10888:	e1530002 	cmp	r3, r2
   1088c:	0a000602 	beq	1209c <rpl_vasnprintf+0x197c>
        if (dp->conversion == '%')
   10890:	e5d50024 	ldrb	r0, [r5, #36]	@ 0x24
            if (!(dp->arg_index == ARG_NONE))
   10894:	e5959028 	ldr	r9, [r5, #40]	@ 0x28
        if (dp->conversion == '%')
   10898:	e3500025 	cmp	r0, #37	@ 0x25
   1089c:	0a0000e5 	beq	10c38 <rpl_vasnprintf+0x518>
            length = augmented_length;
          }
        else
          {
            if (!(dp->arg_index != ARG_NONE))
   108a0:	e3790001 	cmn	r9, #1
   108a4:	0a00121b 	beq	15118 <rpl_vasnprintf+0x49f8>
              abort ();

            if (dp->conversion == 'n')
              {
                switch (a.arg[dp->arg_index].type)
   108a8:	e51b3a18 	ldr	r3, [fp, #-2584]	@ 0xfffff5e8
            if (dp->conversion == 'n')
   108ac:	e350006e 	cmp	r0, #110	@ 0x6e
                switch (a.arg[dp->arg_index].type)
   108b0:	e7d32209 	ldrb	r2, [r3, r9, lsl #4]
   108b4:	e0839209 	add	r9, r3, r9, lsl #4
   108b8:	e50b2a94 	str	r2, [fp, #-2708]	@ 0xfffff56c
            if (dp->conversion == 'n')
   108bc:	0a00010a 	beq	10cec <rpl_vasnprintf+0x5cc>
                   we have no guarantee that the implementation of sprintf will
                   use the exactly same algorithm.  Without this guarantee, it
                   is possible to have buffer overrun bugs.  In order to avoid
                   such bugs, we implement the entire processing of the 's'
                   directive ourselves.  */
                int flags = dp->flags;
   108c0:	e595c008 	ldr	ip, [r5, #8]
            else if (dp->conversion == 's'
   108c4:	e3500073 	cmp	r0, #115	@ 0x73
                int has_precision;
                size_t precision;

                has_width = 0;
                width = 0;
                if (dp->width_start != dp->width_end)
   108c8:	e595200c 	ldr	r2, [r5, #12]
   108cc:	e5951010 	ldr	r1, [r5, #16]
                int flags = dp->flags;
   108d0:	e50bca98 	str	ip, [fp, #-2712]	@ 0xfffff568
            else if (dp->conversion == 's'
   108d4:	0a00011e 	beq	10d54 <rpl_vasnprintf+0x634>
                }
# endif
              }
#endif
#if (NEED_PRINTF_DIRECTIVE_LC || ENABLE_WCHAR_FALLBACK) && HAVE_WINT_T && !WIDE_CHAR_VERSION
            else if (dp->conversion == 'c'
   108d8:	e3500063 	cmp	r0, #99	@ 0x63
   108dc:	0a000172 	beq	10eac <rpl_vasnprintf+0x78c>
                    }
                }
              }
#endif
#if NEED_PRINTF_DIRECTIVE_B || NEED_PRINTF_DIRECTIVE_UPPERCASE_B
            else if (0
   108e0:	e3500062 	cmp	r0, #98	@ 0x62
   108e4:	0a0001c0 	beq	10fec <rpl_vasnprintf+0x8cc>
                  free (tmp);
                length += count;
              }
#endif
#if NEED_PRINTF_DIRECTIVE_A || NEED_PRINTF_LONG_DOUBLE || NEED_PRINTF_DOUBLE || (NEED_WPRINTF_DIRECTIVE_LA && WIDE_CHAR_VERSION)
            else if ((dp->conversion == 'a' || dp->conversion == 'A')
   108e8:	e200c0df 	and	ip, r0, #223	@ 0xdf
   108ec:	e35c0041 	cmp	ip, #65	@ 0x41
   108f0:	1a000217 	bne	11154 <rpl_vasnprintf+0xa34>
                DCHAR_T *tmp;
                DCHAR_T *pad_ptr;
                DCHAR_T *p;

                width = 0;
                if (dp->width_start != dp->width_end)
   108f4:	e1520001 	cmp	r2, r1
   108f8:	0a00054b 	beq	11e2c <rpl_vasnprintf+0x170c>
                  {
                    if (dp->width_arg_index != ARG_NONE)
   108fc:	e5950014 	ldr	r0, [r5, #20]
   10900:	e3700001 	cmn	r0, #1
   10904:	0a0007e2 	beq	12894 <rpl_vasnprintf+0x2174>
                      {
                        int arg;

                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))
   10908:	e7d32200 	ldrb	r2, [r3, r0, lsl #4]
   1090c:	e3520005 	cmp	r2, #5
   10910:	e0832200 	add	r2, r3, r0, lsl #4
   10914:	1a0011ff 	bne	15118 <rpl_vasnprintf+0x49f8>
                          abort ();
                        arg = a.arg[dp->width_arg_index].a.a_int;
   10918:	e5926008 	ldr	r6, [r2, #8]
                        width = arg;
                        if (arg < 0)
   1091c:	e3560000 	cmp	r6, #0
   10920:	ba0003ff 	blt	11924 <rpl_vasnprintf+0x1204>
                      }
                  }

                has_precision = 0;
                precision = 0;
                if (dp->precision_start != dp->precision_end)
   10924:	e5952018 	ldr	r2, [r5, #24]
   10928:	e595101c 	ldr	r1, [r5, #28]
   1092c:	e1520001 	cmp	r2, r1
   10930:	0a00060e 	beq	12170 <rpl_vasnprintf+0x1a50>
                  {
                    if (dp->precision_arg_index != ARG_NONE)
   10934:	e5950020 	ldr	r0, [r5, #32]
   10938:	e3700001 	cmn	r0, #1
   1093c:	0a0007e7 	beq	128e0 <rpl_vasnprintf+0x21c0>
                      {
                        int arg;

                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))
   10940:	e7d32200 	ldrb	r2, [r3, r0, lsl #4]
   10944:	e0833200 	add	r3, r3, r0, lsl #4
   10948:	e3520005 	cmp	r2, #5
   1094c:	1a0011f1 	bne	15118 <rpl_vasnprintf+0x49f8>
                          abort ();
                        arg = a.arg[dp->precision_arg_index].a.a_int;
   10950:	e5934008 	ldr	r4, [r3, #8]
                        /* "A negative precision is taken as if the precision
                            were omitted."  */
                        if (arg >= 0)
   10954:	e3540000 	cmp	r4, #0
   10958:	ba0003ed 	blt	11914 <rpl_vasnprintf+0x11f4>
                  tmp_length =
                    (unsigned int) ((DBL_DIG + 1)
                                    * 0.831 /* decimal -> hexadecimal */
                                   )
                    + 1; /* turn floor into ceil */
                if (tmp_length < precision)
   1095c:	e354000e 	cmp	r4, #14
   10960:	e3a07001 	mov	r7, #1
   10964:	21a03004 	movcs	r3, r4
   10968:	33a0300e 	movcc	r3, #14
   1096c:	e283300c 	add	r3, r3, #12
                  tmp_length = precision;
                /* Account for sign, decimal point etc. */
                tmp_length = xsum (tmp_length, 12);

                if (tmp_length < width)
   10970:	e1530006 	cmp	r3, r6
   10974:	31a03006 	movcc	r3, r6
   10978:	e2933001 	adds	r3, r3, #1
  size_t sum = size1 + size2;
   1097c:	e50b3aa4 	str	r3, [fp, #-2724]	@ 0xfffff55c
  return (sum >= size1 ? sum : SIZE_MAX);
   10980:	2a00009b 	bcs	10bf4 <rpl_vasnprintf+0x4d4>
                  tmp_length = width;

                tmp_length = xsum (tmp_length, 1); /* account for trailing NUL */

                if (tmp_length <= sizeof (tmpbuf) / sizeof (DCHAR_T))
   10984:	e3530faf 	cmp	r3, #700	@ 0x2bc
   10988:	9a000531 	bls	11e54 <rpl_vasnprintf+0x1734>
                  tmp = tmpbuf;
                else
                  {
                    size_t tmp_memsize = xtimes (tmp_length, sizeof (DCHAR_T));

                    if (size_overflow_p (tmp_memsize))
   1098c:	e3730001 	cmn	r3, #1
   10990:	0a000097 	beq	10bf4 <rpl_vasnprintf+0x4d4>
                      /* Overflow, would lead to out of memory.  */
                      goto out_of_memory;
                    tmp = (DCHAR_T *) malloc (tmp_memsize);
   10994:	e51b0aa4 	ldr	r0, [fp, #-2724]	@ 0xfffff55c
   10998:	ebfff71d 	bl	e614 <rpl_malloc>
                    if (tmp == NULL)
   1099c:	e2503000 	subs	r3, r0, #0
   109a0:	e50b3a9c 	str	r3, [fp, #-2716]	@ 0xfffff564
   109a4:	0a000092 	beq	10bf4 <rpl_vasnprintf+0x4d4>
                pad_ptr = NULL;
                p = tmp;
                if (type == TYPE_LONGDOUBLE)
                  {
# if NEED_PRINTF_DIRECTIVE_A || NEED_PRINTF_LONG_DOUBLE || (NEED_WPRINTF_DIRECTIVE_LA && WIDE_CHAR_VERSION)
                    long double arg = a.arg[dp->arg_index].a.a_longdouble;
   109a8:	e5953028 	ldr	r3, [r5, #40]	@ 0x28
   109ac:	e51b9a18 	ldr	r9, [fp, #-2584]	@ 0xfffff5e8
   109b0:	e0899203 	add	r9, r9, r3, lsl #4
                if (type == TYPE_LONGDOUBLE)
   109b4:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
                    long double arg = a.arg[dp->arg_index].a.a_longdouble;
   109b8:	ed998b02 	vldr	d8, [r9, #8]
                if (type == TYPE_LONGDOUBLE)
   109bc:	e353001c 	cmp	r3, #28

                    if (isnanl (arg))
   109c0:	eeb48b48 	vcmp.f64	d8, d8
                if (type == TYPE_LONGDOUBLE)
   109c4:	0a0004be 	beq	11cc4 <rpl_vasnprintf+0x15a4>
                else
                  {
# if NEED_PRINTF_DIRECTIVE_A || NEED_PRINTF_DOUBLE
                    double arg = a.arg[dp->arg_index].a.a_double;

                    if (isnand (arg))
   109c8:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   109cc:	6a0005a2 	bvs	1205c <rpl_vasnprintf+0x193c>
                      }
                    else
                      {
                        int sign = 0;

                        if (signbit (arg)) /* arg < 0.0 or negative zero */
   109d0:	eeb00b48 	vmov.f64	d0, d8
   109d4:	eb0011e7 	bl	15178 <gl_signbitl>
   109d8:	e3500000 	cmp	r0, #0
   109dc:	0a000520 	beq	11e64 <rpl_vasnprintf+0x1744>
                            sign = -1;
                            arg = -arg;
                          }

                        if (sign < 0)
                          *p++ = '-';
   109e0:	e51b9a9c 	ldr	r9, [fp, #-2716]	@ 0xfffff564
   109e4:	e3a0302d 	mov	r3, #45	@ 0x2d
                            arg = -arg;
   109e8:	eeb18b48 	vneg.f64	d8, d8
                          *p++ = '-';
   109ec:	e4c93001 	strb	r3, [r9], #1
                        else if (flags & FLAG_SHOWSIGN)
                          *p++ = '+';
                        else if (flags & FLAG_SPACE)
                          *p++ = ' ';

                        if (arg > 0.0 && arg + arg == arg)
   109f0:	eeb58bc0 	vcmpe.f64	d8, #0.0
                          {
                            if (dp->conversion == 'A')
                              {
                                *p++ = 'I'; *p++ = 'N'; *p++ = 'F';
   109f4:	e2893003 	add	r3, r9, #3
                        if (arg > 0.0 && arg + arg == arg)
   109f8:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   109fc:	da0007d0 	ble	12944 <rpl_vasnprintf+0x2224>
   10a00:	ee387b08 	vadd.f64	d7, d8, d8
   10a04:	eeb47b48 	vcmp.f64	d7, d8
   10a08:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   10a0c:	1a000b28 	bne	136b4 <rpl_vasnprintf+0x2f94>
                            if (dp->conversion == 'A')
   10a10:	e5d52024 	ldrb	r2, [r5, #36]	@ 0x24
                pad_ptr = NULL;
   10a14:	e3a07000 	mov	r7, #0
                            if (dp->conversion == 'A')
   10a18:	e3520041 	cmp	r2, #65	@ 0x41
                                *p++ = 'I'; *p++ = 'N'; *p++ = 'F';
   10a1c:	03042e49 	movweq	r2, #20041	@ 0x4e49
                              }
                            else
                              {
                                *p++ = 'i'; *p++ = 'n'; *p++ = 'f';
   10a20:	13062e69 	movwne	r2, #28265	@ 0x6e69
                                *p++ = 'I'; *p++ = 'N'; *p++ = 'F';
   10a24:	01c920b0 	strheq	r2, [r9]
   10a28:	03a02046 	moveq	r2, #70	@ 0x46
                                *p++ = 'i'; *p++ = 'n'; *p++ = 'f';
   10a2c:	11c920b0 	strhne	r2, [r9]
   10a30:	13a02066 	movne	r2, #102	@ 0x66
   10a34:	e5c92002 	strb	r2, [r9, #2]
# endif
                  }

                /* The generated string now extends from tmp to p, with the
                   zero padding insertion point being at pad_ptr.  */
                count = p - tmp;
   10a38:	e51b2a9c 	ldr	r2, [fp, #-2716]	@ 0xfffff564
   10a3c:	e0434002 	sub	r4, r3, r2

                if (count < width)
   10a40:	e1560004 	cmp	r6, r4
   10a44:	9a000017 	bls	10aa8 <rpl_vasnprintf+0x388>
                  {
                    size_t pad = width - count;
                    DCHAR_T *end = p + pad;

                    if (flags & FLAG_LEFT)
   10a48:	e51b1a98 	ldr	r1, [fp, #-2712]	@ 0xfffff568
                    size_t pad = width - count;
   10a4c:	e0462004 	sub	r2, r6, r4
                    DCHAR_T *end = p + pad;
   10a50:	e0834002 	add	r4, r3, r2
                    if (flags & FLAG_LEFT)
   10a54:	e3110002 	tst	r1, #2
   10a58:	1a00000d 	bne	10a94 <rpl_vasnprintf+0x374>
                      {
                        /* Pad with spaces on the right.  */
                        for (; pad > 0; pad--)
                          *p++ = ' ';
                      }
                    else if ((flags & FLAG_ZERO) && pad_ptr != NULL)
   10a5c:	e51b0a98 	ldr	r0, [fp, #-2712]	@ 0xfffff568
   10a60:	e2571000 	subs	r1, r7, #0
   10a64:	13a01001 	movne	r1, #1
   10a68:	e01112a0 	ands	r1, r1, r0, lsr #5
   10a6c:	1a00056d 	bne	12028 <rpl_vasnprintf+0x1908>
                    else
                      {
                        /* Pad with spaces on the left.  */
                        DCHAR_T *q = end;

                        while (p > tmp)
   10a70:	e51b1a9c 	ldr	r1, [fp, #-2716]	@ 0xfffff564
   10a74:	e1510003 	cmp	r1, r3
   10a78:	351bca9c 	ldrcc	ip, [fp, #-2716]	@ 0xfffff564
   10a7c:	31a01004 	movcc	r1, r4
   10a80:	2a000003 	bcs	10a94 <rpl_vasnprintf+0x374>
                          *--q = *--p;
   10a84:	e5730001 	ldrb	r0, [r3, #-1]!
                        while (p > tmp)
   10a88:	e15c0003 	cmp	ip, r3
                          *--q = *--p;
   10a8c:	e5610001 	strb	r0, [r1, #-1]!
                        while (p > tmp)
   10a90:	1afffffb 	bne	10a84 <rpl_vasnprintf+0x364>
                        for (; pad > 0; pad--)
                          *p++ = ' ';
   10a94:	e1a00003 	mov	r0, r3
   10a98:	e3a01020 	mov	r1, #32
   10a9c:	eb002703 	bl	1a6b0 <memset>
                      }

                    p = end;
                  }

                count = p - tmp;
   10aa0:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   10aa4:	e0444003 	sub	r4, r4, r3

                if (count >= tmp_length)
   10aa8:	e51b3aa4 	ldr	r3, [fp, #-2724]	@ 0xfffff55c
   10aac:	e1530004 	cmp	r3, r4
   10ab0:	9a001198 	bls	15118 <rpl_vasnprintf+0x49f8>
                  /* tmp_length was incorrectly calculated - fix the
                     code above!  */
                  abort ();

                /* Make room for the result.  */
                if (count >= allocated - length)
   10ab4:	e0942008 	adds	r2, r4, r8
   10ab8:	e04a3008 	sub	r3, sl, r8
   10abc:	23a01001 	movcs	r1, #1
   10ac0:	33a01000 	movcc	r1, #0
   10ac4:	e1530004 	cmp	r3, r4
  size_t sum = size1 + size2;
   10ac8:	e1a07002 	mov	r7, r2
   10acc:	8a000016 	bhi	10b2c <rpl_vasnprintf+0x40c>
  return (sum >= size1 ? sum : SIZE_MAX);
   10ad0:	e3510000 	cmp	r1, #0
   10ad4:	1a0006e7 	bne	12678 <rpl_vasnprintf+0x1f58>
                  {
                    size_t n = xsum (length, count);

                    ENSURE_ALLOCATION (n);
   10ad8:	e15a0002 	cmp	sl, r2
   10adc:	2a000012 	bcs	10b2c <rpl_vasnprintf+0x40c>
   10ae0:	e35a0000 	cmp	sl, #0
   10ae4:	0a0007d6 	beq	12a44 <rpl_vasnprintf+0x2324>
   10ae8:	ba000041 	blt	10bf4 <rpl_vasnprintf+0x4d4>
   10aec:	e1a0308a 	lsl	r3, sl, #1
   10af0:	e1530002 	cmp	r3, r2
   10af4:	21a0a003 	movcs	sl, r3
   10af8:	31a0a002 	movcc	sl, r2
   10afc:	e37a0001 	cmn	sl, #1
   10b00:	0a00003b 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   10b04:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
   10b08:	e51b2a90 	ldr	r2, [fp, #-2704]	@ 0xfffff570
   10b0c:	e1530002 	cmp	r3, r2
   10b10:	0a000aaf 	beq	135d4 <rpl_vasnprintf+0x2eb4>
   10b14:	e51b0a88 	ldr	r0, [fp, #-2696]	@ 0xfffff578
   10b18:	e1a0100a 	mov	r1, sl
   10b1c:	ebfff6c8 	bl	e644 <rpl_realloc>
   10b20:	e3500000 	cmp	r0, #0
   10b24:	0a000032 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   10b28:	e50b0a88 	str	r0, [fp, #-2696]	@ 0xfffff578
   10b2c:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
   10b30:	e1a02004 	mov	r2, r4
   10b34:	e51b4a9c 	ldr	r4, [fp, #-2716]	@ 0xfffff564
                  }

                /* Append the result.  */
                memcpy (result + length, tmp, count * sizeof (DCHAR_T));
                if (tmp != tmpbuf)
   10b38:	e24b6e5a 	sub	r6, fp, #1440	@ 0x5a0
   10b3c:	e2466004 	sub	r6, r6, #4
   10b40:	e0830008 	add	r0, r3, r8
   10b44:	e1a01004 	mov	r1, r4
   10b48:	eb003ccc 	bl	1fe80 <memcpy>
   10b4c:	e1540006 	cmp	r4, r6
   10b50:	0a000057 	beq	10cb4 <rpl_vasnprintf+0x594>
                  free (tmp);
   10b54:	e1a00004 	mov	r0, r4
   10b58:	ebffe63e 	bl	a458 <rpl_free>
                length += count;
   10b5c:	ea000054 	b	10cb4 <rpl_vasnprintf+0x594>
    CLEANUP ();
    return NULL;
  }

 out_of_memory_1:
  errno = ENOMEM;
   10b60:	eb002b2b 	bl	1b814 <__errno>
   10b64:	e3a0300c 	mov	r3, #12
   10b68:	e5803000 	str	r3, [r0]
    CLEANUP ();
   10b6c:	e51b09a0 	ldr	r0, [fp, #-2464]	@ 0xfffff660
   10b70:	e24b3e99 	sub	r3, fp, #2448	@ 0x990
   10b74:	e243300c 	sub	r3, r3, #12
   10b78:	e2833008 	add	r3, r3, #8
   10b7c:	e1500003 	cmp	r0, r3
   10b80:	0a000000 	beq	10b88 <rpl_vasnprintf+0x468>
   10b84:	ebffe633 	bl	a458 <rpl_free>
   10b88:	e51b0a18 	ldr	r0, [fp, #-2584]	@ 0xfffff5e8
   10b8c:	e24b3ea1 	sub	r3, fp, #2576	@ 0xa10
   10b90:	e243300c 	sub	r3, r3, #12
   10b94:	e2833008 	add	r3, r3, #8
   10b98:	e1500003 	cmp	r0, r3
   10b9c:	0a000000 	beq	10ba4 <rpl_vasnprintf+0x484>
   10ba0:	ebffe62c 	bl	a458 <rpl_free>
    return NULL;
   10ba4:	e3a05000 	mov	r5, #0
  goto fail_1_with_errno;

 fail_1_with_errno:
  CLEANUP ();
  return NULL;
}
   10ba8:	e1a00005 	mov	r0, r5
   10bac:	e24bd028 	sub	sp, fp, #40	@ 0x28
   10bb0:	ecbd8b02 	vpop	{d8}
   10bb4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10bb8:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
   10bbc:	e1a06000 	mov	r6, r0
                switch (type)
   10bc0:	e243300a 	sub	r3, r3, #10
   10bc4:	e6ef3073 	uxtb	r3, r3
   10bc8:	e3530010 	cmp	r3, #16
   10bcc:	8a000c33 	bhi	13ca0 <rpl_vasnprintf+0x3580>
                        while (digitp != dp->precision_end)
   10bd0:	e3a02001 	mov	r2, #1
   10bd4:	e50b2a9c 	str	r2, [fp, #-2716]	@ 0xfffff564
   10bd8:	e3092d58 	movw	r2, #40280	@ 0x9d58
   10bdc:	e3402002 	movt	r2, #2
   10be0:	e7927103 	ldr	r7, [r2, r3, lsl #2]
                if (tmp_length < precision)
   10be4:	e1570006 	cmp	r7, r6
   10be8:	31a07006 	movcc	r7, r6
   10bec:	e2977002 	adds	r7, r7, #2
   10bf0:	3a000125 	bcc	1108c <rpl_vasnprintf+0x96c>
   10bf4:	e51b5a88 	ldr	r5, [fp, #-2696]	@ 0xfffff578
   10bf8:	e50b5a9c 	str	r5, [fp, #-2716]	@ 0xfffff564
    errno = ENOMEM;
   10bfc:	eb002b04 	bl	1b814 <__errno>
   10c00:	e3a0300c 	mov	r3, #12
   10c04:	e5803000 	str	r3, [r0]
    if (result != resultbuf)
   10c08:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   10c0c:	e51b2a90 	ldr	r2, [fp, #-2704]	@ 0xfffff570
   10c10:	e1530002 	cmp	r3, r2
   10c14:	0a000001 	beq	10c20 <rpl_vasnprintf+0x500>
      free (result);
   10c18:	e1a00003 	mov	r0, r3
   10c1c:	ebffe60d 	bl	a458 <rpl_free>
    if (buf_malloced != NULL)
   10c20:	e51b3aac 	ldr	r3, [fp, #-2732]	@ 0xfffff554
   10c24:	e3530000 	cmp	r3, #0
   10c28:	0affffcf 	beq	10b6c <rpl_vasnprintf+0x44c>
      free (buf_malloced);
   10c2c:	e1a00003 	mov	r0, r3
   10c30:	ebffe608 	bl	a458 <rpl_free>
   10c34:	eaffffcc 	b	10b6c <rpl_vasnprintf+0x44c>
            if (!(dp->arg_index == ARG_NONE))
   10c38:	e3790001 	cmn	r9, #1
   10c3c:	1a001135 	bne	15118 <rpl_vasnprintf+0x49f8>
  size_t sum = size1 + size2;
   10c40:	e2983001 	adds	r3, r8, #1
   10c44:	e1a07003 	mov	r7, r3
  return (sum >= size1 ? sum : SIZE_MAX);
   10c48:	2a0000e1 	bcs	10fd4 <rpl_vasnprintf+0x8b4>
            ENSURE_ALLOCATION (augmented_length);
   10c4c:	e15a0003 	cmp	sl, r3
   10c50:	2a000014 	bcs	10ca8 <rpl_vasnprintf+0x588>
   10c54:	e35a0000 	cmp	sl, #0
   10c58:	0a000002 	beq	10c68 <rpl_vasnprintf+0x548>
   10c5c:	baffffe4 	blt	10bf4 <rpl_vasnprintf+0x4d4>
   10c60:	e1a0208a 	lsl	r2, sl, #1
   10c64:	ea000000 	b	10c6c <rpl_vasnprintf+0x54c>
   10c68:	e3a0200c 	mov	r2, #12
   10c6c:	e1520003 	cmp	r2, r3
   10c70:	21a0a002 	movcs	sl, r2
   10c74:	31a0a003 	movcc	sl, r3
   10c78:	e37a0001 	cmn	sl, #1
   10c7c:	0affffdc 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   10c80:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
   10c84:	e51b2a90 	ldr	r2, [fp, #-2704]	@ 0xfffff570
   10c88:	e1530002 	cmp	r3, r2
   10c8c:	0a000210 	beq	114d4 <rpl_vasnprintf+0xdb4>
   10c90:	e51b0a88 	ldr	r0, [fp, #-2696]	@ 0xfffff578
   10c94:	e1a0100a 	mov	r1, sl
   10c98:	ebfff669 	bl	e644 <rpl_realloc>
   10c9c:	e3500000 	cmp	r0, #0
   10ca0:	0affffd3 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   10ca4:	e50b0a88 	str	r0, [fp, #-2696]	@ 0xfffff578
            result[length] = '%';
   10ca8:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
   10cac:	e3a02025 	mov	r2, #37	@ 0x25
   10cb0:	e7c32008 	strb	r2, [r3, r8]
    for (cp = format, i = 0, dp = &d.dir[0]; ; cp = dp->dir_end, i++, dp++)
   10cb4:	e5954004 	ldr	r4, [r5, #4]
   10cb8:	e285502c 	add	r5, r5, #44	@ 0x2c
   10cbc:	e51b3a8c 	ldr	r3, [fp, #-2700]	@ 0xfffff574
        if (cp != dp->dir_start)
   10cc0:	e5956000 	ldr	r6, [r5]
    for (cp = format, i = 0, dp = &d.dir[0]; ; cp = dp->dir_end, i++, dp++)
   10cc4:	e2833001 	add	r3, r3, #1
   10cc8:	e50b3a8c 	str	r3, [fp, #-2700]	@ 0xfffff574
        if (cp != dp->dir_start)
   10ccc:	e1560004 	cmp	r6, r4
   10cd0:	1afffecc 	bne	10808 <rpl_vasnprintf+0xe8>
   10cd4:	e1a08007 	mov	r8, r7
   10cd8:	eafffee8 	b	10880 <rpl_vasnprintf+0x160>
            ENSURE_ALLOCATION (augmented_length);
   10cdc:	e37a0001 	cmn	sl, #1
   10ce0:	1affffc3 	bne	10bf4 <rpl_vasnprintf+0x4d4>
   10ce4:	e1a0800a 	mov	r8, sl
   10ce8:	eafffedf 	b	1086c <rpl_vasnprintf+0x14c>
                switch (a.arg[dp->arg_index].type)
   10cec:	e2423022 	sub	r3, r2, #34	@ 0x22
   10cf0:	e353000c 	cmp	r3, #12
   10cf4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   10cf8:	ea001106 	b	15118 <rpl_vasnprintf+0x49f8>
   10cfc:	000118bc 	.word	0x000118bc
   10d00:	000118b0 	.word	0x000118b0
   10d04:	00010d30 	.word	0x00010d30
   10d08:	00010d30 	.word	0x00010d30
   10d0c:	00010d40 	.word	0x00010d40
   10d10:	000118bc 	.word	0x000118bc
   10d14:	000118b0 	.word	0x000118b0
   10d18:	00010d30 	.word	0x00010d30
   10d1c:	00010d40 	.word	0x00010d40
   10d20:	00010d30 	.word	0x00010d30
   10d24:	00010d30 	.word	0x00010d30
   10d28:	00010d30 	.word	0x00010d30
   10d2c:	00010d40 	.word	0x00010d40
                    *a.arg[dp->arg_index].a.a_count_int_fast32_t_pointer = length;
   10d30:	e5993008 	ldr	r3, [r9, #8]
   10d34:	e5838000 	str	r8, [r3]
                                    ENSURE_ALLOCATION (bigger_need);
   10d38:	e1a07008 	mov	r7, r8
   10d3c:	eaffffdc 	b	10cb4 <rpl_vasnprintf+0x594>
                    *a.arg[dp->arg_index].a.a_count_int_fast64_t_pointer = length;
   10d40:	e5993008 	ldr	r3, [r9, #8]
   10d44:	e3a02000 	mov	r2, #0
   10d48:	e5838000 	str	r8, [r3]
   10d4c:	e5832004 	str	r2, [r3, #4]
                    break;
   10d50:	eafffff8 	b	10d38 <rpl_vasnprintf+0x618>
                     && a.arg[dp->arg_index].type == TYPE_WIDE_STRING
   10d54:	e51bca94 	ldr	ip, [fp, #-2708]	@ 0xfffff56c
   10d58:	e35c0020 	cmp	ip, #32
   10d5c:	0a00018c 	beq	11394 <rpl_vasnprintf+0xc74>
                if (dp->width_start != dp->width_end)
   10d60:	e1520001 	cmp	r2, r1
   10d64:	0a0004a6 	beq	12004 <rpl_vasnprintf+0x18e4>
                    if (dp->width_arg_index != ARG_NONE)
   10d68:	e595c014 	ldr	ip, [r5, #20]
   10d6c:	e37c0001 	cmn	ip, #1
   10d70:	0a000740 	beq	12a78 <rpl_vasnprintf+0x2358>
                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))
   10d74:	e7d3220c 	ldrb	r2, [r3, ip, lsl #4]
   10d78:	e083c20c 	add	ip, r3, ip, lsl #4
   10d7c:	e3520005 	cmp	r2, #5
   10d80:	1a0010e4 	bne	15118 <rpl_vasnprintf+0x49f8>
                        arg = a.arg[dp->width_arg_index].a.a_int;
   10d84:	e59c2008 	ldr	r2, [ip, #8]
                        if (arg < 0)
   10d88:	e3520000 	cmp	r2, #0
                        arg = a.arg[dp->width_arg_index].a.a_int;
   10d8c:	e50b2ab8 	str	r2, [fp, #-2744]	@ 0xfffff548
                    has_width = 1;
   10d90:	a3a02001 	movge	r2, #1
   10d94:	a50b2ac8 	strge	r2, [fp, #-2760]	@ 0xfffff538
                        if (arg < 0)
   10d98:	aa000006 	bge	10db8 <rpl_vasnprintf+0x698>
                            flags |= FLAG_LEFT;
   10d9c:	e51b1a98 	ldr	r1, [fp, #-2712]	@ 0xfffff568
                            width = -width;
   10da0:	e2622000 	rsb	r2, r2, #0
   10da4:	e50b2ab8 	str	r2, [fp, #-2744]	@ 0xfffff548
                    has_width = 1;
   10da8:	e3a02001 	mov	r2, #1
   10dac:	e50b2ac8 	str	r2, [fp, #-2760]	@ 0xfffff538
                            flags |= FLAG_LEFT;
   10db0:	e3811002 	orr	r1, r1, #2
   10db4:	e50b1a98 	str	r1, [fp, #-2712]	@ 0xfffff568
                if (dp->precision_start != dp->precision_end)
   10db8:	e5951018 	ldr	r1, [r5, #24]
   10dbc:	e595c01c 	ldr	ip, [r5, #28]
   10dc0:	e151000c 	cmp	r1, ip
   10dc4:	0a000492 	beq	12014 <rpl_vasnprintf+0x18f4>
                    if (dp->precision_arg_index != ARG_NONE)
   10dc8:	e5952020 	ldr	r2, [r5, #32]
   10dcc:	e3720001 	cmn	r2, #1
   10dd0:	0a000a0a 	beq	13600 <rpl_vasnprintf+0x2ee0>
                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))
   10dd4:	e7d31202 	ldrb	r1, [r3, r2, lsl #4]
   10dd8:	e0832202 	add	r2, r3, r2, lsl #4
   10ddc:	e3510005 	cmp	r1, #5
   10de0:	1a0010cc 	bne	15118 <rpl_vasnprintf+0x49f8>
                        arg = a.arg[dp->precision_arg_index].a.a_int;
   10de4:	e5923008 	ldr	r3, [r2, #8]
                            precision = arg;
   10de8:	e3530000 	cmp	r3, #0
   10dec:	b3a03006 	movlt	r3, #6
   10df0:	e50b3ac0 	str	r3, [fp, #-2752]	@ 0xfffff540
   10df4:	a3a03001 	movge	r3, #1
   10df8:	b3a03000 	movlt	r3, #0
   10dfc:	e50b3abc 	str	r3, [fp, #-2748]	@ 0xfffff544
                switch (dp->conversion)
   10e00:	e2400041 	sub	r0, r0, #65	@ 0x41
   10e04:	e3500026 	cmp	r0, #38	@ 0x26
   10e08:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
   10e0c:	ea0001bb 	b	11500 <rpl_vasnprintf+0xde0>
   10e10:	00011938 	.word	0x00011938
   10e14:	00011500 	.word	0x00011500
   10e18:	00011500 	.word	0x00011500
   10e1c:	00011500 	.word	0x00011500
   10e20:	00011938 	.word	0x00011938
   10e24:	00011938 	.word	0x00011938
   10e28:	00011938 	.word	0x00011938
   10e2c:	00011500 	.word	0x00011500
   10e30:	00011500 	.word	0x00011500
   10e34:	00011500 	.word	0x00011500
   10e38:	00011500 	.word	0x00011500
   10e3c:	00011500 	.word	0x00011500
   10e40:	00011500 	.word	0x00011500
   10e44:	00011500 	.word	0x00011500
   10e48:	00011500 	.word	0x00011500
   10e4c:	00011500 	.word	0x00011500
   10e50:	00011500 	.word	0x00011500
   10e54:	00011500 	.word	0x00011500
   10e58:	00011500 	.word	0x00011500
   10e5c:	00011500 	.word	0x00011500
   10e60:	00011500 	.word	0x00011500
   10e64:	00011500 	.word	0x00011500
   10e68:	00011500 	.word	0x00011500
   10e6c:	00011500 	.word	0x00011500
   10e70:	00011500 	.word	0x00011500
   10e74:	00011500 	.word	0x00011500
   10e78:	00011500 	.word	0x00011500
   10e7c:	00011500 	.word	0x00011500
   10e80:	00011500 	.word	0x00011500
   10e84:	00011500 	.word	0x00011500
   10e88:	00011500 	.word	0x00011500
   10e8c:	00011500 	.word	0x00011500
   10e90:	00011938 	.word	0x00011938
   10e94:	00011500 	.word	0x00011500
   10e98:	00011500 	.word	0x00011500
   10e9c:	00011500 	.word	0x00011500
   10ea0:	00011938 	.word	0x00011938
   10ea4:	00011938 	.word	0x00011938
   10ea8:	00011938 	.word	0x00011938
                     && a.arg[dp->arg_index].type == TYPE_WIDE_CHAR)
   10eac:	e51bca94 	ldr	ip, [fp, #-2708]	@ 0xfffff56c
   10eb0:	e35c001e 	cmp	ip, #30
   10eb4:	1affffa9 	bne	10d60 <rpl_vasnprintf+0x640>
                if (dp->width_start != dp->width_end)
   10eb8:	e1520001 	cmp	r2, r1
   10ebc:	0a000427 	beq	11f60 <rpl_vasnprintf+0x1840>
                    if (dp->width_arg_index != ARG_NONE)
   10ec0:	e5950014 	ldr	r0, [r5, #20]
   10ec4:	e3700001 	cmn	r0, #1
   10ec8:	0a000ae0 	beq	13a50 <rpl_vasnprintf+0x3330>
                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))
   10ecc:	e7d32200 	ldrb	r2, [r3, r0, lsl #4]
   10ed0:	e0830200 	add	r0, r3, r0, lsl #4
   10ed4:	e3520005 	cmp	r2, #5
   10ed8:	1a00108e 	bne	15118 <rpl_vasnprintf+0x49f8>
                        arg = a.arg[dp->width_arg_index].a.a_int;
   10edc:	e5904008 	ldr	r4, [r0, #8]
                    *a.arg[dp->arg_index].a.a_count_schar_pointer = length;
   10ee0:	e5999008 	ldr	r9, [r9, #8]
                        if (arg < 0)
   10ee4:	e3540000 	cmp	r4, #0
   10ee8:	ba000914 	blt	13340 <rpl_vasnprintf+0x2c20>
                      if (arg != 0)
   10eec:	e3590000 	cmp	r9, #0
   10ef0:	1a00072e 	bne	12bb0 <rpl_vasnprintf+0x2490>
                  if (w < width && !(flags & FLAG_LEFT))
   10ef4:	e3540000 	cmp	r4, #0
   10ef8:	1a000916 	bne	13358 <rpl_vasnprintf+0x2c38>
                      ENSURE_ALLOCATION (xsum (length, characters));
   10efc:	e15a0008 	cmp	sl, r8
   10f00:	21a07008 	movcs	r7, r8
                      characters = 0;
   10f04:	23a06000 	movcs	r6, #0
                      ENSURE_ALLOCATION (xsum (length, characters));
   10f08:	2a000016 	bcs	10f68 <rpl_vasnprintf+0x848>
   10f0c:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
                      characters = 0;
   10f10:	e3a06000 	mov	r6, #0
                      ENSURE_ALLOCATION (xsum (length, characters));
   10f14:	e1a07008 	mov	r7, r8
   10f18:	e1a09006 	mov	r9, r6
   10f1c:	e50b3a9c 	str	r3, [fp, #-2716]	@ 0xfffff564
   10f20:	e35a0000 	cmp	sl, #0
   10f24:	0a000b65 	beq	13cc0 <rpl_vasnprintf+0x35a0>
   10f28:	baffff33 	blt	10bfc <rpl_vasnprintf+0x4dc>
   10f2c:	e1a0a08a 	lsl	sl, sl, #1
   10f30:	e15a0008 	cmp	sl, r8
   10f34:	3a000b64 	bcc	13ccc <rpl_vasnprintf+0x35ac>
   10f38:	e51b3a90 	ldr	r3, [fp, #-2704]	@ 0xfffff570
   10f3c:	e51b2a88 	ldr	r2, [fp, #-2696]	@ 0xfffff578
   10f40:	e1530002 	cmp	r3, r2
   10f44:	0a000bfc 	beq	13f3c <rpl_vasnprintf+0x381c>
   10f48:	e51b0a88 	ldr	r0, [fp, #-2696]	@ 0xfffff578
   10f4c:	e1a0100a 	mov	r1, sl
   10f50:	ebfff5bb 	bl	e644 <rpl_realloc>
   10f54:	e2503000 	subs	r3, r0, #0
   10f58:	e50b3a88 	str	r3, [fp, #-2696]	@ 0xfffff578
   10f5c:	0affff26 	beq	10bfc <rpl_vasnprintf+0x4dc>
                      if (characters > 0) /* implies arg != 0 */
   10f60:	e3560000 	cmp	r6, #0
   10f64:	1a000a22 	bne	137f4 <rpl_vasnprintf+0x30d4>
                  if (w < width && (flags & FLAG_LEFT))
   10f68:	e1560004 	cmp	r6, r4
   10f6c:	2affff50 	bcs	10cb4 <rpl_vasnprintf+0x594>
   10f70:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
   10f74:	e3130002 	tst	r3, #2
   10f78:	0affff4d 	beq	10cb4 <rpl_vasnprintf+0x594>
                      size_t n = width - w;
   10f7c:	e0446006 	sub	r6, r4, r6
  size_t sum = size1 + size2;
   10f80:	e0974006 	adds	r4, r7, r6
   10f84:	2a000b40 	bcs	13c8c <rpl_vasnprintf+0x356c>
                      ENSURE_ALLOCATION (xsum (length, n));
   10f88:	e154000a 	cmp	r4, sl
   10f8c:	9a00000e 	bls	10fcc <rpl_vasnprintf+0x8ac>
   10f90:	e35a0000 	cmp	sl, #0
   10f94:	1a000c7f 	bne	14198 <rpl_vasnprintf+0x3a78>
   10f98:	e354000c 	cmp	r4, #12
   10f9c:	93a0a00c 	movls	sl, #12
   10fa0:	8a000c80 	bhi	141a8 <rpl_vasnprintf+0x3a88>
   10fa4:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
   10fa8:	e51b2a90 	ldr	r2, [fp, #-2704]	@ 0xfffff570
   10fac:	e1530002 	cmp	r3, r2
   10fb0:	0a000cf6 	beq	14390 <rpl_vasnprintf+0x3c70>
   10fb4:	e51b0a88 	ldr	r0, [fp, #-2696]	@ 0xfffff578
   10fb8:	e1a0100a 	mov	r1, sl
   10fbc:	ebfff5a0 	bl	e644 <rpl_realloc>
   10fc0:	e3500000 	cmp	r0, #0
   10fc4:	0a000b32 	beq	13c94 <rpl_vasnprintf+0x3574>
   10fc8:	e50b0a88 	str	r0, [fp, #-2696]	@ 0xfffff578
__ssp_bos_icheck3(memset, void *, int)
   10fcc:	e1a02006 	mov	r2, r6
   10fd0:	ea000335 	b	11cac <rpl_vasnprintf+0x158c>
            ENSURE_ALLOCATION (augmented_length);
   10fd4:	e37a0001 	cmn	sl, #1
   10fd8:	1affff05 	bne	10bf4 <rpl_vasnprintf+0x4d4>
  return (sum >= size1 ? sum : SIZE_MAX);
   10fdc:	e1a0700a 	mov	r7, sl
   10fe0:	eaffff30 	b	10ca8 <rpl_vasnprintf+0x588>
            ENSURE_ALLOCATION (augmented_length);
   10fe4:	e3a0200c 	mov	r2, #12
   10fe8:	eafffe10 	b	10830 <rpl_vasnprintf+0x110>
                if (dp->width_start != dp->width_end)
   10fec:	e1520001 	cmp	r2, r1
   10ff0:	0a00038a 	beq	11e20 <rpl_vasnprintf+0x1700>
                    if (dp->width_arg_index != ARG_NONE)
   10ff4:	e5950014 	ldr	r0, [r5, #20]
   10ff8:	e3700001 	cmn	r0, #1
   10ffc:	0a0005fb 	beq	127f0 <rpl_vasnprintf+0x20d0>
                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))
   11000:	e7d32200 	ldrb	r2, [r3, r0, lsl #4]
   11004:	e0830200 	add	r0, r3, r0, lsl #4
   11008:	e3520005 	cmp	r2, #5
   1100c:	1a001041 	bne	15118 <rpl_vasnprintf+0x49f8>
                        arg = a.arg[dp->width_arg_index].a.a_int;
   11010:	e5904008 	ldr	r4, [r0, #8]
                        if (arg < 0)
   11014:	e3540000 	cmp	r4, #0
                    has_width = 1;
   11018:	a3a02001 	movge	r2, #1
   1101c:	a50b2ab0 	strge	r2, [fp, #-2736]	@ 0xfffff550
                        if (arg < 0)
   11020:	ba000228 	blt	118c8 <rpl_vasnprintf+0x11a8>
                if (dp->precision_start != dp->precision_end)
   11024:	e5950018 	ldr	r0, [r5, #24]
   11028:	e595201c 	ldr	r2, [r5, #28]
   1102c:	e1500002 	cmp	r0, r2
   11030:	0a00022e 	beq	118f0 <rpl_vasnprintf+0x11d0>
                    if (dp->precision_arg_index != ARG_NONE)
   11034:	e5951020 	ldr	r1, [r5, #32]
   11038:	e3710001 	cmn	r1, #1
   1103c:	0a0005fe 	beq	1283c <rpl_vasnprintf+0x211c>
                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))
   11040:	e7d32201 	ldrb	r2, [r3, r1, lsl #4]
   11044:	e0831201 	add	r1, r3, r1, lsl #4
   11048:	e3520005 	cmp	r2, #5
   1104c:	1a001031 	bne	15118 <rpl_vasnprintf+0x49f8>
                        arg = a.arg[dp->precision_arg_index].a.a_int;
   11050:	e5916008 	ldr	r6, [r1, #8]
                            precision = arg;
   11054:	e3560000 	cmp	r6, #0
   11058:	b3a06001 	movlt	r6, #1
   1105c:	a3a03001 	movge	r3, #1
   11060:	b3a03000 	movlt	r3, #0
   11064:	e50b3a9c 	str	r3, [fp, #-2716]	@ 0xfffff564
                switch (type)
   11068:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
   1106c:	e243300a 	sub	r3, r3, #10
   11070:	e6ef3073 	uxtb	r3, r3
   11074:	e3530010 	cmp	r3, #16
   11078:	9afffed6 	bls	10bd8 <rpl_vasnprintf+0x4b8>
                if (tmp_length < precision)
   1107c:	e3560021 	cmp	r6, #33	@ 0x21
   11080:	21a07006 	movcs	r7, r6
   11084:	33a07021 	movcc	r7, #33	@ 0x21
  size_t sum = size1 + size2;
   11088:	e2877002 	add	r7, r7, #2
                if (tmp_length < width)
   1108c:	e1540007 	cmp	r4, r7
   11090:	21a07004 	movcs	r7, r4
                if (tmp_length <= sizeof (tmpbuf) / sizeof (DCHAR_T))
   11094:	e3570faf 	cmp	r7, #700	@ 0x2bc
   11098:	8a00019a 	bhi	11708 <rpl_vasnprintf+0xfe8>
                  tmp = tmpbuf;
   1109c:	e24b3e86 	sub	r3, fp, #2144	@ 0x860
   110a0:	e50b3aa4 	str	r3, [fp, #-2724]	@ 0xfffff55c
                switch (type)
   110a4:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
                tmp_end = tmp + tmp_length;
   110a8:	e51b2aa4 	ldr	r2, [fp, #-2724]	@ 0xfffff55c
                switch (type)
   110ac:	e2433002 	sub	r3, r3, #2
                tmp_end = tmp + tmp_length;
   110b0:	e0822007 	add	r2, r2, r7
   110b4:	e50b2a94 	str	r2, [fp, #-2708]	@ 0xfffff56c
                switch (type)
   110b8:	e3530018 	cmp	r3, #24
   110bc:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   110c0:	ea001014 	b	15118 <rpl_vasnprintf+0x49f8>
   110c4:	0001196c 	.word	0x0001196c
   110c8:	00015118 	.word	0x00015118
   110cc:	00011984 	.word	0x00011984
   110d0:	00015118 	.word	0x00015118
   110d4:	00011728 	.word	0x00011728
   110d8:	00015118 	.word	0x00015118
   110dc:	00011728 	.word	0x00011728
   110e0:	00015118 	.word	0x00015118
   110e4:	00011944 	.word	0x00011944
   110e8:	00015118 	.word	0x00015118
   110ec:	0001196c 	.word	0x0001196c
   110f0:	00015118 	.word	0x00015118
   110f4:	00011984 	.word	0x00011984
   110f8:	00015118 	.word	0x00015118
   110fc:	00011728 	.word	0x00011728
   11100:	00015118 	.word	0x00015118
   11104:	00011944 	.word	0x00011944
   11108:	00015118 	.word	0x00015118
   1110c:	00011728 	.word	0x00011728
   11110:	00015118 	.word	0x00015118
   11114:	00011728 	.word	0x00011728
   11118:	00015118 	.word	0x00015118
   1111c:	00011728 	.word	0x00011728
   11120:	00015118 	.word	0x00015118
   11124:	00011944 	.word	0x00011944
            ENSURE_ALLOCATION (augmented_length);
   11128:	e1a0000a 	mov	r0, sl
   1112c:	ebfff538 	bl	e614 <rpl_malloc>
   11130:	e2509000 	subs	r9, r0, #0
   11134:	0afffeae 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   11138:	e3570000 	cmp	r7, #0
   1113c:	0a000002 	beq	1114c <rpl_vasnprintf+0xa2c>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   11140:	e51b1a90 	ldr	r1, [fp, #-2704]	@ 0xfffff570
   11144:	e1a02007 	mov	r2, r7
   11148:	eb003b4c 	bl	1fe80 <memcpy>
   1114c:	e50b9a88 	str	r9, [fp, #-2696]	@ 0xfffff578
   11150:	eafffdc5 	b	1086c <rpl_vasnprintf+0x14c>
                      || dp->conversion == 'e' || dp->conversion == 'E'
   11154:	e200e0dd 	and	lr, r0, #221	@ 0xdd
                      || dp->conversion == 'g' || dp->conversion == 'G'
   11158:	e35c0046 	cmp	ip, #70	@ 0x46
   1115c:	135e0045 	cmpne	lr, #69	@ 0x45
   11160:	1afffefe 	bne	10d60 <rpl_vasnprintf+0x640>
                     && (0
   11164:	e51bea94 	ldr	lr, [fp, #-2708]	@ 0xfffff56c
   11168:	e24ee01b 	sub	lr, lr, #27
   1116c:	e35e0001 	cmp	lr, #1
   11170:	8afffefa 	bhi	10d60 <rpl_vasnprintf+0x640>
                if (dp->width_start != dp->width_end)
   11174:	e1520001 	cmp	r2, r1
   11178:	0a0005ee 	beq	12938 <rpl_vasnprintf+0x2218>
                    if (dp->width_arg_index != ARG_NONE)
   1117c:	e5950014 	ldr	r0, [r5, #20]
   11180:	e3700001 	cmn	r0, #1
   11184:	0a000a44 	beq	13a9c <rpl_vasnprintf+0x337c>
                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))
   11188:	e7d32200 	ldrb	r2, [r3, r0, lsl #4]
   1118c:	e0830200 	add	r0, r3, r0, lsl #4
   11190:	e3520005 	cmp	r2, #5
   11194:	1a000fdf 	bne	15118 <rpl_vasnprintf+0x49f8>
                        arg = a.arg[dp->width_arg_index].a.a_int;
   11198:	e5902008 	ldr	r2, [r0, #8]
                        if (arg < 0)
   1119c:	e3520000 	cmp	r2, #0
                        arg = a.arg[dp->width_arg_index].a.a_int;
   111a0:	e50b2aa4 	str	r2, [fp, #-2724]	@ 0xfffff55c
                        if (arg < 0)
   111a4:	aa000004 	bge	111bc <rpl_vasnprintf+0xa9c>
                            flags |= FLAG_LEFT;
   111a8:	e51b1a98 	ldr	r1, [fp, #-2712]	@ 0xfffff568
                            width = -width;
   111ac:	e2622000 	rsb	r2, r2, #0
   111b0:	e50b2aa4 	str	r2, [fp, #-2724]	@ 0xfffff55c
                            flags |= FLAG_LEFT;
   111b4:	e3811002 	orr	r1, r1, #2
   111b8:	e50b1a98 	str	r1, [fp, #-2712]	@ 0xfffff568
                if (dp->precision_start != dp->precision_end)
   111bc:	e5952018 	ldr	r2, [r5, #24]
   111c0:	e595101c 	ldr	r1, [r5, #28]
   111c4:	e1520001 	cmp	r2, r1
   111c8:	0a000348 	beq	11ef0 <rpl_vasnprintf+0x17d0>
                    if (dp->precision_arg_index != ARG_NONE)
   111cc:	e5950020 	ldr	r0, [r5, #32]
   111d0:	e3700001 	cmn	r0, #1
   111d4:	0a000a42 	beq	13ae4 <rpl_vasnprintf+0x33c4>
                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))
   111d8:	e7d32200 	ldrb	r2, [r3, r0, lsl #4]
   111dc:	e0830200 	add	r0, r3, r0, lsl #4
   111e0:	e3520005 	cmp	r2, #5
   111e4:	1a000fcb 	bne	15118 <rpl_vasnprintf+0x49f8>
                        arg = a.arg[dp->precision_arg_index].a.a_int;
   111e8:	e5903008 	ldr	r3, [r0, #8]
                        if (arg >= 0)
   111ec:	e3530000 	cmp	r3, #0
   111f0:	ba00033e 	blt	11ef0 <rpl_vasnprintf+0x17d0>
   111f4:	e1a07003 	mov	r7, r3
                if (tmp_length < precision)
   111f8:	e3570010 	cmp	r7, #16
   111fc:	21a04007 	movcs	r4, r7
   11200:	33a04010 	movcc	r4, #16
                if (type == TYPE_LONGDOUBLE)
   11204:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
   11208:	e353001c 	cmp	r3, #28
   1120c:	0a00096d 	beq	137c8 <rpl_vasnprintf+0x30a8>
                  if (dp->conversion == 'f' || dp->conversion == 'F')
   11210:	e35c0046 	cmp	ip, #70	@ 0x46
   11214:	1a000007 	bne	11238 <rpl_vasnprintf+0xb18>
                      double arg = a.arg[dp->arg_index].a.a_double;
   11218:	ed990b02 	vldr	d0, [r9, #8]
                      if (!(isnand (arg) || arg + arg == arg))
   1121c:	eeb40b40 	vcmp.f64	d0, d0
   11220:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   11224:	6a000003 	bvs	11238 <rpl_vasnprintf+0xb18>
   11228:	ee307b00 	vadd.f64	d7, d0, d0
   1122c:	eeb47b40 	vcmp.f64	d7, d0
   11230:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   11234:	1a00033c 	bne	11f2c <rpl_vasnprintf+0x180c>
   11238:	e294400c 	adds	r4, r4, #12
  return (sum >= size1 ? sum : SIZE_MAX);
   1123c:	2afffe6c 	bcs	10bf4 <rpl_vasnprintf+0x4d4>
                if (tmp_length < width)
   11240:	e51b3aa4 	ldr	r3, [fp, #-2724]	@ 0xfffff55c
   11244:	e1530004 	cmp	r3, r4
   11248:	31a03004 	movcc	r3, r4
   1124c:	e2933001 	adds	r3, r3, #1
   11250:	23a02001 	movcs	r2, #1
   11254:	33a02000 	movcc	r2, #0
   11258:	e50b3aa8 	str	r3, [fp, #-2728]	@ 0xfffff558
   1125c:	e50b2ab0 	str	r2, [fp, #-2736]	@ 0xfffff550
   11260:	2afffe63 	bcs	10bf4 <rpl_vasnprintf+0x4d4>
                if (tmp_length <= sizeof (tmpbuf) / sizeof (DCHAR_T))
   11264:	e3530faf 	cmp	r3, #700	@ 0x2bc
   11268:	9a00055d 	bls	127e4 <rpl_vasnprintf+0x20c4>
                    if (size_overflow_p (tmp_memsize))
   1126c:	e3730001 	cmn	r3, #1
   11270:	0afffe5f 	beq	10bf4 <rpl_vasnprintf+0x4d4>
                    tmp = (DCHAR_T *) malloc (tmp_memsize);
   11274:	e1a00003 	mov	r0, r3
   11278:	ebfff4e5 	bl	e614 <rpl_malloc>
                    if (tmp == NULL)
   1127c:	e2503000 	subs	r3, r0, #0
   11280:	e50b3a9c 	str	r3, [fp, #-2716]	@ 0xfffff564
   11284:	0afffe5a 	beq	10bf4 <rpl_vasnprintf+0x4d4>
                    long double arg = a.arg[dp->arg_index].a.a_longdouble;
   11288:	e5953028 	ldr	r3, [r5, #40]	@ 0x28
   1128c:	e51b9a18 	ldr	r9, [fp, #-2584]	@ 0xfffff5e8
   11290:	e0899203 	add	r9, r9, r3, lsl #4
                if (type == TYPE_LONGDOUBLE)
   11294:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
                    long double arg = a.arg[dp->arg_index].a.a_longdouble;
   11298:	ed998b02 	vldr	d8, [r9, #8]
                if (type == TYPE_LONGDOUBLE)
   1129c:	e353001c 	cmp	r3, #28
                    if (isnanl (arg))
   112a0:	eeb48b48 	vcmp.f64	d8, d8
                if (type == TYPE_LONGDOUBLE)
   112a4:	0a000515 	beq	12700 <rpl_vasnprintf+0x1fe0>
                    if (isnand (arg))
   112a8:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   112ac:	6a00065a 	bvs	12c1c <rpl_vasnprintf+0x24fc>
                        if (signbit (arg)) /* arg < 0.0 or negative zero */
   112b0:	eeb00b48 	vmov.f64	d0, d8
   112b4:	eb000faf 	bl	15178 <gl_signbitl>
   112b8:	e3500000 	cmp	r0, #0
   112bc:	1a0005d5 	bne	12a18 <rpl_vasnprintf+0x22f8>
                        else if (flags & FLAG_SHOWSIGN)
   112c0:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
   112c4:	e3130004 	tst	r3, #4
   112c8:	0a0009a1 	beq	13954 <rpl_vasnprintf+0x3234>
                          *p++ = '+';
   112cc:	e51b9a9c 	ldr	r9, [fp, #-2716]	@ 0xfffff564
   112d0:	e3a0302b 	mov	r3, #43	@ 0x2b
   112d4:	e4c93001 	strb	r3, [r9], #1
                        if (arg > 0.0 && arg + arg == arg)
   112d8:	eeb58bc0 	vcmpe.f64	d8, #0.0
   112dc:	eef1fa10 	vmrs	APSR_nzcv, fpscr
                            if (dp->conversion >= 'A' && dp->conversion <= 'Z')
   112e0:	e5d53024 	ldrb	r3, [r5, #36]	@ 0x24
                        if (arg > 0.0 && arg + arg == arg)
   112e4:	da000830 	ble	133ac <rpl_vasnprintf+0x2c8c>
   112e8:	ee387b08 	vadd.f64	d7, d8, d8
   112ec:	eeb47b48 	vcmp.f64	d7, d8
   112f0:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   112f4:	0a00081e 	beq	13374 <rpl_vasnprintf+0x2c54>
                            if (dp->conversion == 'f' || dp->conversion == 'F')
   112f8:	e2433045 	sub	r3, r3, #69	@ 0x45
   112fc:	e3530022 	cmp	r3, #34	@ 0x22
   11300:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   11304:	ea000f83 	b	15118 <rpl_vasnprintf+0x49f8>
   11308:	00012e28 	.word	0x00012e28
   1130c:	00012d9c 	.word	0x00012d9c
   11310:	00012ef0 	.word	0x00012ef0
   11314:	00015118 	.word	0x00015118
   11318:	00015118 	.word	0x00015118
   1131c:	00015118 	.word	0x00015118
   11320:	00015118 	.word	0x00015118
   11324:	00015118 	.word	0x00015118
   11328:	00015118 	.word	0x00015118
   1132c:	00015118 	.word	0x00015118
   11330:	00015118 	.word	0x00015118
   11334:	00015118 	.word	0x00015118
   11338:	00015118 	.word	0x00015118
   1133c:	00015118 	.word	0x00015118
   11340:	00015118 	.word	0x00015118
   11344:	00015118 	.word	0x00015118
   11348:	00015118 	.word	0x00015118
   1134c:	00015118 	.word	0x00015118
   11350:	00015118 	.word	0x00015118
   11354:	00015118 	.word	0x00015118
   11358:	00015118 	.word	0x00015118
   1135c:	00015118 	.word	0x00015118
   11360:	00015118 	.word	0x00015118
   11364:	00015118 	.word	0x00015118
   11368:	00015118 	.word	0x00015118
   1136c:	00015118 	.word	0x00015118
   11370:	00015118 	.word	0x00015118
   11374:	00015118 	.word	0x00015118
   11378:	00015118 	.word	0x00015118
   1137c:	00015118 	.word	0x00015118
   11380:	00015118 	.word	0x00015118
   11384:	00015118 	.word	0x00015118
   11388:	00012e28 	.word	0x00012e28
   1138c:	00012d9c 	.word	0x00012d9c
   11390:	00012ef0 	.word	0x00012ef0
                if (dp->width_start != dp->width_end)
   11394:	e1520001 	cmp	r2, r1
   11398:	0a00016f 	beq	1195c <rpl_vasnprintf+0x123c>
                    if (dp->width_arg_index != ARG_NONE)
   1139c:	e5950014 	ldr	r0, [r5, #20]
   113a0:	e3700001 	cmn	r0, #1
   113a4:	0a000958 	beq	1390c <rpl_vasnprintf+0x31ec>
                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))
   113a8:	e7d32200 	ldrb	r2, [r3, r0, lsl #4]
   113ac:	e0830200 	add	r0, r3, r0, lsl #4
   113b0:	e3520005 	cmp	r2, #5
   113b4:	1a000f57 	bne	15118 <rpl_vasnprintf+0x49f8>
                        arg = a.arg[dp->width_arg_index].a.a_int;
   113b8:	e5902008 	ldr	r2, [r0, #8]
                        if (arg < 0)
   113bc:	e3520000 	cmp	r2, #0
                        arg = a.arg[dp->width_arg_index].a.a_int;
   113c0:	e50b2aa4 	str	r2, [fp, #-2724]	@ 0xfffff55c
                    has_width = 1;
   113c4:	a3a02001 	movge	r2, #1
   113c8:	a50b2a9c 	strge	r2, [fp, #-2716]	@ 0xfffff564
                        if (arg < 0)
   113cc:	aa000006 	bge	113ec <rpl_vasnprintf+0xccc>
                            flags |= FLAG_LEFT;
   113d0:	e51b1a98 	ldr	r1, [fp, #-2712]	@ 0xfffff568
                            width = -width;
   113d4:	e2622000 	rsb	r2, r2, #0
   113d8:	e50b2aa4 	str	r2, [fp, #-2724]	@ 0xfffff55c
                    has_width = 1;
   113dc:	e3a02001 	mov	r2, #1
   113e0:	e50b2a9c 	str	r2, [fp, #-2716]	@ 0xfffff564
                            flags |= FLAG_LEFT;
   113e4:	e3811002 	orr	r1, r1, #2
   113e8:	e50b1a98 	str	r1, [fp, #-2712]	@ 0xfffff568
                if (dp->precision_start != dp->precision_end)
   113ec:	e5951018 	ldr	r1, [r5, #24]
   113f0:	e595001c 	ldr	r0, [r5, #28]
   113f4:	e1510000 	cmp	r1, r0
   113f8:	0a0001a7 	beq	11a9c <rpl_vasnprintf+0x137c>
                    if (dp->precision_arg_index != ARG_NONE)
   113fc:	e5952020 	ldr	r2, [r5, #32]
   11400:	e3720001 	cmn	r2, #1
   11404:	0a00092b 	beq	138b8 <rpl_vasnprintf+0x3198>
                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))
   11408:	e7d31202 	ldrb	r1, [r3, r2, lsl #4]
   1140c:	e0832202 	add	r2, r3, r2, lsl #4
   11410:	e3510005 	cmp	r1, #5
   11414:	1a000f3f 	bne	15118 <rpl_vasnprintf+0x49f8>
                        arg = a.arg[dp->precision_arg_index].a.a_int;
   11418:	e5922008 	ldr	r2, [r2, #8]
                  const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;
   1141c:	e5993008 	ldr	r3, [r9, #8]
                        if (arg >= 0)
   11420:	e3520000 	cmp	r2, #0
                  const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;
   11424:	e50b3a94 	str	r3, [fp, #-2708]	@ 0xfffff56c
                            precision = arg;
   11428:	a1a03002 	movge	r3, r2
                        if (arg >= 0)
   1142c:	ba00019c 	blt	11aa4 <rpl_vasnprintf+0x1384>
                      while (precision > 0)
   11430:	e3530000 	cmp	r3, #0
   11434:	e3a04000 	mov	r4, #0
   11438:	e24b6e5a 	sub	r6, fp, #1440	@ 0x5a0
   1143c:	e50b45a4 	str	r4, [fp, #-1444]	@ 0xfffffa5c
   11440:	e2466004 	sub	r6, r6, #4
   11444:	e50b45a0 	str	r4, [fp, #-1440]	@ 0xfffffa60
   11448:	0a000e9f 	beq	14ecc <rpl_vasnprintf+0x47ac>

__ssp_decl(size_t, wcrtomb, (char *__buf, wchar_t __src, mbstate_t *__ps))
{
  if (__buf != NULL && __src != L'\0')
    __ssp_check(__buf, sizeof(wchar_t), __ssp_bos);
  return __ssp_real_wcrtomb (__buf, __src, __ps);
   1144c:	e50b5ab0 	str	r5, [fp, #-2736]	@ 0xfffff550
   11450:	e1a09003 	mov	r9, r3
   11454:	e1a05004 	mov	r5, r4
   11458:	e51b7a94 	ldr	r7, [fp, #-2708]	@ 0xfffff56c
   1145c:	e1a04006 	mov	r4, r6
   11460:	ea000009 	b	1148c <rpl_vasnprintf+0xd6c>
   11464:	e1a02004 	mov	r2, r4
   11468:	e24b0fba 	sub	r0, fp, #744	@ 0x2e8
   1146c:	eb001568 	bl	16a14 <wcrtomb>
                          if (count < 0)
   11470:	e3500000 	cmp	r0, #0
   11474:	ba00076d 	blt	13230 <rpl_vasnprintf+0x2b10>
                          if (precision < (unsigned int) count)
   11478:	e1500009 	cmp	r0, r9
   1147c:	8a000007 	bhi	114a0 <rpl_vasnprintf+0xd80>
                      while (precision > 0)
   11480:	e0599000 	subs	r9, r9, r0
                          characters += count;
   11484:	e0855000 	add	r5, r5, r0
                      while (precision > 0)
   11488:	0a000af2 	beq	14058 <rpl_vasnprintf+0x3938>
                          if (*arg_end == 0)
   1148c:	e5971000 	ldr	r1, [r7]
   11490:	e1a06007 	mov	r6, r7
   11494:	e2877004 	add	r7, r7, #4
   11498:	e3510000 	cmp	r1, #0
   1149c:	1afffff0 	bne	11464 <rpl_vasnprintf+0xd44>
   114a0:	e1a04005 	mov	r4, r5
   114a4:	e51b5ab0 	ldr	r5, [fp, #-2736]	@ 0xfffff550
   114a8:	e50b6aa8 	str	r6, [fp, #-2728]	@ 0xfffff558
                  if (has_width)
   114ac:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   114b0:	e3530000 	cmp	r3, #0
   114b4:	03a07001 	moveq	r7, #1
   114b8:	0a000183 	beq	11acc <rpl_vasnprintf+0x13ac>
   114bc:	e51b7a9c 	ldr	r7, [fp, #-2716]	@ 0xfffff564
                  if (w < width && !(flags & FLAG_LEFT))
   114c0:	e51b3aa4 	ldr	r3, [fp, #-2724]	@ 0xfffff55c
   114c4:	e50b4ab0 	str	r4, [fp, #-2736]	@ 0xfffff550
   114c8:	e1540003 	cmp	r4, r3
   114cc:	3a000183 	bcc	11ae0 <rpl_vasnprintf+0x13c0>
   114d0:	ea0001a5 	b	11b6c <rpl_vasnprintf+0x144c>
            ENSURE_ALLOCATION (augmented_length);
   114d4:	e1a0000a 	mov	r0, sl
   114d8:	ebfff44d 	bl	e614 <rpl_malloc>
   114dc:	e2504000 	subs	r4, r0, #0
   114e0:	0afffdc3 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   114e4:	e3580000 	cmp	r8, #0
   114e8:	0a000002 	beq	114f8 <rpl_vasnprintf+0xdd8>
   114ec:	e51b1a90 	ldr	r1, [fp, #-2704]	@ 0xfffff570
   114f0:	e1a02008 	mov	r2, r8
   114f4:	eb003a61 	bl	1fe80 <memcpy>
   114f8:	e50b4a88 	str	r4, [fp, #-2696]	@ 0xfffff578
   114fc:	eafffde9 	b	10ca8 <rpl_vasnprintf+0x588>
                switch (dp->conversion)
   11500:	e3a03000 	mov	r3, #0
   11504:	e50b3ab0 	str	r3, [fp, #-2736]	@ 0xfffff550
                if (flags & FLAG_GROUP)
   11508:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
                *fbp++ = '%';
   1150c:	e51b2aa0 	ldr	r2, [fp, #-2720]	@ 0xfffff560
                if (flags & FLAG_GROUP)
   11510:	e3130001 	tst	r3, #1
                *fbp++ = '%';
   11514:	e3a03025 	mov	r3, #37	@ 0x25
                  *fbp++ = '\'';
   11518:	151b1aa0 	ldrne	r1, [fp, #-2720]	@ 0xfffff560
                *fbp++ = '%';
   1151c:	e5c23000 	strb	r3, [r2]
                  *fbp++ = '\'';
   11520:	13a02027 	movne	r2, #39	@ 0x27
                *fbp++ = '%';
   11524:	02823001 	addeq	r3, r2, #1
                  *fbp++ = '\'';
   11528:	15c12001 	strbne	r2, [r1, #1]
   1152c:	12813002 	addne	r3, r1, #2
                if (flags & FLAG_LEFT)
   11530:	e51b2a98 	ldr	r2, [fp, #-2712]	@ 0xfffff568
   11534:	e2122002 	ands	r2, r2, #2
   11538:	e50b2ac4 	str	r2, [fp, #-2756]	@ 0xfffff53c
                  *fbp++ = '-';
   1153c:	13a0202d 	movne	r2, #45	@ 0x2d
   11540:	14c32001 	strbne	r2, [r3], #1
                if (flags & FLAG_SHOWSIGN)
   11544:	e51b2a98 	ldr	r2, [fp, #-2712]	@ 0xfffff568
   11548:	e3120004 	tst	r2, #4
                  *fbp++ = '+';
   1154c:	13a0202b 	movne	r2, #43	@ 0x2b
   11550:	14c32001 	strbne	r2, [r3], #1
                if (flags & FLAG_SPACE)
   11554:	e51b2a98 	ldr	r2, [fp, #-2712]	@ 0xfffff568
   11558:	e3120008 	tst	r2, #8
                  *fbp++ = ' ';
   1155c:	13a02020 	movne	r2, #32
   11560:	14c32001 	strbne	r2, [r3], #1
                if (flags & FLAG_ALT)
   11564:	e51b2a98 	ldr	r2, [fp, #-2712]	@ 0xfffff568
   11568:	e3120010 	tst	r2, #16
                  *fbp++ = '#';
   1156c:	13a02023 	movne	r2, #35	@ 0x23
   11570:	14c32001 	strbne	r2, [r3], #1
                if (!pad_ourselves)
   11574:	e51b2ab0 	ldr	r2, [fp, #-2736]	@ 0xfffff550
   11578:	e3520000 	cmp	r2, #0
   1157c:	1a00000c 	bne	115b4 <rpl_vasnprintf+0xe94>
                    if (flags & FLAG_ZERO)
   11580:	e51b2a98 	ldr	r2, [fp, #-2712]	@ 0xfffff568
   11584:	e3120020 	tst	r2, #32
                      *fbp++ = '0';
   11588:	13a02030 	movne	r2, #48	@ 0x30
   1158c:	14c32001 	strbne	r2, [r3], #1
                    if (dp->width_start != dp->width_end)
   11590:	e595100c 	ldr	r1, [r5, #12]
   11594:	e5954010 	ldr	r4, [r5, #16]
   11598:	e1510004 	cmp	r1, r4
   1159c:	0a000004 	beq	115b4 <rpl_vasnprintf+0xe94>
                        size_t n = dp->width_end - dp->width_start;
   115a0:	e0444001 	sub	r4, r4, r1
   115a4:	e1a00003 	mov	r0, r3
   115a8:	e1a02004 	mov	r2, r4
   115ac:	eb003a33 	bl	1fe80 <memcpy>
                            fbp += n;
   115b0:	e0803004 	add	r3, r0, r4
                    if (dp->precision_start != dp->precision_end)
   115b4:	e5951018 	ldr	r1, [r5, #24]
   115b8:	e595401c 	ldr	r4, [r5, #28]
   115bc:	e1510004 	cmp	r1, r4
   115c0:	0a000004 	beq	115d8 <rpl_vasnprintf+0xeb8>
                        size_t n = dp->precision_end - dp->precision_start;
   115c4:	e0444001 	sub	r4, r4, r1
   115c8:	e1a00003 	mov	r0, r3
   115cc:	e1a02004 	mov	r2, r4
   115d0:	eb003a2a 	bl	1fe80 <memcpy>
                            fbp += n;
   115d4:	e0803004 	add	r3, r0, r4
                switch (type)
   115d8:	e51b2a94 	ldr	r2, [fp, #-2708]	@ 0xfffff56c
   115dc:	e2422007 	sub	r2, r2, #7
   115e0:	e6ef2072 	uxtb	r2, r2
   115e4:	e3520019 	cmp	r2, #25
   115e8:	8a000425 	bhi	12684 <rpl_vasnprintf+0x1f64>
   115ec:	e3a01001 	mov	r1, #1
   115f0:	e3000c0c 	movw	r0, #3084	@ 0xc0c
   115f4:	e1a01211 	lsl	r1, r1, r2
   115f8:	e340000c 	movt	r0, #12
   115fc:	e1110000 	tst	r1, r0
   11600:	1a0001f7 	bne	11de4 <rpl_vasnprintf+0x16c4>
   11604:	e3a00003 	mov	r0, #3
   11608:	e3400280 	movt	r0, #640	@ 0x280
   1160c:	e1110000 	tst	r1, r0
   11610:	1a0001f5 	bne	11dec <rpl_vasnprintf+0x16cc>
   11614:	e3520015 	cmp	r2, #21
   11618:	1a000419 	bne	12684 <rpl_vasnprintf+0x1f64>
                    *fbp++ = 'L';
   1161c:	e1a02003 	mov	r2, r3
   11620:	e3a0304c 	mov	r3, #76	@ 0x4c
   11624:	e4c23001 	strb	r3, [r2], #1
   11628:	e50b2aa8 	str	r2, [fp, #-2728]	@ 0xfffff558
                if (dp->conversion == 'F')
   1162c:	e5d53024 	ldrb	r3, [r5, #36]	@ 0x24
   11630:	e51b2aa8 	ldr	r2, [fp, #-2728]	@ 0xfffff558
                  *fbp = 'f';
   11634:	e3530046 	cmp	r3, #70	@ 0x46
   11638:	03a03066 	moveq	r3, #102	@ 0x66
   1163c:	e5c23000 	strb	r3, [r2]
                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)
   11640:	e51b3ab0 	ldr	r3, [fp, #-2736]	@ 0xfffff550
   11644:	e3530000 	cmp	r3, #0
                fbp[1] = '%';
   11648:	e3a03025 	mov	r3, #37	@ 0x25
   1164c:	e5c23001 	strb	r3, [r2, #1]
                fbp[2] = 'n';
   11650:	e3a0306e 	mov	r3, #110	@ 0x6e
   11654:	e5c23002 	strb	r3, [r2, #2]
                fbp[3] = '\0';
   11658:	e3a03000 	mov	r3, #0
   1165c:	e5c23003 	strb	r3, [r2, #3]
                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)
   11660:	1a0001dd 	bne	11ddc <rpl_vasnprintf+0x16bc>
   11664:	e5953014 	ldr	r3, [r5, #20]
   11668:	e3730001 	cmn	r3, #1
   1166c:	0a0004e3 	beq	12a00 <rpl_vasnprintf+0x22e0>
                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))
   11670:	e51b2a18 	ldr	r2, [fp, #-2584]	@ 0xfffff5e8
   11674:	e7d21203 	ldrb	r1, [r2, r3, lsl #4]
   11678:	e0822203 	add	r2, r2, r3, lsl #4
   1167c:	e3510005 	cmp	r1, #5
   11680:	1a000ea4 	bne	15118 <rpl_vasnprintf+0x49f8>
                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;
   11684:	e5923008 	ldr	r3, [r2, #8]
   11688:	e3a07001 	mov	r7, #1
   1168c:	e50b3a64 	str	r3, [fp, #-2660]	@ 0xfffff59c
                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)
   11690:	e5953020 	ldr	r3, [r5, #32]
   11694:	e3730001 	cmn	r3, #1
   11698:	0a000009 	beq	116c4 <rpl_vasnprintf+0xfa4>
                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))
   1169c:	e51b2a18 	ldr	r2, [fp, #-2584]	@ 0xfffff5e8
   116a0:	e7d21203 	ldrb	r1, [r2, r3, lsl #4]
   116a4:	e0822203 	add	r2, r2, r3, lsl #4
   116a8:	e3510005 	cmp	r1, #5
   116ac:	1a000e99 	bne	15118 <rpl_vasnprintf+0x49f8>
                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;
   116b0:	e5922008 	ldr	r2, [r2, #8]
   116b4:	e24b302c 	sub	r3, fp, #44	@ 0x2c
   116b8:	e0833107 	add	r3, r3, r7, lsl #2
   116bc:	e2877001 	add	r7, r7, #1
   116c0:	e5032a38 	str	r2, [r3, #-2616]	@ 0xfffff5c8
  size_t sum = size1 + size2;
   116c4:	e2983002 	adds	r3, r8, #2
   116c8:	e50b3aa4 	str	r3, [fp, #-2724]	@ 0xfffff55c
   116cc:	2a000716 	bcs	1332c <rpl_vasnprintf+0x2c0c>
                ENSURE_ALLOCATION (xsum (length,
   116d0:	e15a0003 	cmp	sl, r3
   116d4:	2a000716 	bcs	13334 <rpl_vasnprintf+0x2c14>
   116d8:	e35a0000 	cmp	sl, #0
   116dc:	0a0002b1 	beq	121a8 <rpl_vasnprintf+0x1a88>
   116e0:	bafffd43 	blt	10bf4 <rpl_vasnprintf+0x4d4>
   116e4:	e51b3aa4 	ldr	r3, [fp, #-2724]	@ 0xfffff55c
   116e8:	e1a0a08a 	lsl	sl, sl, #1
   116ec:	e15a0003 	cmp	sl, r3
   116f0:	2a0002b0 	bcs	121b8 <rpl_vasnprintf+0x1a98>
   116f4:	e51b3aa4 	ldr	r3, [fp, #-2724]	@ 0xfffff55c
   116f8:	e3730001 	cmn	r3, #1
   116fc:	0afffd3c 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   11700:	e1a0a003 	mov	sl, r3
   11704:	ea0002ab 	b	121b8 <rpl_vasnprintf+0x1a98>
                    if (size_overflow_p (tmp_memsize))
   11708:	e3770001 	cmn	r7, #1
   1170c:	0afffd38 	beq	10bf4 <rpl_vasnprintf+0x4d4>
                    tmp = (DCHAR_T *) malloc (tmp_memsize);
   11710:	e1a00007 	mov	r0, r7
   11714:	ebfff3be 	bl	e614 <rpl_malloc>
                    if (tmp == NULL)
   11718:	e2503000 	subs	r3, r0, #0
   1171c:	e50b3aa4 	str	r3, [fp, #-2724]	@ 0xfffff55c
   11720:	1afffe5f 	bne	110a4 <rpl_vasnprintf+0x984>
   11724:	eafffd32 	b	10bf4 <rpl_vasnprintf+0x4d4>
                    arg = a.arg[dp->arg_index].a.a_uint_fast32_t;
   11728:	e5952028 	ldr	r2, [r5, #40]	@ 0x28
   1172c:	e3a0e000 	mov	lr, #0
   11730:	e51b3a18 	ldr	r3, [fp, #-2584]	@ 0xfffff5e8
   11734:	e0833202 	add	r3, r3, r2, lsl #4
   11738:	e593c008 	ldr	ip, [r3, #8]
                int need_prefix = ((flags & FLAG_ALT) && arg != 0);
   1173c:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
   11740:	e2139010 	ands	r9, r3, #16
   11744:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   11748:	e2232001 	eor	r2, r3, #1
   1174c:	e50b2aa8 	str	r2, [fp, #-2728]	@ 0xfffff558
   11750:	0a000091 	beq	1199c <rpl_vasnprintf+0x127c>
   11754:	e19c300e 	orrs	r3, ip, lr
   11758:	1a0001c8 	bne	11e80 <rpl_vasnprintf+0x1760>
                if (!(has_precision && precision == 0 && arg == 0))
   1175c:	e1a03002 	mov	r3, r2
   11760:	e3560000 	cmp	r6, #0
   11764:	13833001 	orrne	r3, r3, #1
   11768:	e3530000 	cmp	r3, #0
   1176c:	1a0007b8 	bne	13654 <rpl_vasnprintf+0x2f34>
                if (has_precision)
   11770:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   11774:	e3530000 	cmp	r3, #0
   11778:	1a000830 	bne	13840 <rpl_vasnprintf+0x3120>
                if (count < width)
   1177c:	e3540000 	cmp	r4, #0
   11780:	0a0001d3 	beq	11ed4 <rpl_vasnprintf+0x17b4>
                    if (flags & FLAG_LEFT)
   11784:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
                        for (p = tmp_end - pad; p < tmp_end; p++)
   11788:	e2644000 	rsb	r4, r4, #0
                    if (flags & FLAG_LEFT)
   1178c:	e51b9a94 	ldr	r9, [fp, #-2708]	@ 0xfffff56c
   11790:	e2133002 	ands	r3, r3, #2
   11794:	e50b3aa8 	str	r3, [fp, #-2728]	@ 0xfffff558
   11798:	1a0000b7 	bne	11a7c <rpl_vasnprintf+0x135c>
   1179c:	e1a01009 	mov	r1, r9
                    else if ((flags & FLAG_ZERO)
   117a0:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
   117a4:	e3130020 	tst	r3, #32
   117a8:	0a0001c0 	beq	11eb0 <rpl_vasnprintf+0x1790>
                             && !(has_width && has_precision))
   117ac:	e51b3ab0 	ldr	r3, [fp, #-2736]	@ 0xfffff550
   117b0:	e51b2aa8 	ldr	r2, [fp, #-2728]	@ 0xfffff558
   117b4:	e2233001 	eor	r3, r3, #1
   117b8:	e1933002 	orrs	r3, r3, r2
   117bc:	0a0001bb 	beq	11eb0 <rpl_vasnprintf+0x1790>
                        for (p = tmp_start; p < pad_ptr; p++)
   117c0:	e1510009 	cmp	r1, r9
   117c4:	82440001 	subhi	r0, r4, #1
   117c8:	82493001 	subhi	r3, r9, #1
   117cc:	80890000 	addhi	r0, r9, r0
   117d0:	8241e001 	subhi	lr, r1, #1
   117d4:	9a000003 	bls	117e8 <rpl_vasnprintf+0x10c8>
                          *(p - pad) = *p;
   117d8:	e5f32001 	ldrb	r2, [r3, #1]!
                        for (p = tmp_start; p < pad_ptr; p++)
   117dc:	e153000e 	cmp	r3, lr
                          *(p - pad) = *p;
   117e0:	e5e02001 	strb	r2, [r0, #1]!
                        for (p = tmp_start; p < pad_ptr; p++)
   117e4:	1afffffb 	bne	117d8 <rpl_vasnprintf+0x10b8>
                        for (p = pad_ptr - pad; p < pad_ptr; p++)
   117e8:	e0910004 	adds	r0, r1, r4
                    tmp_start = tmp_start - pad;
   117ec:	e0899004 	add	r9, r9, r4
                        for (p = pad_ptr - pad; p < pad_ptr; p++)
   117f0:	3a000002 	bcc	11800 <rpl_vasnprintf+0x10e0>
                          *p = '0';
   117f4:	e2642000 	rsb	r2, r4, #0
   117f8:	e3a01030 	mov	r1, #48	@ 0x30
   117fc:	eb0023ab 	bl	1a6b0 <memset>
                count = tmp_end - tmp_start;
   11800:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
   11804:	e0436009 	sub	r6, r3, r9
                if (count > tmp_length)
   11808:	e1570006 	cmp	r7, r6
   1180c:	3a000e41 	bcc	15118 <rpl_vasnprintf+0x49f8>
   11810:	e0987006 	adds	r7, r8, r6
                if (count >= allocated - length)
   11814:	e04a3008 	sub	r3, sl, r8
   11818:	23a02001 	movcs	r2, #1
   1181c:	33a02000 	movcc	r2, #0
   11820:	e1530006 	cmp	r3, r6
   11824:	8a000015 	bhi	11880 <rpl_vasnprintf+0x1160>
  return (sum >= size1 ? sum : SIZE_MAX);
   11828:	e3520000 	cmp	r2, #0
   1182c:	1a00024c 	bne	12164 <rpl_vasnprintf+0x1a44>
                    ENSURE_ALLOCATION (n);
   11830:	e15a0007 	cmp	sl, r7
   11834:	2a000011 	bcs	11880 <rpl_vasnprintf+0x1160>
   11838:	e35a0000 	cmp	sl, #0
   1183c:	1a00047d 	bne	12a38 <rpl_vasnprintf+0x2318>
   11840:	e3a0300c 	mov	r3, #12
   11844:	e1530007 	cmp	r3, r7
   11848:	21a0a003 	movcs	sl, r3
   1184c:	31a0a007 	movcc	sl, r7
   11850:	e37a0001 	cmn	sl, #1
   11854:	0afffce6 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   11858:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
   1185c:	e51b2a90 	ldr	r2, [fp, #-2704]	@ 0xfffff570
   11860:	e1530002 	cmp	r3, r2
   11864:	0a000746 	beq	13584 <rpl_vasnprintf+0x2e64>
   11868:	e51b0a88 	ldr	r0, [fp, #-2696]	@ 0xfffff578
   1186c:	e1a0100a 	mov	r1, sl
   11870:	ebfff373 	bl	e644 <rpl_realloc>
   11874:	e3500000 	cmp	r0, #0
   11878:	0afffcdd 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   1187c:	e50b0a88 	str	r0, [fp, #-2696]	@ 0xfffff578
   11880:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
   11884:	e1a02006 	mov	r2, r6
   11888:	e1a01009 	mov	r1, r9
   1188c:	e0830008 	add	r0, r3, r8
   11890:	eb00397a 	bl	1fe80 <memcpy>
                if (tmp != tmpbuf)
   11894:	e51b3aa4 	ldr	r3, [fp, #-2724]	@ 0xfffff55c
   11898:	e24b2e86 	sub	r2, fp, #2144	@ 0x860
   1189c:	e1530002 	cmp	r3, r2
   118a0:	0afffd03 	beq	10cb4 <rpl_vasnprintf+0x594>
                  free (tmp);
   118a4:	e1a00003 	mov	r0, r3
   118a8:	ebffe2ea 	bl	a458 <rpl_free>
                length += count;
   118ac:	eafffd00 	b	10cb4 <rpl_vasnprintf+0x594>
                    *a.arg[dp->arg_index].a.a_count_int16_t_pointer = length;
   118b0:	e5993008 	ldr	r3, [r9, #8]
   118b4:	e1c380b0 	strh	r8, [r3]
                    break;
   118b8:	eafffd1e 	b	10d38 <rpl_vasnprintf+0x618>
                    *a.arg[dp->arg_index].a.a_count_schar_pointer = length;
   118bc:	e5993008 	ldr	r3, [r9, #8]
   118c0:	e5c38000 	strb	r8, [r3]
                    break;
   118c4:	eafffd1b 	b	10d38 <rpl_vasnprintf+0x618>
                            flags |= FLAG_LEFT;
   118c8:	e51b2a98 	ldr	r2, [fp, #-2712]	@ 0xfffff568
                            width = -width;
   118cc:	e2644000 	rsb	r4, r4, #0
                if (dp->precision_start != dp->precision_end)
   118d0:	e5950018 	ldr	r0, [r5, #24]
                            flags |= FLAG_LEFT;
   118d4:	e3822002 	orr	r2, r2, #2
   118d8:	e50b2a98 	str	r2, [fp, #-2712]	@ 0xfffff568
                    has_width = 1;
   118dc:	e3a02001 	mov	r2, #1
   118e0:	e50b2ab0 	str	r2, [fp, #-2736]	@ 0xfffff550
                if (dp->precision_start != dp->precision_end)
   118e4:	e595201c 	ldr	r2, [r5, #28]
   118e8:	e1500002 	cmp	r0, r2
   118ec:	1afffdd0 	bne	11034 <rpl_vasnprintf+0x914>
                has_precision = 0;
   118f0:	e3a03000 	mov	r3, #0
                precision = 1;
   118f4:	e3a06001 	mov	r6, #1
                has_precision = 0;
   118f8:	e50b3a9c 	str	r3, [fp, #-2716]	@ 0xfffff564
   118fc:	eafffdd9 	b	11068 <rpl_vasnprintf+0x948>
   11900:	e1a0600c 	mov	r6, ip
                if (dp->precision_start != dp->precision_end)
   11904:	e5952018 	ldr	r2, [r5, #24]
   11908:	e595101c 	ldr	r1, [r5, #28]
   1190c:	e1520001 	cmp	r2, r1
   11910:	1afffc07 	bne	10934 <rpl_vasnprintf+0x214>
                precision = 0;
   11914:	e3a04000 	mov	r4, #0
   11918:	e3a0301a 	mov	r3, #26
                has_precision = 0;
   1191c:	e1a07004 	mov	r7, r4
   11920:	eafffc12 	b	10970 <rpl_vasnprintf+0x250>
                            flags |= FLAG_LEFT;
   11924:	e51b2a98 	ldr	r2, [fp, #-2712]	@ 0xfffff568
                            width = -width;
   11928:	e2666000 	rsb	r6, r6, #0
                            flags |= FLAG_LEFT;
   1192c:	e3822002 	orr	r2, r2, #2
   11930:	e50b2a98 	str	r2, [fp, #-2712]	@ 0xfffff568
                            width = -width;
   11934:	eafffbfa 	b	10924 <rpl_vasnprintf+0x204>
                    pad_ourselves = 1;
   11938:	e3a03001 	mov	r3, #1
   1193c:	e50b3ab0 	str	r3, [fp, #-2736]	@ 0xfffff550
   11940:	eafffef0 	b	11508 <rpl_vasnprintf+0xde8>
                    arg = a.arg[dp->arg_index].a.a_uint_fast64_t;
   11944:	e5952028 	ldr	r2, [r5, #40]	@ 0x28
   11948:	e51b3a18 	ldr	r3, [fp, #-2584]	@ 0xfffff5e8
   1194c:	e0833202 	add	r3, r3, r2, lsl #4
   11950:	e593c008 	ldr	ip, [r3, #8]
   11954:	e593e00c 	ldr	lr, [r3, #12]
                    break;
   11958:	eaffff77 	b	1173c <rpl_vasnprintf+0x101c>
                width = 0;
   1195c:	e3a02000 	mov	r2, #0
   11960:	e50b2aa4 	str	r2, [fp, #-2724]	@ 0xfffff55c
                has_width = 0;
   11964:	e50b2a9c 	str	r2, [fp, #-2716]	@ 0xfffff564
   11968:	eafffe9f 	b	113ec <rpl_vasnprintf+0xccc>
                    arg = a.arg[dp->arg_index].a.a_uint8_t;
   1196c:	e5952028 	ldr	r2, [r5, #40]	@ 0x28
   11970:	e3a0e000 	mov	lr, #0
   11974:	e51b3a18 	ldr	r3, [fp, #-2584]	@ 0xfffff5e8
   11978:	e0833202 	add	r3, r3, r2, lsl #4
   1197c:	e5d3c008 	ldrb	ip, [r3, #8]
                    break;
   11980:	eaffff6d 	b	1173c <rpl_vasnprintf+0x101c>
                    arg = a.arg[dp->arg_index].a.a_uint16_t;
   11984:	e5952028 	ldr	r2, [r5, #40]	@ 0x28
   11988:	e3a0e000 	mov	lr, #0
   1198c:	e51b3a18 	ldr	r3, [fp, #-2584]	@ 0xfffff5e8
   11990:	e0833202 	add	r3, r3, r2, lsl #4
   11994:	e1d3c0b8 	ldrh	ip, [r3, #8]
                    break;
   11998:	eaffff67 	b	1173c <rpl_vasnprintf+0x101c>
                if (!(has_precision && precision == 0 && arg == 0))
   1199c:	e51b3aa8 	ldr	r3, [fp, #-2728]	@ 0xfffff558
   119a0:	e3560000 	cmp	r6, #0
   119a4:	13833001 	orrne	r3, r3, #1
   119a8:	e3130001 	tst	r3, #1
   119ac:	1a000002 	bne	119bc <rpl_vasnprintf+0x129c>
   119b0:	e19c300e 	orrs	r3, ip, lr
   119b4:	150b9aa8 	strne	r9, [fp, #-2728]	@ 0xfffff558
   119b8:	0affff6c 	beq	11770 <rpl_vasnprintf+0x1050>
                int need_prefix = ((flags & FLAG_ALT) && arg != 0);
   119bc:	e51b1a94 	ldr	r1, [fp, #-2708]	@ 0xfffff56c
   119c0:	e1a0300c 	mov	r3, ip
   119c4:	e1a0200e 	mov	r2, lr
                        arg = arg >> 1;
   119c8:	e1a000a3 	lsr	r0, r3, #1
                        *--p = '0' + (arg & 1);
   119cc:	e2033001 	and	r3, r3, #1
   119d0:	e2833030 	add	r3, r3, #48	@ 0x30
   119d4:	e5613001 	strb	r3, [r1, #-1]!
                        arg = arg >> 1;
   119d8:	e1803f82 	orr	r3, r0, r2, lsl #31
   119dc:	e1a020a2 	lsr	r2, r2, #1
                    while (arg != 0);
   119e0:	e1930002 	orrs	r0, r3, r2
   119e4:	1afffff7 	bne	119c8 <rpl_vasnprintf+0x12a8>
   119e8:	e35e0000 	cmp	lr, #0
                if (has_precision)
   119ec:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   119f0:	016f2f1c 	clzeq	r2, ip
   119f4:	116f2f1e 	clzne	r2, lr
   119f8:	02822020 	addeq	r2, r2, #32
   119fc:	e19cc00e 	orrs	ip, ip, lr
   11a00:	e2422040 	sub	r2, r2, #64	@ 0x40
   11a04:	03e02000 	mvneq	r2, #0
   11a08:	e3530000 	cmp	r3, #0
   11a0c:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
   11a10:	e0831002 	add	r1, r3, r2
   11a14:	1a00011b 	bne	11e88 <rpl_vasnprintf+0x1768>
                if (need_prefix)
   11a18:	e3590000 	cmp	r9, #0
                    *--p = '0';
   11a1c:	13063230 	movwne	r3, #25136	@ 0x6230
   11a20:	12419002 	subne	r9, r1, #2
   11a24:	114130b2 	strhne	r3, [r1, #-2]
   11a28:	01a09001 	moveq	r9, r1
                count = tmp_end - tmp_start;
   11a2c:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
   11a30:	e0436009 	sub	r6, r3, r9
                if (count < width)
   11a34:	e1540006 	cmp	r4, r6
   11a38:	9affff72 	bls	11808 <rpl_vasnprintf+0x10e8>
                    if (flags & FLAG_LEFT)
   11a3c:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
                        for (p = tmp_end - pad; p < tmp_end; p++)
   11a40:	e0464004 	sub	r4, r6, r4
                    if (flags & FLAG_LEFT)
   11a44:	e3130002 	tst	r3, #2
   11a48:	0affff54 	beq	117a0 <rpl_vasnprintf+0x1080>
                        for (p = tmp_start; p < tmp_end; p++)
   11a4c:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
   11a50:	e1530009 	cmp	r3, r9
   11a54:	9a000008 	bls	11a7c <rpl_vasnprintf+0x135c>
   11a58:	e51b2a94 	ldr	r2, [fp, #-2708]	@ 0xfffff56c
   11a5c:	e2441001 	sub	r1, r4, #1
   11a60:	e0891001 	add	r1, r9, r1
   11a64:	e2493001 	sub	r3, r9, #1
   11a68:	e242c001 	sub	ip, r2, #1
                          *(p - pad) = *p;
   11a6c:	e5f32001 	ldrb	r2, [r3, #1]!
                        for (p = tmp_start; p < tmp_end; p++)
   11a70:	e153000c 	cmp	r3, ip
                          *(p - pad) = *p;
   11a74:	e5e12001 	strb	r2, [r1, #1]!
                        for (p = tmp_start; p < tmp_end; p++)
   11a78:	1afffffb 	bne	11a6c <rpl_vasnprintf+0x134c>
                        for (p = tmp_end - pad; p < tmp_end; p++)
   11a7c:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
                    tmp_start = tmp_start - pad;
   11a80:	e0899004 	add	r9, r9, r4
                        for (p = tmp_end - pad; p < tmp_end; p++)
   11a84:	e0930004 	adds	r0, r3, r4
   11a88:	3affff5c 	bcc	11800 <rpl_vasnprintf+0x10e0>
                          *p = ' ';
   11a8c:	e2642000 	rsb	r2, r4, #0
   11a90:	e3a01020 	mov	r1, #32
   11a94:	eb002305 	bl	1a6b0 <memset>
   11a98:	eaffff58 	b	11800 <rpl_vasnprintf+0x10e0>
                  const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;
   11a9c:	e5993008 	ldr	r3, [r9, #8]
   11aa0:	e50b3a94 	str	r3, [fp, #-2708]	@ 0xfffff56c
                  else if (has_width)
   11aa4:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   11aa8:	e3530000 	cmp	r3, #0
   11aac:	1a0005cb 	bne	131e0 <rpl_vasnprintf+0x2ac0>
                      arg_end = arg + local_wcslen (arg);
   11ab0:	e51b4a94 	ldr	r4, [fp, #-2708]	@ 0xfffff56c
   11ab4:	e1a00004 	mov	r0, r4
   11ab8:	eb00242a 	bl	1ab68 <wcslen>
                      characters = 0;
   11abc:	e51b7a9c 	ldr	r7, [fp, #-2716]	@ 0xfffff564
                      arg_end = arg + local_wcslen (arg);
   11ac0:	e0843100 	add	r3, r4, r0, lsl #2
   11ac4:	e50b3aa8 	str	r3, [fp, #-2728]	@ 0xfffff558
                      characters = 0;
   11ac8:	e1a04007 	mov	r4, r7
                  if (w < width && !(flags & FLAG_LEFT))
   11acc:	e51b3aa4 	ldr	r3, [fp, #-2724]	@ 0xfffff55c
   11ad0:	e3530000 	cmp	r3, #0
   11ad4:	0a0003d4 	beq	12a2c <rpl_vasnprintf+0x230c>
   11ad8:	e3a03000 	mov	r3, #0
   11adc:	e50b3ab0 	str	r3, [fp, #-2736]	@ 0xfffff550
   11ae0:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
   11ae4:	e3130002 	tst	r3, #2
   11ae8:	1a00001c 	bne	11b60 <rpl_vasnprintf+0x1440>
                      size_t n = width - w;
   11aec:	e51b3aa4 	ldr	r3, [fp, #-2724]	@ 0xfffff55c
   11af0:	e51b2ab0 	ldr	r2, [fp, #-2736]	@ 0xfffff550
   11af4:	e0436002 	sub	r6, r3, r2
  size_t sum = size1 + size2;
   11af8:	e0989006 	adds	r9, r8, r6
   11afc:	2a000cf6 	bcs	14edc <rpl_vasnprintf+0x47bc>
                      ENSURE_ALLOCATION (xsum (length, n));
   11b00:	e15a0009 	cmp	sl, r9
   11b04:	2a00000f 	bcs	11b48 <rpl_vasnprintf+0x1428>
   11b08:	e35a0000 	cmp	sl, #0
   11b0c:	0a000957 	beq	14070 <rpl_vasnprintf+0x3950>
   11b10:	bafffc37 	blt	10bf4 <rpl_vasnprintf+0x4d4>
   11b14:	e1a0a08a 	lsl	sl, sl, #1
   11b18:	e15a0009 	cmp	sl, r9
   11b1c:	3a000956 	bcc	1407c <rpl_vasnprintf+0x395c>
   11b20:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
   11b24:	e51b2a90 	ldr	r2, [fp, #-2704]	@ 0xfffff570
   11b28:	e1530002 	cmp	r3, r2
   11b2c:	0a0009e0 	beq	142b4 <rpl_vasnprintf+0x3b94>
   11b30:	e51b0a88 	ldr	r0, [fp, #-2696]	@ 0xfffff578
   11b34:	e1a0100a 	mov	r1, sl
   11b38:	ebfff2c1 	bl	e644 <rpl_realloc>
   11b3c:	e3500000 	cmp	r0, #0
   11b40:	0afffc2b 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   11b44:	e50b0a88 	str	r0, [fp, #-2696]	@ 0xfffff578
__ssp_bos_icheck3(memset, void *, int)
   11b48:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
   11b4c:	e1a02006 	mov	r2, r6
   11b50:	e3a01020 	mov	r1, #32
   11b54:	e0830008 	add	r0, r3, r8
                      length += n;
   11b58:	e1a08009 	mov	r8, r9
   11b5c:	eb0022d3 	bl	1a6b0 <memset>
                  if (has_precision || has_width)
   11b60:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   11b64:	e1932007 	orrs	r2, r3, r7
   11b68:	0a0005b6 	beq	13248 <rpl_vasnprintf+0x2b28>
   11b6c:	e0981004 	adds	r1, r8, r4
   11b70:	e3a02000 	mov	r2, #0
   11b74:	e50b2a7c 	str	r2, [fp, #-2684]	@ 0xfffff584
   11b78:	e50b2a78 	str	r2, [fp, #-2680]	@ 0xfffff588
   11b7c:	2a000d0d 	bcs	14fb8 <rpl_vasnprintf+0x4898>
                      ENSURE_ALLOCATION (xsum (length, characters));
   11b80:	e151000a 	cmp	r1, sl
   11b84:	9a00000f 	bls	11bc8 <rpl_vasnprintf+0x14a8>
   11b88:	e35a0000 	cmp	sl, #0
   11b8c:	0a0006d1 	beq	136d8 <rpl_vasnprintf+0x2fb8>
   11b90:	bafffc17 	blt	10bf4 <rpl_vasnprintf+0x4d4>
   11b94:	e1a0a08a 	lsl	sl, sl, #1
   11b98:	e15a0001 	cmp	sl, r1
   11b9c:	3a0006d0 	bcc	136e4 <rpl_vasnprintf+0x2fc4>
   11ba0:	e51b3a90 	ldr	r3, [fp, #-2704]	@ 0xfffff570
   11ba4:	e51b2a88 	ldr	r2, [fp, #-2696]	@ 0xfffff578
   11ba8:	e1530002 	cmp	r3, r2
   11bac:	0a000773 	beq	13980 <rpl_vasnprintf+0x3260>
   11bb0:	e51b0a88 	ldr	r0, [fp, #-2696]	@ 0xfffff578
   11bb4:	e1a0100a 	mov	r1, sl
   11bb8:	ebfff2a1 	bl	e644 <rpl_realloc>
   11bbc:	e3500000 	cmp	r0, #0
   11bc0:	0afffc0b 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   11bc4:	e50b0a88 	str	r0, [fp, #-2696]	@ 0xfffff578
                      for (remaining = characters; remaining > 0; )
   11bc8:	e3540000 	cmp	r4, #0
   11bcc:	0a0008b4 	beq	13ea4 <rpl_vasnprintf+0x3784>
   11bd0:	e1a07008 	mov	r7, r8
   11bd4:	e51b9a94 	ldr	r9, [fp, #-2708]	@ 0xfffff56c
   11bd8:	e51b8a88 	ldr	r8, [fp, #-2696]	@ 0xfffff578
                          if (*arg == 0)
   11bdc:	e4991004 	ldr	r1, [r9], #4
   11be0:	e3510000 	cmp	r1, #0
   11be4:	0a000d4b 	beq	15118 <rpl_vasnprintf+0x49f8>
   11be8:	e24b2ea7 	sub	r2, fp, #2672	@ 0xa70
   11bec:	e24b0ea5 	sub	r0, fp, #2640	@ 0xa50
   11bf0:	e242200c 	sub	r2, r2, #12
   11bf4:	e240000c 	sub	r0, r0, #12
   11bf8:	eb001385 	bl	16a14 <wcrtomb>
                          if (count <= 0)
   11bfc:	e2506000 	subs	r6, r0, #0
   11c00:	da000d44 	ble	15118 <rpl_vasnprintf+0x49f8>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   11c04:	e24b1ea5 	sub	r1, fp, #2640	@ 0xa50
   11c08:	e0880007 	add	r0, r8, r7
   11c0c:	e1a02006 	mov	r2, r6
   11c10:	e241100c 	sub	r1, r1, #12
   11c14:	eb003899 	bl	1fe80 <memcpy>
                      for (remaining = characters; remaining > 0; )
   11c18:	e0544006 	subs	r4, r4, r6
                          length += count;
   11c1c:	e0877006 	add	r7, r7, r6
                      for (remaining = characters; remaining > 0; )
   11c20:	1affffed 	bne	11bdc <rpl_vasnprintf+0x14bc>
                          arg++;
   11c24:	e50b9a94 	str	r9, [fp, #-2708]	@ 0xfffff56c
                      if (!(arg == arg_end))
   11c28:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
   11c2c:	e51b2aa8 	ldr	r2, [fp, #-2728]	@ 0xfffff558
   11c30:	e1530002 	cmp	r3, r2
   11c34:	1a000d37 	bne	15118 <rpl_vasnprintf+0x49f8>
                  if (w < width && (flags & FLAG_LEFT))
   11c38:	e51b3aa4 	ldr	r3, [fp, #-2724]	@ 0xfffff55c
   11c3c:	e51b2ab0 	ldr	r2, [fp, #-2736]	@ 0xfffff550
   11c40:	e1530002 	cmp	r3, r2
   11c44:	9afffc1a 	bls	10cb4 <rpl_vasnprintf+0x594>
   11c48:	e51b1a98 	ldr	r1, [fp, #-2712]	@ 0xfffff568
   11c4c:	e3110002 	tst	r1, #2
   11c50:	0afffc17 	beq	10cb4 <rpl_vasnprintf+0x594>
                      size_t n = width - w;
   11c54:	e0438002 	sub	r8, r3, r2
   11c58:	e0974008 	adds	r4, r7, r8
   11c5c:	2a000d21 	bcs	150e8 <rpl_vasnprintf+0x49c8>
                      ENSURE_ALLOCATION (xsum (length, n));
   11c60:	e15a0004 	cmp	sl, r4
   11c64:	2a00000f 	bcs	11ca8 <rpl_vasnprintf+0x1588>
   11c68:	e35a0000 	cmp	sl, #0
   11c6c:	0a0009d2 	beq	143bc <rpl_vasnprintf+0x3c9c>
   11c70:	bafffbdf 	blt	10bf4 <rpl_vasnprintf+0x4d4>
   11c74:	e1a0a08a 	lsl	sl, sl, #1
   11c78:	e15a0004 	cmp	sl, r4
   11c7c:	3a0009d1 	bcc	143c8 <rpl_vasnprintf+0x3ca8>
   11c80:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
   11c84:	e51b2a90 	ldr	r2, [fp, #-2704]	@ 0xfffff570
   11c88:	e1530002 	cmp	r3, r2
   11c8c:	0a000a19 	beq	144f8 <rpl_vasnprintf+0x3dd8>
   11c90:	e51b0a88 	ldr	r0, [fp, #-2696]	@ 0xfffff578
   11c94:	e1a0100a 	mov	r1, sl
   11c98:	ebfff269 	bl	e644 <rpl_realloc>
   11c9c:	e3500000 	cmp	r0, #0
   11ca0:	0afffbd3 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   11ca4:	e50b0a88 	str	r0, [fp, #-2696]	@ 0xfffff578
__ssp_bos_icheck3(memset, void *, int)
   11ca8:	e1a02008 	mov	r2, r8
   11cac:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
   11cb0:	e3a01020 	mov	r1, #32
   11cb4:	e0830007 	add	r0, r3, r7
                      length += n;
   11cb8:	e1a07004 	mov	r7, r4
   11cbc:	eb00227b 	bl	1a6b0 <memset>
   11cc0:	eafffbfb 	b	10cb4 <rpl_vasnprintf+0x594>
                    if (isnanl (arg))
   11cc4:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   11cc8:	6a0000e3 	bvs	1205c <rpl_vasnprintf+0x193c>
                        if (signbit (arg)) /* arg < 0.0L or negative zero */
   11ccc:	eeb00b48 	vmov.f64	d0, d8
   11cd0:	eb000d28 	bl	15178 <gl_signbitl>
   11cd4:	e3500000 	cmp	r0, #0
   11cd8:	0a00026b 	beq	1268c <rpl_vasnprintf+0x1f6c>
                          *p++ = '-';
   11cdc:	e51b9a9c 	ldr	r9, [fp, #-2716]	@ 0xfffff564
   11ce0:	e3a0302d 	mov	r3, #45	@ 0x2d
                            arg = -arg;
   11ce4:	eeb18b48 	vneg.f64	d8, d8
                          *p++ = '-';
   11ce8:	e4c93001 	strb	r3, [r9], #1
                        if (arg > 0.0L && arg + arg == arg)
   11cec:	eeb58bc0 	vcmpe.f64	d8, #0.0
                                *p++ = 'I'; *p++ = 'N'; *p++ = 'F';
   11cf0:	e2893003 	add	r3, r9, #3
                        if (arg > 0.0L && arg + arg == arg)
   11cf4:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   11cf8:	da0006ca 	ble	13828 <rpl_vasnprintf+0x3108>
   11cfc:	ee387b08 	vadd.f64	d7, d8, d8
   11d00:	eeb47b48 	vcmp.f64	d7, d8
   11d04:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   11d08:	0afffb40 	beq	10a10 <rpl_vasnprintf+0x2f0>
                              mantissa = printf_frexpl (arg, &exponent);
   11d0c:	eeb00b48 	vmov.f64	d0, d8
   11d10:	e24b0e86 	sub	r0, fp, #2144	@ 0x860
   11d14:	e50b3a94 	str	r3, [fp, #-2708]	@ 0xfffff56c
   11d18:	eb000d15 	bl	15174 <printf_frexpl>
                                    int digit = (int) tail;
   11d1c:	eefd7bc0 	vcvt.s32.f64	s15, d0
   11d20:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
                                    tail -= digit;
   11d24:	eeb88be7 	vcvt.f64.s32	d8, s15
   11d28:	ee308b48 	vsub.f64	d8, d0, d8
                            if (has_precision
   11d2c:	e354000d 	cmp	r4, #13
   11d30:	83a02000 	movhi	r2, #0
   11d34:	92072001 	andls	r2, r7, #1
   11d38:	e3520000 	cmp	r2, #0
   11d3c:	1a00085a 	bne	13eac <rpl_vasnprintf+0x378c>
                              if ((flags & FLAG_ALT)
   11d40:	e51b2a98 	ldr	r2, [fp, #-2712]	@ 0xfffff568
                            *p++ = '0';
   11d44:	e1a07009 	mov	r7, r9
                              if ((flags & FLAG_ALT)
   11d48:	e3120010 	tst	r2, #16
                            *p++ = '0';
   11d4c:	e3a02030 	mov	r2, #48	@ 0x30
   11d50:	e4c72002 	strb	r2, [r7], #2
                            *p++ = dp->conversion - 'A' + 'X';
   11d54:	e5d52024 	ldrb	r2, [r5, #36]	@ 0x24
   11d58:	e2822017 	add	r2, r2, #23
   11d5c:	e5c92001 	strb	r2, [r9, #1]
                              *p++ = '0' + digit;
   11d60:	ee172a90 	vmov	r2, s15
   11d64:	e2822030 	add	r2, r2, #48	@ 0x30
   11d68:	e5c92002 	strb	r2, [r9, #2]
                              if ((flags & FLAG_ALT)
   11d6c:	1a000911 	bne	141b8 <rpl_vasnprintf+0x3a98>
                                  || mantissa > 0.0L || precision > 0)
   11d70:	eeb58bc0 	vcmpe.f64	d8, #0.0
   11d74:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   11d78:	ca0007e8 	bgt	13d20 <rpl_vasnprintf+0x3600>
   11d7c:	e3540000 	cmp	r4, #0
   11d80:	1a00092a 	bne	14230 <rpl_vasnprintf+0x3b10>
   11d84:	e50b3a94 	str	r3, [fp, #-2708]	@ 0xfffff56c
                              *p++ = dp->conversion - 'A' + 'P';
   11d88:	e51b4a94 	ldr	r4, [fp, #-2708]	@ 0xfffff56c
                                  sprintf ((char *) p, "%+d", exponent);
   11d8c:	e3091150 	movw	r1, #37200	@ 0x9150
                              *p++ = dp->conversion - 'A' + 'P';
   11d90:	e5d52024 	ldrb	r2, [r5, #36]	@ 0x24
                                  sprintf ((char *) p, "%+d", exponent);
   11d94:	e3401002 	movt	r1, #2
                              *p++ = dp->conversion - 'A' + 'P';
   11d98:	e1a03004 	mov	r3, r4
   11d9c:	e282200f 	add	r2, r2, #15
   11da0:	e4c32001 	strb	r2, [r3], #1
                                  sprintf ((char *) p, "%+d", exponent);
   11da4:	e1a00003 	mov	r0, r3
   11da8:	e51b2860 	ldr	r2, [fp, #-2144]	@ 0xfffff7a0
   11dac:	e50b3a94 	str	r3, [fp, #-2708]	@ 0xfffff56c
   11db0:	eb001e36 	bl	19690 <sprintf>
                                  while (*p != '\0')
   11db4:	e5d42001 	ldrb	r2, [r4, #1]
   11db8:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
   11dbc:	e3520000 	cmp	r2, #0
   11dc0:	0a000002 	beq	11dd0 <rpl_vasnprintf+0x16b0>
   11dc4:	e5f32001 	ldrb	r2, [r3, #1]!
   11dc8:	e3520000 	cmp	r2, #0
   11dcc:	1afffffc 	bne	11dc4 <rpl_vasnprintf+0x16a4>
                count = p - tmp;
   11dd0:	e51b2a9c 	ldr	r2, [fp, #-2716]	@ 0xfffff564
   11dd4:	e0434002 	sub	r4, r3, r2
   11dd8:	eafffb18 	b	10a40 <rpl_vasnprintf+0x320>
                prefix_count = 0;
   11ddc:	e1a07003 	mov	r7, r3
   11de0:	eafffe2a 	b	11690 <rpl_vasnprintf+0xf70>
                    *fbp++ = 'l';
   11de4:	e3a0206c 	mov	r2, #108	@ 0x6c
   11de8:	e4c32001 	strb	r2, [r3], #1
                    *fbp++ = 'l';
   11dec:	e1a02003 	mov	r2, r3
   11df0:	e3a0306c 	mov	r3, #108	@ 0x6c
   11df4:	e4c23001 	strb	r3, [r2], #1
   11df8:	e50b2aa8 	str	r2, [fp, #-2728]	@ 0xfffff558
                    break;
   11dfc:	eafffe0a 	b	1162c <rpl_vasnprintf+0xf0c>
        buf = (TCHAR_T *) alloca (buf_neededlength * sizeof (TCHAR_T));
   11e00:	e283300d 	add	r3, r3, #13
   11e04:	e3c33007 	bic	r3, r3, #7
   11e08:	e04dd003 	sub	sp, sp, r3
   11e0c:	e28d3018 	add	r3, sp, #24
   11e10:	e50b3aa0 	str	r3, [fp, #-2720]	@ 0xfffff560
        buf_malloced = NULL;
   11e14:	e3a03000 	mov	r3, #0
   11e18:	e50b3aac 	str	r3, [fp, #-2732]	@ 0xfffff554
   11e1c:	eafffa69 	b	107c8 <rpl_vasnprintf+0xa8>
                width = 0;
   11e20:	e3a04000 	mov	r4, #0
                has_width = 0;
   11e24:	e50b4ab0 	str	r4, [fp, #-2736]	@ 0xfffff550
   11e28:	eafffc7d 	b	11024 <rpl_vasnprintf+0x904>
                if (dp->precision_start != dp->precision_end)
   11e2c:	e5952018 	ldr	r2, [r5, #24]
   11e30:	e595101c 	ldr	r1, [r5, #28]
   11e34:	e1520001 	cmp	r2, r1
                width = 0;
   11e38:	13a06000 	movne	r6, #0
                if (dp->precision_start != dp->precision_end)
   11e3c:	1afffabc 	bne	10934 <rpl_vasnprintf+0x214>
                precision = 0;
   11e40:	e3a04000 	mov	r4, #0
   11e44:	e3a0301b 	mov	r3, #27
                width = 0;
   11e48:	e1a06004 	mov	r6, r4
                has_precision = 0;
   11e4c:	e1a07004 	mov	r7, r4
   11e50:	e50b3aa4 	str	r3, [fp, #-2724]	@ 0xfffff55c
                  tmp = tmpbuf;
   11e54:	e24b3e5a 	sub	r3, fp, #1440	@ 0x5a0
   11e58:	e2433004 	sub	r3, r3, #4
   11e5c:	e50b3a9c 	str	r3, [fp, #-2716]	@ 0xfffff564
   11e60:	eafffad3 	b	109b4 <rpl_vasnprintf+0x294>
                        else if (flags & FLAG_SHOWSIGN)
   11e64:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
   11e68:	e3130004 	tst	r3, #4
   11e6c:	0a00020d 	beq	126a8 <rpl_vasnprintf+0x1f88>
                          *p++ = '+';
   11e70:	e51b9a9c 	ldr	r9, [fp, #-2716]	@ 0xfffff564
   11e74:	e3a0302b 	mov	r3, #43	@ 0x2b
   11e78:	e4c93001 	strb	r3, [r9], #1
   11e7c:	eafffadb 	b	109f0 <rpl_vasnprintf+0x2d0>
                int need_prefix = ((flags & FLAG_ALT) && arg != 0);
   11e80:	e3a09001 	mov	r9, #1
   11e84:	eafffecc 	b	119bc <rpl_vasnprintf+0x129c>
                    DCHAR_T *digits_start = tmp_end - precision;
   11e88:	e0433006 	sub	r3, r3, r6
                    while (p > digits_start)
   11e8c:	e1510003 	cmp	r1, r3
   11e90:	9afffee0 	bls	11a18 <rpl_vasnprintf+0x12f8>
                      *--p = '0';
   11e94:	e3a01030 	mov	r1, #48	@ 0x30
   11e98:	e1a00003 	mov	r0, r3
   11e9c:	e0822006 	add	r2, r2, r6
   11ea0:	eb002202 	bl	1a6b0 <memset>
   11ea4:	e1a03000 	mov	r3, r0
   11ea8:	e1a01000 	mov	r1, r0
   11eac:	eafffed9 	b	11a18 <rpl_vasnprintf+0x12f8>
                        for (p = tmp_start - pad; p < tmp_start; p++)
   11eb0:	e0993004 	adds	r3, r9, r4
   11eb4:	3a000004 	bcc	11ecc <rpl_vasnprintf+0x17ac>
                          *p = ' ';
   11eb8:	e1a00003 	mov	r0, r3
   11ebc:	e2642000 	rsb	r2, r4, #0
   11ec0:	e3a01020 	mov	r1, #32
   11ec4:	eb0021f9 	bl	1a6b0 <memset>
   11ec8:	e1a03000 	mov	r3, r0
                    if (flags & FLAG_LEFT)
   11ecc:	e1a09003 	mov	r9, r3
   11ed0:	eafffe4a 	b	11800 <rpl_vasnprintf+0x10e0>
                if (count >= allocated - length)
   11ed4:	e15a0008 	cmp	sl, r8
                tmp_start = p;
   11ed8:	e51b9a94 	ldr	r9, [fp, #-2708]	@ 0xfffff56c
                count = tmp_end - tmp_start;
   11edc:	e1a06004 	mov	r6, r4
                if (count >= allocated - length)
   11ee0:	11a07008 	movne	r7, r8
   11ee4:	1afffe65 	bne	11880 <rpl_vasnprintf+0x1160>
   11ee8:	e1a0700a 	mov	r7, sl
   11eec:	eafffe4f 	b	11830 <rpl_vasnprintf+0x1110>
                if (type == TYPE_LONGDOUBLE)
   11ef0:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
   11ef4:	e353001c 	cmp	r3, #28
   11ef8:	0a0005da 	beq	13668 <rpl_vasnprintf+0x2f48>
                  if (dp->conversion == 'f' || dp->conversion == 'F')
   11efc:	e35c0046 	cmp	ip, #70	@ 0x46
   11f00:	1a000013 	bne	11f54 <rpl_vasnprintf+0x1834>
                      double arg = a.arg[dp->arg_index].a.a_double;
   11f04:	ed990b02 	vldr	d0, [r9, #8]
                      if (!(isnand (arg) || arg + arg == arg))
   11f08:	eeb40b40 	vcmp.f64	d0, d0
   11f0c:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   11f10:	6a00000f 	bvs	11f54 <rpl_vasnprintf+0x1834>
   11f14:	ee307b00 	vadd.f64	d7, d0, d0
   11f18:	eeb40b47 	vcmp.f64	d0, d7
   11f1c:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   11f20:	0a00000b 	beq	11f54 <rpl_vasnprintf+0x1834>
   11f24:	e3a04010 	mov	r4, #16
   11f28:	e3a07006 	mov	r7, #6
                          int exponent = floorlog10 (arg < 0 ? -arg : arg);
   11f2c:	eeb50bc0 	vcmpe.f64	d0, #0.0
   11f30:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   11f34:	4eb10b40 	vnegmi.f64	d0, d0
   11f38:	ebfff4b8 	bl	f220 <floorlog10>
                          if (exponent >= 0 && tmp_length < exponent + precision)
   11f3c:	e3500000 	cmp	r0, #0
   11f40:	bafffcbc 	blt	11238 <rpl_vasnprintf+0xb18>
   11f44:	e0800007 	add	r0, r0, r7
   11f48:	e1540000 	cmp	r4, r0
   11f4c:	31a04000 	movcc	r4, r0
   11f50:	eafffcb8 	b	11238 <rpl_vasnprintf+0xb18>
   11f54:	e3a0401c 	mov	r4, #28
                    precision = 6;
   11f58:	e3a07006 	mov	r7, #6
   11f5c:	eafffcb7 	b	11240 <rpl_vasnprintf+0xb20>
                  wchar_t arg = (wchar_t) a.arg[dp->arg_index].a.a_wide_char;
   11f60:	e5991008 	ldr	r1, [r9, #8]
                      if (arg != 0)
   11f64:	e3510000 	cmp	r1, #0
   11f68:	0afffb72 	beq	10d38 <rpl_vasnprintf+0x618>
   11f6c:	e24b6e5a 	sub	r6, fp, #1440	@ 0x5a0
   11f70:	e24b9fba 	sub	r9, fp, #744	@ 0x2e8
   11f74:	e2466004 	sub	r6, r6, #4
   11f78:	e3a03000 	mov	r3, #0
   11f7c:	e1a02006 	mov	r2, r6
   11f80:	e1a00009 	mov	r0, r9
   11f84:	e50b35a4 	str	r3, [fp, #-1444]	@ 0xfffffa5c
   11f88:	e50b35a0 	str	r3, [fp, #-1440]	@ 0xfffffa60
   11f8c:	eb0012a0 	bl	16a14 <wcrtomb>
                          if (count < 0)
   11f90:	e2504000 	subs	r4, r0, #0
   11f94:	ba0004a5 	blt	13230 <rpl_vasnprintf+0x2b10>
   11f98:	e0983004 	adds	r3, r8, r4
   11f9c:	e1a07003 	mov	r7, r3
  return (sum >= size1 ? sum : SIZE_MAX);
   11fa0:	2a0007f0 	bcs	13f68 <rpl_vasnprintf+0x3848>
                          ENSURE_ALLOCATION (xsum (length, count));
   11fa4:	e15a0003 	cmp	sl, r3
   11fa8:	2a00000f 	bcs	11fec <rpl_vasnprintf+0x18cc>
   11fac:	e35a0000 	cmp	sl, #0
   11fb0:	0a000908 	beq	143d8 <rpl_vasnprintf+0x3cb8>
   11fb4:	bafffb0e 	blt	10bf4 <rpl_vasnprintf+0x4d4>
   11fb8:	e1a0a08a 	lsl	sl, sl, #1
   11fbc:	e15a0003 	cmp	sl, r3
   11fc0:	3a000907 	bcc	143e4 <rpl_vasnprintf+0x3cc4>
   11fc4:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
   11fc8:	e51b2a90 	ldr	r2, [fp, #-2704]	@ 0xfffff570
   11fcc:	e1530002 	cmp	r3, r2
   11fd0:	0a000970 	beq	14598 <rpl_vasnprintf+0x3e78>
   11fd4:	e51b0a88 	ldr	r0, [fp, #-2696]	@ 0xfffff578
   11fd8:	e1a0100a 	mov	r1, sl
   11fdc:	ebfff198 	bl	e644 <rpl_realloc>
   11fe0:	e3500000 	cmp	r0, #0
   11fe4:	0afffb02 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   11fe8:	e50b0a88 	str	r0, [fp, #-2696]	@ 0xfffff578
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   11fec:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
   11ff0:	e1a02004 	mov	r2, r4
   11ff4:	e1a01009 	mov	r1, r9
   11ff8:	e0830008 	add	r0, r3, r8
   11ffc:	eb00379f 	bl	1fe80 <memcpy>
                  if (w < width && (flags & FLAG_LEFT))
   12000:	eafffb2b 	b	10cb4 <rpl_vasnprintf+0x594>
                width = 0;
   12004:	e3a02000 	mov	r2, #0
   12008:	e50b2ab8 	str	r2, [fp, #-2744]	@ 0xfffff548
                has_width = 0;
   1200c:	e50b2ac8 	str	r2, [fp, #-2760]	@ 0xfffff538
   12010:	eafffb68 	b	10db8 <rpl_vasnprintf+0x698>
                precision = 6;
   12014:	e3a03006 	mov	r3, #6
   12018:	e50b3ac0 	str	r3, [fp, #-2752]	@ 0xfffff540
                has_precision = 0;
   1201c:	e3a03000 	mov	r3, #0
   12020:	e50b3abc 	str	r3, [fp, #-2748]	@ 0xfffff544
   12024:	eafffb75 	b	10e00 <rpl_vasnprintf+0x6e0>
                        while (p > pad_ptr)
   12028:	e1570003 	cmp	r7, r3
   1202c:	2a0007e0 	bcs	13fb4 <rpl_vasnprintf+0x3894>
   12030:	e1a01004 	mov	r1, r4
                          *--q = *--p;
   12034:	e5730001 	ldrb	r0, [r3, #-1]!
                        while (p > pad_ptr)
   12038:	e1570003 	cmp	r7, r3
                          *--q = *--p;
   1203c:	e5610001 	strb	r0, [r1, #-1]!
                        while (p > pad_ptr)
   12040:	1afffffb 	bne	12034 <rpl_vasnprintf+0x1914>
                          *p++ = '0';
   12044:	e1a00007 	mov	r0, r7
   12048:	e3a01030 	mov	r1, #48	@ 0x30
   1204c:	eb002197 	bl	1a6b0 <memset>
                count = p - tmp;
   12050:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   12054:	e0444003 	sub	r4, r4, r3
   12058:	eafffa92 	b	10aa8 <rpl_vasnprintf+0x388>
                        if (dp->conversion == 'A')
   1205c:	e5d53024 	ldrb	r3, [r5, #36]	@ 0x24
   12060:	e3530041 	cmp	r3, #65	@ 0x41
                            *p++ = 'N'; *p++ = 'A'; *p++ = 'N';
   12064:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   12068:	1306116e 	movwne	r1, #24942	@ 0x616e
   1206c:	13a0206e 	movne	r2, #110	@ 0x6e
   12070:	e2833003 	add	r3, r3, #3
                        if (dp->conversion == 'A')
   12074:	0304114e 	movweq	r1, #16718	@ 0x414e
   12078:	03a0204e 	moveq	r2, #78	@ 0x4e
                            *p++ = 'N'; *p++ = 'A'; *p++ = 'N';
   1207c:	e51b0a9c 	ldr	r0, [fp, #-2716]	@ 0xfffff564
                if (count < width)
   12080:	e3560003 	cmp	r6, #3
   12084:	e3a04003 	mov	r4, #3
                            *p++ = 'N'; *p++ = 'A'; *p++ = 'N';
   12088:	e1c010b0 	strh	r1, [r0]
   1208c:	e5c02002 	strb	r2, [r0, #2]
                if (count < width)
   12090:	9afffa87 	bls	10ab4 <rpl_vasnprintf+0x394>
   12094:	e3a07000 	mov	r7, #0
   12098:	eafffa6a 	b	10a48 <rpl_vasnprintf+0x328>
   1209c:	e1a07008 	mov	r7, r8
   120a0:	e51b5a88 	ldr	r5, [fp, #-2696]	@ 0xfffff578
   120a4:	e2976001 	adds	r6, r7, #1
   120a8:	e51b8ab4 	ldr	r8, [fp, #-2740]	@ 0xfffff54c
  size_t sum = size1 + size2;
   120ac:	e1a0900a 	mov	r9, sl
   120b0:	2a000bc3 	bcs	14fc4 <rpl_vasnprintf+0x48a4>
    ENSURE_ALLOCATION (xsum (length, 1));
   120b4:	e15a0006 	cmp	sl, r6
   120b8:	2a00000e 	bcs	120f8 <rpl_vasnprintf+0x19d8>
   120bc:	e35a0000 	cmp	sl, #0
   120c0:	0a00070a 	beq	13cf0 <rpl_vasnprintf+0x35d0>
   120c4:	bafffacb 	blt	10bf8 <rpl_vasnprintf+0x4d8>
   120c8:	e1a0908a 	lsl	r9, sl, #1
   120cc:	e1590006 	cmp	r9, r6
   120d0:	3a000709 	bcc	13cfc <rpl_vasnprintf+0x35dc>
   120d4:	e51b3a90 	ldr	r3, [fp, #-2704]	@ 0xfffff570
   120d8:	e1550003 	cmp	r5, r3
   120dc:	0a0007a9 	beq	13f88 <rpl_vasnprintf+0x3868>
   120e0:	e1a00005 	mov	r0, r5
   120e4:	e1a01009 	mov	r1, r9
   120e8:	ebfff155 	bl	e644 <rpl_realloc>
   120ec:	e3500000 	cmp	r0, #0
   120f0:	11a05000 	movne	r5, r0
   120f4:	0afffabf 	beq	10bf8 <rpl_vasnprintf+0x4d8>
    if (result != resultbuf && length + 1 < allocated)
   120f8:	e51b3a90 	ldr	r3, [fp, #-2704]	@ 0xfffff570
   120fc:	e1550003 	cmp	r5, r3
   12100:	11590006 	cmpne	r9, r6
    result[length] = '\0';
   12104:	e3a03000 	mov	r3, #0
   12108:	e7c53007 	strb	r3, [r5, r7]
    if (result != resultbuf && length + 1 < allocated)
   1210c:	8a0006d8 	bhi	13c74 <rpl_vasnprintf+0x3554>
    if (buf_malloced != NULL)
   12110:	e51b3aac 	ldr	r3, [fp, #-2732]	@ 0xfffff554
   12114:	e3530000 	cmp	r3, #0
   12118:	0a000001 	beq	12124 <rpl_vasnprintf+0x1a04>
      free (buf_malloced);
   1211c:	e1a00003 	mov	r0, r3
   12120:	ebffe0cc 	bl	a458 <rpl_free>
    CLEANUP ();
   12124:	e51b09a0 	ldr	r0, [fp, #-2464]	@ 0xfffff660
   12128:	e24b3e99 	sub	r3, fp, #2448	@ 0x990
   1212c:	e243300c 	sub	r3, r3, #12
   12130:	e2833008 	add	r3, r3, #8
   12134:	e1500003 	cmp	r0, r3
   12138:	0a000000 	beq	12140 <rpl_vasnprintf+0x1a20>
   1213c:	ebffe0c5 	bl	a458 <rpl_free>
   12140:	e51b0a18 	ldr	r0, [fp, #-2584]	@ 0xfffff5e8
   12144:	e24b3ea1 	sub	r3, fp, #2576	@ 0xa10
   12148:	e243300c 	sub	r3, r3, #12
   1214c:	e2833008 	add	r3, r3, #8
   12150:	e1500003 	cmp	r0, r3
   12154:	0a000000 	beq	1215c <rpl_vasnprintf+0x1a3c>
   12158:	ebffe0be 	bl	a458 <rpl_free>
    *lengthp = length;
   1215c:	e5887000 	str	r7, [r8]
    return result;
   12160:	eafffa90 	b	10ba8 <rpl_vasnprintf+0x488>
                    ENSURE_ALLOCATION (n);
   12164:	e37a0001 	cmn	sl, #1
   12168:	1afffaa1 	bne	10bf4 <rpl_vasnprintf+0x4d4>
   1216c:	eafffdc3 	b	11880 <rpl_vasnprintf+0x1160>
                if (tmp_length < width)
   12170:	e356001a 	cmp	r6, #26
                precision = 0;
   12174:	e3a04000 	mov	r4, #0
                if (tmp_length < width)
   12178:	21a03006 	movcs	r3, r6
   1217c:	33a0301a 	movcc	r3, #26
   12180:	e2833001 	add	r3, r3, #1
                if (tmp_length <= sizeof (tmpbuf) / sizeof (DCHAR_T))
   12184:	e3530faf 	cmp	r3, #700	@ 0x2bc
   12188:	e50b3aa4 	str	r3, [fp, #-2724]	@ 0xfffff55c
                has_precision = 0;
   1218c:	81a07004 	movhi	r7, r4
                if (tmp_length <= sizeof (tmpbuf) / sizeof (DCHAR_T))
   12190:	8afff9ff 	bhi	10994 <rpl_vasnprintf+0x274>
                  tmp = tmpbuf;
   12194:	e24b3e5a 	sub	r3, fp, #1440	@ 0x5a0
                has_precision = 0;
   12198:	e1a07004 	mov	r7, r4
                  tmp = tmpbuf;
   1219c:	e2433004 	sub	r3, r3, #4
   121a0:	e50b3a9c 	str	r3, [fp, #-2716]	@ 0xfffff564
   121a4:	eafffa02 	b	109b4 <rpl_vasnprintf+0x294>
                ENSURE_ALLOCATION (xsum (length,
   121a8:	e51b3aa4 	ldr	r3, [fp, #-2724]	@ 0xfffff55c
   121ac:	e353000c 	cmp	r3, #12
   121b0:	93a0a00c 	movls	sl, #12
   121b4:	8afffd4e 	bhi	116f4 <rpl_vasnprintf+0xfd4>
   121b8:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
   121bc:	e51b2a90 	ldr	r2, [fp, #-2704]	@ 0xfffff570
   121c0:	e1530002 	cmp	r3, r2
   121c4:	0a00013d 	beq	126c0 <rpl_vasnprintf+0x1fa0>
   121c8:	e51b0a88 	ldr	r0, [fp, #-2696]	@ 0xfffff578
   121cc:	e1a0100a 	mov	r1, sl
   121d0:	ebfff11b 	bl	e644 <rpl_realloc>
   121d4:	e2503000 	subs	r3, r0, #0
   121d8:	e50b3a9c 	str	r3, [fp, #-2716]	@ 0xfffff564
   121dc:	0afffa84 	beq	10bf4 <rpl_vasnprintf+0x4d4>
                *(TCHAR_T *) (result + length) = '\0';
   121e0:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   121e4:	e3a02000 	mov	r2, #0
   121e8:	e04a6008 	sub	r6, sl, r8
   121ec:	e7c32008 	strb	r2, [r3, r8]
                orig_errno = errno;
   121f0:	eb002587 	bl	1b814 <__errno>
   121f4:	e5903000 	ldr	r3, [r0]
   121f8:	e50b3acc 	str	r3, [fp, #-2764]	@ 0xfffff534
   121fc:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
   12200:	e2433001 	sub	r3, r3, #1
   12204:	e50b3a88 	str	r3, [fp, #-2696]	@ 0xfffff578
                    int count = -1;
   12208:	e3760106 	cmn	r6, #-2147483647	@ 0x80000001
   1220c:	e3e03000 	mvn	r3, #0
   12210:	e50b3a80 	str	r3, [fp, #-2688]	@ 0xfffff580
                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)
   12214:	31a04006 	movcc	r4, r6
   12218:	23e04102 	mvncs	r4, #-2147483648	@ 0x80000000
                    errno = 0;
   1221c:	eb00257c 	bl	1b814 <__errno>
   12220:	e3a03000 	mov	r3, #0
   12224:	e5803000 	str	r3, [r0]
                    switch (type)
   12228:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
   1222c:	e3530020 	cmp	r3, #32
   12230:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   12234:	ea000bb7 	b	15118 <rpl_vasnprintf+0x49f8>
   12238:	00012518 	.word	0x00012518
   1223c:	0001253c 	.word	0x0001253c
   12240:	000124b0 	.word	0x000124b0
   12244:	000124f4 	.word	0x000124f4
   12248:	000122bc 	.word	0x000122bc
   1224c:	000122bc 	.word	0x000122bc
   12250:	000122bc 	.word	0x000122bc
   12254:	000122bc 	.word	0x000122bc
   12258:	000123bc 	.word	0x000123bc
   1225c:	000123bc 	.word	0x000123bc
   12260:	00012518 	.word	0x00012518
   12264:	0001253c 	.word	0x0001253c
   12268:	000124b0 	.word	0x000124b0
   1226c:	000124f4 	.word	0x000124f4
   12270:	000122bc 	.word	0x000122bc
   12274:	000122bc 	.word	0x000122bc
   12278:	000123bc 	.word	0x000123bc
   1227c:	000123bc 	.word	0x000123bc
   12280:	000122bc 	.word	0x000122bc
   12284:	000122bc 	.word	0x000122bc
   12288:	000122bc 	.word	0x000122bc
   1228c:	000122bc 	.word	0x000122bc
   12290:	000122bc 	.word	0x000122bc
   12294:	000122bc 	.word	0x000122bc
   12298:	000123bc 	.word	0x000123bc
   1229c:	000123bc 	.word	0x000123bc
   122a0:	00012560 	.word	0x00012560
   122a4:	00012560 	.word	0x00012560
   122a8:	000122bc 	.word	0x000122bc
   122ac:	000122bc 	.word	0x000122bc
   122b0:	000122bc 	.word	0x000122bc
   122b4:	000122bc 	.word	0x000122bc
   122b8:	000122bc 	.word	0x000122bc
                          void *arg = a.arg[dp->arg_index].a.a_pointer;
   122bc:	e5952028 	ldr	r2, [r5, #40]	@ 0x28
   122c0:	e3570001 	cmp	r7, #1
   122c4:	e51b3a18 	ldr	r3, [fp, #-2584]	@ 0xfffff5e8
   122c8:	e0833202 	add	r3, r3, r2, lsl #4
                          SNPRINTF_BUF (arg);
   122cc:	e51b2a9c 	ldr	r2, [fp, #-2716]	@ 0xfffff564
                          void *arg = a.arg[dp->arg_index].a.a_pointer;
   122d0:	e5933008 	ldr	r3, [r3, #8]
                          SNPRINTF_BUF (arg);
   122d4:	e0829008 	add	r9, r2, r8
   122d8:	0a00007c 	beq	124d0 <rpl_vasnprintf+0x1db0>
   122dc:	e3570002 	cmp	r7, #2
   122e0:	0a0000b5 	beq	125bc <rpl_vasnprintf+0x1e9c>
                          SNPRINTF_BUF (arg);
   122e4:	e24b2d2a 	sub	r2, fp, #2688	@ 0xa80
   122e8:	e1a01004 	mov	r1, r4
   122ec:	e58d2000 	str	r2, [sp]
   122f0:	e1a00009 	mov	r0, r9
   122f4:	e51b2aa0 	ldr	r2, [fp, #-2720]	@ 0xfffff560
   122f8:	eb001c95 	bl	19554 <snprintf>
                    if (count >= 0)
   122fc:	e51b2a80 	ldr	r2, [fp, #-2688]	@ 0xfffff580
   12300:	e3520000 	cmp	r2, #0
   12304:	ba000040 	blt	1240c <rpl_vasnprintf+0x1cec>
                        if ((unsigned int) count < maxlen
   12308:	e1520004 	cmp	r2, r4
   1230c:	e1a03002 	mov	r3, r2
   12310:	2a000002 	bcs	12320 <rpl_vasnprintf+0x1c00>
                            && ((TCHAR_T *) (result + length)) [count] != '\0')
   12314:	e7d91002 	ldrb	r1, [r9, r2]
   12318:	e3510000 	cmp	r1, #0
   1231c:	1a000b7d 	bne	15118 <rpl_vasnprintf+0x49f8>
                        if (retcount > count)
   12320:	e1520000 	cmp	r2, r0
   12324:	aa000001 	bge	12330 <rpl_vasnprintf+0x1c10>
                    if ((unsigned int) count + 1 >= maxlen)
   12328:	e1a03000 	mov	r3, r0
                                count = retcount;
   1232c:	e50b0a80 	str	r0, [fp, #-2688]	@ 0xfffff580
                    if ((unsigned int) count + 1 >= maxlen)
   12330:	e2832001 	add	r2, r3, #1
   12334:	e1520004 	cmp	r2, r4
   12338:	3a00050a 	bcc	13768 <rpl_vasnprintf+0x3048>
                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)
   1233c:	e376010a 	cmn	r6, #-2147483646	@ 0x80000002
   12340:	8a00051c 	bhi	137b8 <rpl_vasnprintf+0x3098>
   12344:	e51b2aa4 	ldr	r2, [fp, #-2724]	@ 0xfffff55c
   12348:	e0823003 	add	r3, r2, r3
  return (sum >= size1 ? sum : SIZE_MAX);
   1234c:	e1580003 	cmp	r8, r3
   12350:	8a000094 	bhi	125a8 <rpl_vasnprintf+0x1e88>
                              xmax (xsum (length,
   12354:	e35a0000 	cmp	sl, #0
   12358:	ba000094 	blt	125b0 <rpl_vasnprintf+0x1e90>
   1235c:	e1a0208a 	lsl	r2, sl, #1
XSIZE_INLINE size_t ATTRIBUTE_PURE
xmax (size_t size1, size_t size2)
{
  /* No explicit check is needed here, because for any n:
     max (SIZE_MAX, n) == SIZE_MAX and max (n, SIZE_MAX) == SIZE_MAX.  */
  return (size1 >= size2 ? size1 : size2);
   12360:	e1520003 	cmp	r2, r3
   12364:	21a03002 	movcs	r3, r2
                            ENSURE_ALLOCATION (n);
   12368:	e153000a 	cmp	r3, sl
   1236c:	9affffa5 	bls	12208 <rpl_vasnprintf+0x1ae8>
   12370:	e35a0000 	cmp	sl, #0
   12374:	1a000b3a 	bne	15064 <rpl_vasnprintf+0x4944>
   12378:	e353000c 	cmp	r3, #12
   1237c:	21a0a003 	movcs	sl, r3
   12380:	33a0a00c 	movcc	sl, #12
   12384:	e37a0001 	cmn	sl, #1
   12388:	0afffa1b 	beq	10bfc <rpl_vasnprintf+0x4dc>
   1238c:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   12390:	e51b2a90 	ldr	r2, [fp, #-2704]	@ 0xfffff570
   12394:	e1530002 	cmp	r3, r2
   12398:	0a000092 	beq	125e8 <rpl_vasnprintf+0x1ec8>
   1239c:	e51b0a9c 	ldr	r0, [fp, #-2716]	@ 0xfffff564
   123a0:	e1a0100a 	mov	r1, sl
   123a4:	ebfff0a6 	bl	e644 <rpl_realloc>
   123a8:	e3500000 	cmp	r0, #0
   123ac:	0afffa12 	beq	10bfc <rpl_vasnprintf+0x4dc>
   123b0:	e04a6008 	sub	r6, sl, r8
   123b4:	e50b0a9c 	str	r0, [fp, #-2716]	@ 0xfffff564
   123b8:	eaffff92 	b	12208 <rpl_vasnprintf+0x1ae8>
                          uint_fast64_t arg = a.arg[dp->arg_index].a.a_uint_fast64_t;
   123bc:	e5952028 	ldr	r2, [r5, #40]	@ 0x28
   123c0:	e3570001 	cmp	r7, #1
   123c4:	e51b3a18 	ldr	r3, [fp, #-2584]	@ 0xfffff5e8
   123c8:	e0833202 	add	r3, r3, r2, lsl #4
                          SNPRINTF_BUF (arg);
   123cc:	e51b2a9c 	ldr	r2, [fp, #-2716]	@ 0xfffff564
   123d0:	e0829008 	add	r9, r2, r8
                          uint_fast64_t arg = a.arg[dp->arg_index].a.a_uint_fast64_t;
   123d4:	e1c320d8 	ldrd	r2, [r3, #8]
                          SNPRINTF_BUF (arg);
   123d8:	0a00009d 	beq	12654 <rpl_vasnprintf+0x1f34>
   123dc:	e3570002 	cmp	r7, #2
   123e0:	0a000090 	beq	12628 <rpl_vasnprintf+0x1f08>
   123e4:	e1cd20f0 	strd	r2, [sp]
   123e8:	e24b3d2a 	sub	r3, fp, #2688	@ 0xa80
   123ec:	e58d3008 	str	r3, [sp, #8]
   123f0:	e1a01004 	mov	r1, r4
   123f4:	e51b2aa0 	ldr	r2, [fp, #-2720]	@ 0xfffff560
   123f8:	e1a00009 	mov	r0, r9
   123fc:	eb001c54 	bl	19554 <snprintf>
                    if (count >= 0)
   12400:	e51b2a80 	ldr	r2, [fp, #-2688]	@ 0xfffff580
   12404:	e3520000 	cmp	r2, #0
   12408:	aaffffbe 	bge	12308 <rpl_vasnprintf+0x1be8>
                        if (fbp[1] != '\0')
   1240c:	e51b3aa8 	ldr	r3, [fp, #-2728]	@ 0xfffff558
   12410:	e5d33001 	ldrb	r3, [r3, #1]
   12414:	e3530000 	cmp	r3, #0
   12418:	1a00007e 	bne	12618 <rpl_vasnprintf+0x1ef8>
                            if (retcount < 0)
   1241c:	e3500000 	cmp	r0, #0
   12420:	aaffffc0 	bge	12328 <rpl_vasnprintf+0x1c08>
                                  MAX_ROOM_NEEDED (&a, dp->arg_index,
   12424:	e51b3ab0 	ldr	r3, [fp, #-2736]	@ 0xfffff550
   12428:	e24b0ea1 	sub	r0, fp, #2576	@ 0xa10
   1242c:	e5d52024 	ldrb	r2, [r5, #36]	@ 0x24
   12430:	e240000c 	sub	r0, r0, #12
   12434:	e5951028 	ldr	r1, [r5, #40]	@ 0x28
   12438:	e58d300c 	str	r3, [sp, #12]
   1243c:	e51b3ac0 	ldr	r3, [fp, #-2752]	@ 0xfffff540
   12440:	e58d3008 	str	r3, [sp, #8]
   12444:	e51b3abc 	ldr	r3, [fp, #-2748]	@ 0xfffff544
   12448:	e58d3004 	str	r3, [sp, #4]
   1244c:	e51b3ab8 	ldr	r3, [fp, #-2744]	@ 0xfffff548
   12450:	e58d3000 	str	r3, [sp]
   12454:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
   12458:	ebfff7e3 	bl	103ec <max_room_needed.isra.0>
                                if (maxlen < tmp_length)
   1245c:	e1540000 	cmp	r4, r0
   12460:	2a0000a1 	bcs	126ec <rpl_vasnprintf+0x1fcc>
  return (sum >= size1 ? sum : SIZE_MAX);
   12464:	e0983000 	adds	r3, r8, r0
   12468:	23e03000 	mvncs	r3, #0
                                      xsum (xtimes (allocated, 2), 12);
   1246c:	e35a0000 	cmp	sl, #0
   12470:	ba00004e 	blt	125b0 <rpl_vasnprintf+0x1e90>
   12474:	e1a0108a 	lsl	r1, sl, #1
  size_t sum = size1 + size2;
   12478:	e291200c 	adds	r2, r1, #12
   1247c:	2afff9de 	bcs	10bfc <rpl_vasnprintf+0x4dc>
                                    if (bigger_need < bigger_need2)
   12480:	e1520003 	cmp	r2, r3
   12484:	31a02003 	movcc	r2, r3
                                    ENSURE_ALLOCATION (bigger_need);
   12488:	e152000a 	cmp	r2, sl
   1248c:	9affff5d 	bls	12208 <rpl_vasnprintf+0x1ae8>
   12490:	e35a0000 	cmp	sl, #0
   12494:	03a0100c 	moveq	r1, #12
   12498:	e1520001 	cmp	r2, r1
   1249c:	21a0a002 	movcs	sl, r2
   124a0:	31a0a001 	movcc	sl, r1
   124a4:	e37a0001 	cmn	sl, #1
   124a8:	1affffb7 	bne	1238c <rpl_vasnprintf+0x1c6c>
   124ac:	eafff9d2 	b	10bfc <rpl_vasnprintf+0x4dc>
                          int16_t arg = a.arg[dp->arg_index].a.a_int16_t;
   124b0:	e5952028 	ldr	r2, [r5, #40]	@ 0x28
   124b4:	e3570001 	cmp	r7, #1
   124b8:	e51b3a18 	ldr	r3, [fp, #-2584]	@ 0xfffff5e8
   124bc:	e0833202 	add	r3, r3, r2, lsl #4
                          SNPRINTF_BUF (arg);
   124c0:	e51b2a9c 	ldr	r2, [fp, #-2716]	@ 0xfffff564
                          int16_t arg = a.arg[dp->arg_index].a.a_int16_t;
   124c4:	e1d330f8 	ldrsh	r3, [r3, #8]
                          SNPRINTF_BUF (arg);
   124c8:	e0829008 	add	r9, r2, r8
   124cc:	1affff82 	bne	122dc <rpl_vasnprintf+0x1bbc>
                          SNPRINTF_BUF (arg);
   124d0:	e58d3000 	str	r3, [sp]
   124d4:	e24b3d2a 	sub	r3, fp, #2688	@ 0xa80
   124d8:	e58d3004 	str	r3, [sp, #4]
   124dc:	e1a01004 	mov	r1, r4
   124e0:	e51b3a64 	ldr	r3, [fp, #-2660]	@ 0xfffff59c
   124e4:	e1a00009 	mov	r0, r9
   124e8:	e51b2aa0 	ldr	r2, [fp, #-2720]	@ 0xfffff560
   124ec:	eb001c18 	bl	19554 <snprintf>
   124f0:	eaffff81 	b	122fc <rpl_vasnprintf+0x1bdc>
                          uint16_t arg = a.arg[dp->arg_index].a.a_uint16_t;
   124f4:	e5952028 	ldr	r2, [r5, #40]	@ 0x28
   124f8:	e3570001 	cmp	r7, #1
   124fc:	e51b3a18 	ldr	r3, [fp, #-2584]	@ 0xfffff5e8
   12500:	e0833202 	add	r3, r3, r2, lsl #4
                          SNPRINTF_BUF (arg);
   12504:	e51b2a9c 	ldr	r2, [fp, #-2716]	@ 0xfffff564
                          SNPRINTF_BUF (arg);
   12508:	e1d330b8 	ldrh	r3, [r3, #8]
                          SNPRINTF_BUF (arg);
   1250c:	e0829008 	add	r9, r2, r8
   12510:	1affff71 	bne	122dc <rpl_vasnprintf+0x1bbc>
   12514:	eaffffed 	b	124d0 <rpl_vasnprintf+0x1db0>
                          int8_t arg = a.arg[dp->arg_index].a.a_int8_t;
   12518:	e5952028 	ldr	r2, [r5, #40]	@ 0x28
   1251c:	e3570001 	cmp	r7, #1
   12520:	e51b3a18 	ldr	r3, [fp, #-2584]	@ 0xfffff5e8
   12524:	e0833202 	add	r3, r3, r2, lsl #4
                          SNPRINTF_BUF (arg);
   12528:	e51b2a9c 	ldr	r2, [fp, #-2716]	@ 0xfffff564
                          int8_t arg = a.arg[dp->arg_index].a.a_int8_t;
   1252c:	e1d330d8 	ldrsb	r3, [r3, #8]
                          SNPRINTF_BUF (arg);
   12530:	e0829008 	add	r9, r2, r8
   12534:	1affff68 	bne	122dc <rpl_vasnprintf+0x1bbc>
   12538:	eaffffe4 	b	124d0 <rpl_vasnprintf+0x1db0>
                          uint8_t arg = a.arg[dp->arg_index].a.a_uint8_t;
   1253c:	e5952028 	ldr	r2, [r5, #40]	@ 0x28
   12540:	e3570001 	cmp	r7, #1
   12544:	e51b3a18 	ldr	r3, [fp, #-2584]	@ 0xfffff5e8
   12548:	e0833202 	add	r3, r3, r2, lsl #4
                          SNPRINTF_BUF (arg);
   1254c:	e51b2a9c 	ldr	r2, [fp, #-2716]	@ 0xfffff564
                          SNPRINTF_BUF (arg);
   12550:	e5d33008 	ldrb	r3, [r3, #8]
                          SNPRINTF_BUF (arg);
   12554:	e0829008 	add	r9, r2, r8
   12558:	1affff5f 	bne	122dc <rpl_vasnprintf+0x1bbc>
   1255c:	eaffffdb 	b	124d0 <rpl_vasnprintf+0x1db0>
                          long double arg = a.arg[dp->arg_index].a.a_longdouble;
   12560:	e5952028 	ldr	r2, [r5, #40]	@ 0x28
   12564:	e3570001 	cmp	r7, #1
   12568:	e51b3a18 	ldr	r3, [fp, #-2584]	@ 0xfffff5e8
   1256c:	e0833202 	add	r3, r3, r2, lsl #4
                          SNPRINTF_BUF (arg);
   12570:	e51b2a9c 	ldr	r2, [fp, #-2716]	@ 0xfffff564
   12574:	e0829008 	add	r9, r2, r8
                          long double arg = a.arg[dp->arg_index].a.a_longdouble;
   12578:	e1c320d8 	ldrd	r2, [r3, #8]
                          SNPRINTF_BUF (arg);
   1257c:	0a00040b 	beq	135b0 <rpl_vasnprintf+0x2e90>
   12580:	e3570002 	cmp	r7, #2
   12584:	0a000130 	beq	12a4c <rpl_vasnprintf+0x232c>
   12588:	e1cd20f0 	strd	r2, [sp]
   1258c:	e24b3d2a 	sub	r3, fp, #2688	@ 0xa80
   12590:	e58d3008 	str	r3, [sp, #8]
   12594:	e1a01004 	mov	r1, r4
   12598:	e51b2aa0 	ldr	r2, [fp, #-2720]	@ 0xfffff560
   1259c:	e1a00009 	mov	r0, r9
   125a0:	eb001beb 	bl	19554 <snprintf>
   125a4:	eaffff54 	b	122fc <rpl_vasnprintf+0x1bdc>
                              xmax (xsum (length,
   125a8:	e35a0000 	cmp	sl, #0
   125ac:	aafff992 	bge	10bfc <rpl_vasnprintf+0x4dc>
                            ENSURE_ALLOCATION (n);
   125b0:	e37a0001 	cmn	sl, #1
   125b4:	1afff990 	bne	10bfc <rpl_vasnprintf+0x4dc>
   125b8:	eaffff12 	b	12208 <rpl_vasnprintf+0x1ae8>
                          SNPRINTF_BUF (arg);
   125bc:	e58d3004 	str	r3, [sp, #4]
   125c0:	e1a01004 	mov	r1, r4
   125c4:	e51b3a60 	ldr	r3, [fp, #-2656]	@ 0xfffff5a0
   125c8:	e1a00009 	mov	r0, r9
   125cc:	e58d3000 	str	r3, [sp]
   125d0:	e24b3d2a 	sub	r3, fp, #2688	@ 0xa80
   125d4:	e58d3008 	str	r3, [sp, #8]
   125d8:	e51b3a64 	ldr	r3, [fp, #-2660]	@ 0xfffff59c
   125dc:	e51b2aa0 	ldr	r2, [fp, #-2720]	@ 0xfffff560
   125e0:	eb001bdb 	bl	19554 <snprintf>
   125e4:	eaffff44 	b	122fc <rpl_vasnprintf+0x1bdc>
                            ENSURE_ALLOCATION (n);
   125e8:	e1a0000a 	mov	r0, sl
   125ec:	ebfff008 	bl	e614 <rpl_malloc>
   125f0:	e2504000 	subs	r4, r0, #0
   125f4:	0afff980 	beq	10bfc <rpl_vasnprintf+0x4dc>
   125f8:	e3580000 	cmp	r8, #0
   125fc:	0a000002 	beq	1260c <rpl_vasnprintf+0x1eec>
   12600:	e51b1a90 	ldr	r1, [fp, #-2704]	@ 0xfffff570
   12604:	e1a02008 	mov	r2, r8
   12608:	eb00361c 	bl	1fe80 <memcpy>
   1260c:	e04a6008 	sub	r6, sl, r8
                                    ENSURE_ALLOCATION (bigger_need);
   12610:	e50b4a9c 	str	r4, [fp, #-2716]	@ 0xfffff564
                  {
   12614:	eafffefb 	b	12208 <rpl_vasnprintf+0x1ae8>
                            fbp[1] = '\0';
   12618:	e51b2aa8 	ldr	r2, [fp, #-2728]	@ 0xfffff558
   1261c:	e3a03000 	mov	r3, #0
   12620:	e5c23001 	strb	r3, [r2, #1]
                            continue;
   12624:	eafffef7 	b	12208 <rpl_vasnprintf+0x1ae8>
                          SNPRINTF_BUF (arg);
   12628:	e1cd20f8 	strd	r2, [sp, #8]
   1262c:	e1a01004 	mov	r1, r4
   12630:	e51b3a60 	ldr	r3, [fp, #-2656]	@ 0xfffff5a0
   12634:	e1a00009 	mov	r0, r9
   12638:	e58d3000 	str	r3, [sp]
   1263c:	e24b3d2a 	sub	r3, fp, #2688	@ 0xa80
   12640:	e58d3010 	str	r3, [sp, #16]
   12644:	e51b3a64 	ldr	r3, [fp, #-2660]	@ 0xfffff59c
   12648:	e51b2aa0 	ldr	r2, [fp, #-2720]	@ 0xfffff560
   1264c:	eb001bc0 	bl	19554 <snprintf>
   12650:	eaffff29 	b	122fc <rpl_vasnprintf+0x1bdc>
   12654:	e1cd20f0 	strd	r2, [sp]
   12658:	e24b3d2a 	sub	r3, fp, #2688	@ 0xa80
   1265c:	e58d3008 	str	r3, [sp, #8]
   12660:	e1a01004 	mov	r1, r4
   12664:	e51b3a64 	ldr	r3, [fp, #-2660]	@ 0xfffff59c
   12668:	e1a00009 	mov	r0, r9
   1266c:	e51b2aa0 	ldr	r2, [fp, #-2720]	@ 0xfffff560
   12670:	eb001bb7 	bl	19554 <snprintf>
   12674:	eaffff20 	b	122fc <rpl_vasnprintf+0x1bdc>
                    ENSURE_ALLOCATION (n);
   12678:	e37a0001 	cmn	sl, #1
   1267c:	1afff95c 	bne	10bf4 <rpl_vasnprintf+0x4d4>
   12680:	eafff929 	b	10b2c <rpl_vasnprintf+0x40c>
                switch (type)
   12684:	e50b3aa8 	str	r3, [fp, #-2728]	@ 0xfffff558
   12688:	eafffbe7 	b	1162c <rpl_vasnprintf+0xf0c>
                        else if (flags & FLAG_SHOWSIGN)
   1268c:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
   12690:	e3130004 	tst	r3, #4
   12694:	0a000109 	beq	12ac0 <rpl_vasnprintf+0x23a0>
                          *p++ = '+';
   12698:	e51b9a9c 	ldr	r9, [fp, #-2716]	@ 0xfffff564
   1269c:	e3a0302b 	mov	r3, #43	@ 0x2b
   126a0:	e4c93001 	strb	r3, [r9], #1
   126a4:	eafffd90 	b	11cec <rpl_vasnprintf+0x15cc>
                        else if (flags & FLAG_SPACE)
   126a8:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
                          *p++ = ' ';
   126ac:	e51b9a9c 	ldr	r9, [fp, #-2716]	@ 0xfffff564
                        else if (flags & FLAG_SPACE)
   126b0:	e3130008 	tst	r3, #8
                          *p++ = ' ';
   126b4:	13a03020 	movne	r3, #32
   126b8:	14c93001 	strbne	r3, [r9], #1
   126bc:	eafff8cb 	b	109f0 <rpl_vasnprintf+0x2d0>
                ENSURE_ALLOCATION (xsum (length,
   126c0:	e1a0000a 	mov	r0, sl
   126c4:	ebffefd2 	bl	e614 <rpl_malloc>
   126c8:	e2503000 	subs	r3, r0, #0
   126cc:	e50b3a9c 	str	r3, [fp, #-2716]	@ 0xfffff564
   126d0:	0afff947 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   126d4:	e3580000 	cmp	r8, #0
   126d8:	0afffec0 	beq	121e0 <rpl_vasnprintf+0x1ac0>
   126dc:	e51b1a90 	ldr	r1, [fp, #-2704]	@ 0xfffff570
   126e0:	e1a02008 	mov	r2, r8
   126e4:	eb0035e5 	bl	1fe80 <memcpy>
   126e8:	eafffebc 	b	121e0 <rpl_vasnprintf+0x1ac0>
                    if (count < 0)
   126ec:	e51b2a80 	ldr	r2, [fp, #-2688]	@ 0xfffff580
   126f0:	e3520000 	cmp	r2, #0
   126f4:	ba0000f7 	blt	12ad8 <rpl_vasnprintf+0x23b8>
                    if ((unsigned int) count + 1 >= maxlen)
   126f8:	e1a03002 	mov	r3, r2
   126fc:	eaffff0b 	b	12330 <rpl_vasnprintf+0x1c10>
                    if (isnanl (arg))
   12700:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   12704:	6a000144 	bvs	12c1c <rpl_vasnprintf+0x24fc>
                        if (signbit (arg)) /* arg < 0.0L or negative zero */
   12708:	eeb00b48 	vmov.f64	d0, d8
   1270c:	eb000a99 	bl	15178 <gl_signbitl>
   12710:	e3500000 	cmp	r0, #0
   12714:	0a000450 	beq	1385c <rpl_vasnprintf+0x313c>
                          *p++ = '-';
   12718:	e51b9a9c 	ldr	r9, [fp, #-2716]	@ 0xfffff564
   1271c:	e3a0302d 	mov	r3, #45	@ 0x2d
                            arg = -arg;
   12720:	eeb18b48 	vneg.f64	d8, d8
                          *p++ = '-';
   12724:	e4c93001 	strb	r3, [r9], #1
                        if (arg > 0.0L && arg + arg == arg)
   12728:	eeb58bc0 	vcmpe.f64	d8, #0.0
   1272c:	eef1fa10 	vmrs	APSR_nzcv, fpscr
                            if (dp->conversion >= 'A' && dp->conversion <= 'Z')
   12730:	e5d53024 	ldrb	r3, [r5, #36]	@ 0x24
                        if (arg > 0.0L && arg + arg == arg)
   12734:	da000500 	ble	13b3c <rpl_vasnprintf+0x341c>
   12738:	ee387b08 	vadd.f64	d7, d8, d8
   1273c:	eeb47b48 	vcmp.f64	d7, d8
   12740:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   12744:	0a00030a 	beq	13374 <rpl_vasnprintf+0x2c54>
                            if (dp->conversion == 'f' || dp->conversion == 'F')
   12748:	e2433045 	sub	r3, r3, #69	@ 0x45
   1274c:	e3530022 	cmp	r3, #34	@ 0x22
   12750:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   12754:	ea000a6f 	b	15118 <rpl_vasnprintf+0x49f8>
   12758:	00013024 	.word	0x00013024
   1275c:	00012fcc 	.word	0x00012fcc
   12760:	000130b8 	.word	0x000130b8
   12764:	00015118 	.word	0x00015118
   12768:	00015118 	.word	0x00015118
   1276c:	00015118 	.word	0x00015118
   12770:	00015118 	.word	0x00015118
   12774:	00015118 	.word	0x00015118
   12778:	00015118 	.word	0x00015118
   1277c:	00015118 	.word	0x00015118
   12780:	00015118 	.word	0x00015118
   12784:	00015118 	.word	0x00015118
   12788:	00015118 	.word	0x00015118
   1278c:	00015118 	.word	0x00015118
   12790:	00015118 	.word	0x00015118
   12794:	00015118 	.word	0x00015118
   12798:	00015118 	.word	0x00015118
   1279c:	00015118 	.word	0x00015118
   127a0:	00015118 	.word	0x00015118
   127a4:	00015118 	.word	0x00015118
   127a8:	00015118 	.word	0x00015118
   127ac:	00015118 	.word	0x00015118
   127b0:	00015118 	.word	0x00015118
   127b4:	00015118 	.word	0x00015118
   127b8:	00015118 	.word	0x00015118
   127bc:	00015118 	.word	0x00015118
   127c0:	00015118 	.word	0x00015118
   127c4:	00015118 	.word	0x00015118
   127c8:	00015118 	.word	0x00015118
   127cc:	00015118 	.word	0x00015118
   127d0:	00015118 	.word	0x00015118
   127d4:	00015118 	.word	0x00015118
   127d8:	00013024 	.word	0x00013024
   127dc:	00012fcc 	.word	0x00012fcc
   127e0:	000130b8 	.word	0x000130b8
                  tmp = tmpbuf;
   127e4:	e24b3fba 	sub	r3, fp, #744	@ 0x2e8
   127e8:	e50b3a9c 	str	r3, [fp, #-2716]	@ 0xfffff564
   127ec:	eafffaa8 	b	11294 <rpl_vasnprintf+0xb74>
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   127f0:	e309c999 	movw	ip, #39321	@ 0x9999
                width = 0;
   127f4:	e3a04000 	mov	r4, #0
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   127f8:	e341c999 	movt	ip, #6553	@ 0x1999
                width = 0;
   127fc:	e1a00004 	mov	r0, r4
   12800:	ea000001 	b	1280c <rpl_vasnprintf+0x20ec>
                        while (digitp != dp->width_end);
   12804:	e1520001 	cmp	r2, r1
   12808:	0a000359 	beq	13574 <rpl_vasnprintf+0x2e54>
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   1280c:	e150000c 	cmp	r0, ip
   12810:	8a000007 	bhi	12834 <rpl_vasnprintf+0x2114>
   12814:	e0800100 	add	r0, r0, r0, lsl #2
   12818:	e1a0e080 	lsl	lr, r0, #1
   1281c:	e4d20001 	ldrb	r0, [r2], #1
   12820:	e2400030 	sub	r0, r0, #48	@ 0x30
   12824:	e090000e 	adds	r0, r0, lr
  return (sum >= size1 ? sum : SIZE_MAX);
   12828:	3afffff5 	bcc	12804 <rpl_vasnprintf+0x20e4>
                        while (digitp != dp->width_end);
   1282c:	e1520001 	cmp	r2, r1
   12830:	0a000509 	beq	13c5c <rpl_vasnprintf+0x353c>
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   12834:	e3e0e000 	mvn	lr, #0
   12838:	eafffff7 	b	1281c <rpl_vasnprintf+0x20fc>
                        const FCHAR_T *digitp = dp->precision_start + 1;
   1283c:	e2803001 	add	r3, r0, #1
                        while (digitp != dp->precision_end)
   12840:	e1520003 	cmp	r2, r3
   12844:	0a00014c 	beq	12d7c <rpl_vasnprintf+0x265c>
                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');
   12848:	e3091999 	movw	r1, #39321	@ 0x9999
                        precision = 0;
   1284c:	e3a06000 	mov	r6, #0
                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');
   12850:	e3411999 	movt	r1, #6553	@ 0x1999
                        precision = 0;
   12854:	e1a00006 	mov	r0, r6
   12858:	ea000001 	b	12864 <rpl_vasnprintf+0x2144>
                        while (digitp != dp->precision_end)
   1285c:	e1520003 	cmp	r2, r3
   12860:	0afff8d4 	beq	10bb8 <rpl_vasnprintf+0x498>
                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');
   12864:	e1500001 	cmp	r0, r1
   12868:	8a000007 	bhi	1288c <rpl_vasnprintf+0x216c>
   1286c:	e0800100 	add	r0, r0, r0, lsl #2
   12870:	e1a00080 	lsl	r0, r0, #1
   12874:	e4d3c001 	ldrb	ip, [r3], #1
   12878:	e24cc030 	sub	ip, ip, #48	@ 0x30
   1287c:	e090000c 	adds	r0, r0, ip
   12880:	3afffff5 	bcc	1285c <rpl_vasnprintf+0x213c>
                        while (digitp != dp->precision_end)
   12884:	e1520003 	cmp	r2, r3
   12888:	0afff8d9 	beq	10bf4 <rpl_vasnprintf+0x4d4>
                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');
   1288c:	e3e00000 	mvn	r0, #0
   12890:	eafffff7 	b	12874 <rpl_vasnprintf+0x2154>
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   12894:	e3090999 	movw	r0, #39321	@ 0x9999
                width = 0;
   12898:	e3a06000 	mov	r6, #0
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   1289c:	e3410999 	movt	r0, #6553	@ 0x1999
                width = 0;
   128a0:	e1a0c006 	mov	ip, r6
   128a4:	ea000001 	b	128b0 <rpl_vasnprintf+0x2190>
                        while (digitp != dp->width_end);
   128a8:	e1520001 	cmp	r2, r1
   128ac:	0afffc13 	beq	11900 <rpl_vasnprintf+0x11e0>
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   128b0:	e15c0000 	cmp	ip, r0
   128b4:	8a000007 	bhi	128d8 <rpl_vasnprintf+0x21b8>
   128b8:	e08cc10c 	add	ip, ip, ip, lsl #2
   128bc:	e1a0c08c 	lsl	ip, ip, #1
   128c0:	e4d2e001 	ldrb	lr, [r2], #1
   128c4:	e24ee030 	sub	lr, lr, #48	@ 0x30
   128c8:	e09cc00e 	adds	ip, ip, lr
   128cc:	3afffff5 	bcc	128a8 <rpl_vasnprintf+0x2188>
                        while (digitp != dp->width_end);
   128d0:	e1520001 	cmp	r2, r1
   128d4:	0a0004e4 	beq	13c6c <rpl_vasnprintf+0x354c>
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   128d8:	e3e0c000 	mvn	ip, #0
   128dc:	eafffff7 	b	128c0 <rpl_vasnprintf+0x21a0>
                        const FCHAR_T *digitp = dp->precision_start + 1;
   128e0:	e2822001 	add	r2, r2, #1
                        while (digitp != dp->precision_end)
   128e4:	e1520001 	cmp	r2, r1
   128e8:	0a000127 	beq	12d8c <rpl_vasnprintf+0x266c>
                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');
   128ec:	e3090999 	movw	r0, #39321	@ 0x9999
                        precision = 0;
   128f0:	e3a04000 	mov	r4, #0
                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');
   128f4:	e3410999 	movt	r0, #6553	@ 0x1999
                        precision = 0;
   128f8:	e1a03004 	mov	r3, r4
   128fc:	ea000001 	b	12908 <rpl_vasnprintf+0x21e8>
                        while (digitp != dp->precision_end)
   12900:	e1520001 	cmp	r2, r1
   12904:	0a000387 	beq	13728 <rpl_vasnprintf+0x3008>
                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');
   12908:	e1530000 	cmp	r3, r0
   1290c:	8a000007 	bhi	12930 <rpl_vasnprintf+0x2210>
   12910:	e0833103 	add	r3, r3, r3, lsl #2
   12914:	e1a0c083 	lsl	ip, r3, #1
   12918:	e4d23001 	ldrb	r3, [r2], #1
   1291c:	e2433030 	sub	r3, r3, #48	@ 0x30
   12920:	e093300c 	adds	r3, r3, ip
   12924:	3afffff5 	bcc	12900 <rpl_vasnprintf+0x21e0>
                        while (digitp != dp->precision_end)
   12928:	e1520001 	cmp	r2, r1
   1292c:	0afff8b0 	beq	10bf4 <rpl_vasnprintf+0x4d4>
                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');
   12930:	e3e0c000 	mvn	ip, #0
   12934:	eafffff7 	b	12918 <rpl_vasnprintf+0x21f8>
                width = 0;
   12938:	e3a02000 	mov	r2, #0
   1293c:	e50b2aa4 	str	r2, [fp, #-2724]	@ 0xfffff55c
   12940:	eafffa1d 	b	111bc <rpl_vasnprintf+0xa9c>
                                exponent = 0;
   12944:	ed9f8baf 	vldr	d8, [pc, #700]	@ 12c08 <rpl_vasnprintf+0x24e8>
   12948:	e3a02000 	mov	r2, #0
   1294c:	e50b2860 	str	r2, [fp, #-2144]	@ 0xfffff7a0
   12950:	ee072a90 	vmov	s15, r2
                                mantissa = 0.0;
   12954:	eeb00b48 	vmov.f64	d0, d8
                            if (has_precision
   12958:	e354000d 	cmp	r4, #13
   1295c:	83a02000 	movhi	r2, #0
   12960:	92072001 	andls	r2, r7, #1
   12964:	e3520000 	cmp	r2, #0
   12968:	1a000412 	bne	139b8 <rpl_vasnprintf+0x3298>
                              if ((flags & FLAG_ALT)
   1296c:	e51b2a98 	ldr	r2, [fp, #-2712]	@ 0xfffff568
                            *p++ = '0';
   12970:	e1a07009 	mov	r7, r9
                              if ((flags & FLAG_ALT)
   12974:	e3120010 	tst	r2, #16
                            *p++ = '0';
   12978:	e3a02030 	mov	r2, #48	@ 0x30
   1297c:	e4c72002 	strb	r2, [r7], #2
                            *p++ = dp->conversion - 'A' + 'X';
   12980:	e5d52024 	ldrb	r2, [r5, #36]	@ 0x24
   12984:	e2822017 	add	r2, r2, #23
   12988:	e5c92001 	strb	r2, [r9, #1]
                              *p++ = '0' + digit;
   1298c:	ee172a90 	vmov	r2, s15
   12990:	e2822030 	add	r2, r2, #48	@ 0x30
   12994:	e5c92002 	strb	r2, [r9, #2]
                              if ((flags & FLAG_ALT)
   12998:	1a00050a 	bne	13dc8 <rpl_vasnprintf+0x36a8>
                                  || mantissa > 0.0 || precision > 0)
   1299c:	eeb58bc0 	vcmpe.f64	d8, #0.0
   129a0:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   129a4:	ca000057 	bgt	12b08 <rpl_vasnprintf+0x23e8>
   129a8:	e3540000 	cmp	r4, #0
   129ac:	1a00051e 	bne	13e2c <rpl_vasnprintf+0x370c>
   129b0:	e50b3a94 	str	r3, [fp, #-2708]	@ 0xfffff56c
                              *p++ = dp->conversion - 'A' + 'P';
   129b4:	e51b4a94 	ldr	r4, [fp, #-2708]	@ 0xfffff56c
                                  sprintf ((char *) p, "%+d", exponent);
   129b8:	e3091150 	movw	r1, #37200	@ 0x9150
                              *p++ = dp->conversion - 'A' + 'P';
   129bc:	e5d52024 	ldrb	r2, [r5, #36]	@ 0x24
                                  sprintf ((char *) p, "%+d", exponent);
   129c0:	e3401002 	movt	r1, #2
                              *p++ = dp->conversion - 'A' + 'P';
   129c4:	e1a03004 	mov	r3, r4
   129c8:	e282200f 	add	r2, r2, #15
   129cc:	e4c32001 	strb	r2, [r3], #1
                                  sprintf ((char *) p, "%+d", exponent);
   129d0:	e1a00003 	mov	r0, r3
   129d4:	e51b2860 	ldr	r2, [fp, #-2144]	@ 0xfffff7a0
   129d8:	e50b3a94 	str	r3, [fp, #-2708]	@ 0xfffff56c
   129dc:	eb001b2b 	bl	19690 <sprintf>
                                  while (*p != '\0')
   129e0:	e5d42001 	ldrb	r2, [r4, #1]
   129e4:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
   129e8:	e3520000 	cmp	r2, #0
   129ec:	0afffcf7 	beq	11dd0 <rpl_vasnprintf+0x16b0>
   129f0:	e5f32001 	ldrb	r2, [r3, #1]!
   129f4:	e3520000 	cmp	r2, #0
   129f8:	1afffffc 	bne	129f0 <rpl_vasnprintf+0x22d0>
   129fc:	eafffcf3 	b	11dd0 <rpl_vasnprintf+0x16b0>
                prefix_count = 0;
   12a00:	e51b7ab0 	ldr	r7, [fp, #-2736]	@ 0xfffff550
   12a04:	eafffb21 	b	11690 <rpl_vasnprintf+0xf70>
  errno = EINVAL;
   12a08:	eb002381 	bl	1b814 <__errno>
   12a0c:	e3a03016 	mov	r3, #22
   12a10:	e5803000 	str	r3, [r0]
  goto fail_1_with_errno;
   12a14:	eafff854 	b	10b6c <rpl_vasnprintf+0x44c>
                          *p++ = '-';
   12a18:	e51b9a9c 	ldr	r9, [fp, #-2716]	@ 0xfffff564
   12a1c:	e3a0302d 	mov	r3, #45	@ 0x2d
                            arg = -arg;
   12a20:	eeb18b48 	vneg.f64	d8, d8
                          *p++ = '-';
   12a24:	e4c93001 	strb	r3, [r9], #1
   12a28:	eafffa2a 	b	112d8 <rpl_vasnprintf+0xbb8>
   12a2c:	e51b3aa4 	ldr	r3, [fp, #-2724]	@ 0xfffff55c
   12a30:	e50b3ab0 	str	r3, [fp, #-2736]	@ 0xfffff550
   12a34:	eafffc49 	b	11b60 <rpl_vasnprintf+0x1440>
                    ENSURE_ALLOCATION (n);
   12a38:	bafff86d 	blt	10bf4 <rpl_vasnprintf+0x4d4>
   12a3c:	e1a0308a 	lsl	r3, sl, #1
   12a40:	eafffb7f 	b	11844 <rpl_vasnprintf+0x1124>
                    ENSURE_ALLOCATION (n);
   12a44:	e3a0300c 	mov	r3, #12
   12a48:	eafff828 	b	10af0 <rpl_vasnprintf+0x3d0>
                          SNPRINTF_BUF (arg);
   12a4c:	e1cd20f8 	strd	r2, [sp, #8]
   12a50:	e1a01004 	mov	r1, r4
   12a54:	e51b3a60 	ldr	r3, [fp, #-2656]	@ 0xfffff5a0
   12a58:	e1a00009 	mov	r0, r9
   12a5c:	e58d3000 	str	r3, [sp]
   12a60:	e24b3d2a 	sub	r3, fp, #2688	@ 0xa80
   12a64:	e58d3010 	str	r3, [sp, #16]
   12a68:	e51b3a64 	ldr	r3, [fp, #-2660]	@ 0xfffff59c
   12a6c:	e51b2aa0 	ldr	r2, [fp, #-2720]	@ 0xfffff560
   12a70:	eb001ab7 	bl	19554 <snprintf>
   12a74:	eafffe20 	b	122fc <rpl_vasnprintf+0x1bdc>
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   12a78:	e3094999 	movw	r4, #39321	@ 0x9999
                width = 0;
   12a7c:	e3a0c000 	mov	ip, #0
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   12a80:	e3414999 	movt	r4, #6553	@ 0x1999
   12a84:	ea000001 	b	12a90 <rpl_vasnprintf+0x2370>
                        while (digitp != dp->width_end);
   12a88:	e1520001 	cmp	r2, r1
   12a8c:	0a0003e7 	beq	13a30 <rpl_vasnprintf+0x3310>
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   12a90:	e15c0004 	cmp	ip, r4
   12a94:	8a000007 	bhi	12ab8 <rpl_vasnprintf+0x2398>
   12a98:	e08cc10c 	add	ip, ip, ip, lsl #2
   12a9c:	e1a0e08c 	lsl	lr, ip, #1
   12aa0:	e4d2c001 	ldrb	ip, [r2], #1
   12aa4:	e24cc030 	sub	ip, ip, #48	@ 0x30
   12aa8:	e09cc00e 	adds	ip, ip, lr
   12aac:	3afffff5 	bcc	12a88 <rpl_vasnprintf+0x2368>
                        while (digitp != dp->width_end);
   12ab0:	e1520001 	cmp	r2, r1
   12ab4:	0a0004f5 	beq	13e90 <rpl_vasnprintf+0x3770>
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   12ab8:	e3e0e000 	mvn	lr, #0
   12abc:	eafffff7 	b	12aa0 <rpl_vasnprintf+0x2380>
                        else if (flags & FLAG_SPACE)
   12ac0:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
                          *p++ = ' ';
   12ac4:	e51b9a9c 	ldr	r9, [fp, #-2716]	@ 0xfffff564
                        else if (flags & FLAG_SPACE)
   12ac8:	e3130008 	tst	r3, #8
                          *p++ = ' ';
   12acc:	13a03020 	movne	r3, #32
   12ad0:	14c93001 	strbne	r3, [r9], #1
   12ad4:	eafffc84 	b	11cec <rpl_vasnprintf+0x15cc>
                        if (errno == 0)
   12ad8:	eb00234d 	bl	1b814 <__errno>
   12adc:	e5903000 	ldr	r3, [r0]
   12ae0:	e3530000 	cmp	r3, #0
   12ae4:	1afff847 	bne	10c08 <rpl_vasnprintf+0x4e8>
                            if (dp->conversion == 'c' || dp->conversion == 's')
   12ae8:	e5d53024 	ldrb	r3, [r5, #36]	@ 0x24
   12aec:	e20330ef 	and	r3, r3, #239	@ 0xef
   12af0:	e3530063 	cmp	r3, #99	@ 0x63
   12af4:	0a0001cf 	beq	13238 <rpl_vasnprintf+0x2b18>
                              errno = EINVAL;
   12af8:	eb002345 	bl	1b814 <__errno>
   12afc:	e3a03016 	mov	r3, #22
   12b00:	e5803000 	str	r3, [r0]
                        goto fail_with_errno;
   12b04:	eafff83f 	b	10c08 <rpl_vasnprintf+0x4e8>
                                  *p++ = decimal_point_char ();
   12b08:	e2893004 	add	r3, r9, #4
  sprintf (pointbuf, "%#.0f", 1.0);
   12b0c:	e3091148 	movw	r1, #37192	@ 0x9148
                                  *p++ = decimal_point_char ();
   12b10:	e50b3a94 	str	r3, [fp, #-2708]	@ 0xfffff56c
  sprintf (pointbuf, "%#.0f", 1.0);
   12b14:	e3a03000 	mov	r3, #0
   12b18:	e3433ff0 	movt	r3, #16368	@ 0x3ff0
   12b1c:	e3401002 	movt	r1, #2
   12b20:	e24b0fba 	sub	r0, fp, #744	@ 0x2e8
   12b24:	e3a02000 	mov	r2, #0
   12b28:	eb001ad8 	bl	19690 <sprintf>
  return (point[0] != '\0' ? point[0] : '.');
   12b2c:	e55b32e7 	ldrb	r3, [fp, #-743]	@ 0xfffffd19
   12b30:	e3530000 	cmp	r3, #0
                                  *p++ = decimal_point_char ();
   12b34:	03a0302e 	moveq	r3, #46	@ 0x2e
   12b38:	e5c93003 	strb	r3, [r9, #3]
                                      mantissa *= 16.0;
   12b3c:	ed9f6b33 	vldr	d6, [pc, #204]	@ 12c10 <rpl_vasnprintf+0x24f0>
   12b40:	e51b1a94 	ldr	r1, [fp, #-2708]	@ 0xfffff56c
   12b44:	ee288b06 	vmul.f64	d8, d8, d6
                                      digit = (int) mantissa;
   12b48:	eefd7bc8 	vcvt.s32.f64	s15, d8
   12b4c:	ee172a90 	vmov	r2, s15
                                      mantissa -= digit;
   12b50:	eeb87be7 	vcvt.f64.s32	d7, s15
                                             + (digit < 10
   12b54:	e3520009 	cmp	r2, #9
   12b58:	c5d53024 	ldrbgt	r3, [r5, #36]	@ 0x24
   12b5c:	d3a03030 	movle	r3, #48	@ 0x30
                                      mantissa -= digit;
   12b60:	ee388b47 	vsub.f64	d8, d8, d7
                                             + (digit < 10
   12b64:	c243300a 	subgt	r3, r3, #10
   12b68:	c6ef3073 	uxtbgt	r3, r3
                                      if (precision > 0)
   12b6c:	e3540000 	cmp	r4, #0
                                        precision--;
   12b70:	12444001 	subne	r4, r4, #1
                                             + (digit < 10
   12b74:	e0833002 	add	r3, r3, r2
                                  while (mantissa > 0.0)
   12b78:	eeb58bc0 	vcmpe.f64	d8, #0.0
   12b7c:	eef1fa10 	vmrs	APSR_nzcv, fpscr
                                      *p++ = digit
   12b80:	e4c13001 	strb	r3, [r1], #1
                                  while (mantissa > 0.0)
   12b84:	caffffee 	bgt	12b44 <rpl_vasnprintf+0x2424>
   12b88:	e50b1a94 	str	r1, [fp, #-2708]	@ 0xfffff56c
                                  while (precision > 0)
   12b8c:	e3540000 	cmp	r4, #0
   12b90:	0affff87 	beq	129b4 <rpl_vasnprintf+0x2294>
                                      *p++ = '0';
   12b94:	e51b9a94 	ldr	r9, [fp, #-2708]	@ 0xfffff56c
   12b98:	e1a02004 	mov	r2, r4
   12b9c:	e3a01030 	mov	r1, #48	@ 0x30
   12ba0:	e1a00009 	mov	r0, r9
   12ba4:	eb001ec1 	bl	1a6b0 <memset>
   12ba8:	e0893004 	add	r3, r9, r4
   12bac:	eaffff7f 	b	129b0 <rpl_vasnprintf+0x2290>
   12bb0:	e24b6e5a 	sub	r6, fp, #1440	@ 0x5a0
   12bb4:	e3a03000 	mov	r3, #0
   12bb8:	e2466004 	sub	r6, r6, #4
   12bbc:	e1a01009 	mov	r1, r9
   12bc0:	e1a02006 	mov	r2, r6
   12bc4:	e24b0fba 	sub	r0, fp, #744	@ 0x2e8
   12bc8:	e50b35a4 	str	r3, [fp, #-1444]	@ 0xfffffa5c
   12bcc:	e50b35a0 	str	r3, [fp, #-1440]	@ 0xfffffa60
   12bd0:	eb000f8f 	bl	16a14 <wcrtomb>
                          if (count < 0)
   12bd4:	e2506000 	subs	r6, r0, #0
   12bd8:	ba000194 	blt	13230 <rpl_vasnprintf+0x2b10>
                  if (w < width && !(flags & FLAG_LEFT))
   12bdc:	e1540006 	cmp	r4, r6
   12be0:	8a00015d 	bhi	1315c <rpl_vasnprintf+0x2a3c>
  size_t sum = size1 + size2;
   12be4:	e0983006 	adds	r3, r8, r6
   12be8:	2a0002d7 	bcs	1374c <rpl_vasnprintf+0x302c>
                      ENSURE_ALLOCATION (xsum (length, characters));
   12bec:	e153000a 	cmp	r3, sl
   12bf0:	9a0002d7 	bls	13754 <rpl_vasnprintf+0x3034>
   12bf4:	e1a07008 	mov	r7, r8
   12bf8:	e1a08003 	mov	r8, r3
   12bfc:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
   12c00:	e50b3a9c 	str	r3, [fp, #-2716]	@ 0xfffff564
   12c04:	eafff8c5 	b	10f20 <rpl_vasnprintf+0x800>
	...
   12c14:	40300000 	.word	0x40300000
   12c18:	00029e24 	.word	0x00029e24
                        if (dp->conversion >= 'A' && dp->conversion <= 'Z')
   12c1c:	e5d53024 	ldrb	r3, [r5, #36]	@ 0x24
   12c20:	e2433041 	sub	r3, r3, #65	@ 0x41
   12c24:	e3530019 	cmp	r3, #25
                            *p++ = 'N'; *p++ = 'A'; *p++ = 'N';
   12c28:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   12c2c:	8306216e 	movwhi	r2, #24942	@ 0x616e
   12c30:	e2834003 	add	r4, r3, #3
   12c34:	83a0306e 	movhi	r3, #110	@ 0x6e
                        if (dp->conversion >= 'A' && dp->conversion <= 'Z')
   12c38:	9304214e 	movwls	r2, #16718	@ 0x414e
   12c3c:	93a0304e 	movls	r3, #78	@ 0x4e
                            *p++ = 'N'; *p++ = 'A'; *p++ = 'N';
   12c40:	e51b1a9c 	ldr	r1, [fp, #-2716]	@ 0xfffff564
   12c44:	e5c13002 	strb	r3, [r1, #2]
                if (count < width)
   12c48:	e51b3aa4 	ldr	r3, [fp, #-2724]	@ 0xfffff55c
                            *p++ = 'N'; *p++ = 'A'; *p++ = 'N';
   12c4c:	e1c120b0 	strh	r2, [r1]
                if (count < width)
   12c50:	e3530003 	cmp	r3, #3
   12c54:	93a06003 	movls	r6, #3
   12c58:	9a00001d 	bls	12cd4 <rpl_vasnprintf+0x25b4>
   12c5c:	e3a09000 	mov	r9, #0
   12c60:	e3a06003 	mov	r6, #3
                    size_t pad = width - count;
   12c64:	e51b3aa4 	ldr	r3, [fp, #-2724]	@ 0xfffff55c
   12c68:	e0432006 	sub	r2, r3, r6
                    if (flags & FLAG_LEFT)
   12c6c:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
                    DCHAR_T *end = p + pad;
   12c70:	e0846002 	add	r6, r4, r2
                    if (flags & FLAG_LEFT)
   12c74:	e3130002 	tst	r3, #2
   12c78:	1a00000d 	bne	12cb4 <rpl_vasnprintf+0x2594>
                    else if ((flags & FLAG_ZERO) && pad_ptr != NULL)
   12c7c:	e51b1a98 	ldr	r1, [fp, #-2712]	@ 0xfffff568
   12c80:	e2593000 	subs	r3, r9, #0
   12c84:	13a03001 	movne	r3, #1
   12c88:	e01332a1 	ands	r3, r3, r1, lsr #5
   12c8c:	1a000298 	bne	136f4 <rpl_vasnprintf+0x2fd4>
                        while (p > tmp)
   12c90:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   12c94:	e1530004 	cmp	r3, r4
   12c98:	351b0a9c 	ldrcc	r0, [fp, #-2716]	@ 0xfffff564
   12c9c:	31a03006 	movcc	r3, r6
   12ca0:	2a000003 	bcs	12cb4 <rpl_vasnprintf+0x2594>
                          *--q = *--p;
   12ca4:	e5741001 	ldrb	r1, [r4, #-1]!
                        while (p > tmp)
   12ca8:	e1500004 	cmp	r0, r4
                          *--q = *--p;
   12cac:	e5631001 	strb	r1, [r3, #-1]!
                        while (p > tmp)
   12cb0:	1afffffb 	bne	12ca4 <rpl_vasnprintf+0x2584>
                          *p++ = ' ';
   12cb4:	e1a00004 	mov	r0, r4
   12cb8:	e3a01020 	mov	r1, #32
   12cbc:	eb001e7b 	bl	1a6b0 <memset>
                count = p - tmp;
   12cc0:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   12cc4:	e0466003 	sub	r6, r6, r3
                if (count >= tmp_length)
   12cc8:	e51b3aa8 	ldr	r3, [fp, #-2728]	@ 0xfffff558
   12ccc:	e1530006 	cmp	r3, r6
   12cd0:	9a000910 	bls	15118 <rpl_vasnprintf+0x49f8>
                if (count >= allocated - length)
   12cd4:	e0982006 	adds	r2, r8, r6
   12cd8:	e04a3008 	sub	r3, sl, r8
   12cdc:	23a01001 	movcs	r1, #1
   12ce0:	33a01000 	movcc	r1, #0
   12ce4:	e1530006 	cmp	r3, r6
   12ce8:	e1a07002 	mov	r7, r2
   12cec:	8a000016 	bhi	12d4c <rpl_vasnprintf+0x262c>
  return (sum >= size1 ? sum : SIZE_MAX);
   12cf0:	e3510000 	cmp	r1, #0
   12cf4:	1a000298 	bne	1375c <rpl_vasnprintf+0x303c>
                    ENSURE_ALLOCATION (n);
   12cf8:	e15a0002 	cmp	sl, r2
   12cfc:	2a000012 	bcs	12d4c <rpl_vasnprintf+0x262c>
   12d00:	e35a0000 	cmp	sl, #0
   12d04:	0a000400 	beq	13d0c <rpl_vasnprintf+0x35ec>
   12d08:	bafff7b9 	blt	10bf4 <rpl_vasnprintf+0x4d4>
   12d0c:	e1a0308a 	lsl	r3, sl, #1
   12d10:	e1530002 	cmp	r3, r2
   12d14:	21a0a003 	movcs	sl, r3
   12d18:	31a0a002 	movcc	sl, r2
   12d1c:	e37a0001 	cmn	sl, #1
   12d20:	0afff7b3 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   12d24:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
   12d28:	e51b2a90 	ldr	r2, [fp, #-2704]	@ 0xfffff570
   12d2c:	e1530002 	cmp	r3, r2
   12d30:	0a00044b 	beq	13e64 <rpl_vasnprintf+0x3744>
   12d34:	e51b0a88 	ldr	r0, [fp, #-2696]	@ 0xfffff578
   12d38:	e1a0100a 	mov	r1, sl
   12d3c:	ebffee40 	bl	e644 <rpl_realloc>
   12d40:	e3500000 	cmp	r0, #0
   12d44:	0afff7aa 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   12d48:	e50b0a88 	str	r0, [fp, #-2696]	@ 0xfffff578
   12d4c:	e51b4a9c 	ldr	r4, [fp, #-2716]	@ 0xfffff564
   12d50:	e1a02006 	mov	r2, r6
   12d54:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
                if (tmp != tmpbuf)
   12d58:	e24b9fba 	sub	r9, fp, #744	@ 0x2e8
   12d5c:	e1a01004 	mov	r1, r4
   12d60:	e0830008 	add	r0, r3, r8
   12d64:	eb003445 	bl	1fe80 <memcpy>
   12d68:	e1540009 	cmp	r4, r9
   12d6c:	e1a00004 	mov	r0, r4
   12d70:	0afff7cf 	beq	10cb4 <rpl_vasnprintf+0x594>
                  free (tmp);
   12d74:	ebffddb7 	bl	a458 <rpl_free>
              {
   12d78:	eafff7cd 	b	10cb4 <rpl_vasnprintf+0x594>
                        has_precision = 1;
   12d7c:	e3a03001 	mov	r3, #1
                        precision = 0;
   12d80:	e3a06000 	mov	r6, #0
                        has_precision = 1;
   12d84:	e50b3a9c 	str	r3, [fp, #-2716]	@ 0xfffff564
   12d88:	eafff8b6 	b	11068 <rpl_vasnprintf+0x948>
                        precision = 0;
   12d8c:	e3a04000 	mov	r4, #0
                        while (digitp != dp->precision_end)
   12d90:	e3a07001 	mov	r7, #1
   12d94:	e3a0301a 	mov	r3, #26
   12d98:	eafff6f4 	b	10970 <rpl_vasnprintf+0x250>
  void *memory = decode_double (x, &e, &m);
   12d9c:	e24b6e5a 	sub	r6, fp, #1440	@ 0x5a0
   12da0:	eeb00b48 	vmov.f64	d0, d8
   12da4:	e2466004 	sub	r6, r6, #4
   12da8:	e24b0e86 	sub	r0, fp, #2144	@ 0x860
   12dac:	e1a01006 	mov	r1, r6
   12db0:	ebfff1be 	bl	f4b0 <decode_double>
  if (memory != NULL)
   12db4:	e2503000 	subs	r3, r0, #0
   12db8:	0afff78d 	beq	10bf4 <rpl_vasnprintf+0x4d4>
    return scale10_round_decimal_decoded (e, m, memory, n);
   12dbc:	e58d7000 	str	r7, [sp]
   12dc0:	e51b0860 	ldr	r0, [fp, #-2144]	@ 0xfffff7a0
   12dc4:	e8960006 	ldm	r6, {r1, r2}
   12dc8:	ebfff37a 	bl	fbb8 <scale10_round_decimal_decoded>
                                if (digits == NULL)
   12dcc:	e2503000 	subs	r3, r0, #0
   12dd0:	e50b3ab0 	str	r3, [fp, #-2736]	@ 0xfffff550
   12dd4:	0afff786 	beq	10bf4 <rpl_vasnprintf+0x4d4>
                                ndigits = strlen (digits);
   12dd8:	fa0035a8 	blx	20480 <strlen>
                                if (ndigits > precision)
   12ddc:	e1500007 	cmp	r0, r7
                                ndigits = strlen (digits);
   12de0:	e1a03000 	mov	r3, r0
                                    *p++ = '0';
   12de4:	91a04009 	movls	r4, r9
                                  *p++ = '0';
   12de8:	93a03030 	movls	r3, #48	@ 0x30
                                ndigits = strlen (digits);
   12dec:	e50b0a94 	str	r0, [fp, #-2708]	@ 0xfffff56c
                                  *p++ = '0';
   12df0:	94c43001 	strbls	r3, [r4], #1
                                if (ndigits > precision)
   12df4:	8a00053b 	bhi	142e8 <rpl_vasnprintf+0x3bc8>
                                if ((flags & FLAG_ALT) || precision > 0)
   12df8:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
   12dfc:	e2033010 	and	r3, r3, #16
   12e00:	e1933007 	orrs	r3, r3, r7
   12e04:	1a000471 	bne	13fd0 <rpl_vasnprintf+0x38b0>
                                free (digits);
   12e08:	e51b0ab0 	ldr	r0, [fp, #-2736]	@ 0xfffff550
   12e0c:	ebffdd91 	bl	a458 <rpl_free>
                count = p - tmp;
   12e10:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   12e14:	e0446003 	sub	r6, r4, r3
                if (count < width)
   12e18:	e51b3aa4 	ldr	r3, [fp, #-2724]	@ 0xfffff55c
   12e1c:	e1560003 	cmp	r6, r3
   12e20:	2affffa8 	bcs	12cc8 <rpl_vasnprintf+0x25a8>
   12e24:	eaffff8e 	b	12c64 <rpl_vasnprintf+0x2544>
                                    exponent = floorlog10 (arg);
   12e28:	eeb00b48 	vmov.f64	d0, d8
   12e2c:	e24b6e5a 	sub	r6, fp, #1440	@ 0x5a0
   12e30:	ebfff0fa 	bl	f220 <floorlog10>
   12e34:	e3a03002 	mov	r3, #2
                                        if (ndigits == precision + 1)
   12e38:	e2871001 	add	r1, r7, #1
   12e3c:	e24b2e86 	sub	r2, fp, #2144	@ 0x860
   12e40:	e50b1ab0 	str	r1, [fp, #-2736]	@ 0xfffff550
                                            || ndigits > precision + 2)
   12e44:	e0871003 	add	r1, r7, r3
   12e48:	e50b9ac4 	str	r9, [fp, #-2756]	@ 0xfffff53c
   12e4c:	e50b8acc 	str	r8, [fp, #-2764]	@ 0xfffff534
   12e50:	e2466004 	sub	r6, r6, #4
   12e54:	e1a08000 	mov	r8, r0
   12e58:	e1a09003 	mov	r9, r3
   12e5c:	e50b1ab8 	str	r1, [fp, #-2744]	@ 0xfffff548
   12e60:	e50b5ac0 	str	r5, [fp, #-2752]	@ 0xfffff540
   12e64:	e50baac8 	str	sl, [fp, #-2760]	@ 0xfffff538
   12e68:	e50b2a94 	str	r2, [fp, #-2708]	@ 0xfffff56c
   12e6c:	ea000018 	b	12ed4 <rpl_vasnprintf+0x27b4>
                                          scale10_round_decimal_double (arg,
   12e70:	e047a008 	sub	sl, r7, r8
    return scale10_round_decimal_decoded (e, m, memory, n);
   12e74:	e58da000 	str	sl, [sp]
   12e78:	e51b0860 	ldr	r0, [fp, #-2144]	@ 0xfffff7a0
   12e7c:	e8960006 	ldm	r6, {r1, r2}
   12e80:	ebfff34c 	bl	fbb8 <scale10_round_decimal_decoded>
                                        if (digits == NULL)
   12e84:	e2505000 	subs	r5, r0, #0
   12e88:	0afff759 	beq	10bf4 <rpl_vasnprintf+0x4d4>
                                        ndigits = strlen (digits);
   12e8c:	fa00357b 	blx	20480 <strlen>
                                        if (ndigits == precision + 1)
   12e90:	e51b3ab0 	ldr	r3, [fp, #-2736]	@ 0xfffff550
                                        ndigits = strlen (digits);
   12e94:	e1a04000 	mov	r4, r0
                                        if (ndigits == precision + 1)
   12e98:	e1530000 	cmp	r3, r0
   12e9c:	0a0005cc 	beq	145d4 <rpl_vasnprintf+0x3eb4>
                                        if (ndigits < precision
   12ea0:	e1500007 	cmp	r0, r7
   12ea4:	3a00089b 	bcc	15118 <rpl_vasnprintf+0x49f8>
                                            || ndigits > precision + 2)
   12ea8:	e51b3ab8 	ldr	r3, [fp, #-2744]	@ 0xfffff548
   12eac:	e1530000 	cmp	r3, r0
   12eb0:	3a000898 	bcc	15118 <rpl_vasnprintf+0x49f8>
                                        if (adjusted)
   12eb4:	e3590001 	cmp	r9, #1
   12eb8:	0a000896 	beq	15118 <rpl_vasnprintf+0x49f8>
                                        free (digits);
   12ebc:	e1a00005 	mov	r0, r5
  return (point[0] != '\0' ? point[0] : '.');
   12ec0:	e3a09001 	mov	r9, #1
                                        free (digits);
   12ec4:	ebffdd63 	bl	a458 <rpl_free>
                                        if (ndigits == precision)
   12ec8:	e1540007 	cmp	r4, r7
                                          exponent -= 1;
   12ecc:	02488001 	subeq	r8, r8, #1
                                          exponent += 1;
   12ed0:	12888001 	addne	r8, r8, #1
  void *memory = decode_double (x, &e, &m);
   12ed4:	e51b0a94 	ldr	r0, [fp, #-2708]	@ 0xfffff56c
   12ed8:	e1a01006 	mov	r1, r6
   12edc:	eeb00b48 	vmov.f64	d0, d8
   12ee0:	ebfff172 	bl	f4b0 <decode_double>
  if (memory != NULL)
   12ee4:	e2503000 	subs	r3, r0, #0
   12ee8:	1affffe0 	bne	12e70 <rpl_vasnprintf+0x2750>
   12eec:	eafff740 	b	10bf4 <rpl_vasnprintf+0x4d4>
                                if (precision == 0)
   12ef0:	e3570001 	cmp	r7, #1
   12ef4:	21a03007 	movcs	r3, r7
   12ef8:	33a03001 	movcc	r3, #1
   12efc:	e50b3ab8 	str	r3, [fp, #-2744]	@ 0xfffff548
                                    exponent = floorlog10 (arg);
   12f00:	eeb00b48 	vmov.f64	d0, d8
   12f04:	e24b6e5a 	sub	r6, fp, #1440	@ 0x5a0
   12f08:	ebfff0c4 	bl	f220 <floorlog10>
                                    --ndigits;
   12f0c:	e51b3ab8 	ldr	r3, [fp, #-2744]	@ 0xfffff548
   12f10:	e24b2e86 	sub	r2, fp, #2144	@ 0x860
   12f14:	e50b9ac8 	str	r9, [fp, #-2760]	@ 0xfffff538
                                    exponent = floorlog10 (arg);
   12f18:	e3a07002 	mov	r7, #2
   12f1c:	e50b8ad0 	str	r8, [fp, #-2768]	@ 0xfffff530
   12f20:	e2466004 	sub	r6, r6, #4
                                            || ndigits > precision + 1)
   12f24:	e2831001 	add	r1, r3, #1
                                    --ndigits;
   12f28:	e2434001 	sub	r4, r3, #1
   12f2c:	e1a09003 	mov	r9, r3
   12f30:	e1a08000 	mov	r8, r0
                                            || ndigits > precision + 1)
   12f34:	e50b1ac0 	str	r1, [fp, #-2752]	@ 0xfffff540
   12f38:	e50b5ac4 	str	r5, [fp, #-2756]	@ 0xfffff53c
   12f3c:	e50baacc 	str	sl, [fp, #-2764]	@ 0xfffff534
   12f40:	e50b2abc 	str	r2, [fp, #-2748]	@ 0xfffff544
   12f44:	ea000019 	b	12fb0 <rpl_vasnprintf+0x2890>
                                                                        (int)(precision - 1) - exponent);
   12f48:	e049a008 	sub	sl, r9, r8
   12f4c:	e24a2001 	sub	r2, sl, #1
    return scale10_round_decimal_decoded (e, m, memory, n);
   12f50:	e58d2000 	str	r2, [sp]
   12f54:	e51b0860 	ldr	r0, [fp, #-2144]	@ 0xfffff7a0
   12f58:	e8960006 	ldm	r6, {r1, r2}
   12f5c:	ebfff315 	bl	fbb8 <scale10_round_decimal_decoded>
                                        if (digits == NULL)
   12f60:	e2503000 	subs	r3, r0, #0
   12f64:	e50b3a94 	str	r3, [fp, #-2708]	@ 0xfffff56c
   12f68:	0afff721 	beq	10bf4 <rpl_vasnprintf+0x4d4>
                                        ndigits = strlen (digits);
   12f6c:	fa003543 	blx	20480 <strlen>
                                        if (ndigits == precision)
   12f70:	e1500009 	cmp	r0, r9
                                        ndigits = strlen (digits);
   12f74:	e1a05000 	mov	r5, r0
                                        if (ndigits == precision)
   12f78:	0a000622 	beq	14808 <rpl_vasnprintf+0x40e8>
                                        if (ndigits < precision - 1
   12f7c:	e1500004 	cmp	r0, r4
   12f80:	3a000864 	bcc	15118 <rpl_vasnprintf+0x49f8>
                                            || ndigits > precision + 1)
   12f84:	e51b2ac0 	ldr	r2, [fp, #-2752]	@ 0xfffff540
   12f88:	e1520000 	cmp	r2, r0
   12f8c:	3a000861 	bcc	15118 <rpl_vasnprintf+0x49f8>
                                        if (adjusted)
   12f90:	e3570001 	cmp	r7, #1
   12f94:	0a00085f 	beq	15118 <rpl_vasnprintf+0x49f8>
                                        free (digits);
   12f98:	e51b0a94 	ldr	r0, [fp, #-2708]	@ 0xfffff56c
  return (point[0] != '\0' ? point[0] : '.');
   12f9c:	e3a07001 	mov	r7, #1
                                        free (digits);
   12fa0:	ebffdd2c 	bl	a458 <rpl_free>
                                        if (ndigits < precision)
   12fa4:	e1550009 	cmp	r5, r9
                                          exponent -= 1;
   12fa8:	32488001 	subcc	r8, r8, #1
                                          exponent += 1;
   12fac:	22888001 	addcs	r8, r8, #1
  void *memory = decode_double (x, &e, &m);
   12fb0:	e51b0abc 	ldr	r0, [fp, #-2748]	@ 0xfffff544
   12fb4:	e1a01006 	mov	r1, r6
   12fb8:	eeb00b48 	vmov.f64	d0, d8
   12fbc:	ebfff13b 	bl	f4b0 <decode_double>
  if (memory != NULL)
   12fc0:	e2503000 	subs	r3, r0, #0
   12fc4:	1affffdf 	bne	12f48 <rpl_vasnprintf+0x2828>
   12fc8:	eafff709 	b	10bf4 <rpl_vasnprintf+0x4d4>
                                  scale10_round_decimal_long_double (arg, precision);
   12fcc:	eeb00b48 	vmov.f64	d0, d8
   12fd0:	e1a00007 	mov	r0, r7
   12fd4:	ebfff491 	bl	10220 <scale10_round_decimal_long_double>
                                if (digits == NULL)
   12fd8:	e2506000 	subs	r6, r0, #0
   12fdc:	0afff704 	beq	10bf4 <rpl_vasnprintf+0x4d4>
                                ndigits = strlen (digits);
   12fe0:	fa003526 	blx	20480 <strlen>
                                if (ndigits > precision)
   12fe4:	e1500007 	cmp	r0, r7
                                ndigits = strlen (digits);
   12fe8:	e1a03000 	mov	r3, r0
                                    *p++ = '0';
   12fec:	91a04009 	movls	r4, r9
                                  *p++ = '0';
   12ff0:	93a03030 	movls	r3, #48	@ 0x30
                                ndigits = strlen (digits);
   12ff4:	e50b0a94 	str	r0, [fp, #-2708]	@ 0xfffff56c
                                  *p++ = '0';
   12ff8:	94c43001 	strbls	r3, [r4], #1
                                if (ndigits > precision)
   12ffc:	8a0005c4 	bhi	14714 <rpl_vasnprintf+0x3ff4>
                                if ((flags & FLAG_ALT) || precision > 0)
   13000:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
   13004:	e2033010 	and	r3, r3, #16
   13008:	e1933007 	orrs	r3, r3, r7
   1300c:	1a00050a 	bne	1443c <rpl_vasnprintf+0x3d1c>
                                    free (digits);
   13010:	e1a00006 	mov	r0, r6
   13014:	ebffdd0f 	bl	a458 <rpl_free>
                count = p - tmp;
   13018:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   1301c:	e0446003 	sub	r6, r4, r3
   13020:	eaffff7c 	b	12e18 <rpl_vasnprintf+0x26f8>
                                    exponent = floorlog10l (arg);
   13024:	eeb00b48 	vmov.f64	d0, d8
   13028:	e3a06002 	mov	r6, #2
   1302c:	ebffefd7 	bl	ef90 <floorlog10l>
                                        if (ndigits == precision + 1)
   13030:	e2873001 	add	r3, r7, #1
   13034:	e50b9ab8 	str	r9, [fp, #-2744]	@ 0xfffff548
   13038:	e50b3a94 	str	r3, [fp, #-2708]	@ 0xfffff56c
                                            || ndigits > precision + 2)
   1303c:	e0873006 	add	r3, r7, r6
                                    exponent = floorlog10l (arg);
   13040:	e1a04000 	mov	r4, r0
                                    adjusted = 0;
   13044:	e1a09003 	mov	r9, r3
   13048:	e50b5ab0 	str	r5, [fp, #-2736]	@ 0xfffff550
   1304c:	e50baabc 	str	sl, [fp, #-2748]	@ 0xfffff544
   13050:	e50b8ac0 	str	r8, [fp, #-2752]	@ 0xfffff540
   13054:	ea000010 	b	1309c <rpl_vasnprintf+0x297c>
                                        ndigits = strlen (digits);
   13058:	fa003508 	blx	20480 <strlen>
                                        if (ndigits == precision + 1)
   1305c:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
                                        ndigits = strlen (digits);
   13060:	e1a08000 	mov	r8, r0
                                        if (ndigits == precision + 1)
   13064:	e1530000 	cmp	r3, r0
   13068:	0a00064f 	beq	149ac <rpl_vasnprintf+0x428c>
                                        if (ndigits < precision
   1306c:	e1500007 	cmp	r0, r7
   13070:	3a000828 	bcc	15118 <rpl_vasnprintf+0x49f8>
                                            || ndigits > precision + 2)
   13074:	e1590000 	cmp	r9, r0
   13078:	3a000826 	bcc	15118 <rpl_vasnprintf+0x49f8>
                                        if (adjusted)
   1307c:	e3560001 	cmp	r6, #1
   13080:	0a000824 	beq	15118 <rpl_vasnprintf+0x49f8>
                                        free (digits);
   13084:	e1a0000a 	mov	r0, sl
  return (point[0] != '\0' ? point[0] : '.');
   13088:	e3a06001 	mov	r6, #1
                                        free (digits);
   1308c:	ebffdcf1 	bl	a458 <rpl_free>
                                        if (ndigits == precision)
   13090:	e1580007 	cmp	r8, r7
                                          exponent -= 1;
   13094:	02444001 	subeq	r4, r4, #1
                                          exponent += 1;
   13098:	12844001 	addne	r4, r4, #1
                                          scale10_round_decimal_long_double (arg,
   1309c:	e0475004 	sub	r5, r7, r4
   130a0:	eeb00b48 	vmov.f64	d0, d8
   130a4:	e1a00005 	mov	r0, r5
   130a8:	ebfff45c 	bl	10220 <scale10_round_decimal_long_double>
                                        if (digits == NULL)
   130ac:	e250a000 	subs	sl, r0, #0
   130b0:	1affffe8 	bne	13058 <rpl_vasnprintf+0x2938>
   130b4:	eafff6ce 	b	10bf4 <rpl_vasnprintf+0x4d4>
                                if (precision == 0)
   130b8:	e3570001 	cmp	r7, #1
   130bc:	21a06007 	movcs	r6, r7
   130c0:	33a06001 	movcc	r6, #1
                                    exponent = floorlog10l (arg);
   130c4:	eeb00b48 	vmov.f64	d0, d8
   130c8:	e3a04002 	mov	r4, #2
   130cc:	ebffefaf 	bl	ef90 <floorlog10l>
                                        if (ndigits < precision - 1
   130d0:	e2463001 	sub	r3, r6, #1
   130d4:	e50b5abc 	str	r5, [fp, #-2748]	@ 0xfffff544
   130d8:	e50b3a94 	str	r3, [fp, #-2708]	@ 0xfffff56c
                                            || ndigits > precision + 1)
   130dc:	e2863001 	add	r3, r6, #1
   130e0:	e1a05004 	mov	r5, r4
   130e4:	e50b3ab8 	str	r3, [fp, #-2744]	@ 0xfffff548
   130e8:	e1a04000 	mov	r4, r0
   130ec:	e50b9ac0 	str	r9, [fp, #-2752]	@ 0xfffff540
   130f0:	e50b8ac4 	str	r8, [fp, #-2756]	@ 0xfffff53c
   130f4:	ea000011 	b	13140 <rpl_vasnprintf+0x2a20>
                                        ndigits = strlen (digits);
   130f8:	fa0034e0 	blx	20480 <strlen>
                                        if (ndigits == precision)
   130fc:	e1500006 	cmp	r0, r6
                                        ndigits = strlen (digits);
   13100:	e1a09000 	mov	r9, r0
                                        if (ndigits == precision)
   13104:	0a000676 	beq	14ae4 <rpl_vasnprintf+0x43c4>
                                        if (ndigits < precision - 1
   13108:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
   1310c:	e1530000 	cmp	r3, r0
   13110:	8a000800 	bhi	15118 <rpl_vasnprintf+0x49f8>
                                            || ndigits > precision + 1)
   13114:	e51b3ab8 	ldr	r3, [fp, #-2744]	@ 0xfffff548
   13118:	e1530000 	cmp	r3, r0
   1311c:	3a0007fd 	bcc	15118 <rpl_vasnprintf+0x49f8>
                                        if (adjusted)
   13120:	e3550001 	cmp	r5, #1
   13124:	0a0007fb 	beq	15118 <rpl_vasnprintf+0x49f8>
                                        free (digits);
   13128:	e1a00008 	mov	r0, r8
  return (point[0] != '\0' ? point[0] : '.');
   1312c:	e3a05001 	mov	r5, #1
                                        free (digits);
   13130:	ebffdcc8 	bl	a458 <rpl_free>
                                        if (ndigits < precision)
   13134:	e1590006 	cmp	r9, r6
                                          exponent -= 1;
   13138:	32444001 	subcc	r4, r4, #1
                                          exponent += 1;
   1313c:	22844001 	addcs	r4, r4, #1
                                                                             (int)(precision - 1) - exponent);
   13140:	e0467004 	sub	r7, r6, r4
                                          scale10_round_decimal_long_double (arg,
   13144:	eeb00b48 	vmov.f64	d0, d8
   13148:	e2470001 	sub	r0, r7, #1
   1314c:	ebfff433 	bl	10220 <scale10_round_decimal_long_double>
                                        if (digits == NULL)
   13150:	e2508000 	subs	r8, r0, #0
   13154:	1affffe7 	bne	130f8 <rpl_vasnprintf+0x29d8>
   13158:	eafff6a5 	b	10bf4 <rpl_vasnprintf+0x4d4>
                  if (w < width && !(flags & FLAG_LEFT))
   1315c:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
   13160:	e3130002 	tst	r3, #2
                      size_t n = width - w;
   13164:	00443006 	subeq	r3, r4, r6
                  if (w < width && !(flags & FLAG_LEFT))
   13168:	1afffe9d 	bne	12be4 <rpl_vasnprintf+0x24c4>
  size_t sum = size1 + size2;
   1316c:	e0987003 	adds	r7, r8, r3
   13170:	2a000772 	bcs	14f40 <rpl_vasnprintf+0x4820>
                      ENSURE_ALLOCATION (xsum (length, n));
   13174:	e15a0007 	cmp	sl, r7
   13178:	2a000011 	bcs	131c4 <rpl_vasnprintf+0x2aa4>
   1317c:	e35a0000 	cmp	sl, #0
   13180:	0a0003c1 	beq	1408c <rpl_vasnprintf+0x396c>
   13184:	bafff69a 	blt	10bf4 <rpl_vasnprintf+0x4d4>
   13188:	e1a0a08a 	lsl	sl, sl, #1
   1318c:	e15a0007 	cmp	sl, r7
   13190:	3a0003c0 	bcc	14098 <rpl_vasnprintf+0x3978>
   13194:	e51b2a88 	ldr	r2, [fp, #-2696]	@ 0xfffff578
   13198:	e51b1a90 	ldr	r1, [fp, #-2704]	@ 0xfffff570
   1319c:	e1520001 	cmp	r2, r1
   131a0:	0a000432 	beq	14270 <rpl_vasnprintf+0x3b50>
   131a4:	e51b0a88 	ldr	r0, [fp, #-2696]	@ 0xfffff578
   131a8:	e1a0100a 	mov	r1, sl
   131ac:	e50b3a94 	str	r3, [fp, #-2708]	@ 0xfffff56c
   131b0:	ebffed23 	bl	e644 <rpl_realloc>
   131b4:	e3500000 	cmp	r0, #0
   131b8:	0afff68d 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   131bc:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
   131c0:	e50b0a88 	str	r0, [fp, #-2696]	@ 0xfffff578
__ssp_bos_icheck3(memset, void *, int)
   131c4:	e1a02003 	mov	r2, r3
   131c8:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
   131cc:	e3a01020 	mov	r1, #32
   131d0:	e0830008 	add	r0, r3, r8
                      length += n;
   131d4:	e1a08007 	mov	r8, r7
   131d8:	eb001d34 	bl	1a6b0 <memset>
   131dc:	eafffe80 	b	12be4 <rpl_vasnprintf+0x24c4>
                          if (*arg_end == 0)
   131e0:	e51b7a94 	ldr	r7, [fp, #-2708]	@ 0xfffff56c
   131e4:	e3a04000 	mov	r4, #0
   131e8:	e50b45a4 	str	r4, [fp, #-1444]	@ 0xfffffa5c
   131ec:	e24b6e5a 	sub	r6, fp, #1440	@ 0x5a0
   131f0:	e50b45a0 	str	r4, [fp, #-1440]	@ 0xfffffa60
   131f4:	e2466004 	sub	r6, r6, #4
   131f8:	e5971000 	ldr	r1, [r7]
   131fc:	e1510004 	cmp	r1, r4
   13200:	0a000554 	beq	14758 <rpl_vasnprintf+0x4038>
   13204:	e24b9fba 	sub	r9, fp, #744	@ 0x2e8
   13208:	ea000003 	b	1321c <rpl_vasnprintf+0x2afc>
   1320c:	e5b71004 	ldr	r1, [r7, #4]!
                          characters += count;
   13210:	e0844000 	add	r4, r4, r0
                          if (*arg_end == 0)
   13214:	e3510000 	cmp	r1, #0
   13218:	0a0001e3 	beq	139ac <rpl_vasnprintf+0x328c>
   1321c:	e1a02006 	mov	r2, r6
   13220:	e1a00009 	mov	r0, r9
   13224:	eb000dfa 	bl	16a14 <wcrtomb>
                          if (count < 0)
   13228:	e3500000 	cmp	r0, #0
   1322c:	aafffff6 	bge	1320c <rpl_vasnprintf+0x2aec>
   13230:	e51b5a88 	ldr	r5, [fp, #-2696]	@ 0xfffff578
   13234:	e50b5a9c 	str	r5, [fp, #-2716]	@ 0xfffff564
    errno = EILSEQ;
   13238:	eb002175 	bl	1b814 <__errno>
   1323c:	e3a0308a 	mov	r3, #138	@ 0x8a
   13240:	e5803000 	str	r3, [r0]
    goto fail_with_errno;
   13244:	eafff66f 	b	10c08 <rpl_vasnprintf+0x4e8>
                      while (arg < arg_end)
   13248:	e51b3aa8 	ldr	r3, [fp, #-2728]	@ 0xfffff558
   1324c:	e51b6a94 	ldr	r6, [fp, #-2708]	@ 0xfffff56c
   13250:	e50b2a74 	str	r2, [fp, #-2676]	@ 0xfffff58c
   13254:	e50b2a70 	str	r2, [fp, #-2672]	@ 0xfffff590
   13258:	e1530006 	cmp	r3, r6
   1325c:	9a00068a 	bls	14c8c <rpl_vasnprintf+0x456c>
   13260:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
   13264:	e50b5a88 	str	r5, [fp, #-2696]	@ 0xfffff578
   13268:	e1a05003 	mov	r5, r3
   1326c:	ea000018 	b	132d4 <rpl_vasnprintf+0x2bb4>
                          ENSURE_ALLOCATION (xsum (length, count));
   13270:	e159000a 	cmp	r9, sl
   13274:	9a00000e 	bls	132b4 <rpl_vasnprintf+0x2b94>
   13278:	e35a0000 	cmp	sl, #0
   1327c:	0a000023 	beq	13310 <rpl_vasnprintf+0x2bf0>
   13280:	bafff65c 	blt	10bf8 <rpl_vasnprintf+0x4d8>
   13284:	e1a0a08a 	lsl	sl, sl, #1
   13288:	e15a0009 	cmp	sl, r9
   1328c:	3a000022 	bcc	1331c <rpl_vasnprintf+0x2bfc>
   13290:	e51b3a90 	ldr	r3, [fp, #-2704]	@ 0xfffff570
   13294:	e1550003 	cmp	r5, r3
   13298:	0a0000a9 	beq	13544 <rpl_vasnprintf+0x2e24>
   1329c:	e1a0100a 	mov	r1, sl
   132a0:	e1a00005 	mov	r0, r5
   132a4:	ebffece6 	bl	e644 <rpl_realloc>
   132a8:	e3500000 	cmp	r0, #0
   132ac:	0afff651 	beq	10bf8 <rpl_vasnprintf+0x4d8>
   132b0:	e1a05000 	mov	r5, r0
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   132b4:	e1a02004 	mov	r2, r4
   132b8:	e0850008 	add	r0, r5, r8
   132bc:	e24b1fba 	sub	r1, fp, #744	@ 0x2e8
   132c0:	eb0032ee 	bl	1fe80 <memcpy>
                      while (arg < arg_end)
   132c4:	e51b3aa8 	ldr	r3, [fp, #-2728]	@ 0xfffff558
   132c8:	e1530006 	cmp	r3, r6
   132cc:	9a0003d2 	bls	1421c <rpl_vasnprintf+0x3afc>
   132d0:	e1a08009 	mov	r8, r9
                          if (*arg == 0)
   132d4:	e4961004 	ldr	r1, [r6], #4
   132d8:	e3510000 	cmp	r1, #0
   132dc:	0a00078d 	beq	15118 <rpl_vasnprintf+0x49f8>
   132e0:	e24b2ea7 	sub	r2, fp, #2672	@ 0xa70
   132e4:	e24b0fba 	sub	r0, fp, #744	@ 0x2e8
   132e8:	e2422004 	sub	r2, r2, #4
   132ec:	eb000dc8 	bl	16a14 <wcrtomb>
                          if (count <= 0)
   132f0:	e2504000 	subs	r4, r0, #0
   132f4:	daffffce 	ble	13234 <rpl_vasnprintf+0x2b14>
   132f8:	e0949008 	adds	r9, r4, r8
   132fc:	e1a07009 	mov	r7, r9
  return (sum >= size1 ? sum : SIZE_MAX);
   13300:	3affffda 	bcc	13270 <rpl_vasnprintf+0x2b50>
                          ENSURE_ALLOCATION (xsum (length, count));
   13304:	e37a0001 	cmn	sl, #1
   13308:	1afff63a 	bne	10bf8 <rpl_vasnprintf+0x4d8>
   1330c:	eaffffe8 	b	132b4 <rpl_vasnprintf+0x2b94>
   13310:	e359000c 	cmp	r9, #12
   13314:	93a0a00c 	movls	sl, #12
   13318:	9affffdc 	bls	13290 <rpl_vasnprintf+0x2b70>
   1331c:	e3790001 	cmn	r9, #1
   13320:	0afff634 	beq	10bf8 <rpl_vasnprintf+0x4d8>
   13324:	e1a0a009 	mov	sl, r9
   13328:	eaffffd8 	b	13290 <rpl_vasnprintf+0x2b70>
                ENSURE_ALLOCATION (xsum (length,
   1332c:	e37a0001 	cmn	sl, #1
   13330:	1afff62f 	bne	10bf4 <rpl_vasnprintf+0x4d4>
   13334:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
   13338:	e50b3a9c 	str	r3, [fp, #-2716]	@ 0xfffff564
   1333c:	eafffba7 	b	121e0 <rpl_vasnprintf+0x1ac0>
                            flags |= FLAG_LEFT;
   13340:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
                      if (arg != 0)
   13344:	e3590000 	cmp	r9, #0
                            width = -width;
   13348:	e2644000 	rsb	r4, r4, #0
                            flags |= FLAG_LEFT;
   1334c:	e3833002 	orr	r3, r3, #2
   13350:	e50b3a98 	str	r3, [fp, #-2712]	@ 0xfffff568
                      if (arg != 0)
   13354:	1afffe15 	bne	12bb0 <rpl_vasnprintf+0x2490>
                  if (w < width && !(flags & FLAG_LEFT))
   13358:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
   1335c:	e2133002 	ands	r3, r3, #2
   13360:	1afff6e5 	bne	10efc <rpl_vasnprintf+0x7dc>
   13364:	e1a09003 	mov	r9, r3
   13368:	e1a03004 	mov	r3, r4
                      characters = 0;
   1336c:	e1a06009 	mov	r6, r9
   13370:	eaffff7d 	b	1316c <rpl_vasnprintf+0x2a4c>
                            if (dp->conversion >= 'A' && dp->conversion <= 'Z')
   13374:	e2433041 	sub	r3, r3, #65	@ 0x41
                                *p++ = 'I'; *p++ = 'N'; *p++ = 'F';
   13378:	e2894003 	add	r4, r9, #3
                            if (dp->conversion >= 'A' && dp->conversion <= 'Z')
   1337c:	e3530019 	cmp	r3, #25
                                *p++ = 'I'; *p++ = 'N'; *p++ = 'F';
   13380:	93043e49 	movwls	r3, #20041	@ 0x4e49
                                *p++ = 'i'; *p++ = 'n'; *p++ = 'f';
   13384:	83063e69 	movwhi	r3, #28265	@ 0x6e69
                                *p++ = 'I'; *p++ = 'N'; *p++ = 'F';
   13388:	91c930b0 	strhls	r3, [r9]
   1338c:	93a03046 	movls	r3, #70	@ 0x46
                                *p++ = 'i'; *p++ = 'n'; *p++ = 'f';
   13390:	81c930b0 	strhhi	r3, [r9]
   13394:	83a03066 	movhi	r3, #102	@ 0x66
   13398:	e5c93002 	strb	r3, [r9, #2]
                pad_ptr = NULL;
   1339c:	e3a09000 	mov	r9, #0
                count = p - tmp;
   133a0:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   133a4:	e0446003 	sub	r6, r4, r3
   133a8:	eafffe9a 	b	12e18 <rpl_vasnprintf+0x26f8>
                            if (dp->conversion == 'f' || dp->conversion == 'F')
   133ac:	e2433045 	sub	r3, r3, #69	@ 0x45
   133b0:	e3530022 	cmp	r3, #34	@ 0x22
   133b4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   133b8:	ea000756 	b	15118 <rpl_vasnprintf+0x49f8>
   133bc:	000134d8 	.word	0x000134d8
   133c0:	00012d9c 	.word	0x00012d9c
   133c4:	00013448 	.word	0x00013448
   133c8:	00015118 	.word	0x00015118
   133cc:	00015118 	.word	0x00015118
   133d0:	00015118 	.word	0x00015118
   133d4:	00015118 	.word	0x00015118
   133d8:	00015118 	.word	0x00015118
   133dc:	00015118 	.word	0x00015118
   133e0:	00015118 	.word	0x00015118
   133e4:	00015118 	.word	0x00015118
   133e8:	00015118 	.word	0x00015118
   133ec:	00015118 	.word	0x00015118
   133f0:	00015118 	.word	0x00015118
   133f4:	00015118 	.word	0x00015118
   133f8:	00015118 	.word	0x00015118
   133fc:	00015118 	.word	0x00015118
   13400:	00015118 	.word	0x00015118
   13404:	00015118 	.word	0x00015118
   13408:	00015118 	.word	0x00015118
   1340c:	00015118 	.word	0x00015118
   13410:	00015118 	.word	0x00015118
   13414:	00015118 	.word	0x00015118
   13418:	00015118 	.word	0x00015118
   1341c:	00015118 	.word	0x00015118
   13420:	00015118 	.word	0x00015118
   13424:	00015118 	.word	0x00015118
   13428:	00015118 	.word	0x00015118
   1342c:	00015118 	.word	0x00015118
   13430:	00015118 	.word	0x00015118
   13434:	00015118 	.word	0x00015118
   13438:	00015118 	.word	0x00015118
   1343c:	000134d8 	.word	0x000134d8
   13440:	00012d9c 	.word	0x00012d9c
   13444:	00013448 	.word	0x00013448
                                if (precision == 0)
   13448:	e3570001 	cmp	r7, #1
                                if (arg == 0.0)
   1344c:	eeb58b40 	vcmp.f64	d8, #0.0
   13450:	21a03007 	movcs	r3, r7
   13454:	33a03001 	movcc	r3, #1
   13458:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   1345c:	e50b3ab8 	str	r3, [fp, #-2744]	@ 0xfffff548
   13460:	1afffea6 	bne	12f00 <rpl_vasnprintf+0x27e0>
                                      (flags & FLAG_ALT ? 0 : precision - 1);
   13464:	e51b2a98 	ldr	r2, [fp, #-2712]	@ 0xfffff568
   13468:	e3120010 	tst	r2, #16
   1346c:	0a00010b 	beq	138a0 <rpl_vasnprintf+0x3180>
                                    --ndigits;
   13470:	e2436001 	sub	r6, r3, #1
                                    *p++ = '0';
   13474:	e3a07030 	mov	r7, #48	@ 0x30
   13478:	e1a04009 	mov	r4, r9
  sprintf (pointbuf, "%#.0f", 1.0);
   1347c:	e3091148 	movw	r1, #37192	@ 0x9148
   13480:	e24b0e5a 	sub	r0, fp, #1440	@ 0x5a0
   13484:	e3a03000 	mov	r3, #0
   13488:	e3401002 	movt	r1, #2
   1348c:	e3433ff0 	movt	r3, #16368	@ 0x3ff0
   13490:	e2400004 	sub	r0, r0, #4
   13494:	e3a02000 	mov	r2, #0
                                    *p++ = '0';
   13498:	e4c47002 	strb	r7, [r4], #2
  sprintf (pointbuf, "%#.0f", 1.0);
   1349c:	eb00187b 	bl	19690 <sprintf>
  return (point[0] != '\0' ? point[0] : '.');
   134a0:	e55b35a3 	ldrb	r3, [fp, #-1443]	@ 0xfffffa5d
   134a4:	e3530000 	cmp	r3, #0
   134a8:	03a0302e 	moveq	r3, #46	@ 0x2e
                                        while (ndigits > nzeroes)
   134ac:	e3560000 	cmp	r6, #0
                                        *p++ = decimal_point_char ();
   134b0:	e5c93001 	strb	r3, [r9, #1]
                                        while (ndigits > nzeroes)
   134b4:	0a00001f 	beq	13538 <rpl_vasnprintf+0x2e18>
                                            *p++ = '0';
   134b8:	e1a02006 	mov	r2, r6
   134bc:	e1a00004 	mov	r0, r4
   134c0:	e1a01007 	mov	r1, r7
   134c4:	e0844006 	add	r4, r4, r6
   134c8:	eb001c78 	bl	1a6b0 <memset>
                count = p - tmp;
   134cc:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   134d0:	e0446003 	sub	r6, r4, r3
   134d4:	eafffe4f 	b	12e18 <rpl_vasnprintf+0x26f8>
                                if (arg == 0.0)
   134d8:	eeb58b40 	vcmp.f64	d8, #0.0
   134dc:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   134e0:	1afffe50 	bne	12e28 <rpl_vasnprintf+0x2708>
                                    if ((flags & FLAG_ALT) || precision > 0)
   134e4:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
                                    *p++ = '0';
   134e8:	e3a04030 	mov	r4, #48	@ 0x30
   134ec:	e5c94000 	strb	r4, [r9]
                                    if ((flags & FLAG_ALT) || precision > 0)
   134f0:	e2033010 	and	r3, r3, #16
   134f4:	e1933007 	orrs	r3, r3, r7
                                    *p++ = '0';
   134f8:	02896001 	addeq	r6, r9, #1
                                    if ((flags & FLAG_ALT) || precision > 0)
   134fc:	e50b3ab0 	str	r3, [fp, #-2736]	@ 0xfffff550
   13500:	1a00038b 	bne	14334 <rpl_vasnprintf+0x3c14>
                                *p++ = dp->conversion; /* 'e' or 'E' */
   13504:	e5d53024 	ldrb	r3, [r5, #36]	@ 0x24
   13508:	e1a04006 	mov	r4, r6
                                      sprintf ((char *) p, decimal_format, exponent);
   1350c:	e51b2ab0 	ldr	r2, [fp, #-2736]	@ 0xfffff550
   13510:	e51f1900 	ldr	r1, [pc, #-2304]	@ 12c18 <rpl_vasnprintf+0x24f8>
                                *p++ = dp->conversion; /* 'e' or 'E' */
   13514:	e4c43001 	strb	r3, [r4], #1
                                      sprintf ((char *) p, decimal_format, exponent);
   13518:	e1a00004 	mov	r0, r4
   1351c:	eb00185b 	bl	19690 <sprintf>
                                      while (*p != '\0')
   13520:	e5d63001 	ldrb	r3, [r6, #1]
   13524:	e3530000 	cmp	r3, #0
   13528:	0a000002 	beq	13538 <rpl_vasnprintf+0x2e18>
   1352c:	e5f43001 	ldrb	r3, [r4, #1]!
   13530:	e3530000 	cmp	r3, #0
   13534:	1afffffc 	bne	1352c <rpl_vasnprintf+0x2e0c>
                count = p - tmp;
   13538:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   1353c:	e0446003 	sub	r6, r4, r3
   13540:	eafffe34 	b	12e18 <rpl_vasnprintf+0x26f8>
                          ENSURE_ALLOCATION (xsum (length, count));
   13544:	e1a0000a 	mov	r0, sl
   13548:	ebffec31 	bl	e614 <rpl_malloc>
   1354c:	e2503000 	subs	r3, r0, #0
   13550:	e50b3a94 	str	r3, [fp, #-2708]	@ 0xfffff56c
   13554:	0afff5a7 	beq	10bf8 <rpl_vasnprintf+0x4d8>
   13558:	e3580000 	cmp	r8, #0
   1355c:	0a000002 	beq	1356c <rpl_vasnprintf+0x2e4c>
   13560:	e51b1a90 	ldr	r1, [fp, #-2704]	@ 0xfffff570
   13564:	e1a02008 	mov	r2, r8
   13568:	eb003244 	bl	1fe80 <memcpy>
   1356c:	e51b5a94 	ldr	r5, [fp, #-2708]	@ 0xfffff56c
   13570:	eaffff4f 	b	132b4 <rpl_vasnprintf+0x2b94>
                    has_width = 1;
   13574:	e3a02001 	mov	r2, #1
   13578:	e1a04000 	mov	r4, r0
   1357c:	e50b2ab0 	str	r2, [fp, #-2736]	@ 0xfffff550
   13580:	eafff6a7 	b	11024 <rpl_vasnprintf+0x904>
                    ENSURE_ALLOCATION (n);
   13584:	e1a0000a 	mov	r0, sl
   13588:	ebffec21 	bl	e614 <rpl_malloc>
   1358c:	e2504000 	subs	r4, r0, #0
   13590:	0afff597 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   13594:	e3580000 	cmp	r8, #0
   13598:	0a000002 	beq	135a8 <rpl_vasnprintf+0x2e88>
   1359c:	e51b1a90 	ldr	r1, [fp, #-2704]	@ 0xfffff570
   135a0:	e1a02008 	mov	r2, r8
   135a4:	eb003235 	bl	1fe80 <memcpy>
   135a8:	e50b4a88 	str	r4, [fp, #-2696]	@ 0xfffff578
   135ac:	eafff8b3 	b	11880 <rpl_vasnprintf+0x1160>
                          SNPRINTF_BUF (arg);
   135b0:	e1cd20f0 	strd	r2, [sp]
   135b4:	e24b3d2a 	sub	r3, fp, #2688	@ 0xa80
   135b8:	e58d3008 	str	r3, [sp, #8]
   135bc:	e1a01004 	mov	r1, r4
   135c0:	e51b3a64 	ldr	r3, [fp, #-2660]	@ 0xfffff59c
   135c4:	e1a00009 	mov	r0, r9
   135c8:	e51b2aa0 	ldr	r2, [fp, #-2720]	@ 0xfffff560
   135cc:	eb0017e0 	bl	19554 <snprintf>
   135d0:	eafffb49 	b	122fc <rpl_vasnprintf+0x1bdc>
                    ENSURE_ALLOCATION (n);
   135d4:	e1a0000a 	mov	r0, sl
   135d8:	ebffec0d 	bl	e614 <rpl_malloc>
   135dc:	e2506000 	subs	r6, r0, #0
   135e0:	0afff583 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   135e4:	e3580000 	cmp	r8, #0
   135e8:	0a000002 	beq	135f8 <rpl_vasnprintf+0x2ed8>
   135ec:	e51b1a90 	ldr	r1, [fp, #-2704]	@ 0xfffff570
   135f0:	e1a02008 	mov	r2, r8
   135f4:	eb003221 	bl	1fe80 <memcpy>
   135f8:	e50b6a88 	str	r6, [fp, #-2696]	@ 0xfffff578
   135fc:	eafff54a 	b	10b2c <rpl_vasnprintf+0x40c>
                        const FCHAR_T *digitp = dp->precision_start + 1;
   13600:	e2811001 	add	r1, r1, #1
                        while (digitp != dp->precision_end)
   13604:	e15c0001 	cmp	ip, r1
   13608:	0a0000d7 	beq	1396c <rpl_vasnprintf+0x324c>
                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');
   1360c:	e309e999 	movw	lr, #39321	@ 0x9999
                        precision = 0;
   13610:	e3a03000 	mov	r3, #0
                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');
   13614:	e341e999 	movt	lr, #6553	@ 0x1999
   13618:	ea000001 	b	13624 <rpl_vasnprintf+0x2f04>
                        while (digitp != dp->precision_end)
   1361c:	e15c0001 	cmp	ip, r1
   13620:	0a0000d2 	beq	13970 <rpl_vasnprintf+0x3250>
                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');
   13624:	e153000e 	cmp	r3, lr
   13628:	8a000007 	bhi	1364c <rpl_vasnprintf+0x2f2c>
   1362c:	e0833103 	add	r3, r3, r3, lsl #2
   13630:	e1a03083 	lsl	r3, r3, #1
   13634:	e4d12001 	ldrb	r2, [r1], #1
   13638:	e2422030 	sub	r2, r2, #48	@ 0x30
   1363c:	e0933002 	adds	r3, r3, r2
   13640:	3afffff5 	bcc	1361c <rpl_vasnprintf+0x2efc>
                        while (digitp != dp->precision_end)
   13644:	e15c0001 	cmp	ip, r1
   13648:	0a000249 	beq	13f74 <rpl_vasnprintf+0x3854>
                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');
   1364c:	e3e03000 	mvn	r3, #0
   13650:	eafffff7 	b	13634 <rpl_vasnprintf+0x2f14>
                        *--p = '0' + (arg & 1);
   13654:	e51b2a94 	ldr	r2, [fp, #-2708]	@ 0xfffff56c
   13658:	e3a03030 	mov	r3, #48	@ 0x30
   1365c:	e3a09000 	mov	r9, #0
   13660:	e5423001 	strb	r3, [r2, #-1]
                    while (arg != 0);
   13664:	eafff8df 	b	119e8 <rpl_vasnprintf+0x12c8>
                  if (dp->conversion == 'f' || dp->conversion == 'F')
   13668:	e35c0046 	cmp	ip, #70	@ 0x46
   1366c:	1afffa38 	bne	11f54 <rpl_vasnprintf+0x1834>
                      long double arg = a.arg[dp->arg_index].a.a_longdouble;
   13670:	ed990b02 	vldr	d0, [r9, #8]
                      if (!(isnanl (arg) || arg + arg == arg))
   13674:	eeb40b40 	vcmp.f64	d0, d0
   13678:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   1367c:	6afffa34 	bvs	11f54 <rpl_vasnprintf+0x1834>
   13680:	ee307b00 	vadd.f64	d7, d0, d0
   13684:	eeb47b40 	vcmp.f64	d7, d0
   13688:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   1368c:	0afffa30 	beq	11f54 <rpl_vasnprintf+0x1834>
   13690:	e3a04010 	mov	r4, #16
   13694:	e3a07006 	mov	r7, #6
                          int exponent = floorlog10l (arg < 0 ? -arg : arg);
   13698:	eeb50bc0 	vcmpe.f64	d0, #0.0
   1369c:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   136a0:	4eb10b40 	vnegmi.f64	d0, d0
   136a4:	ebffee39 	bl	ef90 <floorlog10l>
                          if (exponent >= 0 && tmp_length < exponent + precision)
   136a8:	e3500000 	cmp	r0, #0
   136ac:	aafffa24 	bge	11f44 <rpl_vasnprintf+0x1824>
   136b0:	eafff6e0 	b	11238 <rpl_vasnprintf+0xb18>
                              mantissa = printf_frexp (arg, &exponent);
   136b4:	eeb00b48 	vmov.f64	d0, d8
   136b8:	e24b0e86 	sub	r0, fp, #2144	@ 0x860
   136bc:	e50b3a94 	str	r3, [fp, #-2708]	@ 0xfffff56c
   136c0:	eb000695 	bl	1511c <printf_frexp>
                                    int digit = (int) tail;
   136c4:	eefd7bc0 	vcvt.s32.f64	s15, d0
   136c8:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
                                    tail -= digit;
   136cc:	eeb88be7 	vcvt.f64.s32	d8, s15
   136d0:	ee308b48 	vsub.f64	d8, d0, d8
   136d4:	eafffc9f 	b	12958 <rpl_vasnprintf+0x2238>
                      ENSURE_ALLOCATION (xsum (length, characters));
   136d8:	e351000c 	cmp	r1, #12
   136dc:	93a0a00c 	movls	sl, #12
   136e0:	9afff92e 	bls	11ba0 <rpl_vasnprintf+0x1480>
   136e4:	e3710001 	cmn	r1, #1
   136e8:	0afff541 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   136ec:	e1a0a001 	mov	sl, r1
   136f0:	eafff92a 	b	11ba0 <rpl_vasnprintf+0x1480>
                        while (p > pad_ptr)
   136f4:	e1590004 	cmp	r9, r4
   136f8:	2a000389 	bcs	14524 <rpl_vasnprintf+0x3e04>
   136fc:	e1a03006 	mov	r3, r6
                          *--q = *--p;
   13700:	e5741001 	ldrb	r1, [r4, #-1]!
                        while (p > pad_ptr)
   13704:	e1590004 	cmp	r9, r4
                          *--q = *--p;
   13708:	e5631001 	strb	r1, [r3, #-1]!
                        while (p > pad_ptr)
   1370c:	1afffffb 	bne	13700 <rpl_vasnprintf+0x2fe0>
                          *p++ = '0';
   13710:	e1a00009 	mov	r0, r9
   13714:	e3a01030 	mov	r1, #48	@ 0x30
   13718:	eb001be4 	bl	1a6b0 <memset>
                count = p - tmp;
   1371c:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   13720:	e0466003 	sub	r6, r6, r3
   13724:	eafffd67 	b	12cc8 <rpl_vasnprintf+0x25a8>
                if (tmp_length < precision)
   13728:	e353000e 	cmp	r3, #14
   1372c:	e1a04003 	mov	r4, r3
   13730:	93a07001 	movls	r7, #1
   13734:	93a0301a 	movls	r3, #26
   13738:	9afff48c 	bls	10970 <rpl_vasnprintf+0x250>
  size_t sum = size1 + size2;
   1373c:	e294300c 	adds	r3, r4, #12
  return (sum >= size1 ? sum : SIZE_MAX);
   13740:	2afff52b 	bcs	10bf4 <rpl_vasnprintf+0x4d4>
   13744:	e3a07001 	mov	r7, #1
   13748:	eafff488 	b	10970 <rpl_vasnprintf+0x250>
                      ENSURE_ALLOCATION (xsum (length, characters));
   1374c:	e37a0001 	cmn	sl, #1
   13750:	1a00014f 	bne	13c94 <rpl_vasnprintf+0x3574>
   13754:	e1a07008 	mov	r7, r8
   13758:	eafff600 	b	10f60 <rpl_vasnprintf+0x840>
                    ENSURE_ALLOCATION (n);
   1375c:	e37a0001 	cmn	sl, #1
   13760:	1afff523 	bne	10bf4 <rpl_vasnprintf+0x4d4>
   13764:	eafffd78 	b	12d4c <rpl_vasnprintf+0x262c>
                    if (pad_ourselves && has_width)
   13768:	e51b1ab0 	ldr	r1, [fp, #-2736]	@ 0xfffff550
   1376c:	e51b2ac8 	ldr	r2, [fp, #-2760]	@ 0xfffff538
   13770:	e0022001 	and	r2, r2, r1
                        if (w < width)
   13774:	e51b1ab8 	ldr	r1, [fp, #-2744]	@ 0xfffff548
   13778:	e1510003 	cmp	r1, r3
   1377c:	93a02000 	movls	r2, #0
   13780:	82022001 	andhi	r2, r2, #1
   13784:	e3520000 	cmp	r2, #0
   13788:	1a000246 	bne	140a8 <rpl_vasnprintf+0x3988>
                    if (dp->conversion == 'F')
   1378c:	e5d53024 	ldrb	r3, [r5, #36]	@ 0x24
                        for (rc = count; rc > 0; rc--, rp++)
   13790:	e51b7a80 	ldr	r7, [fp, #-2688]	@ 0xfffff580
                    if (dp->conversion == 'F')
   13794:	e3530046 	cmp	r3, #70	@ 0x46
   13798:	0a000348 	beq	144c0 <rpl_vasnprintf+0x3da0>
                errno = orig_errno;
   1379c:	eb00201c 	bl	1b814 <__errno>
   137a0:	e51b3acc 	ldr	r3, [fp, #-2764]	@ 0xfffff534
                    length += count;
   137a4:	e0887007 	add	r7, r8, r7
                errno = orig_errno;
   137a8:	e5803000 	str	r3, [r0]
   137ac:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   137b0:	e50b3a88 	str	r3, [fp, #-2696]	@ 0xfffff578
   137b4:	eafff53e 	b	10cb4 <rpl_vasnprintf+0x594>
    errno = EOVERFLOW;
   137b8:	eb002015 	bl	1b814 <__errno>
   137bc:	e3a0308b 	mov	r3, #139	@ 0x8b
   137c0:	e5803000 	str	r3, [r0]
    goto fail_with_errno;
   137c4:	eafff50f 	b	10c08 <rpl_vasnprintf+0x4e8>
                  if (dp->conversion == 'f' || dp->conversion == 'F')
   137c8:	e35c0046 	cmp	ip, #70	@ 0x46
   137cc:	1afff699 	bne	11238 <rpl_vasnprintf+0xb18>
                      long double arg = a.arg[dp->arg_index].a.a_longdouble;
   137d0:	ed990b02 	vldr	d0, [r9, #8]
                      if (!(isnanl (arg) || arg + arg == arg))
   137d4:	eeb40b40 	vcmp.f64	d0, d0
   137d8:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   137dc:	6afff695 	bvs	11238 <rpl_vasnprintf+0xb18>
   137e0:	ee307b00 	vadd.f64	d7, d0, d0
   137e4:	eeb47b40 	vcmp.f64	d7, d0
   137e8:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   137ec:	1affffa9 	bne	13698 <rpl_vasnprintf+0x2f78>
   137f0:	eafff690 	b	11238 <rpl_vasnprintf+0xb18>
   137f4:	e3a03000 	mov	r3, #0
   137f8:	e24b2ea6 	sub	r2, fp, #2656	@ 0xa60
   137fc:	e50b3a6c 	str	r3, [fp, #-2668]	@ 0xfffff594
   13800:	e1a01009 	mov	r1, r9
   13804:	e50b3a68 	str	r3, [fp, #-2664]	@ 0xfffff598
   13808:	e242200c 	sub	r2, r2, #12
   1380c:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
   13810:	e0830007 	add	r0, r3, r7
   13814:	eb000c7e 	bl	16a14 <wcrtomb>
                          if (count <= 0)
   13818:	e3500000 	cmp	r0, #0
   1381c:	da00063d 	ble	15118 <rpl_vasnprintf+0x49f8>
                          length += count;
   13820:	e0877000 	add	r7, r7, r0
   13824:	eafff5cf 	b	10f68 <rpl_vasnprintf+0x848>
                                exponent = 0;
   13828:	ed9f8bea 	vldr	d8, [pc, #936]	@ 13bd8 <rpl_vasnprintf+0x34b8>
   1382c:	e3a02000 	mov	r2, #0
   13830:	e50b2860 	str	r2, [fp, #-2144]	@ 0xfffff7a0
   13834:	ee072a90 	vmov	s15, r2
                                mantissa = 0.0L;
   13838:	eeb00b48 	vmov.f64	d0, d8
   1383c:	eafff93a 	b	11d2c <rpl_vasnprintf+0x160c>
                if (count < width)
   13840:	e3540000 	cmp	r4, #0
   13844:	0afff9a2 	beq	11ed4 <rpl_vasnprintf+0x17b4>
   13848:	e51b9a94 	ldr	r9, [fp, #-2708]	@ 0xfffff56c
                count = tmp_end - tmp_start;
   1384c:	e3a06000 	mov	r6, #0
                if (count < width)
   13850:	e50b6aa8 	str	r6, [fp, #-2728]	@ 0xfffff558
   13854:	e1a01009 	mov	r1, r9
   13858:	eafff877 	b	11a3c <rpl_vasnprintf+0x131c>
                        else if (flags & FLAG_SHOWSIGN)
   1385c:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
   13860:	e3130004 	tst	r3, #4
   13864:	0a00016a 	beq	13e14 <rpl_vasnprintf+0x36f4>
                          *p++ = '+';
   13868:	e51b9a9c 	ldr	r9, [fp, #-2716]	@ 0xfffff564
   1386c:	e3a0302b 	mov	r3, #43	@ 0x2b
   13870:	e4c93001 	strb	r3, [r9], #1
   13874:	eafffbab 	b	12728 <rpl_vasnprintf+0x2008>
                                if (precision == 0)
   13878:	e3570001 	cmp	r7, #1
                                if (arg == 0.0L)
   1387c:	eeb58b40 	vcmp.f64	d8, #0.0
   13880:	21a06007 	movcs	r6, r7
   13884:	33a06001 	movcc	r6, #1
   13888:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   1388c:	1afffe0c 	bne	130c4 <rpl_vasnprintf+0x29a4>
                                      (flags & FLAG_ALT ? 0 : precision - 1);
   13890:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
   13894:	e3130010 	tst	r3, #16
                                    --ndigits;
   13898:	12466001 	subne	r6, r6, #1
                                      (flags & FLAG_ALT ? 0 : precision - 1);
   1389c:	1afffef4 	bne	13474 <rpl_vasnprintf+0x2d54>
                                    *p++ = '0';
   138a0:	e1a04009 	mov	r4, r9
   138a4:	e3a03030 	mov	r3, #48	@ 0x30
   138a8:	e4c43001 	strb	r3, [r4], #1
                count = p - tmp;
   138ac:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   138b0:	e0446003 	sub	r6, r4, r3
   138b4:	eafffd57 	b	12e18 <rpl_vasnprintf+0x26f8>
                        const FCHAR_T *digitp = dp->precision_start + 1;
   138b8:	e2811001 	add	r1, r1, #1
                        while (digitp != dp->precision_end)
   138bc:	e1500001 	cmp	r0, r1
   138c0:	0a00039f 	beq	14744 <rpl_vasnprintf+0x4024>
                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');
   138c4:	e309c999 	movw	ip, #39321	@ 0x9999
                        precision = 0;
   138c8:	e3a03000 	mov	r3, #0
                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');
   138cc:	e341c999 	movt	ip, #6553	@ 0x1999
   138d0:	ea000001 	b	138dc <rpl_vasnprintf+0x31bc>
                        while (digitp != dp->precision_end)
   138d4:	e1500001 	cmp	r0, r1
   138d8:	0a000059 	beq	13a44 <rpl_vasnprintf+0x3324>
                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');
   138dc:	e153000c 	cmp	r3, ip
   138e0:	8a000007 	bhi	13904 <rpl_vasnprintf+0x31e4>
   138e4:	e0833103 	add	r3, r3, r3, lsl #2
   138e8:	e1a02083 	lsl	r2, r3, #1
   138ec:	e4d13001 	ldrb	r3, [r1], #1
   138f0:	e2433030 	sub	r3, r3, #48	@ 0x30
   138f4:	e0933002 	adds	r3, r3, r2
   138f8:	3afffff5 	bcc	138d4 <rpl_vasnprintf+0x31b4>
                        while (digitp != dp->precision_end)
   138fc:	e1500001 	cmp	r0, r1
   13900:	0a00004e 	beq	13a40 <rpl_vasnprintf+0x3320>
                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');
   13904:	e3e02000 	mvn	r2, #0
   13908:	eafffff7 	b	138ec <rpl_vasnprintf+0x31cc>
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   1390c:	e309c999 	movw	ip, #39321	@ 0x9999
                width = 0;
   13910:	e3a00000 	mov	r0, #0
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   13914:	e341c999 	movt	ip, #6553	@ 0x1999
   13918:	ea000001 	b	13924 <rpl_vasnprintf+0x3204>
                        while (digitp != dp->width_end);
   1391c:	e1520001 	cmp	r2, r1
   13920:	0a0000e2 	beq	13cb0 <rpl_vasnprintf+0x3590>
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   13924:	e150000c 	cmp	r0, ip
   13928:	8a000007 	bhi	1394c <rpl_vasnprintf+0x322c>
   1392c:	e0800100 	add	r0, r0, r0, lsl #2
   13930:	e1a00080 	lsl	r0, r0, #1
   13934:	e4d2e001 	ldrb	lr, [r2], #1
   13938:	e24ee030 	sub	lr, lr, #48	@ 0x30
   1393c:	e090000e 	adds	r0, r0, lr
   13940:	3afffff5 	bcc	1391c <rpl_vasnprintf+0x31fc>
                        while (digitp != dp->width_end);
   13944:	e1520001 	cmp	r2, r1
   13948:	0a00019b 	beq	13fbc <rpl_vasnprintf+0x389c>
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   1394c:	e3e00000 	mvn	r0, #0
   13950:	eafffff7 	b	13934 <rpl_vasnprintf+0x3214>
                        else if (flags & FLAG_SPACE)
   13954:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
                          *p++ = ' ';
   13958:	e51b9a9c 	ldr	r9, [fp, #-2716]	@ 0xfffff564
                        else if (flags & FLAG_SPACE)
   1395c:	e3130008 	tst	r3, #8
                          *p++ = ' ';
   13960:	13a03020 	movne	r3, #32
   13964:	14c93001 	strbne	r3, [r9], #1
   13968:	eafff65a 	b	112d8 <rpl_vasnprintf+0xbb8>
                        precision = 0;
   1396c:	e3a03000 	mov	r3, #0
   13970:	e50b3ac0 	str	r3, [fp, #-2752]	@ 0xfffff540
                        has_precision = 1;
   13974:	e3a03001 	mov	r3, #1
   13978:	e50b3abc 	str	r3, [fp, #-2748]	@ 0xfffff544
   1397c:	eafff51f 	b	10e00 <rpl_vasnprintf+0x6e0>
                      ENSURE_ALLOCATION (xsum (length, characters));
   13980:	e1a0000a 	mov	r0, sl
   13984:	ebffeb22 	bl	e614 <rpl_malloc>
   13988:	e2506000 	subs	r6, r0, #0
   1398c:	0afff498 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   13990:	e3580000 	cmp	r8, #0
   13994:	0a000002 	beq	139a4 <rpl_vasnprintf+0x3284>
   13998:	e51b1a90 	ldr	r1, [fp, #-2704]	@ 0xfffff570
   1399c:	e1a02008 	mov	r2, r8
   139a0:	eb003136 	bl	1fe80 <memcpy>
   139a4:	e50b6a88 	str	r6, [fp, #-2696]	@ 0xfffff578
   139a8:	eafff886 	b	11bc8 <rpl_vasnprintf+0x14a8>
   139ac:	e50b7aa8 	str	r7, [fp, #-2728]	@ 0xfffff558
                  if (has_width)
   139b0:	e3a07000 	mov	r7, #0
   139b4:	eafff6c1 	b	114c0 <rpl_vasnprintf+0xda0>
                                    if (q == 0)
   139b8:	e3540000 	cmp	r4, #0
   139bc:	0a000007 	beq	139e0 <rpl_vasnprintf+0x32c0>
                                    tail *= 16.0;
   139c0:	ed9f5b86 	vldr	d5, [pc, #536]	@ 13be0 <rpl_vasnprintf+0x34c0>
                                for (q = precision; ; q--)
   139c4:	e1a02004 	mov	r2, r4
                                    tail *= 16.0;
   139c8:	ee288b05 	vmul.f64	d8, d8, d5
                                    if (q == 0)
   139cc:	e2522001 	subs	r2, r2, #1
                                    int digit = (int) tail;
   139d0:	eefd7bc8 	vcvt.s32.f64	s15, d8
                                    tail -= digit;
   139d4:	eeb86be7 	vcvt.f64.s32	d6, s15
   139d8:	ee388b46 	vsub.f64	d8, d8, d6
                                    if (q == 0)
   139dc:	1afffff9 	bne	139c8 <rpl_vasnprintf+0x32a8>
                                        if (digit & 1 ? tail >= 0.5 : tail > 0.5)
   139e0:	ee172a90 	vmov	r2, s15
   139e4:	ed9f7b7f 	vldr	d7, [pc, #508]	@ 13be8 <rpl_vasnprintf+0x34c8>
   139e8:	e3120001 	tst	r2, #1
   139ec:	eeb48bc7 	vcmpe.f64	d8, d7
   139f0:	0a00014d 	beq	13f2c <rpl_vasnprintf+0x380c>
   139f4:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   139f8:	a3a02001 	movge	r2, #1
   139fc:	b3a02000 	movlt	r2, #0
   13a00:	e3520000 	cmp	r2, #0
   13a04:	0a000146 	beq	13f24 <rpl_vasnprintf+0x3804>
                                          tail = 1 - tail;
   13a08:	ed9f7b78 	vldr	d7, [pc, #480]	@ 13bf0 <rpl_vasnprintf+0x34d0>
   13a0c:	ee378b48 	vsub.f64	d8, d7, d8
                                if (tail != 0.0)
   13a10:	eeb58b40 	vcmp.f64	d8, #0.0
   13a14:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   13a18:	1a0001f7 	bne	141fc <rpl_vasnprintf+0x3adc>
                                mantissa += tail;
   13a1c:	ee308b08 	vadd.f64	d8, d0, d8
                              digit = (int) mantissa;
   13a20:	eefd7bc8 	vcvt.s32.f64	s15, d8
                              mantissa -= digit;
   13a24:	eeb86be7 	vcvt.f64.s32	d6, s15
   13a28:	ee388b46 	vsub.f64	d8, d8, d6
   13a2c:	eafffbce 	b	1296c <rpl_vasnprintf+0x224c>
                    has_width = 1;
   13a30:	e3a02001 	mov	r2, #1
   13a34:	e50bcab8 	str	ip, [fp, #-2744]	@ 0xfffff548
   13a38:	e50b2ac8 	str	r2, [fp, #-2760]	@ 0xfffff538
   13a3c:	eafff4dd 	b	10db8 <rpl_vasnprintf+0x698>
   13a40:	e3e03000 	mvn	r3, #0
                  const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;
   13a44:	e5992008 	ldr	r2, [r9, #8]
   13a48:	e50b2a94 	str	r2, [fp, #-2708]	@ 0xfffff56c
                  if (has_precision)
   13a4c:	eafff677 	b	11430 <rpl_vasnprintf+0xd10>
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   13a50:	e3093999 	movw	r3, #39321	@ 0x9999
                width = 0;
   13a54:	e3a04000 	mov	r4, #0
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   13a58:	e3413999 	movt	r3, #6553	@ 0x1999
                width = 0;
   13a5c:	e1a00004 	mov	r0, r4
   13a60:	ea000001 	b	13a6c <rpl_vasnprintf+0x334c>
                        while (digitp != dp->width_end);
   13a64:	e1520001 	cmp	r2, r1
   13a68:	0a0000a9 	beq	13d14 <rpl_vasnprintf+0x35f4>
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   13a6c:	e1500003 	cmp	r0, r3
   13a70:	8a000007 	bhi	13a94 <rpl_vasnprintf+0x3374>
   13a74:	e0800100 	add	r0, r0, r0, lsl #2
   13a78:	e1a00080 	lsl	r0, r0, #1
   13a7c:	e4d2c001 	ldrb	ip, [r2], #1
   13a80:	e24cc030 	sub	ip, ip, #48	@ 0x30
   13a84:	e090000c 	adds	r0, r0, ip
   13a88:	3afffff5 	bcc	13a64 <rpl_vasnprintf+0x3344>
                        while (digitp != dp->width_end);
   13a8c:	e1520001 	cmp	r2, r1
   13a90:	0a000174 	beq	14068 <rpl_vasnprintf+0x3948>
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   13a94:	e3e00000 	mvn	r0, #0
   13a98:	eafffff7 	b	13a7c <rpl_vasnprintf+0x335c>
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   13a9c:	e3094999 	movw	r4, #39321	@ 0x9999
                width = 0;
   13aa0:	e3a00000 	mov	r0, #0
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   13aa4:	e3414999 	movt	r4, #6553	@ 0x1999
   13aa8:	ea000001 	b	13ab4 <rpl_vasnprintf+0x3394>
                        while (digitp != dp->width_end);
   13aac:	e1520001 	cmp	r2, r1
   13ab0:	0a0000d5 	beq	13e0c <rpl_vasnprintf+0x36ec>
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   13ab4:	e1500004 	cmp	r0, r4
   13ab8:	8a000007 	bhi	13adc <rpl_vasnprintf+0x33bc>
   13abc:	e0800100 	add	r0, r0, r0, lsl #2
   13ac0:	e1a00080 	lsl	r0, r0, #1
   13ac4:	e4d2e001 	ldrb	lr, [r2], #1
   13ac8:	e24ee030 	sub	lr, lr, #48	@ 0x30
   13acc:	e090000e 	adds	r0, r0, lr
   13ad0:	3afffff5 	bcc	13aac <rpl_vasnprintf+0x338c>
                        while (digitp != dp->width_end);
   13ad4:	e1520001 	cmp	r2, r1
   13ad8:	0a0001ab 	beq	1418c <rpl_vasnprintf+0x3a6c>
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   13adc:	e3e00000 	mvn	r0, #0
   13ae0:	eafffff7 	b	13ac4 <rpl_vasnprintf+0x33a4>
                        const FCHAR_T *digitp = dp->precision_start + 1;
   13ae4:	e2822001 	add	r2, r2, #1
                        while (digitp != dp->precision_end)
   13ae8:	e1510002 	cmp	r1, r2
   13aec:	0a00031d 	beq	14768 <rpl_vasnprintf+0x4048>
                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');
   13af0:	e3090999 	movw	r0, #39321	@ 0x9999
                        precision = 0;
   13af4:	e3a07000 	mov	r7, #0
                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');
   13af8:	e3410999 	movt	r0, #6553	@ 0x1999
                        precision = 0;
   13afc:	e1a03007 	mov	r3, r7
   13b00:	ea000001 	b	13b0c <rpl_vasnprintf+0x33ec>
                        while (digitp != dp->precision_end)
   13b04:	e1510002 	cmp	r1, r2
   13b08:	0afff5b9 	beq	111f4 <rpl_vasnprintf+0xad4>
                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');
   13b0c:	e1530000 	cmp	r3, r0
   13b10:	8a000007 	bhi	13b34 <rpl_vasnprintf+0x3414>
   13b14:	e0833103 	add	r3, r3, r3, lsl #2
   13b18:	e1a03083 	lsl	r3, r3, #1
   13b1c:	e4d2e001 	ldrb	lr, [r2], #1
   13b20:	e24ee030 	sub	lr, lr, #48	@ 0x30
   13b24:	e093300e 	adds	r3, r3, lr
   13b28:	3afffff5 	bcc	13b04 <rpl_vasnprintf+0x33e4>
                        while (digitp != dp->precision_end)
   13b2c:	e1510002 	cmp	r1, r2
   13b30:	0a0001cc 	beq	14268 <rpl_vasnprintf+0x3b48>
                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');
   13b34:	e3e03000 	mvn	r3, #0
   13b38:	eafffff7 	b	13b1c <rpl_vasnprintf+0x33fc>
                            if (dp->conversion == 'f' || dp->conversion == 'F')
   13b3c:	e2433045 	sub	r3, r3, #69	@ 0x45
   13b40:	e3530022 	cmp	r3, #34	@ 0x22
   13b44:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   13b48:	ea000572 	b	15118 <rpl_vasnprintf+0x49f8>
   13b4c:	00013bf8 	.word	0x00013bf8
   13b50:	00012fcc 	.word	0x00012fcc
   13b54:	00013878 	.word	0x00013878
   13b58:	00015118 	.word	0x00015118
   13b5c:	00015118 	.word	0x00015118
   13b60:	00015118 	.word	0x00015118
   13b64:	00015118 	.word	0x00015118
   13b68:	00015118 	.word	0x00015118
   13b6c:	00015118 	.word	0x00015118
   13b70:	00015118 	.word	0x00015118
   13b74:	00015118 	.word	0x00015118
   13b78:	00015118 	.word	0x00015118
   13b7c:	00015118 	.word	0x00015118
   13b80:	00015118 	.word	0x00015118
   13b84:	00015118 	.word	0x00015118
   13b88:	00015118 	.word	0x00015118
   13b8c:	00015118 	.word	0x00015118
   13b90:	00015118 	.word	0x00015118
   13b94:	00015118 	.word	0x00015118
   13b98:	00015118 	.word	0x00015118
   13b9c:	00015118 	.word	0x00015118
   13ba0:	00015118 	.word	0x00015118
   13ba4:	00015118 	.word	0x00015118
   13ba8:	00015118 	.word	0x00015118
   13bac:	00015118 	.word	0x00015118
   13bb0:	00015118 	.word	0x00015118
   13bb4:	00015118 	.word	0x00015118
   13bb8:	00015118 	.word	0x00015118
   13bbc:	00015118 	.word	0x00015118
   13bc0:	00015118 	.word	0x00015118
   13bc4:	00015118 	.word	0x00015118
   13bc8:	00015118 	.word	0x00015118
   13bcc:	00013bf8 	.word	0x00013bf8
   13bd0:	00012fcc 	.word	0x00012fcc
   13bd4:	00013878 	.word	0x00013878
	...
   13be4:	40300000 	.word	0x40300000
   13be8:	00000000 	.word	0x00000000
   13bec:	3fe00000 	.word	0x3fe00000
   13bf0:	00000000 	.word	0x00000000
   13bf4:	3ff00000 	.word	0x3ff00000
                                if (arg == 0.0L)
   13bf8:	eeb58b40 	vcmp.f64	d8, #0.0
   13bfc:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   13c00:	1afffd07 	bne	13024 <rpl_vasnprintf+0x2904>
                                    if ((flags & FLAG_ALT) || precision > 0)
   13c04:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
   13c08:	e2033010 	and	r3, r3, #16
   13c0c:	e1934007 	orrs	r4, r3, r7
                                    *p++ = '0';
   13c10:	e3a03030 	mov	r3, #48	@ 0x30
   13c14:	02896001 	addeq	r6, r9, #1
   13c18:	e5c93000 	strb	r3, [r9]
                                    if ((flags & FLAG_ALT) || precision > 0)
   13c1c:	1a0002a6 	bne	146bc <rpl_vasnprintf+0x3f9c>
                                *p++ = dp->conversion; /* 'e' or 'E' */
   13c20:	e5d53024 	ldrb	r3, [r5, #36]	@ 0x24
                                    sprintf ((char *) p, "%+.2d", exponent);
   13c24:	e1a02004 	mov	r2, r4
   13c28:	e3091154 	movw	r1, #37204	@ 0x9154
                                *p++ = dp->conversion; /* 'e' or 'E' */
   13c2c:	e1a04006 	mov	r4, r6
                                    sprintf ((char *) p, "%+.2d", exponent);
   13c30:	e3401002 	movt	r1, #2
                                *p++ = dp->conversion; /* 'e' or 'E' */
   13c34:	e4c43001 	strb	r3, [r4], #1
                                    sprintf ((char *) p, "%+.2d", exponent);
   13c38:	e1a00004 	mov	r0, r4
   13c3c:	eb001693 	bl	19690 <sprintf>
                                    while (*p != '\0')
   13c40:	e5d63001 	ldrb	r3, [r6, #1]
   13c44:	e3530000 	cmp	r3, #0
   13c48:	0afffe3a 	beq	13538 <rpl_vasnprintf+0x2e18>
   13c4c:	e5f43001 	ldrb	r3, [r4, #1]!
   13c50:	e3530000 	cmp	r3, #0
   13c54:	1afffffc 	bne	13c4c <rpl_vasnprintf+0x352c>
   13c58:	eafffe36 	b	13538 <rpl_vasnprintf+0x2e18>
                    has_width = 1;
   13c5c:	e3a02001 	mov	r2, #1
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   13c60:	e3e04000 	mvn	r4, #0
                    has_width = 1;
   13c64:	e50b2ab0 	str	r2, [fp, #-2736]	@ 0xfffff550
   13c68:	eafff4ed 	b	11024 <rpl_vasnprintf+0x904>
   13c6c:	e3e06000 	mvn	r6, #0
   13c70:	eafff723 	b	11904 <rpl_vasnprintf+0x11e4>
        memory = (DCHAR_T *) realloc (result, (length + 1) * sizeof (DCHAR_T));
   13c74:	e1a00005 	mov	r0, r5
   13c78:	e1a01006 	mov	r1, r6
   13c7c:	ebffea70 	bl	e644 <rpl_realloc>
          result = memory;
   13c80:	e3500000 	cmp	r0, #0
   13c84:	11a05000 	movne	r5, r0
   13c88:	eafff920 	b	12110 <rpl_vasnprintf+0x19f0>
                      ENSURE_ALLOCATION (xsum (length, n));
   13c8c:	e37a0001 	cmn	sl, #1
   13c90:	0afff4cd 	beq	10fcc <rpl_vasnprintf+0x8ac>
                      ENSURE_ALLOCATION (xsum (length, characters));
   13c94:	e51b5a88 	ldr	r5, [fp, #-2696]	@ 0xfffff578
   13c98:	e50b5a9c 	str	r5, [fp, #-2716]	@ 0xfffff564
   13c9c:	eafff3d6 	b	10bfc <rpl_vasnprintf+0x4dc>
                        while (digitp != dp->precision_end)
   13ca0:	e3a03001 	mov	r3, #1
   13ca4:	e3a07021 	mov	r7, #33	@ 0x21
   13ca8:	e50b3a9c 	str	r3, [fp, #-2716]	@ 0xfffff564
   13cac:	eafff3cc 	b	10be4 <rpl_vasnprintf+0x4c4>
                    has_width = 1;
   13cb0:	e3a02001 	mov	r2, #1
   13cb4:	e50b0aa4 	str	r0, [fp, #-2724]	@ 0xfffff55c
   13cb8:	e50b2a9c 	str	r2, [fp, #-2716]	@ 0xfffff564
   13cbc:	eafff5ca 	b	113ec <rpl_vasnprintf+0xccc>
                      ENSURE_ALLOCATION (xsum (length, characters));
   13cc0:	e358000c 	cmp	r8, #12
   13cc4:	93a0a00c 	movls	sl, #12
   13cc8:	9afff49a 	bls	10f38 <rpl_vasnprintf+0x818>
   13ccc:	e3780001 	cmn	r8, #1
   13cd0:	13a03000 	movne	r3, #0
   13cd4:	03a03001 	moveq	r3, #1
   13cd8:	e1570008 	cmp	r7, r8
   13cdc:	83833001 	orrhi	r3, r3, #1
   13ce0:	e3530000 	cmp	r3, #0
   13ce4:	1afff3c4 	bne	10bfc <rpl_vasnprintf+0x4dc>
   13ce8:	e1a0a008 	mov	sl, r8
   13cec:	eafff491 	b	10f38 <rpl_vasnprintf+0x818>
    ENSURE_ALLOCATION (xsum (length, 1));
   13cf0:	e356000c 	cmp	r6, #12
   13cf4:	93a0900c 	movls	r9, #12
   13cf8:	9afff8f5 	bls	120d4 <rpl_vasnprintf+0x19b4>
   13cfc:	e3760001 	cmn	r6, #1
   13d00:	0afff3bc 	beq	10bf8 <rpl_vasnprintf+0x4d8>
   13d04:	e1a09006 	mov	r9, r6
   13d08:	eafff8f1 	b	120d4 <rpl_vasnprintf+0x19b4>
                    ENSURE_ALLOCATION (n);
   13d0c:	e3a0300c 	mov	r3, #12
   13d10:	eafffbfe 	b	12d10 <rpl_vasnprintf+0x25f0>
   13d14:	e1a04000 	mov	r4, r0
                  wchar_t arg = (wchar_t) a.arg[dp->arg_index].a.a_wide_char;
   13d18:	e5999008 	ldr	r9, [r9, #8]
                  if (has_width)
   13d1c:	eafff472 	b	10eec <rpl_vasnprintf+0x7cc>
                                  *p++ = decimal_point_char ();
   13d20:	e2893004 	add	r3, r9, #4
  sprintf (pointbuf, "%#.0f", 1.0);
   13d24:	e3091148 	movw	r1, #37192	@ 0x9148
                                  *p++ = decimal_point_char ();
   13d28:	e50b3a94 	str	r3, [fp, #-2708]	@ 0xfffff56c
  sprintf (pointbuf, "%#.0f", 1.0);
   13d2c:	e3a03000 	mov	r3, #0
   13d30:	e3433ff0 	movt	r3, #16368	@ 0x3ff0
   13d34:	e3401002 	movt	r1, #2
   13d38:	e24b0fba 	sub	r0, fp, #744	@ 0x2e8
   13d3c:	e3a02000 	mov	r2, #0
   13d40:	eb001652 	bl	19690 <sprintf>
  return (point[0] != '\0' ? point[0] : '.');
   13d44:	e55b32e7 	ldrb	r3, [fp, #-743]	@ 0xfffffd19
   13d48:	e3530000 	cmp	r3, #0
                                  *p++ = decimal_point_char ();
   13d4c:	03a0302e 	moveq	r3, #46	@ 0x2e
   13d50:	e5c93003 	strb	r3, [r9, #3]
                                      mantissa *= 16.0L;
   13d54:	ed1f6b5f 	vldr	d6, [pc, #-380]	@ 13be0 <rpl_vasnprintf+0x34c0>
   13d58:	e51b1a94 	ldr	r1, [fp, #-2708]	@ 0xfffff56c
   13d5c:	ee288b06 	vmul.f64	d8, d8, d6
                                      digit = (int) mantissa;
   13d60:	eefd7bc8 	vcvt.s32.f64	s15, d8
   13d64:	ee172a90 	vmov	r2, s15
                                      mantissa -= digit;
   13d68:	eeb87be7 	vcvt.f64.s32	d7, s15
                                             + (digit < 10
   13d6c:	e3520009 	cmp	r2, #9
   13d70:	c5d53024 	ldrbgt	r3, [r5, #36]	@ 0x24
   13d74:	d3a03030 	movle	r3, #48	@ 0x30
                                      mantissa -= digit;
   13d78:	ee388b47 	vsub.f64	d8, d8, d7
                                             + (digit < 10
   13d7c:	c243300a 	subgt	r3, r3, #10
   13d80:	c6ef3073 	uxtbgt	r3, r3
                                      if (precision > 0)
   13d84:	e3540000 	cmp	r4, #0
                                        precision--;
   13d88:	12444001 	subne	r4, r4, #1
                                             + (digit < 10
   13d8c:	e0833002 	add	r3, r3, r2
                                  while (mantissa > 0.0L)
   13d90:	eeb58bc0 	vcmpe.f64	d8, #0.0
   13d94:	eef1fa10 	vmrs	APSR_nzcv, fpscr
                                      *p++ = digit
   13d98:	e4c13001 	strb	r3, [r1], #1
                                  while (mantissa > 0.0L)
   13d9c:	caffffee 	bgt	13d5c <rpl_vasnprintf+0x363c>
   13da0:	e50b1a94 	str	r1, [fp, #-2708]	@ 0xfffff56c
                                  while (precision > 0)
   13da4:	e3540000 	cmp	r4, #0
   13da8:	0afff7f6 	beq	11d88 <rpl_vasnprintf+0x1668>
                                      *p++ = '0';
   13dac:	e51b9a94 	ldr	r9, [fp, #-2708]	@ 0xfffff56c
   13db0:	e1a02004 	mov	r2, r4
   13db4:	e3a01030 	mov	r1, #48	@ 0x30
   13db8:	e1a00009 	mov	r0, r9
   13dbc:	eb001a3b 	bl	1a6b0 <memset>
   13dc0:	e0893004 	add	r3, r9, r4
   13dc4:	eafff7ee 	b	11d84 <rpl_vasnprintf+0x1664>
                                  *p++ = decimal_point_char ();
   13dc8:	e2893004 	add	r3, r9, #4
  sprintf (pointbuf, "%#.0f", 1.0);
   13dcc:	e3091148 	movw	r1, #37192	@ 0x9148
                                  *p++ = decimal_point_char ();
   13dd0:	e50b3a94 	str	r3, [fp, #-2708]	@ 0xfffff56c
  sprintf (pointbuf, "%#.0f", 1.0);
   13dd4:	e3a03000 	mov	r3, #0
   13dd8:	e3433ff0 	movt	r3, #16368	@ 0x3ff0
   13ddc:	e3401002 	movt	r1, #2
   13de0:	e24b0fba 	sub	r0, fp, #744	@ 0x2e8
   13de4:	e3a02000 	mov	r2, #0
   13de8:	eb001628 	bl	19690 <sprintf>
  return (point[0] != '\0' ? point[0] : '.');
   13dec:	e55b32e7 	ldrb	r3, [fp, #-743]	@ 0xfffffd19
                                  while (mantissa > 0.0)
   13df0:	eeb58bc0 	vcmpe.f64	d8, #0.0
  return (point[0] != '\0' ? point[0] : '.');
   13df4:	e3530000 	cmp	r3, #0
   13df8:	03a0302e 	moveq	r3, #46	@ 0x2e
                                  while (mantissa > 0.0)
   13dfc:	eef1fa10 	vmrs	APSR_nzcv, fpscr
                                  *p++ = decimal_point_char ();
   13e00:	e5c93003 	strb	r3, [r9, #3]
                                  while (mantissa > 0.0)
   13e04:	cafffb4c 	bgt	12b3c <rpl_vasnprintf+0x241c>
   13e08:	eafffb5f 	b	12b8c <rpl_vasnprintf+0x246c>
   13e0c:	e50b0aa4 	str	r0, [fp, #-2724]	@ 0xfffff55c
   13e10:	eafff4e9 	b	111bc <rpl_vasnprintf+0xa9c>
                        else if (flags & FLAG_SPACE)
   13e14:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
                          *p++ = ' ';
   13e18:	e51b9a9c 	ldr	r9, [fp, #-2716]	@ 0xfffff564
                        else if (flags & FLAG_SPACE)
   13e1c:	e3130008 	tst	r3, #8
                          *p++ = ' ';
   13e20:	13a03020 	movne	r3, #32
   13e24:	14c93001 	strbne	r3, [r9], #1
   13e28:	eafffa3e 	b	12728 <rpl_vasnprintf+0x2008>
                                  *p++ = decimal_point_char ();
   13e2c:	e2893004 	add	r3, r9, #4
  sprintf (pointbuf, "%#.0f", 1.0);
   13e30:	e3091148 	movw	r1, #37192	@ 0x9148
                                  *p++ = decimal_point_char ();
   13e34:	e50b3a94 	str	r3, [fp, #-2708]	@ 0xfffff56c
  sprintf (pointbuf, "%#.0f", 1.0);
   13e38:	e3a03000 	mov	r3, #0
   13e3c:	e3433ff0 	movt	r3, #16368	@ 0x3ff0
   13e40:	e3401002 	movt	r1, #2
   13e44:	e24b0fba 	sub	r0, fp, #744	@ 0x2e8
   13e48:	e3a02000 	mov	r2, #0
   13e4c:	eb00160f 	bl	19690 <sprintf>
  return (point[0] != '\0' ? point[0] : '.');
   13e50:	e55b32e7 	ldrb	r3, [fp, #-743]	@ 0xfffffd19
   13e54:	e3530000 	cmp	r3, #0
                                  *p++ = decimal_point_char ();
   13e58:	03a0302e 	moveq	r3, #46	@ 0x2e
   13e5c:	e5c93003 	strb	r3, [r9, #3]
                                  while (precision > 0)
   13e60:	eafffb4b 	b	12b94 <rpl_vasnprintf+0x2474>
                    ENSURE_ALLOCATION (n);
   13e64:	e1a0000a 	mov	r0, sl
   13e68:	ebffe9e9 	bl	e614 <rpl_malloc>
   13e6c:	e2504000 	subs	r4, r0, #0
   13e70:	0afff35f 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   13e74:	e3580000 	cmp	r8, #0
   13e78:	0a000002 	beq	13e88 <rpl_vasnprintf+0x3768>
   13e7c:	e51b1a90 	ldr	r1, [fp, #-2704]	@ 0xfffff570
   13e80:	e1a02008 	mov	r2, r8
   13e84:	eb002ffd 	bl	1fe80 <memcpy>
   13e88:	e50b4a88 	str	r4, [fp, #-2696]	@ 0xfffff578
   13e8c:	eafffbae 	b	12d4c <rpl_vasnprintf+0x262c>
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   13e90:	e3e02000 	mvn	r2, #0
   13e94:	e50b2ab8 	str	r2, [fp, #-2744]	@ 0xfffff548
                    has_width = 1;
   13e98:	e3a02001 	mov	r2, #1
   13e9c:	e50b2ac8 	str	r2, [fp, #-2760]	@ 0xfffff538
   13ea0:	eafff3c4 	b	10db8 <rpl_vasnprintf+0x698>
                      for (remaining = characters; remaining > 0; )
   13ea4:	e1a07008 	mov	r7, r8
   13ea8:	eafff75e 	b	11c28 <rpl_vasnprintf+0x1508>
                                    if (q == 0)
   13eac:	e3540000 	cmp	r4, #0
   13eb0:	0a000007 	beq	13ed4 <rpl_vasnprintf+0x37b4>
                                    tail *= 16.0L;
   13eb4:	ed1f5bb7 	vldr	d5, [pc, #-732]	@ 13be0 <rpl_vasnprintf+0x34c0>
                                for (q = precision; ; q--)
   13eb8:	e1a02004 	mov	r2, r4
                                    tail *= 16.0L;
   13ebc:	ee288b05 	vmul.f64	d8, d8, d5
                                    if (q == 0)
   13ec0:	e2522001 	subs	r2, r2, #1
                                    int digit = (int) tail;
   13ec4:	eefd7bc8 	vcvt.s32.f64	s15, d8
                                    tail -= digit;
   13ec8:	eeb86be7 	vcvt.f64.s32	d6, s15
   13ecc:	ee388b46 	vsub.f64	d8, d8, d6
                                    if (q == 0)
   13ed0:	1afffff9 	bne	13ebc <rpl_vasnprintf+0x379c>
                                        if (digit & 1 ? tail >= 0.5L : tail > 0.5L)
   13ed4:	ee172a90 	vmov	r2, s15
   13ed8:	ed1f7bbe 	vldr	d7, [pc, #-760]	@ 13be8 <rpl_vasnprintf+0x34c8>
   13edc:	e3120001 	tst	r2, #1
   13ee0:	eeb48bc7 	vcmpe.f64	d8, d7
   13ee4:	0a00010e 	beq	14324 <rpl_vasnprintf+0x3c04>
   13ee8:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   13eec:	a3a02001 	movge	r2, #1
   13ef0:	b3a02000 	movlt	r2, #0
   13ef4:	e3520000 	cmp	r2, #0
   13ef8:	0a000107 	beq	1431c <rpl_vasnprintf+0x3bfc>
                                          tail = 1 - tail;
   13efc:	ed1f7bc5 	vldr	d7, [pc, #-788]	@ 13bf0 <rpl_vasnprintf+0x34d0>
   13f00:	ee378b48 	vsub.f64	d8, d7, d8
                                if (tail != 0.0L)
   13f04:	eeb58b40 	vcmp.f64	d8, #0.0
   13f08:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   13f0c:	1a0001e2 	bne	1469c <rpl_vasnprintf+0x3f7c>
                                mantissa += tail;
   13f10:	ee308b08 	vadd.f64	d8, d0, d8
                              digit = (int) mantissa;
   13f14:	eefd7bc8 	vcvt.s32.f64	s15, d8
                              mantissa -= digit;
   13f18:	eeb86be7 	vcvt.f64.s32	d6, s15
   13f1c:	ee388b46 	vsub.f64	d8, d8, d6
   13f20:	eafff786 	b	11d40 <rpl_vasnprintf+0x1620>
                                          tail = - tail;
   13f24:	eeb18b48 	vneg.f64	d8, d8
   13f28:	eafffeb8 	b	13a10 <rpl_vasnprintf+0x32f0>
                                        if (digit & 1 ? tail >= 0.5 : tail > 0.5)
   13f2c:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   13f30:	c3a02001 	movgt	r2, #1
   13f34:	d3a02000 	movle	r2, #0
   13f38:	eafffeb0 	b	13a00 <rpl_vasnprintf+0x32e0>
                      ENSURE_ALLOCATION (xsum (length, characters));
   13f3c:	e1a0000a 	mov	r0, sl
   13f40:	ebffe9b3 	bl	e614 <rpl_malloc>
   13f44:	e2503000 	subs	r3, r0, #0
   13f48:	e50b3a88 	str	r3, [fp, #-2696]	@ 0xfffff578
   13f4c:	0afff32a 	beq	10bfc <rpl_vasnprintf+0x4dc>
   13f50:	e3570000 	cmp	r7, #0
   13f54:	0afff401 	beq	10f60 <rpl_vasnprintf+0x840>
   13f58:	e51b1a90 	ldr	r1, [fp, #-2704]	@ 0xfffff570
   13f5c:	e1a02007 	mov	r2, r7
   13f60:	eb002fc6 	bl	1fe80 <memcpy>
   13f64:	eafff3fd 	b	10f60 <rpl_vasnprintf+0x840>
                          ENSURE_ALLOCATION (xsum (length, count));
   13f68:	e37a0001 	cmn	sl, #1
   13f6c:	1afff320 	bne	10bf4 <rpl_vasnprintf+0x4d4>
   13f70:	eafff81d 	b	11fec <rpl_vasnprintf+0x18cc>
   13f74:	e3e03000 	mvn	r3, #0
   13f78:	e50b3ac0 	str	r3, [fp, #-2752]	@ 0xfffff540
                        has_precision = 1;
   13f7c:	e3a03001 	mov	r3, #1
   13f80:	e50b3abc 	str	r3, [fp, #-2748]	@ 0xfffff544
   13f84:	eafff39d 	b	10e00 <rpl_vasnprintf+0x6e0>
    ENSURE_ALLOCATION (xsum (length, 1));
   13f88:	e1a00009 	mov	r0, r9
   13f8c:	ebffe9a0 	bl	e614 <rpl_malloc>
   13f90:	e2504000 	subs	r4, r0, #0
   13f94:	0afff317 	beq	10bf8 <rpl_vasnprintf+0x4d8>
   13f98:	e3570000 	cmp	r7, #0
   13f9c:	0a000002 	beq	13fac <rpl_vasnprintf+0x388c>
   13fa0:	e51b1a90 	ldr	r1, [fp, #-2704]	@ 0xfffff570
   13fa4:	e1a02007 	mov	r2, r7
   13fa8:	eb002fb4 	bl	1fe80 <memcpy>
   13fac:	e1a05004 	mov	r5, r4
   13fb0:	eafff850 	b	120f8 <rpl_vasnprintf+0x19d8>
                        while (p > pad_ptr)
   13fb4:	e1a07003 	mov	r7, r3
   13fb8:	eafff821 	b	12044 <rpl_vasnprintf+0x1924>
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   13fbc:	e3e02000 	mvn	r2, #0
   13fc0:	e50b2aa4 	str	r2, [fp, #-2724]	@ 0xfffff55c
                    has_width = 1;
   13fc4:	e3a02001 	mov	r2, #1
   13fc8:	e50b2a9c 	str	r2, [fp, #-2716]	@ 0xfffff564
   13fcc:	eafff506 	b	113ec <rpl_vasnprintf+0xccc>
  sprintf (pointbuf, "%#.0f", 1.0);
   13fd0:	e3091148 	movw	r1, #37192	@ 0x9148
   13fd4:	e3a03000 	mov	r3, #0
   13fd8:	e1a00006 	mov	r0, r6
   13fdc:	e3433ff0 	movt	r3, #16368	@ 0x3ff0
   13fe0:	e3401002 	movt	r1, #2
   13fe4:	e3a02000 	mov	r2, #0
   13fe8:	eb0015a8 	bl	19690 <sprintf>
  return (point[0] != '\0' ? point[0] : '.');
   13fec:	e55b35a3 	ldrb	r3, [fp, #-1443]	@ 0xfffffa5d
                                    *p++ = decimal_point_char ();
   13ff0:	e1a06004 	mov	r6, r4
  return (point[0] != '\0' ? point[0] : '.');
   13ff4:	e3530000 	cmp	r3, #0
   13ff8:	03a0302e 	moveq	r3, #46	@ 0x2e
                                    *p++ = decimal_point_char ();
   13ffc:	e4c63001 	strb	r3, [r6], #1
                                    for (; precision > ndigits; precision--)
   14000:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
   14004:	e1530007 	cmp	r3, r7
   14008:	2a00030d 	bcs	14c44 <rpl_vasnprintf+0x4524>
                                      *p++ = '0';
   1400c:	e0474003 	sub	r4, r7, r3
   14010:	e3a01030 	mov	r1, #48	@ 0x30
   14014:	e1a02004 	mov	r2, r4
   14018:	e0864004 	add	r4, r6, r4
   1401c:	e1a00006 	mov	r0, r6
   14020:	eb0019a2 	bl	1a6b0 <memset>
                                    while (ndigits > 0)
   14024:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
   14028:	e3530000 	cmp	r3, #0
   1402c:	0afffb75 	beq	12e08 <rpl_vasnprintf+0x26e8>
   14030:	e51b0ab0 	ldr	r0, [fp, #-2736]	@ 0xfffff550
   14034:	e2442001 	sub	r2, r4, #1
   14038:	e0803003 	add	r3, r0, r3
                                        *p++ = digits[ndigits];
   1403c:	e5731001 	ldrb	r1, [r3, #-1]!
                                    while (ndigits > 0)
   14040:	e1530000 	cmp	r3, r0
                                        *p++ = digits[ndigits];
   14044:	e5e21001 	strb	r1, [r2, #1]!
                                    while (ndigits > 0)
   14048:	1afffffb 	bne	1403c <rpl_vasnprintf+0x391c>
   1404c:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
   14050:	e0844003 	add	r4, r4, r3
   14054:	eafffb6b 	b	12e08 <rpl_vasnprintf+0x26e8>
                          arg_end++;
   14058:	e1a04005 	mov	r4, r5
   1405c:	e50b7aa8 	str	r7, [fp, #-2728]	@ 0xfffff558
   14060:	e51b5ab0 	ldr	r5, [fp, #-2736]	@ 0xfffff550
   14064:	eafff510 	b	114ac <rpl_vasnprintf+0xd8c>
   14068:	e3e04000 	mvn	r4, #0
   1406c:	eaffff29 	b	13d18 <rpl_vasnprintf+0x35f8>
                      ENSURE_ALLOCATION (xsum (length, n));
   14070:	e359000c 	cmp	r9, #12
   14074:	93a0a00c 	movls	sl, #12
   14078:	9afff6a8 	bls	11b20 <rpl_vasnprintf+0x1400>
   1407c:	e3790001 	cmn	r9, #1
   14080:	0afff2db 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   14084:	e1a0a009 	mov	sl, r9
   14088:	eafff6a4 	b	11b20 <rpl_vasnprintf+0x1400>
                      ENSURE_ALLOCATION (xsum (length, n));
   1408c:	e357000c 	cmp	r7, #12
   14090:	93a0a00c 	movls	sl, #12
   14094:	9afffc3e 	bls	13194 <rpl_vasnprintf+0x2a74>
   14098:	e3770001 	cmn	r7, #1
   1409c:	0afff2d4 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   140a0:	e1a0a007 	mov	sl, r7
   140a4:	eafffc3a 	b	13194 <rpl_vasnprintf+0x2a74>
                            if (xsum (count, pad) > allocated - length)
   140a8:	e1510006 	cmp	r1, r6
   140ac:	e1a02001 	mov	r2, r1
                            size_t pad = width - w;
   140b0:	e0417003 	sub	r7, r1, r3
                            if (xsum (count, pad) > allocated - length)
   140b4:	8a00011c 	bhi	1452c <rpl_vasnprintf+0x3e0c>
                                length -= count;
   140b8:	e51bca80 	ldr	ip, [fp, #-2688]	@ 0xfffff580
                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);
   140bc:	e5d9e000 	ldrb	lr, [r9]
                              DCHAR_T *p = rp + count;
   140c0:	e089300c 	add	r3, r9, ip
                              DCHAR_T * const rp = result + length;
   140c4:	e1a00009 	mov	r0, r9
                              DCHAR_T *end = p + pad;
   140c8:	e0836007 	add	r6, r3, r7
                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);
   140cc:	e35e002d 	cmp	lr, #45	@ 0x2d
                                             && rp[1] == 'x')
   140d0:	05d92001 	ldrbeq	r2, [r9, #1]
   140d4:	11a0200e 	movne	r2, lr
                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);
   140d8:	02891001 	addeq	r1, r9, #1
   140dc:	11a01009 	movne	r1, r9
                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))
   140e0:	e3c22020 	bic	r2, r2, #32
                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')
   140e4:	e2422041 	sub	r2, r2, #65	@ 0x41
   140e8:	e3520019 	cmp	r2, #25
                              count = count + pad; /* = end - rp */
   140ec:	e087200c 	add	r2, r7, ip
                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')
   140f0:	9a00011f 	bls	14574 <rpl_vasnprintf+0x3e54>
                                    if (p - rp >= 2
   140f4:	e35c0001 	cmp	ip, #1
   140f8:	da000001 	ble	14104 <rpl_vasnprintf+0x39e4>
                                        && *rp == '0'
   140fc:	e35e0030 	cmp	lr, #48	@ 0x30
   14100:	0a0002d1 	beq	14c4c <rpl_vasnprintf+0x452c>
                              if (flags & FLAG_LEFT)
   14104:	e51bcac4 	ldr	ip, [fp, #-2756]	@ 0xfffff53c
                              count = count + pad; /* = end - rp */
   14108:	e50b2a80 	str	r2, [fp, #-2688]	@ 0xfffff580
                              if (flags & FLAG_LEFT)
   1410c:	e35c0000 	cmp	ip, #0
   14110:	1a00011b 	bne	14584 <rpl_vasnprintf+0x3e64>
                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL
   14114:	e51b2a98 	ldr	r2, [fp, #-2712]	@ 0xfffff568
   14118:	e3120020 	tst	r2, #32
   1411c:	0a0000bb 	beq	14410 <rpl_vasnprintf+0x3cf0>
                                       && !(has_precision
   14120:	e51b2abc 	ldr	r2, [fp, #-2748]	@ 0xfffff544
   14124:	e3520000 	cmp	r2, #0
   14128:	0a00000b 	beq	1415c <rpl_vasnprintf+0x3a3c>
                                            && (dp->conversion == 'd'
   1412c:	e5d52024 	ldrb	r2, [r5, #36]	@ 0x24
                                       && !(has_precision
   14130:	e3520064 	cmp	r2, #100	@ 0x64
   14134:	13520069 	cmpne	r2, #105	@ 0x69
   14138:	0a0000b4 	beq	14410 <rpl_vasnprintf+0x3cf0>
   1413c:	e3520078 	cmp	r2, #120	@ 0x78
   14140:	8a000005 	bhi	1415c <rpl_vasnprintf+0x3a3c>
   14144:	e3520061 	cmp	r2, #97	@ 0x61
   14148:	8a0000a9 	bhi	143f4 <rpl_vasnprintf+0x3cd4>
   1414c:	e3520042 	cmp	r2, #66	@ 0x42
   14150:	0a0000ae 	beq	14410 <rpl_vasnprintf+0x3cf0>
   14154:	e3520058 	cmp	r2, #88	@ 0x58
   14158:	0a0000ac 	beq	14410 <rpl_vasnprintf+0x3cf0>
                                  while (p > pad_ptr)
   1415c:	e1530001 	cmp	r3, r1
   14160:	81a02006 	movhi	r2, r6
   14164:	9a000391 	bls	14fb0 <rpl_vasnprintf+0x4890>
                                    *--q = *--p;
   14168:	e5730001 	ldrb	r0, [r3, #-1]!
                                  while (p > pad_ptr)
   1416c:	e1530001 	cmp	r3, r1
                                    *--q = *--p;
   14170:	e5620001 	strb	r0, [r2, #-1]!
                                  while (p > pad_ptr)
   14174:	1afffffb 	bne	14168 <rpl_vasnprintf+0x3a48>
                                    *p++ = '0';
   14178:	e1a02007 	mov	r2, r7
   1417c:	e1a00001 	mov	r0, r1
   14180:	e3a01030 	mov	r1, #48	@ 0x30
   14184:	eb001949 	bl	1a6b0 <memset>
   14188:	eafffd7f 	b	1378c <rpl_vasnprintf+0x306c>
                          width = xsum (xtimes (width, 10), *digitp++ - '0');
   1418c:	e3e02000 	mvn	r2, #0
   14190:	e50b2aa4 	str	r2, [fp, #-2724]	@ 0xfffff55c
   14194:	eafff408 	b	111bc <rpl_vasnprintf+0xa9c>
                      ENSURE_ALLOCATION (xsum (length, n));
   14198:	bafffebd 	blt	13c94 <rpl_vasnprintf+0x3574>
   1419c:	e1a0a08a 	lsl	sl, sl, #1
   141a0:	e15a0004 	cmp	sl, r4
   141a4:	2afff37e 	bcs	10fa4 <rpl_vasnprintf+0x884>
   141a8:	e3740001 	cmn	r4, #1
   141ac:	0afffeb8 	beq	13c94 <rpl_vasnprintf+0x3574>
   141b0:	e1a0a004 	mov	sl, r4
   141b4:	eafff37a 	b	10fa4 <rpl_vasnprintf+0x884>
                                  *p++ = decimal_point_char ();
   141b8:	e2893004 	add	r3, r9, #4
  sprintf (pointbuf, "%#.0f", 1.0);
   141bc:	e3091148 	movw	r1, #37192	@ 0x9148
                                  *p++ = decimal_point_char ();
   141c0:	e50b3a94 	str	r3, [fp, #-2708]	@ 0xfffff56c
  sprintf (pointbuf, "%#.0f", 1.0);
   141c4:	e3a03000 	mov	r3, #0
   141c8:	e3433ff0 	movt	r3, #16368	@ 0x3ff0
   141cc:	e3401002 	movt	r1, #2
   141d0:	e24b0fba 	sub	r0, fp, #744	@ 0x2e8
   141d4:	e3a02000 	mov	r2, #0
   141d8:	eb00152c 	bl	19690 <sprintf>
  return (point[0] != '\0' ? point[0] : '.');
   141dc:	e55b32e7 	ldrb	r3, [fp, #-743]	@ 0xfffffd19
                                  while (mantissa > 0.0L)
   141e0:	eeb58bc0 	vcmpe.f64	d8, #0.0
  return (point[0] != '\0' ? point[0] : '.');
   141e4:	e3530000 	cmp	r3, #0
   141e8:	03a0302e 	moveq	r3, #46	@ 0x2e
                                  while (mantissa > 0.0L)
   141ec:	eef1fa10 	vmrs	APSR_nzcv, fpscr
                                  *p++ = decimal_point_char ();
   141f0:	e5c93003 	strb	r3, [r9, #3]
                                  while (mantissa > 0.0L)
   141f4:	cafffed6 	bgt	13d54 <rpl_vasnprintf+0x3634>
   141f8:	eafffee9 	b	13da4 <rpl_vasnprintf+0x3684>
                                  for (q = precision; q > 0; q--)
   141fc:	e3540000 	cmp	r4, #0
   14200:	0afffe05 	beq	13a1c <rpl_vasnprintf+0x32fc>
                                    tail *= 0.0625;
   14204:	ed9f7bef 	vldr	d7, [pc, #956]	@ 145c8 <rpl_vasnprintf+0x3ea8>
                                  for (q = precision; q > 0; q--)
   14208:	e1a02004 	mov	r2, r4
   1420c:	e2522001 	subs	r2, r2, #1
                                    tail *= 0.0625;
   14210:	ee288b07 	vmul.f64	d8, d8, d7
                                  for (q = precision; q > 0; q--)
   14214:	1afffffc 	bne	1420c <rpl_vasnprintf+0x3aec>
   14218:	eafffdff 	b	13a1c <rpl_vasnprintf+0x32fc>
   1421c:	e50b5a9c 	str	r5, [fp, #-2716]	@ 0xfffff564
   14220:	e51b5a88 	ldr	r5, [fp, #-2696]	@ 0xfffff578
   14224:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   14228:	e50b3a88 	str	r3, [fp, #-2696]	@ 0xfffff578
   1422c:	eafff681 	b	11c38 <rpl_vasnprintf+0x1518>
                                  *p++ = decimal_point_char ();
   14230:	e2893004 	add	r3, r9, #4
  sprintf (pointbuf, "%#.0f", 1.0);
   14234:	e3091148 	movw	r1, #37192	@ 0x9148
                                  *p++ = decimal_point_char ();
   14238:	e50b3a94 	str	r3, [fp, #-2708]	@ 0xfffff56c
  sprintf (pointbuf, "%#.0f", 1.0);
   1423c:	e3a03000 	mov	r3, #0
   14240:	e3433ff0 	movt	r3, #16368	@ 0x3ff0
   14244:	e3401002 	movt	r1, #2
   14248:	e24b0fba 	sub	r0, fp, #744	@ 0x2e8
   1424c:	e3a02000 	mov	r2, #0
   14250:	eb00150e 	bl	19690 <sprintf>
  return (point[0] != '\0' ? point[0] : '.');
   14254:	e55b32e7 	ldrb	r3, [fp, #-743]	@ 0xfffffd19
   14258:	e3530000 	cmp	r3, #0
                                  *p++ = decimal_point_char ();
   1425c:	03a0302e 	moveq	r3, #46	@ 0x2e
   14260:	e5c93003 	strb	r3, [r9, #3]
                                  while (precision > 0)
   14264:	eafffed0 	b	13dac <rpl_vasnprintf+0x368c>
   14268:	e3e07000 	mvn	r7, #0
   1426c:	eafff3e1 	b	111f8 <rpl_vasnprintf+0xad8>
                      ENSURE_ALLOCATION (xsum (length, n));
   14270:	e1a0000a 	mov	r0, sl
   14274:	e50b3a9c 	str	r3, [fp, #-2716]	@ 0xfffff564
   14278:	ebffe8e5 	bl	e614 <rpl_malloc>
   1427c:	e2503000 	subs	r3, r0, #0
   14280:	e50b3a94 	str	r3, [fp, #-2708]	@ 0xfffff56c
   14284:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   14288:	0afff259 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   1428c:	e3580000 	cmp	r8, #0
   14290:	0a000004 	beq	142a8 <rpl_vasnprintf+0x3b88>
   14294:	e51b1a90 	ldr	r1, [fp, #-2704]	@ 0xfffff570
   14298:	e1a02008 	mov	r2, r8
   1429c:	e50b3a88 	str	r3, [fp, #-2696]	@ 0xfffff578
   142a0:	eb002ef6 	bl	1fe80 <memcpy>
   142a4:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
   142a8:	e51b2a94 	ldr	r2, [fp, #-2708]	@ 0xfffff56c
   142ac:	e50b2a88 	str	r2, [fp, #-2696]	@ 0xfffff578
   142b0:	eafffbc3 	b	131c4 <rpl_vasnprintf+0x2aa4>
                      ENSURE_ALLOCATION (xsum (length, n));
   142b4:	e1a0000a 	mov	r0, sl
   142b8:	ebffe8d5 	bl	e614 <rpl_malloc>
   142bc:	e2503000 	subs	r3, r0, #0
   142c0:	e50b3ab8 	str	r3, [fp, #-2744]	@ 0xfffff548
   142c4:	0afff24a 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   142c8:	e3580000 	cmp	r8, #0
   142cc:	0a000002 	beq	142dc <rpl_vasnprintf+0x3bbc>
   142d0:	e51b1a90 	ldr	r1, [fp, #-2704]	@ 0xfffff570
   142d4:	e1a02008 	mov	r2, r8
   142d8:	eb002ee8 	bl	1fe80 <memcpy>
   142dc:	e51b3ab8 	ldr	r3, [fp, #-2744]	@ 0xfffff548
   142e0:	e50b3a88 	str	r3, [fp, #-2696]	@ 0xfffff578
   142e4:	eafff617 	b	11b48 <rpl_vasnprintf+0x1428>
   142e8:	e51b1ab0 	ldr	r1, [fp, #-2736]	@ 0xfffff550
   142ec:	e2492001 	sub	r2, r9, #1
   142f0:	e0813003 	add	r3, r1, r3
   142f4:	e0810007 	add	r0, r1, r7
                                      *p++ = digits[ndigits];
   142f8:	e5731001 	ldrb	r1, [r3, #-1]!
                                  while (ndigits > precision);
   142fc:	e1530000 	cmp	r3, r0
                                      *p++ = digits[ndigits];
   14300:	e5e21001 	strb	r1, [r2, #1]!
                                  while (ndigits > precision);
   14304:	1afffffb 	bne	142f8 <rpl_vasnprintf+0x3bd8>
   14308:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
                                      --ndigits;
   1430c:	e50b7a94 	str	r7, [fp, #-2708]	@ 0xfffff56c
   14310:	e0434007 	sub	r4, r3, r7
   14314:	e0894004 	add	r4, r9, r4
   14318:	eafffab6 	b	12df8 <rpl_vasnprintf+0x26d8>
                                          tail = - tail;
   1431c:	eeb18b48 	vneg.f64	d8, d8
   14320:	eafffef7 	b	13f04 <rpl_vasnprintf+0x37e4>
                                        if (digit & 1 ? tail >= 0.5L : tail > 0.5L)
   14324:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   14328:	c3a02001 	movgt	r2, #1
   1432c:	d3a02000 	movle	r2, #0
   14330:	eafffeef 	b	13ef4 <rpl_vasnprintf+0x37d4>
  sprintf (pointbuf, "%#.0f", 1.0);
   14334:	e3091148 	movw	r1, #37192	@ 0x9148
   14338:	e24b0e5a 	sub	r0, fp, #1440	@ 0x5a0
   1433c:	e3a03000 	mov	r3, #0
   14340:	e3401002 	movt	r1, #2
   14344:	e3433ff0 	movt	r3, #16368	@ 0x3ff0
   14348:	e2400004 	sub	r0, r0, #4
   1434c:	e3a02000 	mov	r2, #0
                                        *p++ = decimal_point_char ();
   14350:	e2896002 	add	r6, r9, #2
  sprintf (pointbuf, "%#.0f", 1.0);
   14354:	eb0014cd 	bl	19690 <sprintf>
  return (point[0] != '\0' ? point[0] : '.');
   14358:	e55b35a3 	ldrb	r3, [fp, #-1443]	@ 0xfffffa5d
   1435c:	e3530000 	cmp	r3, #0
   14360:	03a0302e 	moveq	r3, #46	@ 0x2e
                                        for (; precision > 0; precision--)
   14364:	e3570000 	cmp	r7, #0
                                        *p++ = decimal_point_char ();
   14368:	e5c93001 	strb	r3, [r9, #1]
                                        for (; precision > 0; precision--)
   1436c:	0a00026d 	beq	14d28 <rpl_vasnprintf+0x4608>
                                          *p++ = '0';
   14370:	e1a00006 	mov	r0, r6
   14374:	e1a01004 	mov	r1, r4
   14378:	e1a02007 	mov	r2, r7
   1437c:	e0866007 	add	r6, r6, r7
   14380:	eb0018ca 	bl	1a6b0 <memset>
                                    exponent = 0;
   14384:	e3a03000 	mov	r3, #0
   14388:	e50b3ab0 	str	r3, [fp, #-2736]	@ 0xfffff550
   1438c:	eafffc5c 	b	13504 <rpl_vasnprintf+0x2de4>
                      ENSURE_ALLOCATION (xsum (length, n));
   14390:	e1a0000a 	mov	r0, sl
   14394:	ebffe89e 	bl	e614 <rpl_malloc>
   14398:	e2508000 	subs	r8, r0, #0
   1439c:	0afffe3c 	beq	13c94 <rpl_vasnprintf+0x3574>
   143a0:	e3570000 	cmp	r7, #0
   143a4:	0a000002 	beq	143b4 <rpl_vasnprintf+0x3c94>
   143a8:	e51b1a90 	ldr	r1, [fp, #-2704]	@ 0xfffff570
   143ac:	e1a02007 	mov	r2, r7
   143b0:	eb002eb2 	bl	1fe80 <memcpy>
   143b4:	e50b8a88 	str	r8, [fp, #-2696]	@ 0xfffff578
   143b8:	eafff303 	b	10fcc <rpl_vasnprintf+0x8ac>
                      ENSURE_ALLOCATION (xsum (length, n));
   143bc:	e354000c 	cmp	r4, #12
   143c0:	93a0a00c 	movls	sl, #12
   143c4:	9afff62d 	bls	11c80 <rpl_vasnprintf+0x1560>
   143c8:	e3740001 	cmn	r4, #1
   143cc:	0afff208 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   143d0:	e1a0a004 	mov	sl, r4
   143d4:	eafff629 	b	11c80 <rpl_vasnprintf+0x1560>
                          ENSURE_ALLOCATION (xsum (length, count));
   143d8:	e353000c 	cmp	r3, #12
   143dc:	93a0a00c 	movls	sl, #12
   143e0:	9afff6f7 	bls	11fc4 <rpl_vasnprintf+0x18a4>
   143e4:	e3730001 	cmn	r3, #1
   143e8:	0afff201 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   143ec:	e1a0a003 	mov	sl, r3
   143f0:	eafff6f3 	b	11fc4 <rpl_vasnprintf+0x18a4>
   143f4:	e2422062 	sub	r2, r2, #98	@ 0x62
   143f8:	e302c001 	movw	ip, #8193	@ 0x2001
   143fc:	e6ef2072 	uxtb	r2, r2
   14400:	e340c048 	movt	ip, #72	@ 0x48
   14404:	e1a0c23c 	lsr	ip, ip, r2
   14408:	e31c0001 	tst	ip, #1
   1440c:	0affff52 	beq	1415c <rpl_vasnprintf+0x3a3c>
                                  while (p > rp)
   14410:	e1590003 	cmp	r9, r3
   14414:	31a02006 	movcc	r2, r6
   14418:	2a000226 	bcs	14cb8 <rpl_vasnprintf+0x4598>
                                    *--q = *--p;
   1441c:	e5731001 	ldrb	r1, [r3, #-1]!
                                  while (p > rp)
   14420:	e1590003 	cmp	r9, r3
                                    *--q = *--p;
   14424:	e5621001 	strb	r1, [r2, #-1]!
                                  while (p > rp)
   14428:	1afffffb 	bne	1441c <rpl_vasnprintf+0x3cfc>
                                    *p++ = ' ';
   1442c:	e1a02007 	mov	r2, r7
   14430:	e3a01020 	mov	r1, #32
   14434:	eb00189d 	bl	1a6b0 <memset>
   14438:	eafffcd3 	b	1378c <rpl_vasnprintf+0x306c>
  sprintf (pointbuf, "%#.0f", 1.0);
   1443c:	e3091148 	movw	r1, #37192	@ 0x9148
   14440:	e24b0e5a 	sub	r0, fp, #1440	@ 0x5a0
   14444:	e3a03000 	mov	r3, #0
   14448:	e3401002 	movt	r1, #2
   1444c:	e3433ff0 	movt	r3, #16368	@ 0x3ff0
   14450:	e2400004 	sub	r0, r0, #4
   14454:	e3a02000 	mov	r2, #0
   14458:	eb00148c 	bl	19690 <sprintf>
  return (point[0] != '\0' ? point[0] : '.');
   1445c:	e55b35a3 	ldrb	r3, [fp, #-1443]	@ 0xfffffa5d
   14460:	e3530000 	cmp	r3, #0
   14464:	03a0302e 	moveq	r3, #46	@ 0x2e
                                    *p++ = decimal_point_char ();
   14468:	e4c43001 	strb	r3, [r4], #1
                                    for (; precision > ndigits; precision--)
   1446c:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
   14470:	e1530007 	cmp	r3, r7
   14474:	2a000005 	bcs	14490 <rpl_vasnprintf+0x3d70>
                                      *p++ = '0';
   14478:	e0477003 	sub	r7, r7, r3
   1447c:	e1a00004 	mov	r0, r4
   14480:	e0844007 	add	r4, r4, r7
   14484:	e3a01030 	mov	r1, #48	@ 0x30
   14488:	e1a02007 	mov	r2, r7
   1448c:	eb001887 	bl	1a6b0 <memset>
                                    while (ndigits > 0)
   14490:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
   14494:	e3530000 	cmp	r3, #0
   14498:	0afffadc 	beq	13010 <rpl_vasnprintf+0x28f0>
   1449c:	e0863003 	add	r3, r6, r3
   144a0:	e2442001 	sub	r2, r4, #1
                                        *p++ = digits[ndigits];
   144a4:	e5731001 	ldrb	r1, [r3, #-1]!
                                    while (ndigits > 0)
   144a8:	e1560003 	cmp	r6, r3
                                        *p++ = digits[ndigits];
   144ac:	e5e21001 	strb	r1, [r2, #1]!
                                    while (ndigits > 0)
   144b0:	1afffffb 	bne	144a4 <rpl_vasnprintf+0x3d84>
   144b4:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
   144b8:	e0844003 	add	r4, r4, r3
                                free (digits);
   144bc:	eafffad3 	b	13010 <rpl_vasnprintf+0x28f0>
                        for (rc = count; rc > 0; rc--, rp++)
   144c0:	e3570000 	cmp	r7, #0
   144c4:	0afffcb4 	beq	1379c <rpl_vasnprintf+0x307c>
   144c8:	e2477001 	sub	r7, r7, #1
   144cc:	e2493001 	sub	r3, r9, #1
   144d0:	e0891007 	add	r1, r9, r7
                          if (*rp >= 'a' && *rp <= 'z')
   144d4:	e5f32001 	ldrb	r2, [r3, #1]!
   144d8:	e2420061 	sub	r0, r2, #97	@ 0x61
   144dc:	e3500019 	cmp	r0, #25
                            *rp = *rp - 'a' + 'A';
   144e0:	92422020 	subls	r2, r2, #32
   144e4:	95c32000 	strbls	r2, [r3]
                        for (rc = count; rc > 0; rc--, rp++)
   144e8:	e1530001 	cmp	r3, r1
   144ec:	1afffff8 	bne	144d4 <rpl_vasnprintf+0x3db4>
   144f0:	e51b7a80 	ldr	r7, [fp, #-2688]	@ 0xfffff580
   144f4:	eafffca8 	b	1379c <rpl_vasnprintf+0x307c>
                      ENSURE_ALLOCATION (xsum (length, n));
   144f8:	e1a0000a 	mov	r0, sl
   144fc:	ebffe844 	bl	e614 <rpl_malloc>
   14500:	e2506000 	subs	r6, r0, #0
   14504:	0afff1ba 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   14508:	e3570000 	cmp	r7, #0
   1450c:	0a000002 	beq	1451c <rpl_vasnprintf+0x3dfc>
   14510:	e51b1a90 	ldr	r1, [fp, #-2704]	@ 0xfffff570
   14514:	e1a02007 	mov	r2, r7
   14518:	eb002e58 	bl	1fe80 <memcpy>
   1451c:	e50b6a88 	str	r6, [fp, #-2696]	@ 0xfffff578
   14520:	eafff5e0 	b	11ca8 <rpl_vasnprintf+0x1588>
                        while (p > pad_ptr)
   14524:	e1a09004 	mov	r9, r4
   14528:	eafffc78 	b	13710 <rpl_vasnprintf+0x2ff0>
  size_t sum = size1 + size2;
   1452c:	e0986003 	adds	r6, r8, r3
   14530:	2a000146 	bcs	14a50 <rpl_vasnprintf+0x4330>
   14534:	e51b3ab8 	ldr	r3, [fp, #-2744]	@ 0xfffff548
   14538:	e0883003 	add	r3, r8, r3
  return (sum >= size1 ? sum : SIZE_MAX);
   1453c:	e1560003 	cmp	r6, r3
   14540:	8a000142 	bhi	14a50 <rpl_vasnprintf+0x4330>
                                  xmax (xsum3 (length, count, pad),
   14544:	e35a0000 	cmp	sl, #0
   14548:	ba000142 	blt	14a58 <rpl_vasnprintf+0x4338>
   1454c:	e1a0208a 	lsl	r2, sl, #1
  return (size1 >= size2 ? size1 : size2);
   14550:	e1520003 	cmp	r2, r3
   14554:	21a03002 	movcs	r3, r2
                                ENSURE_ALLOCATION (n);
   14558:	e15a0003 	cmp	sl, r3
   1455c:	3a0001df 	bcc	14ce0 <rpl_vasnprintf+0x45c0>
                                length -= count;
   14560:	e51bca80 	ldr	ip, [fp, #-2688]	@ 0xfffff580
   14564:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   14568:	e046800c 	sub	r8, r6, ip
   1456c:	e0839008 	add	r9, r3, r8
   14570:	eafffed1 	b	140bc <rpl_vasnprintf+0x399c>
                              if (flags & FLAG_LEFT)
   14574:	e51b1ac4 	ldr	r1, [fp, #-2756]	@ 0xfffff53c
                              count = count + pad; /* = end - rp */
   14578:	e50b2a80 	str	r2, [fp, #-2688]	@ 0xfffff580
                              if (flags & FLAG_LEFT)
   1457c:	e3510000 	cmp	r1, #0
   14580:	0affffa2 	beq	14410 <rpl_vasnprintf+0x3cf0>
                                    *p++ = ' ';
   14584:	e1a02007 	mov	r2, r7
   14588:	e1a00003 	mov	r0, r3
   1458c:	e3a01020 	mov	r1, #32
   14590:	eb001846 	bl	1a6b0 <memset>
   14594:	eafffc7c 	b	1378c <rpl_vasnprintf+0x306c>
                          ENSURE_ALLOCATION (xsum (length, count));
   14598:	e1a0000a 	mov	r0, sl
   1459c:	ebffe81c 	bl	e614 <rpl_malloc>
   145a0:	e2506000 	subs	r6, r0, #0
   145a4:	0afff192 	beq	10bf4 <rpl_vasnprintf+0x4d4>
   145a8:	e3580000 	cmp	r8, #0
   145ac:	0a000002 	beq	145bc <rpl_vasnprintf+0x3e9c>
   145b0:	e51b1a90 	ldr	r1, [fp, #-2704]	@ 0xfffff570
   145b4:	e1a02008 	mov	r2, r8
   145b8:	eb002e30 	bl	1fe80 <memcpy>
   145bc:	e50b6a88 	str	r6, [fp, #-2696]	@ 0xfffff578
   145c0:	eafff689 	b	11fec <rpl_vasnprintf+0x18cc>
   145c4:	e320f000 	nop	{0}
   145c8:	00000000 	.word	0x00000000
   145cc:	3fb00000 	.word	0x3fb00000
   145d0:	00029e2c 	.word	0x00029e2c
  for (; precision > 0; precision--, digits++)
   145d4:	e3570000 	cmp	r7, #0
   145d8:	e50b5ab8 	str	r5, [fp, #-2744]	@ 0xfffff548
   145dc:	e50baabc 	str	sl, [fp, #-2748]	@ 0xfffff544
   145e0:	e50b8ab0 	str	r8, [fp, #-2736]	@ 0xfffff550
   145e4:	e51b9ac4 	ldr	r9, [fp, #-2756]	@ 0xfffff53c
   145e8:	e51baac8 	ldr	sl, [fp, #-2760]	@ 0xfffff538
   145ec:	e51b5ac0 	ldr	r5, [fp, #-2752]	@ 0xfffff540
   145f0:	e51b8acc 	ldr	r8, [fp, #-2764]	@ 0xfffff534
   145f4:	e51b2a94 	ldr	r2, [fp, #-2708]	@ 0xfffff56c
   145f8:	051b3ab8 	ldreq	r3, [fp, #-2744]	@ 0xfffff548
   145fc:	0a00005c 	beq	14774 <rpl_vasnprintf+0x4054>
   14600:	e51b1ab8 	ldr	r1, [fp, #-2744]	@ 0xfffff548
   14604:	e1a03001 	mov	r3, r1
   14608:	e0810007 	add	r0, r1, r7
   1460c:	ea000001 	b	14618 <rpl_vasnprintf+0x3ef8>
   14610:	e1530000 	cmp	r3, r0
   14614:	0a000056 	beq	14774 <rpl_vasnprintf+0x4054>
    if (*digits != '0')
   14618:	e4d31001 	ldrb	r1, [r3], #1
   1461c:	e3510030 	cmp	r1, #48	@ 0x30
   14620:	0afffffa 	beq	14610 <rpl_vasnprintf+0x3ef0>
                                    *p++ = digits[--ndigits];
   14624:	e51b2ab8 	ldr	r2, [fp, #-2744]	@ 0xfffff548
   14628:	e2444001 	sub	r4, r4, #1
   1462c:	e7d23004 	ldrb	r3, [r2, r4]
   14630:	e0827004 	add	r7, r2, r4
   14634:	e5c93000 	strb	r3, [r9]
  sprintf (pointbuf, "%#.0f", 1.0);
   14638:	e3091148 	movw	r1, #37192	@ 0x9148
   1463c:	e3a03000 	mov	r3, #0
   14640:	e1a00006 	mov	r0, r6
   14644:	e3433ff0 	movt	r3, #16368	@ 0x3ff0
   14648:	e3401002 	movt	r1, #2
   1464c:	e3a02000 	mov	r2, #0
   14650:	eb00140e 	bl	19690 <sprintf>
  return (point[0] != '\0' ? point[0] : '.');
   14654:	e55b35a3 	ldrb	r3, [fp, #-1443]	@ 0xfffffa5d
                                        *p++ = decimal_point_char ();
   14658:	e2896002 	add	r6, r9, #2
  return (point[0] != '\0' ? point[0] : '.');
   1465c:	e3530000 	cmp	r3, #0
   14660:	03a0302e 	moveq	r3, #46	@ 0x2e
                                        while (ndigits > 0)
   14664:	e3540000 	cmp	r4, #0
                                        *p++ = decimal_point_char ();
   14668:	e5c93001 	strb	r3, [r9, #1]
                                        while (ndigits > 0)
   1466c:	0a000007 	beq	14690 <rpl_vasnprintf+0x3f70>
   14670:	e51b0ab8 	ldr	r0, [fp, #-2744]	@ 0xfffff548
   14674:	e1a03007 	mov	r3, r7
   14678:	e2892001 	add	r2, r9, #1
                                            *p++ = digits[ndigits];
   1467c:	e5731001 	ldrb	r1, [r3, #-1]!
                                        while (ndigits > 0)
   14680:	e1530000 	cmp	r3, r0
                                            *p++ = digits[ndigits];
   14684:	e5e21001 	strb	r1, [r2, #1]!
                                        while (ndigits > 0)
   14688:	1afffffb 	bne	1467c <rpl_vasnprintf+0x3f5c>
   1468c:	e0866004 	add	r6, r6, r4
                                    free (digits);
   14690:	e51b0ab8 	ldr	r0, [fp, #-2744]	@ 0xfffff548
   14694:	ebffd76f 	bl	a458 <rpl_free>
   14698:	eafffb99 	b	13504 <rpl_vasnprintf+0x2de4>
                                  for (q = precision; q > 0; q--)
   1469c:	e3540000 	cmp	r4, #0
   146a0:	0afffe1a 	beq	13f10 <rpl_vasnprintf+0x37f0>
                                    tail *= 0.0625L;
   146a4:	ed1f7b39 	vldr	d7, [pc, #-228]	@ 145c8 <rpl_vasnprintf+0x3ea8>
                                  for (q = precision; q > 0; q--)
   146a8:	e1a02004 	mov	r2, r4
   146ac:	e2522001 	subs	r2, r2, #1
                                    tail *= 0.0625L;
   146b0:	ee288b07 	vmul.f64	d8, d8, d7
                                  for (q = precision; q > 0; q--)
   146b4:	1afffffc 	bne	146ac <rpl_vasnprintf+0x3f8c>
   146b8:	eafffe14 	b	13f10 <rpl_vasnprintf+0x37f0>
  sprintf (pointbuf, "%#.0f", 1.0);
   146bc:	e3091148 	movw	r1, #37192	@ 0x9148
   146c0:	e24b0e5a 	sub	r0, fp, #1440	@ 0x5a0
   146c4:	e3a03000 	mov	r3, #0
   146c8:	e3401002 	movt	r1, #2
   146cc:	e3433ff0 	movt	r3, #16368	@ 0x3ff0
   146d0:	e2400004 	sub	r0, r0, #4
   146d4:	e3a02000 	mov	r2, #0
                                        *p++ = decimal_point_char ();
   146d8:	e2896002 	add	r6, r9, #2
  sprintf (pointbuf, "%#.0f", 1.0);
   146dc:	eb0013eb 	bl	19690 <sprintf>
  return (point[0] != '\0' ? point[0] : '.');
   146e0:	e55b35a3 	ldrb	r3, [fp, #-1443]	@ 0xfffffa5d
   146e4:	e3530000 	cmp	r3, #0
   146e8:	03a0302e 	moveq	r3, #46	@ 0x2e
                                        for (; precision > 0; precision--)
   146ec:	e3570000 	cmp	r7, #0
                                        *p++ = decimal_point_char ();
   146f0:	e5c93001 	strb	r3, [r9, #1]
                                        for (; precision > 0; precision--)
   146f4:	0a000171 	beq	14cc0 <rpl_vasnprintf+0x45a0>
                                          *p++ = '0';
   146f8:	e1a00006 	mov	r0, r6
   146fc:	e3a01030 	mov	r1, #48	@ 0x30
   14700:	e1a02007 	mov	r2, r7
   14704:	e0866007 	add	r6, r6, r7
                                    exponent = 0;
   14708:	e3a04000 	mov	r4, #0
                                          *p++ = '0';
   1470c:	eb0017e7 	bl	1a6b0 <memset>
   14710:	eafffd42 	b	13c20 <rpl_vasnprintf+0x3500>
   14714:	e0863003 	add	r3, r6, r3
   14718:	e2492001 	sub	r2, r9, #1
   1471c:	e0860007 	add	r0, r6, r7
                                      *p++ = digits[ndigits];
   14720:	e5731001 	ldrb	r1, [r3, #-1]!
                                  while (ndigits > precision);
   14724:	e1530000 	cmp	r3, r0
                                      *p++ = digits[ndigits];
   14728:	e5e21001 	strb	r1, [r2, #1]!
                                  while (ndigits > precision);
   1472c:	1afffffb 	bne	14720 <rpl_vasnprintf+0x4000>
   14730:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
                                      --ndigits;
   14734:	e50b7a94 	str	r7, [fp, #-2708]	@ 0xfffff56c
   14738:	e0434007 	sub	r4, r3, r7
   1473c:	e0894004 	add	r4, r9, r4
   14740:	eafffa2e 	b	13000 <rpl_vasnprintf+0x28e0>
                  const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;
   14744:	e5993008 	ldr	r3, [r9, #8]
                      characters = 0;
   14748:	e3a04000 	mov	r4, #0
                  const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;
   1474c:	e50b3aa8 	str	r3, [fp, #-2728]	@ 0xfffff558
   14750:	e50b3a94 	str	r3, [fp, #-2708]	@ 0xfffff56c
   14754:	eafff354 	b	114ac <rpl_vasnprintf+0xd8c>
                      arg_end = arg;
   14758:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
                      characters = 0;
   1475c:	e1a04001 	mov	r4, r1
                      arg_end = arg;
   14760:	e50b3aa8 	str	r3, [fp, #-2728]	@ 0xfffff558
   14764:	eafffc91 	b	139b0 <rpl_vasnprintf+0x3290>
                        precision = 0;
   14768:	e3a07000 	mov	r7, #0
                        while (digitp != dp->precision_end)
   1476c:	e3a04010 	mov	r4, #16
   14770:	eafff2a3 	b	11204 <rpl_vasnprintf+0xae4>
  if (*digits != '1')
   14774:	e5d31000 	ldrb	r1, [r3]
   14778:	e3510031 	cmp	r1, #49	@ 0x31
   1477c:	1a000016 	bne	147dc <rpl_vasnprintf+0x40bc>
                                    if (is_borderline (digits, precision))
   14780:	e5d33001 	ldrb	r3, [r3, #1]
   14784:	e3530000 	cmp	r3, #0
   14788:	1a000013 	bne	147dc <rpl_vasnprintf+0x40bc>
  void *memory = decode_double (x, &e, &m);
   1478c:	e1a00002 	mov	r0, r2
   14790:	eeb00b48 	vmov.f64	d0, d8
   14794:	e1a01006 	mov	r1, r6
   14798:	ebffeb44 	bl	f4b0 <decode_double>
  if (memory != NULL)
   1479c:	e2503000 	subs	r3, r0, #0
   147a0:	0a000214 	beq	14ff8 <rpl_vasnprintf+0x48d8>
                                          scale10_round_decimal_double (arg,
   147a4:	e51b2abc 	ldr	r2, [fp, #-2748]	@ 0xfffff544
   147a8:	e2822001 	add	r2, r2, #1
    return scale10_round_decimal_decoded (e, m, memory, n);
   147ac:	e58d2000 	str	r2, [sp]
   147b0:	e51b0860 	ldr	r0, [fp, #-2144]	@ 0xfffff7a0
   147b4:	e8960006 	ldm	r6, {r1, r2}
   147b8:	ebffecfe 	bl	fbb8 <scale10_round_decimal_decoded>
                                        if (digits2 == NULL)
   147bc:	e2503000 	subs	r3, r0, #0
   147c0:	e50b3a94 	str	r3, [fp, #-2708]	@ 0xfffff56c
   147c4:	0a00020b 	beq	14ff8 <rpl_vasnprintf+0x48d8>
                                        if (strlen (digits2) == precision + 1)
   147c8:	fa002f2c 	blx	20480 <strlen>
   147cc:	e1500004 	cmp	r0, r4
   147d0:	0a000194 	beq	14e28 <rpl_vasnprintf+0x4708>
                                          free (digits2);
   147d4:	e51b0a94 	ldr	r0, [fp, #-2708]	@ 0xfffff56c
   147d8:	ebffd71e 	bl	a458 <rpl_free>
                                    if ((flags & FLAG_ALT) || precision > 0)
   147dc:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
                                    *p++ = digits[--ndigits];
   147e0:	e2444001 	sub	r4, r4, #1
   147e4:	e51b2ab8 	ldr	r2, [fp, #-2744]	@ 0xfffff548
                                    if ((flags & FLAG_ALT) || precision > 0)
   147e8:	e2033010 	and	r3, r3, #16
   147ec:	e1933007 	orrs	r3, r3, r7
                                    *p++ = digits[--ndigits];
   147f0:	e7d23004 	ldrb	r3, [r2, r4]
   147f4:	e0827004 	add	r7, r2, r4
   147f8:	02896001 	addeq	r6, r9, #1
   147fc:	e5c93000 	strb	r3, [r9]
                                    if ((flags & FLAG_ALT) || precision > 0)
   14800:	0affffa2 	beq	14690 <rpl_vasnprintf+0x3f70>
   14804:	eaffff8b 	b	14638 <rpl_vasnprintf+0x3f18>
  for (; precision > 0; precision--, digits++)
   14808:	e3540000 	cmp	r4, #0
   1480c:	e1a0000a 	mov	r0, sl
   14810:	e50b8abc 	str	r8, [fp, #-2748]	@ 0xfffff544
   14814:	e51b5ac4 	ldr	r5, [fp, #-2756]	@ 0xfffff53c
   14818:	e51b9ac8 	ldr	r9, [fp, #-2760]	@ 0xfffff538
   1481c:	e51baacc 	ldr	sl, [fp, #-2764]	@ 0xfffff534
   14820:	e51b8ad0 	ldr	r8, [fp, #-2768]	@ 0xfffff530
   14824:	e51b2a94 	ldr	r2, [fp, #-2708]	@ 0xfffff56c
   14828:	0a00009c 	beq	14aa0 <rpl_vasnprintf+0x4380>
   1482c:	e1a03002 	mov	r3, r2
   14830:	e0822004 	add	r2, r2, r4
   14834:	ea000001 	b	14840 <rpl_vasnprintf+0x4120>
   14838:	e1520003 	cmp	r2, r3
   1483c:	0a000097 	beq	14aa0 <rpl_vasnprintf+0x4380>
    if (*digits != '0')
   14840:	e4d31001 	ldrb	r1, [r3], #1
   14844:	e3510030 	cmp	r1, #48	@ 0x30
   14848:	0afffffa 	beq	14838 <rpl_vasnprintf+0x4118>
                                          scale10_round_decimal_double (arg,
   1484c:	e51b6a94 	ldr	r6, [fp, #-2708]	@ 0xfffff56c
                                        && exponent < (long)precision)
   14850:	e51b3ab8 	ldr	r3, [fp, #-2744]	@ 0xfffff548
   14854:	e51b2abc 	ldr	r2, [fp, #-2748]	@ 0xfffff544
   14858:	e1520003 	cmp	r2, r3
   1485c:	b3a03001 	movlt	r3, #1
   14860:	a3a03000 	movge	r3, #0
   14864:	e3720004 	cmn	r2, #4
                                    if ((flags & FLAG_ALT) == 0)
   14868:	e51b2a98 	ldr	r2, [fp, #-2712]	@ 0xfffff568
                                        && exponent < (long)precision)
   1486c:	b3a03000 	movlt	r3, #0
                                    if ((flags & FLAG_ALT) == 0)
   14870:	e2121010 	ands	r1, r2, #16
   14874:	051b0ab0 	ldreq	r0, [fp, #-2736]	@ 0xfffff550
   14878:	02462001 	subeq	r2, r6, #1
   1487c:	0a00002f 	beq	14940 <rpl_vasnprintf+0x4220>
                                    if (exponent >= -4
   14880:	e3530000 	cmp	r3, #0
   14884:	0a00017a 	beq	14e74 <rpl_vasnprintf+0x4754>
                                        if (exponent >= 0)
   14888:	e51b0abc 	ldr	r0, [fp, #-2748]	@ 0xfffff544
   1488c:	e3500000 	cmp	r0, #0
   14890:	ba000126 	blt	14d30 <rpl_vasnprintf+0x4610>
                                            for (; ecount > 0; ecount--)
   14894:	e51b3ab8 	ldr	r3, [fp, #-2744]	@ 0xfffff548
   14898:	e0890000 	add	r0, r9, r0
   1489c:	e0862003 	add	r2, r6, r3
   148a0:	e2493001 	sub	r3, r9, #1
                                              *p++ = digits[--ndigits];
   148a4:	e572c001 	ldrb	ip, [r2, #-1]!
   148a8:	e5e3c001 	strb	ip, [r3, #1]!
                                            for (; ecount > 0; ecount--)
   148ac:	e1530000 	cmp	r3, r0
   148b0:	1afffffb 	bne	148a4 <rpl_vasnprintf+0x4184>
   148b4:	e51b2abc 	ldr	r2, [fp, #-2748]	@ 0xfffff544
   148b8:	e51b3ab8 	ldr	r3, [fp, #-2744]	@ 0xfffff548
   148bc:	e0433002 	sub	r3, r3, r2
   148c0:	e2437001 	sub	r7, r3, #1
                                            if ((flags & FLAG_ALT) || ndigits > nzeroes)
   148c4:	e51b3ab0 	ldr	r3, [fp, #-2736]	@ 0xfffff550
   148c8:	e1570003 	cmp	r7, r3
   148cc:	93510000 	cmpls	r1, #0
   148d0:	e2823001 	add	r3, r2, #1
   148d4:	e0894003 	add	r4, r9, r3
   148d8:	0afff9cc 	beq	13010 <rpl_vasnprintf+0x28f0>
                                                *p++ = decimal_point_char ();
   148dc:	e2822002 	add	r2, r2, #2
   148e0:	e50b3ab8 	str	r3, [fp, #-2744]	@ 0xfffff548
   148e4:	e0893002 	add	r3, r9, r2
   148e8:	e50b3a94 	str	r3, [fp, #-2708]	@ 0xfffff56c
   148ec:	ebffe999 	bl	ef58 <decimal_point_char>
                                                while (ndigits > nzeroes)
   148f0:	e51b2ab0 	ldr	r2, [fp, #-2736]	@ 0xfffff550
                                                *p++ = decimal_point_char ();
   148f4:	e51b3ab8 	ldr	r3, [fp, #-2744]	@ 0xfffff548
                                                while (ndigits > nzeroes)
   148f8:	e1570002 	cmp	r7, r2
                                                *p++ = decimal_point_char ();
   148fc:	e7c90003 	strb	r0, [r9, r3]
                                                while (ndigits > nzeroes)
   14900:	9a00018c 	bls	14f38 <rpl_vasnprintf+0x4818>
   14904:	e0863007 	add	r3, r6, r7
   14908:	e0862002 	add	r2, r6, r2
                                                    *p++ = digits[ndigits];
   1490c:	e5731001 	ldrb	r1, [r3, #-1]!
                                                while (ndigits > nzeroes)
   14910:	e1530002 	cmp	r3, r2
                                                    *p++ = digits[ndigits];
   14914:	e5e41001 	strb	r1, [r4, #1]!
                                                while (ndigits > nzeroes)
   14918:	1afffffb 	bne	1490c <rpl_vasnprintf+0x41ec>
   1491c:	e51b3ab0 	ldr	r3, [fp, #-2736]	@ 0xfffff550
   14920:	e51b2a94 	ldr	r2, [fp, #-2708]	@ 0xfffff56c
   14924:	e0473003 	sub	r3, r7, r3
   14928:	e0824003 	add	r4, r2, r3
   1492c:	eafff9b7 	b	13010 <rpl_vasnprintf+0x28f0>
                                             && digits[nzeroes] == '0')
   14930:	e51bcab8 	ldr	ip, [fp, #-2744]	@ 0xfffff548
                                        nzeroes++;
   14934:	e2800001 	add	r0, r0, #1
                                             && digits[nzeroes] == '0')
   14938:	e150000c 	cmp	r0, ip
   1493c:	0a000002 	beq	1494c <rpl_vasnprintf+0x422c>
   14940:	e5f2c001 	ldrb	ip, [r2, #1]!
   14944:	e35c0030 	cmp	ip, #48	@ 0x30
   14948:	0afffff8 	beq	14930 <rpl_vasnprintf+0x4210>
                                    if (exponent >= -4
   1494c:	e3530000 	cmp	r3, #0
   14950:	e50b0ab0 	str	r0, [fp, #-2736]	@ 0xfffff550
   14954:	1affffcb 	bne	14888 <rpl_vasnprintf+0x4168>
                                        if ((flags & FLAG_ALT) || ndigits > nzeroes)
   14958:	e51b3ab0 	ldr	r3, [fp, #-2736]	@ 0xfffff550
                                        *p++ = digits[--ndigits];
   1495c:	e1a07009 	mov	r7, r9
                                        if ((flags & FLAG_ALT) || ndigits > nzeroes)
   14960:	e1530004 	cmp	r3, r4
                                        *p++ = digits[--ndigits];
   14964:	e7d63004 	ldrb	r3, [r6, r4]
   14968:	e4c73001 	strb	r3, [r7], #1
                                        if ((flags & FLAG_ALT) || ndigits > nzeroes)
   1496c:	3a000152 	bcc	14ebc <rpl_vasnprintf+0x479c>
                                        *p++ = dp->conversion - 'G' + 'E'; /* 'e' or 'E' */
   14970:	e5d53024 	ldrb	r3, [r5, #36]	@ 0x24
   14974:	e1a04007 	mov	r4, r7
                                              sprintf ((char *) p, decimal_format, exponent);
   14978:	e51b2abc 	ldr	r2, [fp, #-2748]	@ 0xfffff544
   1497c:	e51f13b4 	ldr	r1, [pc, #-948]	@ 145d0 <rpl_vasnprintf+0x3eb0>
                                        *p++ = dp->conversion - 'G' + 'E'; /* 'e' or 'E' */
   14980:	e2433002 	sub	r3, r3, #2
   14984:	e4c43001 	strb	r3, [r4], #1
                                              sprintf ((char *) p, decimal_format, exponent);
   14988:	e1a00004 	mov	r0, r4
   1498c:	eb00133f 	bl	19690 <sprintf>
                                              while (*p != '\0')
   14990:	e5d73001 	ldrb	r3, [r7, #1]
   14994:	e3530000 	cmp	r3, #0
   14998:	0afff99c 	beq	13010 <rpl_vasnprintf+0x28f0>
   1499c:	e5f43001 	ldrb	r3, [r4, #1]!
   149a0:	e3530000 	cmp	r3, #0
   149a4:	1afffffc 	bne	1499c <rpl_vasnprintf+0x427c>
   149a8:	eafff998 	b	13010 <rpl_vasnprintf+0x28f0>
  for (; precision > 0; precision--, digits++)
   149ac:	e3570000 	cmp	r7, #0
   149b0:	e1a0600a 	mov	r6, sl
   149b4:	e1a0c005 	mov	ip, r5
   149b8:	e1a01000 	mov	r1, r0
   149bc:	e51b5ab0 	ldr	r5, [fp, #-2736]	@ 0xfffff550
   149c0:	01a00006 	moveq	r0, r6
   149c4:	e51b9ab8 	ldr	r9, [fp, #-2744]	@ 0xfffff548
   149c8:	e51baabc 	ldr	sl, [fp, #-2748]	@ 0xfffff544
   149cc:	e51b8ac0 	ldr	r8, [fp, #-2752]	@ 0xfffff540
   149d0:	0a000023 	beq	14a64 <rpl_vasnprintf+0x4344>
   149d4:	e1a02006 	mov	r2, r6
   149d8:	e0860007 	add	r0, r6, r7
   149dc:	ea000001 	b	149e8 <rpl_vasnprintf+0x42c8>
   149e0:	e1500002 	cmp	r0, r2
   149e4:	0a00001e 	beq	14a64 <rpl_vasnprintf+0x4344>
    if (*digits != '0')
   149e8:	e4d23001 	ldrb	r3, [r2], #1
   149ec:	e3530030 	cmp	r3, #48	@ 0x30
   149f0:	0afffffa 	beq	149e0 <rpl_vasnprintf+0x42c0>
                                    *p++ = digits[--ndigits];
   149f4:	e2411001 	sub	r1, r1, #1
                                          scale10_round_decimal_long_double (arg,
   149f8:	e50b6a94 	str	r6, [fp, #-2708]	@ 0xfffff56c
                                    *p++ = digits[--ndigits];
   149fc:	e7d63001 	ldrb	r3, [r6, r1]
   14a00:	e0867001 	add	r7, r6, r1
   14a04:	e5c93000 	strb	r3, [r9]
                                        *p++ = decimal_point_char ();
   14a08:	e50b1ab0 	str	r1, [fp, #-2736]	@ 0xfffff550
   14a0c:	e2896002 	add	r6, r9, #2
   14a10:	ebffe950 	bl	ef58 <decimal_point_char>
                                        while (ndigits > 0)
   14a14:	e51b1ab0 	ldr	r1, [fp, #-2736]	@ 0xfffff550
                                        *p++ = decimal_point_char ();
   14a18:	e5c90001 	strb	r0, [r9, #1]
                                        while (ndigits > 0)
   14a1c:	e3510000 	cmp	r1, #0
   14a20:	0a000007 	beq	14a44 <rpl_vasnprintf+0x4324>
   14a24:	e1a03007 	mov	r3, r7
   14a28:	e2892001 	add	r2, r9, #1
                                            *p++ = digits[ndigits];
   14a2c:	e5730001 	ldrb	r0, [r3, #-1]!
   14a30:	e5e20001 	strb	r0, [r2, #1]!
                                        while (ndigits > 0)
   14a34:	e51b0a94 	ldr	r0, [fp, #-2708]	@ 0xfffff56c
   14a38:	e1500003 	cmp	r0, r3
   14a3c:	1afffffa 	bne	14a2c <rpl_vasnprintf+0x430c>
   14a40:	e0866001 	add	r6, r6, r1
                                    free (digits);
   14a44:	e51b0a94 	ldr	r0, [fp, #-2708]	@ 0xfffff56c
   14a48:	ebffd682 	bl	a458 <rpl_free>
   14a4c:	eafffc73 	b	13c20 <rpl_vasnprintf+0x3500>
                                  xmax (xsum3 (length, count, pad),
   14a50:	e35a0000 	cmp	sl, #0
   14a54:	aafff068 	bge	10bfc <rpl_vasnprintf+0x4dc>
                                ENSURE_ALLOCATION (n);
   14a58:	e37a0001 	cmn	sl, #1
   14a5c:	1afff066 	bne	10bfc <rpl_vasnprintf+0x4dc>
   14a60:	eafffebe 	b	14560 <rpl_vasnprintf+0x3e40>
  if (*digits != '1')
   14a64:	e5d02000 	ldrb	r2, [r0]
   14a68:	e3520031 	cmp	r2, #49	@ 0x31
   14a6c:	0a0000cd 	beq	14da8 <rpl_vasnprintf+0x4688>
                                          scale10_round_decimal_long_double (arg,
   14a70:	e50b6a94 	str	r6, [fp, #-2708]	@ 0xfffff56c
                                    if ((flags & FLAG_ALT) || precision > 0)
   14a74:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
                                    *p++ = digits[--ndigits];
   14a78:	e2411001 	sub	r1, r1, #1
   14a7c:	e51b2a94 	ldr	r2, [fp, #-2708]	@ 0xfffff56c
                                    if ((flags & FLAG_ALT) || precision > 0)
   14a80:	e2033010 	and	r3, r3, #16
   14a84:	e1933007 	orrs	r3, r3, r7
                                    *p++ = digits[--ndigits];
   14a88:	e7d23001 	ldrb	r3, [r2, r1]
   14a8c:	e0827001 	add	r7, r2, r1
   14a90:	02896001 	addeq	r6, r9, #1
   14a94:	e5c93000 	strb	r3, [r9]
                                    if ((flags & FLAG_ALT) || precision > 0)
   14a98:	0affffe9 	beq	14a44 <rpl_vasnprintf+0x4324>
   14a9c:	eaffffd9 	b	14a08 <rpl_vasnprintf+0x42e8>
  if (*digits != '1')
   14aa0:	e5d23000 	ldrb	r3, [r2]
   14aa4:	e3530031 	cmp	r3, #49	@ 0x31
   14aa8:	1affff67 	bne	1484c <rpl_vasnprintf+0x412c>
                                    if (is_borderline (digits, precision - 1))
   14aac:	e5d23001 	ldrb	r3, [r2, #1]
   14ab0:	e3530000 	cmp	r3, #0
   14ab4:	1affff64 	bne	1484c <rpl_vasnprintf+0x412c>
                                          scale10_round_decimal_double (arg,
   14ab8:	eeb00b48 	vmov.f64	d0, d8
   14abc:	ebffee39 	bl	103a8 <scale10_round_decimal_double>
                                        if (digits2 == NULL)
   14ac0:	e2506000 	subs	r6, r0, #0
   14ac4:	0a000147 	beq	14fe8 <rpl_vasnprintf+0x48c8>
                                        if (strlen (digits2) == precision)
   14ac8:	fa002e6c 	blx	20480 <strlen>
   14acc:	e51b3ab8 	ldr	r3, [fp, #-2744]	@ 0xfffff548
   14ad0:	e1500003 	cmp	r0, r3
   14ad4:	0a00013d 	beq	14fd0 <rpl_vasnprintf+0x48b0>
                                          free (digits2);
   14ad8:	e1a00006 	mov	r0, r6
   14adc:	ebffd65d 	bl	a458 <rpl_free>
   14ae0:	eaffff59 	b	1484c <rpl_vasnprintf+0x412c>
                                    if (is_borderline (digits, precision - 1))
   14ae4:	e2463001 	sub	r3, r6, #1
   14ae8:	e1a00008 	mov	r0, r8
   14aec:	e1a01003 	mov	r1, r3
   14af0:	e50b8a94 	str	r8, [fp, #-2708]	@ 0xfffff56c
   14af4:	e51b5abc 	ldr	r5, [fp, #-2748]	@ 0xfffff544
   14af8:	e1a02007 	mov	r2, r7
   14afc:	e50b4ab8 	str	r4, [fp, #-2744]	@ 0xfffff548
   14b00:	e1a07009 	mov	r7, r9
   14b04:	e50b3abc 	str	r3, [fp, #-2748]	@ 0xfffff544
   14b08:	ebffe8a2 	bl	ed98 <is_borderline>
   14b0c:	e3500000 	cmp	r0, #0
   14b10:	e51b9ac0 	ldr	r9, [fp, #-2752]	@ 0xfffff540
   14b14:	e51b8ac4 	ldr	r8, [fp, #-2756]	@ 0xfffff53c
   14b18:	1a0000b7 	bne	14dfc <rpl_vasnprintf+0x46dc>
                                        && exponent < (long)precision)
   14b1c:	e51b3ab8 	ldr	r3, [fp, #-2744]	@ 0xfffff548
   14b20:	e1530007 	cmp	r3, r7
   14b24:	e1a02003 	mov	r2, r3
   14b28:	b3a02001 	movlt	r2, #1
   14b2c:	a3a02000 	movge	r2, #0
   14b30:	e3730004 	cmn	r3, #4
                                    if ((flags & FLAG_ALT) == 0)
   14b34:	e51b3a98 	ldr	r3, [fp, #-2712]	@ 0xfffff568
                                        && exponent < (long)precision)
   14b38:	b3a02000 	movlt	r2, #0
                                    if ((flags & FLAG_ALT) == 0)
   14b3c:	e2130010 	ands	r0, r3, #16
   14b40:	051b3a94 	ldreq	r3, [fp, #-2708]	@ 0xfffff56c
   14b44:	02431001 	subeq	r1, r3, #1
   14b48:	051b3ab0 	ldreq	r3, [fp, #-2736]	@ 0xfffff550
   14b4c:	0a00001d 	beq	14bc8 <rpl_vasnprintf+0x44a8>
                                    if (exponent >= -4
   14b50:	e3520000 	cmp	r2, #0
   14b54:	0a00012b 	beq	15008 <rpl_vasnprintf+0x48e8>
                                        if (exponent >= 0)
   14b58:	e51b3ab8 	ldr	r3, [fp, #-2744]	@ 0xfffff548
   14b5c:	e3530000 	cmp	r3, #0
   14b60:	ba000143 	blt	15074 <rpl_vasnprintf+0x4954>
                                            for (; ecount > 0; ecount--)
   14b64:	e51b2a94 	ldr	r2, [fp, #-2708]	@ 0xfffff56c
   14b68:	e089c003 	add	ip, r9, r3
   14b6c:	e0821007 	add	r1, r2, r7
   14b70:	e2492001 	sub	r2, r9, #1
                                              *p++ = digits[--ndigits];
   14b74:	e5713001 	ldrb	r3, [r1, #-1]!
   14b78:	e5e23001 	strb	r3, [r2, #1]!
                                            for (; ecount > 0; ecount--)
   14b7c:	e15c0002 	cmp	ip, r2
   14b80:	1afffffb 	bne	14b74 <rpl_vasnprintf+0x4454>
   14b84:	e51b2ab8 	ldr	r2, [fp, #-2744]	@ 0xfffff548
   14b88:	e0473002 	sub	r3, r7, r2
   14b8c:	e2437001 	sub	r7, r3, #1
                                            if ((flags & FLAG_ALT) || ndigits > nzeroes)
   14b90:	e51b3ab0 	ldr	r3, [fp, #-2736]	@ 0xfffff550
   14b94:	e1570003 	cmp	r7, r3
   14b98:	93500000 	cmpls	r0, #0
   14b9c:	e2823001 	add	r3, r2, #1
   14ba0:	e0894003 	add	r4, r9, r3
   14ba4:	1a0000cf 	bne	14ee8 <rpl_vasnprintf+0x47c8>
                                    free (digits);
   14ba8:	e51b0a94 	ldr	r0, [fp, #-2708]	@ 0xfffff56c
   14bac:	ebffd629 	bl	a458 <rpl_free>
                count = p - tmp;
   14bb0:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   14bb4:	e0446003 	sub	r6, r4, r3
   14bb8:	eafff896 	b	12e18 <rpl_vasnprintf+0x26f8>
                                        nzeroes++;
   14bbc:	e2833001 	add	r3, r3, #1
                                             && digits[nzeroes] == '0')
   14bc0:	e1570003 	cmp	r7, r3
   14bc4:	9a000002 	bls	14bd4 <rpl_vasnprintf+0x44b4>
   14bc8:	e5f1c001 	ldrb	ip, [r1, #1]!
   14bcc:	e35c0030 	cmp	ip, #48	@ 0x30
   14bd0:	0afffff9 	beq	14bbc <rpl_vasnprintf+0x449c>
                                    if (exponent >= -4
   14bd4:	e3520000 	cmp	r2, #0
   14bd8:	e50b3ab0 	str	r3, [fp, #-2736]	@ 0xfffff550
   14bdc:	1affffdd 	bne	14b58 <rpl_vasnprintf+0x4438>
                                        if ((flags & FLAG_ALT) || ndigits > nzeroes)
   14be0:	e51b3abc 	ldr	r3, [fp, #-2748]	@ 0xfffff544
                                        *p++ = digits[--ndigits];
   14be4:	e2894001 	add	r4, r9, #1
                                        if ((flags & FLAG_ALT) || ndigits > nzeroes)
   14be8:	e51b2ab0 	ldr	r2, [fp, #-2736]	@ 0xfffff550
                                        *p++ = digits[--ndigits];
   14bec:	e1a06004 	mov	r6, r4
                                        if ((flags & FLAG_ALT) || ndigits > nzeroes)
   14bf0:	e1530002 	cmp	r3, r2
                                        *p++ = digits[--ndigits];
   14bf4:	e51b2a94 	ldr	r2, [fp, #-2708]	@ 0xfffff56c
   14bf8:	e7d23003 	ldrb	r3, [r2, r3]
   14bfc:	e5c93000 	strb	r3, [r9]
                                        if ((flags & FLAG_ALT) || ndigits > nzeroes)
   14c00:	8a000105 	bhi	1501c <rpl_vasnprintf+0x48fc>
                                        *p++ = dp->conversion - 'G' + 'E'; /* 'e' or 'E' */
   14c04:	e5d53024 	ldrb	r3, [r5, #36]	@ 0x24
   14c08:	e1a04006 	mov	r4, r6
                                            sprintf ((char *) p, "%+.2d", exponent);
   14c0c:	e3091154 	movw	r1, #37204	@ 0x9154
   14c10:	e51b2ab8 	ldr	r2, [fp, #-2744]	@ 0xfffff548
   14c14:	e3401002 	movt	r1, #2
                                        *p++ = dp->conversion - 'G' + 'E'; /* 'e' or 'E' */
   14c18:	e2433002 	sub	r3, r3, #2
   14c1c:	e4c43001 	strb	r3, [r4], #1
                                            sprintf ((char *) p, "%+.2d", exponent);
   14c20:	e1a00004 	mov	r0, r4
   14c24:	eb001299 	bl	19690 <sprintf>
                                            while (*p != '\0')
   14c28:	e5d63001 	ldrb	r3, [r6, #1]
   14c2c:	e3530000 	cmp	r3, #0
   14c30:	0affffdc 	beq	14ba8 <rpl_vasnprintf+0x4488>
   14c34:	e5f43001 	ldrb	r3, [r4, #1]!
   14c38:	e3530000 	cmp	r3, #0
   14c3c:	1afffffc 	bne	14c34 <rpl_vasnprintf+0x4514>
   14c40:	eaffffd8 	b	14ba8 <rpl_vasnprintf+0x4488>
                                    *p++ = decimal_point_char ();
   14c44:	e1a04006 	mov	r4, r6
   14c48:	eafffcf5 	b	14024 <rpl_vasnprintf+0x3904>
                                        && (((dp->conversion == 'a'
   14c4c:	e5d5c024 	ldrb	ip, [r5, #36]	@ 0x24
   14c50:	e35c0078 	cmp	ip, #120	@ 0x78
   14c54:	135c0061 	cmpne	ip, #97	@ 0x61
   14c58:	1a00000f 	bne	14c9c <rpl_vasnprintf+0x457c>
                                             && rp[1] == 'x')
   14c5c:	e5d9c001 	ldrb	ip, [r9, #1]
   14c60:	e35c0078 	cmp	ip, #120	@ 0x78
   14c64:	1afffd26 	bne	14104 <rpl_vasnprintf+0x39e4>
                              if (flags & FLAG_LEFT)
   14c68:	e51bcac4 	ldr	ip, [fp, #-2756]	@ 0xfffff53c
                              count = count + pad; /* = end - rp */
   14c6c:	e50b2a80 	str	r2, [fp, #-2688]	@ 0xfffff580
                              if (flags & FLAG_LEFT)
   14c70:	e35c0000 	cmp	ip, #0
   14c74:	1afffe42 	bne	14584 <rpl_vasnprintf+0x3e64>
                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL
   14c78:	e51b2a98 	ldr	r2, [fp, #-2712]	@ 0xfffff568
   14c7c:	e3120020 	tst	r2, #32
                                      pad_ptr += 2;
   14c80:	12811002 	addne	r1, r1, #2
                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL
   14c84:	1afffd25 	bne	14120 <rpl_vasnprintf+0x3a00>
   14c88:	eafffde0 	b	14410 <rpl_vasnprintf+0x3cf0>
                      while (arg < arg_end)
   14c8c:	e51b3a88 	ldr	r3, [fp, #-2696]	@ 0xfffff578
   14c90:	e1a07008 	mov	r7, r8
   14c94:	e50b3a9c 	str	r3, [fp, #-2716]	@ 0xfffff564
   14c98:	eafffd61 	b	14224 <rpl_vasnprintf+0x3b04>
                                            || ((dp->conversion == 'A'
   14c9c:	e35c0058 	cmp	ip, #88	@ 0x58
   14ca0:	135c0041 	cmpne	ip, #65	@ 0x41
   14ca4:	1a000007 	bne	14cc8 <rpl_vasnprintf+0x45a8>
                                                && rp[1] == 'X')
   14ca8:	e5d9c001 	ldrb	ip, [r9, #1]
   14cac:	e35c0058 	cmp	ip, #88	@ 0x58
   14cb0:	1afffd13 	bne	14104 <rpl_vasnprintf+0x39e4>
   14cb4:	eaffffeb 	b	14c68 <rpl_vasnprintf+0x4548>
                                  while (p > rp)
   14cb8:	e1a00003 	mov	r0, r3
   14cbc:	eafffdda 	b	1442c <rpl_vasnprintf+0x3d0c>
                                    exponent = 0;
   14cc0:	e1a04007 	mov	r4, r7
   14cc4:	eafffbd5 	b	13c20 <rpl_vasnprintf+0x3500>
                                            || (dp->conversion == 'b'
   14cc8:	e35c0062 	cmp	ip, #98	@ 0x62
   14ccc:	1a00009e 	bne	14f4c <rpl_vasnprintf+0x482c>
                                                && rp[1] == 'b')
   14cd0:	e5d9c001 	ldrb	ip, [r9, #1]
   14cd4:	e35c0062 	cmp	ip, #98	@ 0x62
   14cd8:	1afffd09 	bne	14104 <rpl_vasnprintf+0x39e4>
   14cdc:	eaffffe1 	b	14c68 <rpl_vasnprintf+0x4548>
                                ENSURE_ALLOCATION (n);
   14ce0:	e35a0000 	cmp	sl, #0
   14ce4:	03a0200c 	moveq	r2, #12
   14ce8:	e1520003 	cmp	r2, r3
   14cec:	21a0a002 	movcs	sl, r2
   14cf0:	31a0a003 	movcc	sl, r3
   14cf4:	e37a0001 	cmn	sl, #1
   14cf8:	0affefbf 	beq	10bfc <rpl_vasnprintf+0x4dc>
   14cfc:	e51b3a9c 	ldr	r3, [fp, #-2716]	@ 0xfffff564
   14d00:	e51b2a90 	ldr	r2, [fp, #-2704]	@ 0xfffff570
   14d04:	e1530002 	cmp	r3, r2
   14d08:	0a00004e 	beq	14e48 <rpl_vasnprintf+0x4728>
   14d0c:	e51b0a9c 	ldr	r0, [fp, #-2716]	@ 0xfffff564
   14d10:	e1a0100a 	mov	r1, sl
   14d14:	ebffe64a 	bl	e644 <rpl_realloc>
   14d18:	e3500000 	cmp	r0, #0
   14d1c:	0affefb6 	beq	10bfc <rpl_vasnprintf+0x4dc>
   14d20:	e50b0a9c 	str	r0, [fp, #-2716]	@ 0xfffff564
   14d24:	eafffe0d 	b	14560 <rpl_vasnprintf+0x3e40>
                                    exponent = 0;
   14d28:	e50b7ab0 	str	r7, [fp, #-2736]	@ 0xfffff550
   14d2c:	eafff9f4 	b	13504 <rpl_vasnprintf+0x2de4>
                                            size_t ecount = -exponent - 1;
   14d30:	e51b3abc 	ldr	r3, [fp, #-2748]	@ 0xfffff544
                                            *p++ = '0';
   14d34:	e3a01030 	mov	r1, #48	@ 0x30
   14d38:	e1a04009 	mov	r4, r9
   14d3c:	e4c41002 	strb	r1, [r4], #2
                                            size_t ecount = -exponent - 1;
   14d40:	e1e07003 	mvn	r7, r3
                                            *p++ = decimal_point_char ();
   14d44:	ebffe883 	bl	ef58 <decimal_point_char>
                                            for (; ecount > 0; ecount--)
   14d48:	e3570000 	cmp	r7, #0
                                            *p++ = decimal_point_char ();
   14d4c:	e5c90001 	strb	r0, [r9, #1]
                                            for (; ecount > 0; ecount--)
   14d50:	0a000004 	beq	14d68 <rpl_vasnprintf+0x4648>
                                              *p++ = '0';
   14d54:	e1a00004 	mov	r0, r4
   14d58:	e0844007 	add	r4, r4, r7
   14d5c:	e3a01030 	mov	r1, #48	@ 0x30
   14d60:	e1a02007 	mov	r2, r7
   14d64:	eb001651 	bl	1a6b0 <memset>
                                            while (ndigits > nzeroes)
   14d68:	e51b3ab8 	ldr	r3, [fp, #-2744]	@ 0xfffff548
   14d6c:	e51b1ab0 	ldr	r1, [fp, #-2736]	@ 0xfffff550
   14d70:	e1530001 	cmp	r3, r1
   14d74:	9afff8a5 	bls	13010 <rpl_vasnprintf+0x28f0>
   14d78:	e0863003 	add	r3, r6, r3
   14d7c:	e2442001 	sub	r2, r4, #1
   14d80:	e0861001 	add	r1, r6, r1
                                                *p++ = digits[ndigits];
   14d84:	e5730001 	ldrb	r0, [r3, #-1]!
                                            while (ndigits > nzeroes)
   14d88:	e1530001 	cmp	r3, r1
                                                *p++ = digits[ndigits];
   14d8c:	e5e20001 	strb	r0, [r2, #1]!
                                            while (ndigits > nzeroes)
   14d90:	1afffffb 	bne	14d84 <rpl_vasnprintf+0x4664>
   14d94:	e51b3ab8 	ldr	r3, [fp, #-2744]	@ 0xfffff548
   14d98:	e51b2ab0 	ldr	r2, [fp, #-2736]	@ 0xfffff550
   14d9c:	e0433002 	sub	r3, r3, r2
   14da0:	e0844003 	add	r4, r4, r3
   14da4:	eafff899 	b	13010 <rpl_vasnprintf+0x28f0>
                                    if (is_borderline (digits, precision))
   14da8:	e5d02001 	ldrb	r2, [r0, #1]
   14dac:	e3520000 	cmp	r2, #0
   14db0:	1affff2e 	bne	14a70 <rpl_vasnprintf+0x4350>
                                          scale10_round_decimal_long_double (arg,
   14db4:	e28c0001 	add	r0, ip, #1
   14db8:	eeb00b48 	vmov.f64	d0, d8
   14dbc:	e50b1ab0 	str	r1, [fp, #-2736]	@ 0xfffff550
   14dc0:	ebffed16 	bl	10220 <scale10_round_decimal_long_double>
                                        if (digits2 == NULL)
   14dc4:	e2503000 	subs	r3, r0, #0
   14dc8:	e51b1ab0 	ldr	r1, [fp, #-2736]	@ 0xfffff550
   14dcc:	e50b3a94 	str	r3, [fp, #-2708]	@ 0xfffff56c
   14dd0:	0a0000cc 	beq	15108 <rpl_vasnprintf+0x49e8>
                                        if (strlen (digits2) == precision + 1)
   14dd4:	e50b1ab0 	str	r1, [fp, #-2736]	@ 0xfffff550
   14dd8:	fa002da8 	blx	20480 <strlen>
   14ddc:	e51b1ab0 	ldr	r1, [fp, #-2736]	@ 0xfffff550
   14de0:	e1500001 	cmp	r0, r1
   14de4:	0a0000c2 	beq	150f4 <rpl_vasnprintf+0x49d4>
                                          free (digits2);
   14de8:	e51b0a94 	ldr	r0, [fp, #-2708]	@ 0xfffff56c
   14dec:	e50b1ab0 	str	r1, [fp, #-2736]	@ 0xfffff550
   14df0:	ebffd598 	bl	a458 <rpl_free>
   14df4:	e51b1ab0 	ldr	r1, [fp, #-2736]	@ 0xfffff550
   14df8:	eaffff1c 	b	14a70 <rpl_vasnprintf+0x4350>
                                          scale10_round_decimal_long_double (arg,
   14dfc:	e1a00002 	mov	r0, r2
   14e00:	eeb00b48 	vmov.f64	d0, d8
   14e04:	ebffed05 	bl	10220 <scale10_round_decimal_long_double>
                                        if (digits2 == NULL)
   14e08:	e2504000 	subs	r4, r0, #0
   14e0c:	0a000075 	beq	14fe8 <rpl_vasnprintf+0x48c8>
                                        if (strlen (digits2) == precision)
   14e10:	fa002d9a 	blx	20480 <strlen>
   14e14:	e1500006 	cmp	r0, r6
   14e18:	0a00005d 	beq	14f94 <rpl_vasnprintf+0x4874>
                                          free (digits2);
   14e1c:	e1a00004 	mov	r0, r4
   14e20:	ebffd58c 	bl	a458 <rpl_free>
   14e24:	eaffff3c 	b	14b1c <rpl_vasnprintf+0x43fc>
                                            free (digits);
   14e28:	e51b0ab8 	ldr	r0, [fp, #-2744]	@ 0xfffff548
   14e2c:	ebffd589 	bl	a458 <rpl_free>
                                            exponent -= 1;
   14e30:	e51b3ab0 	ldr	r3, [fp, #-2736]	@ 0xfffff550
   14e34:	e2433001 	sub	r3, r3, #1
   14e38:	e50b3ab0 	str	r3, [fp, #-2736]	@ 0xfffff550
                                            digits = digits2;
   14e3c:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
   14e40:	e50b3ab8 	str	r3, [fp, #-2744]	@ 0xfffff548
   14e44:	eafffe64 	b	147dc <rpl_vasnprintf+0x40bc>
                                ENSURE_ALLOCATION (n);
   14e48:	e1a0000a 	mov	r0, sl
   14e4c:	ebffe5f0 	bl	e614 <rpl_malloc>
   14e50:	e2504000 	subs	r4, r0, #0
   14e54:	0affef68 	beq	10bfc <rpl_vasnprintf+0x4dc>
   14e58:	e3560000 	cmp	r6, #0
   14e5c:	0a000002 	beq	14e6c <rpl_vasnprintf+0x474c>
   14e60:	e51b1a90 	ldr	r1, [fp, #-2704]	@ 0xfffff570
   14e64:	e1a02006 	mov	r2, r6
   14e68:	eb002c04 	bl	1fe80 <memcpy>
   14e6c:	e50b4a9c 	str	r4, [fp, #-2716]	@ 0xfffff564
   14e70:	eafffdba 	b	14560 <rpl_vasnprintf+0x3e40>
                                        *p++ = digits[--ndigits];
   14e74:	e7d63004 	ldrb	r3, [r6, r4]
   14e78:	e1a07009 	mov	r7, r9
   14e7c:	e4c73002 	strb	r3, [r7], #2
                                            *p++ = decimal_point_char ();
   14e80:	ebffe834 	bl	ef58 <decimal_point_char>
                                            while (ndigits > nzeroes)
   14e84:	e3540000 	cmp	r4, #0
                                            *p++ = decimal_point_char ();
   14e88:	e5c90001 	strb	r0, [r9, #1]
                                            while (ndigits > nzeroes)
   14e8c:	0afffeb7 	beq	14970 <rpl_vasnprintf+0x4250>
   14e90:	e51b3ab8 	ldr	r3, [fp, #-2744]	@ 0xfffff548
   14e94:	e0862004 	add	r2, r6, r4
   14e98:	e2833001 	add	r3, r3, #1
   14e9c:	e0893003 	add	r3, r9, r3
                                                *p++ = digits[ndigits];
   14ea0:	e5721001 	ldrb	r1, [r2, #-1]!
                                            while (ndigits > nzeroes)
   14ea4:	e51b0ab0 	ldr	r0, [fp, #-2736]	@ 0xfffff550
                                                *p++ = digits[ndigits];
   14ea8:	e4c71001 	strb	r1, [r7], #1
                                            while (ndigits > nzeroes)
   14eac:	e0431007 	sub	r1, r3, r7
   14eb0:	e1500001 	cmp	r0, r1
   14eb4:	3afffff9 	bcc	14ea0 <rpl_vasnprintf+0x4780>
   14eb8:	eafffeac 	b	14970 <rpl_vasnprintf+0x4250>
                                            *p++ = decimal_point_char ();
   14ebc:	ebffe825 	bl	ef58 <decimal_point_char>
   14ec0:	e2897002 	add	r7, r9, #2
   14ec4:	e5c90001 	strb	r0, [r9, #1]
                                            while (ndigits > nzeroes)
   14ec8:	eafffff0 	b	14e90 <rpl_vasnprintf+0x4770>
                      characters = 0;
   14ecc:	e1a04003 	mov	r4, r3
                      arg_end = arg;
   14ed0:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
   14ed4:	e50b3aa8 	str	r3, [fp, #-2728]	@ 0xfffff558
   14ed8:	eafff173 	b	114ac <rpl_vasnprintf+0xd8c>
                      ENSURE_ALLOCATION (xsum (length, n));
   14edc:	e37a0001 	cmn	sl, #1
   14ee0:	1affef43 	bne	10bf4 <rpl_vasnprintf+0x4d4>
   14ee4:	eafff317 	b	11b48 <rpl_vasnprintf+0x1428>
                                                *p++ = decimal_point_char ();
   14ee8:	e2826002 	add	r6, r2, #2
   14eec:	e50b3abc 	str	r3, [fp, #-2748]	@ 0xfffff544
   14ef0:	ebffe818 	bl	ef58 <decimal_point_char>
   14ef4:	e51b3abc 	ldr	r3, [fp, #-2748]	@ 0xfffff544
   14ef8:	e0896006 	add	r6, r9, r6
   14efc:	e7c90003 	strb	r0, [r9, r3]
                                                while (ndigits > nzeroes)
   14f00:	e51b3ab0 	ldr	r3, [fp, #-2736]	@ 0xfffff550
   14f04:	e1570003 	cmp	r7, r3
   14f08:	9a00001f 	bls	14f8c <rpl_vasnprintf+0x486c>
   14f0c:	e51b1a94 	ldr	r1, [fp, #-2708]	@ 0xfffff56c
   14f10:	e0812007 	add	r2, r1, r7
   14f14:	e0813003 	add	r3, r1, r3
                                                    *p++ = digits[ndigits];
   14f18:	e5721001 	ldrb	r1, [r2, #-1]!
                                                while (ndigits > nzeroes)
   14f1c:	e1530002 	cmp	r3, r2
                                                    *p++ = digits[ndigits];
   14f20:	e5e41001 	strb	r1, [r4, #1]!
                                                while (ndigits > nzeroes)
   14f24:	1afffffb 	bne	14f18 <rpl_vasnprintf+0x47f8>
   14f28:	e51b3ab0 	ldr	r3, [fp, #-2736]	@ 0xfffff550
   14f2c:	e0473003 	sub	r3, r7, r3
   14f30:	e0864003 	add	r4, r6, r3
   14f34:	eaffff1b 	b	14ba8 <rpl_vasnprintf+0x4488>
                                                *p++ = decimal_point_char ();
   14f38:	e51b4a94 	ldr	r4, [fp, #-2708]	@ 0xfffff56c
   14f3c:	eafff833 	b	13010 <rpl_vasnprintf+0x28f0>
                      ENSURE_ALLOCATION (xsum (length, n));
   14f40:	e37a0001 	cmn	sl, #1
   14f44:	1affef2a 	bne	10bf4 <rpl_vasnprintf+0x4d4>
   14f48:	eafff89d 	b	131c4 <rpl_vasnprintf+0x2aa4>
                                            || (dp->conversion == 'B'
   14f4c:	e35c0042 	cmp	ip, #66	@ 0x42
   14f50:	1afffc6b 	bne	14104 <rpl_vasnprintf+0x39e4>
                                                && rp[1] == 'B')))
   14f54:	e5d9c001 	ldrb	ip, [r9, #1]
   14f58:	e35c0042 	cmp	ip, #66	@ 0x42
   14f5c:	0affff41 	beq	14c68 <rpl_vasnprintf+0x4548>
                              if (flags & FLAG_LEFT)
   14f60:	e51bcac4 	ldr	ip, [fp, #-2756]	@ 0xfffff53c
                              count = count + pad; /* = end - rp */
   14f64:	e50b2a80 	str	r2, [fp, #-2688]	@ 0xfffff580
                              if (flags & FLAG_LEFT)
   14f68:	e35c0000 	cmp	ip, #0
   14f6c:	1afffd84 	bne	14584 <rpl_vasnprintf+0x3e64>
                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL
   14f70:	e51b2a98 	ldr	r2, [fp, #-2712]	@ 0xfffff568
   14f74:	e3120020 	tst	r2, #32
   14f78:	0afffd24 	beq	14410 <rpl_vasnprintf+0x3cf0>
                                       && !(has_precision
   14f7c:	e51b2abc 	ldr	r2, [fp, #-2748]	@ 0xfffff544
   14f80:	e3520000 	cmp	r2, #0
   14f84:	1afffd21 	bne	14410 <rpl_vasnprintf+0x3cf0>
   14f88:	eafffc73 	b	1415c <rpl_vasnprintf+0x3a3c>
                                                *p++ = decimal_point_char ();
   14f8c:	e1a04006 	mov	r4, r6
   14f90:	eaffff04 	b	14ba8 <rpl_vasnprintf+0x4488>
                                            free (digits);
   14f94:	e51b0a94 	ldr	r0, [fp, #-2708]	@ 0xfffff56c
   14f98:	ebffd52e 	bl	a458 <rpl_free>
                                            exponent -= 1;
   14f9c:	e51b3ab8 	ldr	r3, [fp, #-2744]	@ 0xfffff548
                                            digits = digits2;
   14fa0:	e50b4a94 	str	r4, [fp, #-2708]	@ 0xfffff56c
                                            exponent -= 1;
   14fa4:	e2433001 	sub	r3, r3, #1
   14fa8:	e50b3ab8 	str	r3, [fp, #-2744]	@ 0xfffff548
   14fac:	eafffeda 	b	14b1c <rpl_vasnprintf+0x43fc>
                                  while (p > pad_ptr)
   14fb0:	e1a01003 	mov	r1, r3
   14fb4:	eafffc6f 	b	14178 <rpl_vasnprintf+0x3a58>
                      ENSURE_ALLOCATION (xsum (length, characters));
   14fb8:	e37a0001 	cmn	sl, #1
   14fbc:	1affef0c 	bne	10bf4 <rpl_vasnprintf+0x4d4>
   14fc0:	eafff300 	b	11bc8 <rpl_vasnprintf+0x14a8>
    ENSURE_ALLOCATION (xsum (length, 1));
   14fc4:	e37a0001 	cmn	sl, #1
   14fc8:	1affef0a 	bne	10bf8 <rpl_vasnprintf+0x4d8>
   14fcc:	eafff449 	b	120f8 <rpl_vasnprintf+0x19d8>
                                            free (digits);
   14fd0:	e51b0a94 	ldr	r0, [fp, #-2708]	@ 0xfffff56c
   14fd4:	ebffd51f 	bl	a458 <rpl_free>
                                            exponent -= 1;
   14fd8:	e51b3abc 	ldr	r3, [fp, #-2748]	@ 0xfffff544
   14fdc:	e2433001 	sub	r3, r3, #1
   14fe0:	e50b3abc 	str	r3, [fp, #-2748]	@ 0xfffff544
   14fe4:	eafffe19 	b	14850 <rpl_vasnprintf+0x4130>
                                            free (digits);
   14fe8:	e51b0a94 	ldr	r0, [fp, #-2708]	@ 0xfffff56c
   14fec:	e51b5a88 	ldr	r5, [fp, #-2696]	@ 0xfffff578
   14ff0:	ebffd518 	bl	a458 <rpl_free>
                                            goto out_of_memory;
   14ff4:	eaffeeff 	b	10bf8 <rpl_vasnprintf+0x4d8>
                                            free (digits);
   14ff8:	e51b0ab8 	ldr	r0, [fp, #-2744]	@ 0xfffff548
   14ffc:	e51b5a88 	ldr	r5, [fp, #-2696]	@ 0xfffff578
   15000:	ebffd514 	bl	a458 <rpl_free>
                                            goto out_of_memory;
   15004:	eaffeefb 	b	10bf8 <rpl_vasnprintf+0x4d8>
                                        *p++ = digits[--ndigits];
   15008:	e51b3a94 	ldr	r3, [fp, #-2708]	@ 0xfffff56c
   1500c:	e1a04009 	mov	r4, r9
   15010:	e51b2abc 	ldr	r2, [fp, #-2748]	@ 0xfffff544
   15014:	e7d33002 	ldrb	r3, [r3, r2]
   15018:	e4c43001 	strb	r3, [r4], #1
                                            *p++ = decimal_point_char ();
   1501c:	ebffe7cd 	bl	ef58 <decimal_point_char>
                                        *p++ = digits[--ndigits];
   15020:	e51b3abc 	ldr	r3, [fp, #-2748]	@ 0xfffff544
                                            *p++ = decimal_point_char ();
   15024:	e5c90001 	strb	r0, [r9, #1]
                                            while (ndigits > nzeroes)
   15028:	ea000003 	b	1503c <rpl_vasnprintf+0x491c>
                                                *p++ = digits[ndigits];
   1502c:	e51b2a94 	ldr	r2, [fp, #-2708]	@ 0xfffff56c
                                                --ndigits;
   15030:	e2433001 	sub	r3, r3, #1
                                                *p++ = digits[ndigits];
   15034:	e7d22003 	ldrb	r2, [r2, r3]
   15038:	e5e42001 	strb	r2, [r4, #1]!
                                            while (ndigits > nzeroes)
   1503c:	e51b2ab0 	ldr	r2, [fp, #-2736]	@ 0xfffff550
   15040:	e1530002 	cmp	r3, r2
   15044:	8afffff8 	bhi	1502c <rpl_vasnprintf+0x490c>
   15048:	e51b3abc 	ldr	r3, [fp, #-2748]	@ 0xfffff544
   1504c:	e1530002 	cmp	r3, r2
   15050:	20436002 	subcs	r6, r3, r2
   15054:	33a06000 	movcc	r6, #0
   15058:	e2866002 	add	r6, r6, #2
   1505c:	e0896006 	add	r6, r9, r6
   15060:	eafffee7 	b	14c04 <rpl_vasnprintf+0x44e4>
                            ENSURE_ALLOCATION (n);
   15064:	e1530002 	cmp	r3, r2
   15068:	21a0a003 	movcs	sl, r3
   1506c:	31a0a002 	movcc	sl, r2
   15070:	eafff4c3 	b	12384 <rpl_vasnprintf+0x1c64>
                                            size_t ecount = -exponent - 1;
   15074:	e51b3ab8 	ldr	r3, [fp, #-2744]	@ 0xfffff548
                                            *p++ = '0';
   15078:	e3a01030 	mov	r1, #48	@ 0x30
   1507c:	e1a04009 	mov	r4, r9
   15080:	e4c41002 	strb	r1, [r4], #2
                                            size_t ecount = -exponent - 1;
   15084:	e1e06003 	mvn	r6, r3
                                            *p++ = decimal_point_char ();
   15088:	ebffe7b2 	bl	ef58 <decimal_point_char>
                                            for (; ecount > 0; ecount--)
   1508c:	e3560000 	cmp	r6, #0
                                            *p++ = decimal_point_char ();
   15090:	e5c90001 	strb	r0, [r9, #1]
                                            for (; ecount > 0; ecount--)
   15094:	0a000004 	beq	150ac <rpl_vasnprintf+0x498c>
                                              *p++ = '0';
   15098:	e1a00004 	mov	r0, r4
   1509c:	e0844006 	add	r4, r4, r6
   150a0:	e3a01030 	mov	r1, #48	@ 0x30
   150a4:	e1a02006 	mov	r2, r6
   150a8:	eb001580 	bl	1a6b0 <memset>
                                            while (ndigits > nzeroes)
   150ac:	e51b3ab0 	ldr	r3, [fp, #-2736]	@ 0xfffff550
   150b0:	e1570003 	cmp	r7, r3
   150b4:	9afffebb 	bls	14ba8 <rpl_vasnprintf+0x4488>
   150b8:	e51b0a94 	ldr	r0, [fp, #-2708]	@ 0xfffff56c
   150bc:	e2441001 	sub	r1, r4, #1
   150c0:	e0802007 	add	r2, r0, r7
   150c4:	e0800003 	add	r0, r0, r3
                                                *p++ = digits[ndigits];
   150c8:	e5723001 	ldrb	r3, [r2, #-1]!
                                            while (ndigits > nzeroes)
   150cc:	e1500002 	cmp	r0, r2
                                                *p++ = digits[ndigits];
   150d0:	e5e13001 	strb	r3, [r1, #1]!
                                            while (ndigits > nzeroes)
   150d4:	1afffffb 	bne	150c8 <rpl_vasnprintf+0x49a8>
   150d8:	e51b3ab0 	ldr	r3, [fp, #-2736]	@ 0xfffff550
   150dc:	e0473003 	sub	r3, r7, r3
   150e0:	e0844003 	add	r4, r4, r3
   150e4:	eafffeaf 	b	14ba8 <rpl_vasnprintf+0x4488>
                      ENSURE_ALLOCATION (xsum (length, n));
   150e8:	e37a0001 	cmn	sl, #1
   150ec:	1affeec0 	bne	10bf4 <rpl_vasnprintf+0x4d4>
   150f0:	eafff2ec 	b	11ca8 <rpl_vasnprintf+0x1588>
                                            free (digits);
   150f4:	e1a00006 	mov	r0, r6
                                            exponent -= 1;
   150f8:	e2444001 	sub	r4, r4, #1
                                            free (digits);
   150fc:	ebffd4d5 	bl	a458 <rpl_free>
                                            exponent -= 1;
   15100:	e51b1ab0 	ldr	r1, [fp, #-2736]	@ 0xfffff550
   15104:	eafffe5a 	b	14a74 <rpl_vasnprintf+0x4354>
                                            free (digits);
   15108:	e1a00006 	mov	r0, r6
   1510c:	e51b5a88 	ldr	r5, [fp, #-2696]	@ 0xfffff578
   15110:	ebffd4d0 	bl	a458 <rpl_free>
                                            goto out_of_memory;
   15114:	eaffeeb7 	b	10bf8 <rpl_vasnprintf+0x4d8>
                    abort ();
   15118:	eb00057b 	bl	1670c <abort>

0001511c <printf_frexp>:
# define L_(literal) literal
#endif

DOUBLE
FUNC (DOUBLE x, int *expptr)
{
   1511c:	e92d4030 	push	{r4, r5, lr}
   15120:	e24dd00c 	sub	sp, sp, #12
   15124:	e1a04000 	mov	r4, r0

  BEGIN_ROUNDING ();

#ifdef USE_FREXP_LDEXP
  /* frexp and ldexp are usually faster than the loop below.  */
  x = FREXP (x, &exponent);
   15128:	e28d0004 	add	r0, sp, #4

  x = x + x;
  exponent -= 1;

  if (exponent < MIN_EXP - 1)
   1512c:	e30f5c02 	movw	r5, #64514	@ 0xfc02
  x = FREXP (x, &exponent);
   15130:	eb002d2c 	bl	205e8 <frexp>
  exponent -= 1;
   15134:	e59d0004 	ldr	r0, [sp, #4]
  if (exponent < MIN_EXP - 1)
   15138:	e34f5fff 	movt	r5, #65535	@ 0xffff
  x = x + x;
   1513c:	ee300b00 	vadd.f64	d0, d0, d0
  exponent -= 1;
   15140:	e2403001 	sub	r3, r0, #1
  if (exponent < MIN_EXP - 1)
   15144:	e1530005 	cmp	r3, r5
   15148:	ba000002 	blt	15158 <printf_frexp+0x3c>
  }
#endif

  END_ROUNDING ();

  *expptr = exponent;
   1514c:	e5843000 	str	r3, [r4]
  return x;
}
   15150:	e28dd00c 	add	sp, sp, #12
   15154:	e8bd8030 	pop	{r4, r5, pc}
      x = LDEXP (x, exponent - (MIN_EXP - 1));
   15158:	e2800fff 	add	r0, r0, #1020	@ 0x3fc
   1515c:	e2800001 	add	r0, r0, #1
   15160:	eb002cfc 	bl	20558 <ldexp>
   15164:	e1a03005 	mov	r3, r5
  *expptr = exponent;
   15168:	e5843000 	str	r3, [r4]
}
   1516c:	e28dd00c 	add	sp, sp, #12
   15170:	e8bd8030 	pop	{r4, r5, pc}

00015174 <printf_frexpl>:
# include "printf-frexp.h"

long double
printf_frexpl (long double x, int *expptr)
{
  return printf_frexp (x, expptr);
   15174:	eaffffe8 	b	1511c <printf_frexp>

00015178 <gl_signbitl>:
    ((sizeof (long double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))
  union { long double value; unsigned int word[NWORDS]; } m;
  m.value = arg;
  return (m.word[LDBL_SIGNBIT_WORD] >> LDBL_SIGNBIT_BIT) & 1;
#elif HAVE_COPYSIGNL_IN_LIBC
  return copysignl (1.0L, arg) < 0;
   15178:	ed9f6b08 	vldr	d6, [pc, #32]	@ 151a0 <gl_signbitl+0x28>
   1517c:	ed9f7b09 	vldr	d7, [pc, #36]	@ 151a8 <gl_signbitl+0x30>
   15180:	ee103a90 	vmov	r3, s1
   15184:	e3530000 	cmp	r3, #0
   15188:	beb07b46 	vmovlt.f64	d7, d6
   1518c:	eeb57bc0 	vcmpe.f64	d7, #0.0
   15190:	eef1fa10 	vmrs	APSR_nzcv, fpscr
      return (memcmp (&plus_zero, &arg_mem, SIZEOF_LDBL) != 0);
    }
  else
    return 0;
#endif
}
   15194:	43a00001 	movmi	r0, #1
   15198:	53a00000 	movpl	r0, #0
   1519c:	e12fff1e 	bx	lr
   151a0:	00000000 	.word	0x00000000
   151a4:	bff00000 	.word	0xbff00000
   151a8:	00000000 	.word	0x00000000
   151ac:	3ff00000 	.word	0x3ff00000

000151b0 <printf_fetchargs>:
PRINTF_FETCHARGS (va_list args, arguments *a)
{
  size_t i;
  argument *ap;

  for (i = 0, ap = &a->arg[0]; i < a->count; i++, ap++)
   151b0:	e591c000 	ldr	ip, [r1]
   151b4:	e5913004 	ldr	r3, [r1, #4]
   151b8:	e35c0000 	cmp	ip, #0
   151bc:	0a00005b 	beq	15330 <printf_fetchargs+0x180>
{
   151c0:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
   151c4:	e2831010 	add	r1, r3, #16
  for (i = 0, ap = &a->arg[0]; i < a->count; i++, ap++)
   151c8:	e3a0e000 	mov	lr, #0
    switch (ap->type)
   151cc:	e5513010 	ldrb	r3, [r1, #-16]
   151d0:	e2433001 	sub	r3, r3, #1
   151d4:	e353002d 	cmp	r3, #45	@ 0x2d
   151d8:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   151dc:	ea000055 	b	15338 <printf_fetchargs+0x188>
   151e0:	000152cc 	.word	0x000152cc
   151e4:	000152cc 	.word	0x000152cc
   151e8:	000152d8 	.word	0x000152d8
   151ec:	000152d8 	.word	0x000152d8
   151f0:	00015298 	.word	0x00015298
   151f4:	00015298 	.word	0x00015298
   151f8:	00015298 	.word	0x00015298
   151fc:	00015298 	.word	0x00015298
   15200:	000152b8 	.word	0x000152b8
   15204:	000152b8 	.word	0x000152b8
   15208:	000152cc 	.word	0x000152cc
   1520c:	000152cc 	.word	0x000152cc
   15210:	000152d8 	.word	0x000152d8
   15214:	000152d8 	.word	0x000152d8
   15218:	00015298 	.word	0x00015298
   1521c:	00015298 	.word	0x00015298
   15220:	000152b8 	.word	0x000152b8
   15224:	000152b8 	.word	0x000152b8
   15228:	00015298 	.word	0x00015298
   1522c:	00015298 	.word	0x00015298
   15230:	00015298 	.word	0x00015298
   15234:	00015298 	.word	0x00015298
   15238:	00015298 	.word	0x00015298
   1523c:	00015298 	.word	0x00015298
   15240:	000152b8 	.word	0x000152b8
   15244:	000152b8 	.word	0x000152b8
   15248:	000152e4 	.word	0x000152e4
   1524c:	000152e4 	.word	0x000152e4
   15250:	00015298 	.word	0x00015298
   15254:	00015298 	.word	0x00015298
   15258:	000152f8 	.word	0x000152f8
   1525c:	00015314 	.word	0x00015314
   15260:	00015298 	.word	0x00015298
   15264:	00015298 	.word	0x00015298
   15268:	00015298 	.word	0x00015298
   1526c:	00015298 	.word	0x00015298
   15270:	00015298 	.word	0x00015298
   15274:	00015298 	.word	0x00015298
   15278:	00015298 	.word	0x00015298
   1527c:	00015298 	.word	0x00015298
   15280:	00015298 	.word	0x00015298
   15284:	00015298 	.word	0x00015298
   15288:	00015298 	.word	0x00015298
   1528c:	00015298 	.word	0x00015298
   15290:	00015298 	.word	0x00015298
   15294:	00015298 	.word	0x00015298
        break;
      case TYPE_COUNT_INT_FAST32_T_POINTER:
        ap->a.a_count_int_fast32_t_pointer = va_arg (args, int_fast32_t *);
        break;
      case TYPE_COUNT_INT_FAST64_T_POINTER:
        ap->a.a_count_int_fast64_t_pointer = va_arg (args, int_fast64_t *);
   15298:	e4903004 	ldr	r3, [r0], #4
   1529c:	e5013008 	str	r3, [r1, #-8]
  for (i = 0, ap = &a->arg[0]; i < a->count; i++, ap++)
   152a0:	e28ee001 	add	lr, lr, #1
   152a4:	e2811010 	add	r1, r1, #16
   152a8:	e15c000e 	cmp	ip, lr
   152ac:	1affffc6 	bne	151cc <printf_fetchargs+0x1c>
#endif
      default:
        /* Unknown type.  */
        return -1;
      }
  return 0;
   152b0:	e3a00000 	mov	r0, #0
   152b4:	e49df004 	pop	{pc}		@ (ldr pc, [sp], #4)
        ap->a.a_uint_fast64_t = va_arg (args, uint_fast64_t);
   152b8:	e2800007 	add	r0, r0, #7
   152bc:	e3c00007 	bic	r0, r0, #7
   152c0:	e0c020d8 	ldrd	r2, [r0], #8
   152c4:	e14120f8 	strd	r2, [r1, #-8]
        break;
   152c8:	eafffff4 	b	152a0 <printf_fetchargs+0xf0>
        ap->a.a_uint8_t = va_arg (args, /* uint8_t */ int);
   152cc:	e4903004 	ldr	r3, [r0], #4
   152d0:	e5413008 	strb	r3, [r1, #-8]
        break;
   152d4:	eafffff1 	b	152a0 <printf_fetchargs+0xf0>
        ap->a.a_uint16_t = va_arg (args, /* uint16_t */ int);
   152d8:	e4903004 	ldr	r3, [r0], #4
   152dc:	e14130b8 	strh	r3, [r1, #-8]
        break;
   152e0:	eaffffee 	b	152a0 <printf_fetchargs+0xf0>
        ap->a.a_longdouble = va_arg (args, long double);
   152e4:	e2800007 	add	r0, r0, #7
   152e8:	e3c00007 	bic	r0, r0, #7
   152ec:	e0c020d8 	ldrd	r2, [r0], #8
   152f0:	e14120f8 	strd	r2, [r1, #-8]
        break;
   152f4:	eaffffe9 	b	152a0 <printf_fetchargs+0xf0>
        ap->a.a_string = va_arg (args, const char *);
   152f8:	e4902004 	ldr	r2, [r0], #4
        if (ap->a.a_string == NULL)
   152fc:	e309315c 	movw	r3, #37212	@ 0x915c
   15300:	e3403002 	movt	r3, #2
   15304:	e3520000 	cmp	r2, #0
   15308:	01a02003 	moveq	r2, r3
          ap->a.a_string = "(NULL)";
   1530c:	e5012008 	str	r2, [r1, #-8]
   15310:	eaffffe2 	b	152a0 <printf_fetchargs+0xf0>
        ap->a.a_wide_string = va_arg (args, const wchar_t *);
   15314:	e4902004 	ldr	r2, [r0], #4
        if (ap->a.a_wide_string == NULL)
   15318:	e3093e34 	movw	r3, #40500	@ 0x9e34
   1531c:	e3403002 	movt	r3, #2
   15320:	e3520000 	cmp	r2, #0
   15324:	01a02003 	moveq	r2, r3
            ap->a.a_wide_string = wide_null_string;
   15328:	e5012008 	str	r2, [r1, #-8]
   1532c:	eaffffdb 	b	152a0 <printf_fetchargs+0xf0>
  return 0;
   15330:	e3a00000 	mov	r0, #0
}
   15334:	e12fff1e 	bx	lr
    switch (ap->type)
   15338:	e3e00000 	mvn	r0, #0
}
   1533c:	e49df004 	pop	{pc}		@ (ldr pc, [sp], #4)

00015340 <printf_parse>:
#ifdef STATIC
STATIC
#endif
int
PRINTF_PARSE (const CHAR_T *format, DIRECTIVES *d, arguments *a)
{
   15340:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  size_t d_allocated;           /* allocated elements of d->dir */
  size_t a_allocated;           /* allocated elements of a->arg */
  size_t max_width_length = 0;
  size_t max_precision_length = 0;

  d->count = 0;
   15344:	e3a03000 	mov	r3, #0
   15348:	e1a06001 	mov	r6, r1
{
   1534c:	e1a08002 	mov	r8, r2
   15350:	e1a09001 	mov	r9, r1
   15354:	e24dd024 	sub	sp, sp, #36	@ 0x24
  d->count = 0;
   15358:	e4863010 	str	r3, [r6], #16
    else if (a->arg[n].type != (_type_))                                \
      /* Ambiguous type for positional argument.  */                    \
      goto error;                                                       \
  }

  while (*cp != '\0')
   1535c:	e1a02003 	mov	r2, r3
  d->dir = d->direct_alloc_dir;
   15360:	e5816004 	str	r6, [r1, #4]
  a->count = 0;
   15364:	e1a01008 	mov	r1, r8
   15368:	e4813008 	str	r3, [r1], #8
  a_allocated = N_DIRECT_ALLOC_ARGUMENTS;
   1536c:	e3a03007 	mov	r3, #7
{
   15370:	e1a04000 	mov	r4, r0
  size_t arg_posn = 0;          /* number of regular arguments consumed */
   15374:	e1a0a002 	mov	sl, r2
  d->count = 0;
   15378:	e58d6018 	str	r6, [sp, #24]
  a->count = 0;
   1537c:	e58d1008 	str	r1, [sp, #8]
  a->arg = a->direct_alloc_arg;
   15380:	e5881004 	str	r1, [r8, #4]
  a_allocated = N_DIRECT_ALLOC_ARGUMENTS;
   15384:	e58d3004 	str	r3, [sp, #4]
  size_t max_precision_length = 0;
   15388:	e58d2014 	str	r2, [sp, #20]
  size_t max_width_length = 0;
   1538c:	e58d2010 	str	r2, [sp, #16]
  d_allocated = N_DIRECT_ALLOC_DIRECTIVES;
   15390:	e58d300c 	str	r3, [sp, #12]
  while (*cp != '\0')
   15394:	ea000001 	b	153a0 <printf_parse+0x60>
    {
      CHAR_T c = *cp++;
      if (c == '%')
   15398:	e3550025 	cmp	r5, #37	@ 0x25
   1539c:	0a00000d 	beq	153d8 <printf_parse+0x98>
      CHAR_T c = *cp++;
   153a0:	e1a03004 	mov	r3, r4
  while (*cp != '\0')
   153a4:	e4d45001 	ldrb	r5, [r4], #1
   153a8:	e3550000 	cmp	r5, #0
   153ac:	1afffff9 	bne	15398 <printf_parse+0x58>
          /* Non-ASCII character.  Not supported.  */
          goto error;
        }
#endif
    }
  d->dir[d->count].dir_start = cp;
   153b0:	e3a0102c 	mov	r1, #44	@ 0x2c

  d->max_width_length = max_width_length;
  d->max_precision_length = max_precision_length;
  return 0;
   153b4:	e1a00005 	mov	r0, r5
  d->dir[d->count].dir_start = cp;
   153b8:	e0020291 	mul	r2, r1, r2
   153bc:	e7863002 	str	r3, [r6, r2]
  d->max_width_length = max_width_length;
   153c0:	e59d3010 	ldr	r3, [sp, #16]
   153c4:	e5893008 	str	r3, [r9, #8]
  d->max_precision_length = max_precision_length;
   153c8:	e59d3014 	ldr	r3, [sp, #20]
   153cc:	e589300c 	str	r3, [r9, #12]
    free (a->arg);
  if (d->dir != d->direct_alloc_dir)
    free (d->dir);
  errno = ENOMEM;
  return -1;
}
   153d0:	e28dd024 	add	sp, sp, #36	@ 0x24
   153d4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
          DIRECTIVE *dp = &d->dir[d->count]; /* pointer to next directive */
   153d8:	e3a0102c 	mov	r1, #44	@ 0x2c
          dp->width_arg_index = ARG_NONE;
   153dc:	e3e0b000 	mvn	fp, #0
          DIRECTIVE *dp = &d->dir[d->count]; /* pointer to next directive */
   153e0:	e0020291 	mul	r2, r1, r2
          dp->dir_start = cp - 1;
   153e4:	e7863002 	str	r3, [r6, r2]
          DIRECTIVE *dp = &d->dir[d->count]; /* pointer to next directive */
   153e8:	e0866002 	add	r6, r6, r2
          dp->flags = 0;
   153ec:	e3a03000 	mov	r3, #0
          dp->width_arg_index = ARG_NONE;
   153f0:	e586b014 	str	fp, [r6, #20]
          dp->flags = 0;
   153f4:	e5863008 	str	r3, [r6, #8]
          dp->width_start = NULL;
   153f8:	e586300c 	str	r3, [r6, #12]
   153fc:	e5863010 	str	r3, [r6, #16]
          dp->precision_start = NULL;
   15400:	e5863018 	str	r3, [r6, #24]
   15404:	e586301c 	str	r3, [r6, #28]
          dp->precision_arg_index = ARG_NONE;
   15408:	e586b020 	str	fp, [r6, #32]
          dp->arg_index = ARG_NONE;
   1540c:	e586b028 	str	fp, [r6, #40]	@ 0x28
          if (*cp >= '0' && *cp <= '9')
   15410:	e5d47000 	ldrb	r7, [r4]
   15414:	e2470030 	sub	r0, r7, #48	@ 0x30
   15418:	e6ef3070 	uxtb	r3, r0
   1541c:	e3530009 	cmp	r3, #9
   15420:	9a000258 	bls	15d88 <printf_parse+0xa48>
   15424:	e2843001 	add	r3, r4, #1
              if (*cp == '\'')
   15428:	e2472020 	sub	r2, r7, #32
   1542c:	e3520010 	cmp	r2, #16
   15430:	979ff102 	ldrls	pc, [pc, r2, lsl #2]
   15434:	ea000010 	b	1547c <printf_parse+0x13c>
   15438:	000155ac 	.word	0x000155ac
   1543c:	0001547c 	.word	0x0001547c
   15440:	0001547c 	.word	0x0001547c
   15444:	000155a0 	.word	0x000155a0
   15448:	0001547c 	.word	0x0001547c
   1544c:	0001547c 	.word	0x0001547c
   15450:	0001547c 	.word	0x0001547c
   15454:	00015594 	.word	0x00015594
   15458:	0001547c 	.word	0x0001547c
   1545c:	0001547c 	.word	0x0001547c
   15460:	0001547c 	.word	0x0001547c
   15464:	00015588 	.word	0x00015588
   15468:	0001547c 	.word	0x0001547c
   1546c:	0001557c 	.word	0x0001557c
   15470:	0001547c 	.word	0x0001547c
   15474:	0001547c 	.word	0x0001547c
   15478:	00015568 	.word	0x00015568
          if (*cp == '*')
   1547c:	e357002a 	cmp	r7, #42	@ 0x2a
   15480:	e2434001 	sub	r4, r3, #1
   15484:	0a0000ba 	beq	15774 <printf_parse+0x434>
          else if (*cp >= '0' && *cp <= '9')
   15488:	e2473030 	sub	r3, r7, #48	@ 0x30
   1548c:	e3530009 	cmp	r3, #9
   15490:	9a00025d 	bls	15e0c <printf_parse+0xacc>
          if (*cp == '.')
   15494:	e357002e 	cmp	r7, #46	@ 0x2e
   15498:	0a0000fc 	beq	15890 <printf_parse+0x550>
            if (*cp == 'h')
   1549c:	e247304c 	sub	r3, r7, #76	@ 0x4c
   154a0:	e353002e 	cmp	r3, #46	@ 0x2e
   154a4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   154a8:	ea000042 	b	155b8 <printf_parse+0x278>
   154ac:	00015c74 	.word	0x00015c74
   154b0:	000155b8 	.word	0x000155b8
   154b4:	000155b8 	.word	0x000155b8
   154b8:	000155b8 	.word	0x000155b8
   154bc:	000155b8 	.word	0x000155b8
   154c0:	000155b8 	.word	0x000155b8
   154c4:	000155b8 	.word	0x000155b8
   154c8:	000155b8 	.word	0x000155b8
   154cc:	000155b8 	.word	0x000155b8
   154d0:	000155b8 	.word	0x000155b8
   154d4:	000155b8 	.word	0x000155b8
   154d8:	000155b8 	.word	0x000155b8
   154dc:	000155b8 	.word	0x000155b8
   154e0:	000155b8 	.word	0x000155b8
   154e4:	00015bd8 	.word	0x00015bd8
   154e8:	000155b8 	.word	0x000155b8
   154ec:	000155b8 	.word	0x000155b8
   154f0:	000155b8 	.word	0x000155b8
   154f4:	000155b8 	.word	0x000155b8
   154f8:	000155b8 	.word	0x000155b8
   154fc:	000155b8 	.word	0x000155b8
   15500:	000155b8 	.word	0x000155b8
   15504:	000155b8 	.word	0x000155b8
   15508:	000155b8 	.word	0x000155b8
   1550c:	000155b8 	.word	0x000155b8
   15510:	000155b8 	.word	0x000155b8
   15514:	000155b8 	.word	0x000155b8
   15518:	000155b8 	.word	0x000155b8
   1551c:	00015c90 	.word	0x00015c90
   15520:	000155b8 	.word	0x000155b8
   15524:	00015c74 	.word	0x00015c74
   15528:	000155b8 	.word	0x000155b8
   1552c:	00015d08 	.word	0x00015d08
   15530:	000155b8 	.word	0x000155b8
   15534:	000155b8 	.word	0x000155b8
   15538:	000155b8 	.word	0x000155b8
   1553c:	000155b8 	.word	0x000155b8
   15540:	000155b8 	.word	0x000155b8
   15544:	000155b8 	.word	0x000155b8
   15548:	000155b8 	.word	0x000155b8
   1554c:	00015bd8 	.word	0x00015bd8
   15550:	000155b8 	.word	0x000155b8
   15554:	000155b8 	.word	0x000155b8
   15558:	00015cb4 	.word	0x00015cb4
   1555c:	000155b8 	.word	0x000155b8
   15560:	000155b8 	.word	0x000155b8
   15564:	00015bd8 	.word	0x00015bd8
                  dp->flags |= FLAG_ZERO;
   15568:	e5962008 	ldr	r2, [r6, #8]
   1556c:	e3822020 	orr	r2, r2, #32
                  dp->flags |= FLAG_GROUP;
   15570:	e5862008 	str	r2, [r6, #8]
              if (*cp == '\'')
   15574:	e4d37001 	ldrb	r7, [r3], #1
   15578:	eaffffaa 	b	15428 <printf_parse+0xe8>
                  dp->flags |= FLAG_LEFT;
   1557c:	e5962008 	ldr	r2, [r6, #8]
   15580:	e3822002 	orr	r2, r2, #2
                  cp++;
   15584:	eafffff9 	b	15570 <printf_parse+0x230>
                  dp->flags |= FLAG_SHOWSIGN;
   15588:	e5962008 	ldr	r2, [r6, #8]
   1558c:	e3822004 	orr	r2, r2, #4
                  cp++;
   15590:	eafffff6 	b	15570 <printf_parse+0x230>
                  dp->flags |= FLAG_GROUP;
   15594:	e5962008 	ldr	r2, [r6, #8]
   15598:	e3822001 	orr	r2, r2, #1
                  cp++;
   1559c:	eafffff3 	b	15570 <printf_parse+0x230>
                  dp->flags |= FLAG_ALT;
   155a0:	e5962008 	ldr	r2, [r6, #8]
   155a4:	e3822010 	orr	r2, r2, #16
                  cp++;
   155a8:	eafffff0 	b	15570 <printf_parse+0x230>
                  dp->flags |= FLAG_SPACE;
   155ac:	e5962008 	ldr	r2, [r6, #8]
   155b0:	e3822008 	orr	r2, r2, #8
                  cp++;
   155b4:	eaffffed 	b	15570 <printf_parse+0x230>
                        signed_type = TYPE_INT8_T;
   155b8:	e3a0001b 	mov	r0, #27
   155bc:	e3a05024 	mov	r5, #36	@ 0x24
   155c0:	e3a03006 	mov	r3, #6
   155c4:	e3a01005 	mov	r1, #5
            switch (c)
   155c8:	e2472025 	sub	r2, r7, #37	@ 0x25
            c = *cp++;
   155cc:	e2844001 	add	r4, r4, #1
            switch (c)
   155d0:	e3520053 	cmp	r2, #83	@ 0x53
   155d4:	979ff102 	ldrls	pc, [pc, r2, lsl #2]
   155d8:	ea000057 	b	1573c <printf_parse+0x3fc>
   155dc:	00015aa0 	.word	0x00015aa0
   155e0:	0001573c 	.word	0x0001573c
   155e4:	0001573c 	.word	0x0001573c
   155e8:	0001573c 	.word	0x0001573c
   155ec:	0001573c 	.word	0x0001573c
   155f0:	0001573c 	.word	0x0001573c
   155f4:	0001573c 	.word	0x0001573c
   155f8:	0001573c 	.word	0x0001573c
   155fc:	0001573c 	.word	0x0001573c
   15600:	0001573c 	.word	0x0001573c
   15604:	0001573c 	.word	0x0001573c
   15608:	0001573c 	.word	0x0001573c
   1560c:	0001573c 	.word	0x0001573c
   15610:	0001573c 	.word	0x0001573c
   15614:	0001573c 	.word	0x0001573c
   15618:	0001573c 	.word	0x0001573c
   1561c:	0001573c 	.word	0x0001573c
   15620:	0001573c 	.word	0x0001573c
   15624:	0001573c 	.word	0x0001573c
   15628:	0001573c 	.word	0x0001573c
   1562c:	0001573c 	.word	0x0001573c
   15630:	0001573c 	.word	0x0001573c
   15634:	0001573c 	.word	0x0001573c
   15638:	0001573c 	.word	0x0001573c
   1563c:	0001573c 	.word	0x0001573c
   15640:	0001573c 	.word	0x0001573c
   15644:	0001573c 	.word	0x0001573c
   15648:	0001573c 	.word	0x0001573c
   1564c:	00015bc0 	.word	0x00015bc0
   15650:	0001573c 	.word	0x0001573c
   15654:	00015d3c 	.word	0x00015d3c
   15658:	0001573c 	.word	0x0001573c
   1565c:	00015bc0 	.word	0x00015bc0
   15660:	00015bc0 	.word	0x00015bc0
   15664:	00015bc0 	.word	0x00015bc0
   15668:	0001573c 	.word	0x0001573c
   1566c:	0001573c 	.word	0x0001573c
   15670:	0001573c 	.word	0x0001573c
   15674:	0001573c 	.word	0x0001573c
   15678:	0001573c 	.word	0x0001573c
   1567c:	0001573c 	.word	0x0001573c
   15680:	0001573c 	.word	0x0001573c
   15684:	0001573c 	.word	0x0001573c
   15688:	0001573c 	.word	0x0001573c
   1568c:	0001573c 	.word	0x0001573c
   15690:	0001573c 	.word	0x0001573c
   15694:	000159b0 	.word	0x000159b0
   15698:	0001573c 	.word	0x0001573c
   1569c:	0001573c 	.word	0x0001573c
   156a0:	0001573c 	.word	0x0001573c
   156a4:	0001573c 	.word	0x0001573c
   156a8:	000159b8 	.word	0x000159b8
   156ac:	0001573c 	.word	0x0001573c
   156b0:	0001573c 	.word	0x0001573c
   156b4:	0001573c 	.word	0x0001573c
   156b8:	0001573c 	.word	0x0001573c
   156bc:	0001573c 	.word	0x0001573c
   156c0:	0001573c 	.word	0x0001573c
   156c4:	0001573c 	.word	0x0001573c
   156c8:	0001573c 	.word	0x0001573c
   156cc:	00015bc0 	.word	0x00015bc0
   156d0:	000159b8 	.word	0x000159b8
   156d4:	00015d48 	.word	0x00015d48
   156d8:	00015ec8 	.word	0x00015ec8
   156dc:	00015bc0 	.word	0x00015bc0
   156e0:	00015bc0 	.word	0x00015bc0
   156e4:	00015bc0 	.word	0x00015bc0
   156e8:	0001573c 	.word	0x0001573c
   156ec:	00015ec8 	.word	0x00015ec8
   156f0:	0001573c 	.word	0x0001573c
   156f4:	0001573c 	.word	0x0001573c
   156f8:	0001573c 	.word	0x0001573c
   156fc:	0001573c 	.word	0x0001573c
   15700:	00015d60 	.word	0x00015d60
   15704:	000159b8 	.word	0x000159b8
   15708:	00015d80 	.word	0x00015d80
   1570c:	0001573c 	.word	0x0001573c
   15710:	0001573c 	.word	0x0001573c
   15714:	00015d68 	.word	0x00015d68
   15718:	0001573c 	.word	0x0001573c
   1571c:	000159b8 	.word	0x000159b8
   15720:	0001573c 	.word	0x0001573c
   15724:	0001573c 	.word	0x0001573c
   15728:	000159b8 	.word	0x000159b8
                    if (dp->arg_index == ARG_NONE)
   1572c:	e37a0001 	cmn	sl, #1
                    dp->arg_index = arg_posn++;
   15730:	e28a5001 	add	r5, sl, #1
   15734:	e586a028 	str	sl, [r6, #40]	@ 0x28
                    if (dp->arg_index == ARG_NONE)
   15738:	1a0000a3 	bne	159cc <printf_parse+0x68c>
   1573c:	e5980004 	ldr	r0, [r8, #4]
  if (a->arg != a->direct_alloc_arg)
   15740:	e59d3008 	ldr	r3, [sp, #8]
   15744:	e1530000 	cmp	r3, r0
   15748:	0a000000 	beq	15750 <printf_parse+0x410>
    free (a->arg);
   1574c:	ebffd341 	bl	a458 <rpl_free>
  if (d->dir != d->direct_alloc_dir)
   15750:	e5990004 	ldr	r0, [r9, #4]
   15754:	e59d3018 	ldr	r3, [sp, #24]
   15758:	e1530000 	cmp	r3, r0
   1575c:	0a000000 	beq	15764 <printf_parse+0x424>
    free (d->dir);
   15760:	ebffd33c 	bl	a458 <rpl_free>
  errno = EINVAL;
   15764:	eb00182a 	bl	1b814 <__errno>
   15768:	e3a03016 	mov	r3, #22
   1576c:	e5803000 	str	r3, [r0]
  return -1;
   15770:	ea0000e1 	b	15afc <printf_parse+0x7bc>
              dp->width_start = cp;
   15774:	e59d1010 	ldr	r1, [sp, #16]
              cp++;
   15778:	e1a0e003 	mov	lr, r3
              dp->width_start = cp;
   1577c:	e586400c 	str	r4, [r6, #12]
              dp->width_end = cp;
   15780:	e5863010 	str	r3, [r6, #16]
              if (*cp >= '0' && *cp <= '9')
   15784:	e5d42001 	ldrb	r2, [r4, #1]
   15788:	e3510001 	cmp	r1, #1
   1578c:	33a01001 	movcc	r1, #1
   15790:	e58d1010 	str	r1, [sp, #16]
   15794:	e2422030 	sub	r2, r2, #48	@ 0x30
   15798:	e6ef1072 	uxtb	r1, r2
   1579c:	e3510009 	cmp	r1, #9
   157a0:	9a000113 	bls	15bf4 <printf_parse+0x8b4>
                  if (dp->width_arg_index == ARG_NONE)
   157a4:	e37a0001 	cmn	sl, #1
                  dp->width_arg_index = arg_posn++;
   157a8:	e28a2001 	add	r2, sl, #1
   157ac:	e586a014 	str	sl, [r6, #20]
                  if (dp->width_arg_index == ARG_NONE)
   157b0:	0affffe1 	beq	1573c <printf_parse+0x3fc>
   157b4:	e1a0700a 	mov	r7, sl
   157b8:	e1a04003 	mov	r4, r3
                  dp->width_arg_index = arg_posn++;
   157bc:	e1a0a002 	mov	sl, r2
              REGISTER_ARG (dp->width_arg_index, TYPE_INT);
   157c0:	e59d3004 	ldr	r3, [sp, #4]
   157c4:	e1530007 	cmp	r3, r7
   157c8:	8a000018 	bhi	15830 <printf_parse+0x4f0>
   157cc:	e3530000 	cmp	r3, #0
   157d0:	ba0000bc 	blt	15ac8 <printf_parse+0x788>
   157d4:	e59d3004 	ldr	r3, [sp, #4]
   157d8:	e5980004 	ldr	r0, [r8, #4]
   157dc:	e1a03083 	lsl	r3, r3, #1
   157e0:	e1530007 	cmp	r3, r7
   157e4:	e58d3004 	str	r3, [sp, #4]
  size_t sum = size1 + size2;
   157e8:	92873001 	addls	r3, r7, #1
   157ec:	958d3004 	strls	r3, [sp, #4]
   157f0:	e59d3004 	ldr	r3, [sp, #4]
   157f4:	e373021f 	cmn	r3, #-268435455	@ 0xf0000001
   157f8:	8a0000b3 	bhi	15acc <printf_parse+0x78c>
   157fc:	e59d2008 	ldr	r2, [sp, #8]
   15800:	e1a01203 	lsl	r1, r3, #4
   15804:	e1520000 	cmp	r2, r0
   15808:	0a0001be 	beq	15f08 <printf_parse+0xbc8>
   1580c:	ebffe38c 	bl	e644 <rpl_realloc>
   15810:	e1a03000 	mov	r3, r0
   15814:	e3530000 	cmp	r3, #0
   15818:	e5980004 	ldr	r0, [r8, #4]
   1581c:	0a0000aa 	beq	15acc <printf_parse+0x78c>
   15820:	e59d2008 	ldr	r2, [sp, #8]
   15824:	e1520000 	cmp	r2, r0
   15828:	0a0001ba 	beq	15f18 <printf_parse+0xbd8>
   1582c:	e5883004 	str	r3, [r8, #4]
   15830:	e5983000 	ldr	r3, [r8]
   15834:	e1530007 	cmp	r3, r7
   15838:	8a00000b 	bhi	1586c <printf_parse+0x52c>
   1583c:	e5982004 	ldr	r2, [r8, #4]
   15840:	e3a01000 	mov	r1, #0
   15844:	e2420010 	sub	r0, r2, #16
   15848:	e0822203 	add	r2, r2, r3, lsl #4
   1584c:	e2833001 	add	r3, r3, #1
   15850:	e1530007 	cmp	r3, r7
   15854:	e1a0c002 	mov	ip, r2
   15858:	e7c01203 	strb	r1, [r0, r3, lsl #4]
   1585c:	e2822010 	add	r2, r2, #16
   15860:	9afffff9 	bls	1584c <printf_parse+0x50c>
   15864:	e5883000 	str	r3, [r8]
   15868:	e5cc1000 	strb	r1, [ip]
   1586c:	e5980004 	ldr	r0, [r8, #4]
   15870:	e7d03207 	ldrb	r3, [r0, r7, lsl #4]
   15874:	e3530000 	cmp	r3, #0
   15878:	1a000176 	bne	15e58 <printf_parse+0xb18>
   1587c:	e3a03005 	mov	r3, #5
   15880:	e7c03207 	strb	r3, [r0, r7, lsl #4]
          if (*cp == '.')
   15884:	e5d47000 	ldrb	r7, [r4]
   15888:	e357002e 	cmp	r7, #46	@ 0x2e
   1588c:	1affff02 	bne	1549c <printf_parse+0x15c>
              if (*cp == '*')
   15890:	e5d43001 	ldrb	r3, [r4, #1]
                  dp->precision_start = cp - 1;
   15894:	e5864018 	str	r4, [r6, #24]
              if (*cp == '*')
   15898:	e353002a 	cmp	r3, #42	@ 0x2a
   1589c:	1a0000b5 	bne	15b78 <printf_parse+0x838>
                  if (max_precision_length < 2)
   158a0:	e59d3014 	ldr	r3, [sp, #20]
   158a4:	e3530002 	cmp	r3, #2
   158a8:	33a03002 	movcc	r3, #2
   158ac:	e58d3014 	str	r3, [sp, #20]
                  cp++;
   158b0:	e2843002 	add	r3, r4, #2
                  dp->precision_end = cp;
   158b4:	e586301c 	str	r3, [r6, #28]
                  if (*cp >= '0' && *cp <= '9')
   158b8:	e5d42002 	ldrb	r2, [r4, #2]
   158bc:	e2422030 	sub	r2, r2, #48	@ 0x30
   158c0:	e6ef1072 	uxtb	r1, r2
   158c4:	e3510009 	cmp	r1, #9
   158c8:	9a000199 	bls	15f34 <printf_parse+0xbf4>
                  if (dp->precision_arg_index == ARG_NONE)
   158cc:	e5964020 	ldr	r4, [r6, #32]
   158d0:	e3740001 	cmn	r4, #1
   158d4:	0a000184 	beq	15eec <printf_parse+0xbac>
                  REGISTER_ARG (dp->precision_arg_index, TYPE_INT);
   158d8:	e59d2004 	ldr	r2, [sp, #4]
   158dc:	e1520004 	cmp	r2, r4
   158e0:	8a00001a 	bhi	15950 <printf_parse+0x610>
   158e4:	e3520000 	cmp	r2, #0
   158e8:	ba000076 	blt	15ac8 <printf_parse+0x788>
   158ec:	e59d2004 	ldr	r2, [sp, #4]
   158f0:	e5980004 	ldr	r0, [r8, #4]
   158f4:	e1a02082 	lsl	r2, r2, #1
   158f8:	e1520004 	cmp	r2, r4
   158fc:	e58d2004 	str	r2, [sp, #4]
   15900:	92842001 	addls	r2, r4, #1
   15904:	958d2004 	strls	r2, [sp, #4]
   15908:	e59d2004 	ldr	r2, [sp, #4]
   1590c:	e372021f 	cmn	r2, #-268435455	@ 0xf0000001
   15910:	8a00006d 	bhi	15acc <printf_parse+0x78c>
   15914:	e59d1008 	ldr	r1, [sp, #8]
   15918:	e58d301c 	str	r3, [sp, #28]
   1591c:	e1510000 	cmp	r1, r0
   15920:	e1a01202 	lsl	r1, r2, #4
   15924:	0a0001ca 	beq	16054 <printf_parse+0xd14>
   15928:	ebffe345 	bl	e644 <rpl_realloc>
   1592c:	e59d301c 	ldr	r3, [sp, #28]
   15930:	e1a07000 	mov	r7, r0
   15934:	e3570000 	cmp	r7, #0
   15938:	e5980004 	ldr	r0, [r8, #4]
   1593c:	0a000062 	beq	15acc <printf_parse+0x78c>
   15940:	e59d2008 	ldr	r2, [sp, #8]
   15944:	e1520000 	cmp	r2, r0
   15948:	0a0001b9 	beq	16034 <printf_parse+0xcf4>
   1594c:	e5887004 	str	r7, [r8, #4]
   15950:	e5982000 	ldr	r2, [r8]
   15954:	e1520004 	cmp	r2, r4
   15958:	8a00000b 	bhi	1598c <printf_parse+0x64c>
   1595c:	e5981004 	ldr	r1, [r8, #4]
   15960:	e3a00000 	mov	r0, #0
   15964:	e241c010 	sub	ip, r1, #16
   15968:	e0811202 	add	r1, r1, r2, lsl #4
   1596c:	e2822001 	add	r2, r2, #1
   15970:	e1520004 	cmp	r2, r4
   15974:	e1a0e001 	mov	lr, r1
   15978:	e7cc0202 	strb	r0, [ip, r2, lsl #4]
   1597c:	e2811010 	add	r1, r1, #16
   15980:	9afffff9 	bls	1596c <printf_parse+0x62c>
   15984:	e5882000 	str	r2, [r8]
   15988:	e5ce0000 	strb	r0, [lr]
   1598c:	e5980004 	ldr	r0, [r8, #4]
   15990:	e7d02204 	ldrb	r2, [r0, r4, lsl #4]
   15994:	e3520000 	cmp	r2, #0
   15998:	1a000145 	bne	15eb4 <printf_parse+0xb74>
   1599c:	e3a02005 	mov	r2, #5
   159a0:	e7c02204 	strb	r2, [r0, r4, lsl #4]
   159a4:	e1a04003 	mov	r4, r3
            if (*cp == 'h')
   159a8:	e5d37000 	ldrb	r7, [r3]
   159ac:	eafffeba 	b	1549c <printf_parse+0x15c>
                  type = TYPE_WIDE_STRING;
   159b0:	e3a03020 	mov	r3, #32
            c = *cp++;
   159b4:	e3a07073 	mov	r7, #115	@ 0x73
                if (dp->arg_index == ARG_NONE)
   159b8:	e37b0001 	cmn	fp, #1
   159bc:	0affff5a 	beq	1572c <printf_parse+0x3ec>
                dp->arg_index = arg_index;
   159c0:	e1a0500a 	mov	r5, sl
   159c4:	e1a0a00b 	mov	sl, fp
   159c8:	e586b028 	str	fp, [r6, #40]	@ 0x28
                REGISTER_ARG (dp->arg_index, type);
   159cc:	e59d2004 	ldr	r2, [sp, #4]
   159d0:	e152000a 	cmp	r2, sl
   159d4:	8a00001a 	bhi	15a44 <printf_parse+0x704>
   159d8:	e3520000 	cmp	r2, #0
   159dc:	ba000039 	blt	15ac8 <printf_parse+0x788>
   159e0:	e59d2004 	ldr	r2, [sp, #4]
   159e4:	e5980004 	ldr	r0, [r8, #4]
   159e8:	e1a02082 	lsl	r2, r2, #1
   159ec:	e152000a 	cmp	r2, sl
   159f0:	e58d2004 	str	r2, [sp, #4]
   159f4:	928a2001 	addls	r2, sl, #1
   159f8:	958d2004 	strls	r2, [sp, #4]
   159fc:	e59d2004 	ldr	r2, [sp, #4]
   15a00:	e372021f 	cmn	r2, #-268435455	@ 0xf0000001
   15a04:	8a000030 	bhi	15acc <printf_parse+0x78c>
   15a08:	e59d1008 	ldr	r1, [sp, #8]
   15a0c:	e58d301c 	str	r3, [sp, #28]
   15a10:	e1510000 	cmp	r1, r0
   15a14:	e1a01202 	lsl	r1, r2, #4
   15a18:	0a000111 	beq	15e64 <printf_parse+0xb24>
   15a1c:	ebffe308 	bl	e644 <rpl_realloc>
   15a20:	e59d301c 	ldr	r3, [sp, #28]
   15a24:	e1a0b000 	mov	fp, r0
   15a28:	e35b0000 	cmp	fp, #0
   15a2c:	e5980004 	ldr	r0, [r8, #4]
   15a30:	0a000025 	beq	15acc <printf_parse+0x78c>
   15a34:	e59d2008 	ldr	r2, [sp, #8]
   15a38:	e1520000 	cmp	r2, r0
   15a3c:	0a00010d 	beq	15e78 <printf_parse+0xb38>
   15a40:	e588b004 	str	fp, [r8, #4]
   15a44:	e5982000 	ldr	r2, [r8]
   15a48:	e152000a 	cmp	r2, sl
   15a4c:	8a00000b 	bhi	15a80 <printf_parse+0x740>
   15a50:	e5981004 	ldr	r1, [r8, #4]
   15a54:	e3a00000 	mov	r0, #0
   15a58:	e241c010 	sub	ip, r1, #16
   15a5c:	e0811202 	add	r1, r1, r2, lsl #4
   15a60:	e2822001 	add	r2, r2, #1
   15a64:	e152000a 	cmp	r2, sl
   15a68:	e1a0e001 	mov	lr, r1
   15a6c:	e7cc0202 	strb	r0, [ip, r2, lsl #4]
   15a70:	e2811010 	add	r1, r1, #16
   15a74:	9afffff9 	bls	15a60 <printf_parse+0x720>
   15a78:	e5882000 	str	r2, [r8]
   15a7c:	e5ce0000 	strb	r0, [lr]
   15a80:	e5980004 	ldr	r0, [r8, #4]
   15a84:	e7d0220a 	ldrb	r2, [r0, sl, lsl #4]
   15a88:	e3520000 	cmp	r2, #0
   15a8c:	07c0320a 	strbeq	r3, [r0, sl, lsl #4]
   15a90:	0a000001 	beq	15a9c <printf_parse+0x75c>
   15a94:	e1520003 	cmp	r2, r3
   15a98:	1affff28 	bne	15740 <printf_parse+0x400>
                dp->arg_index = arg_index;
   15a9c:	e1a0a005 	mov	sl, r5
            dp->conversion = c;
   15aa0:	e5c67024 	strb	r7, [r6, #36]	@ 0x24
          d->count++;
   15aa4:	e5992000 	ldr	r2, [r9]
          if (d->count >= d_allocated)
   15aa8:	e59d300c 	ldr	r3, [sp, #12]
            dp->dir_end = cp;
   15aac:	e5864004 	str	r4, [r6, #4]
          d->count++;
   15ab0:	e2822001 	add	r2, r2, #1
          if (d->count >= d_allocated)
   15ab4:	e1530002 	cmp	r3, r2
          d->count++;
   15ab8:	e5892000 	str	r2, [r9]
          if (d->count >= d_allocated)
   15abc:	9a000011 	bls	15b08 <printf_parse+0x7c8>
              memory = (DIRECTIVE *) (d->dir != d->direct_alloc_dir
   15ac0:	e5996004 	ldr	r6, [r9, #4]
   15ac4:	eafffe35 	b	153a0 <printf_parse+0x60>
   15ac8:	e5980004 	ldr	r0, [r8, #4]
  if (a->arg != a->direct_alloc_arg)
   15acc:	e59d3008 	ldr	r3, [sp, #8]
   15ad0:	e1530000 	cmp	r3, r0
   15ad4:	0a000000 	beq	15adc <printf_parse+0x79c>
    free (a->arg);
   15ad8:	ebffd25e 	bl	a458 <rpl_free>
  if (d->dir != d->direct_alloc_dir)
   15adc:	e5990004 	ldr	r0, [r9, #4]
   15ae0:	e59d3018 	ldr	r3, [sp, #24]
   15ae4:	e1530000 	cmp	r3, r0
   15ae8:	0a000000 	beq	15af0 <printf_parse+0x7b0>
    free (d->dir);
   15aec:	ebffd259 	bl	a458 <rpl_free>
  errno = ENOMEM;
   15af0:	eb001747 	bl	1b814 <__errno>
   15af4:	e3a0300c 	mov	r3, #12
   15af8:	e5803000 	str	r3, [r0]
  return -1;
   15afc:	e3e00000 	mvn	r0, #0
}
   15b00:	e28dd024 	add	sp, sp, #36	@ 0x24
   15b04:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
              d_allocated = xtimes (d_allocated, 2);
   15b08:	e59d300c 	ldr	r3, [sp, #12]
   15b0c:	e3530000 	cmp	r3, #0
   15b10:	baffffec 	blt	15ac8 <printf_parse+0x788>
   15b14:	e59d300c 	ldr	r3, [sp, #12]
   15b18:	e1a05083 	lsl	r5, r3, #1
              memory_size = xtimes (d_allocated, sizeof (DIRECTIVE));
   15b1c:	e307345d 	movw	r3, #29789	@ 0x745d
   15b20:	e34035d1 	movt	r3, #1489	@ 0x5d1
   15b24:	e1550003 	cmp	r5, r3
   15b28:	8affffe6 	bhi	15ac8 <printf_parse+0x788>
              memory = (DIRECTIVE *) (d->dir != d->direct_alloc_dir
   15b2c:	e59d3018 	ldr	r3, [sp, #24]
              memory_size = xtimes (d_allocated, sizeof (DIRECTIVE));
   15b30:	e3a01058 	mov	r1, #88	@ 0x58
              memory = (DIRECTIVE *) (d->dir != d->direct_alloc_dir
   15b34:	e5990004 	ldr	r0, [r9, #4]
   15b38:	e1530000 	cmp	r3, r0
              memory_size = xtimes (d_allocated, sizeof (DIRECTIVE));
   15b3c:	e59d300c 	ldr	r3, [sp, #12]
   15b40:	e0010391 	mul	r1, r1, r3
              memory = (DIRECTIVE *) (d->dir != d->direct_alloc_dir
   15b44:	0a00001f 	beq	15bc8 <printf_parse+0x888>
                                      ? realloc (d->dir, memory_size)
   15b48:	ebffe2bd 	bl	e644 <rpl_realloc>
   15b4c:	e1a06000 	mov	r6, r0
              if (memory == NULL)
   15b50:	e3560000 	cmp	r6, #0
   15b54:	0affffdb 	beq	15ac8 <printf_parse+0x788>
              if (d->dir == d->direct_alloc_dir)
   15b58:	e5993004 	ldr	r3, [r9, #4]
   15b5c:	e59d2018 	ldr	r2, [sp, #24]
   15b60:	e1520003 	cmp	r2, r3
   15b64:	0a0000cb 	beq	15e98 <printf_parse+0xb58>
          DIRECTIVE *dp = &d->dir[d->count]; /* pointer to next directive */
   15b68:	e5992000 	ldr	r2, [r9]
              d_allocated = xtimes (d_allocated, 2);
   15b6c:	e58d500c 	str	r5, [sp, #12]
              d->dir = memory;
   15b70:	e5896004 	str	r6, [r9, #4]
   15b74:	eafffe09 	b	153a0 <printf_parse+0x60>
                  for (; *cp >= '0' && *cp <= '9'; cp++)
   15b78:	e5d43001 	ldrb	r3, [r4, #1]
              cp++;
   15b7c:	e2842001 	add	r2, r4, #1
                  for (; *cp >= '0' && *cp <= '9'; cp++)
   15b80:	e2433030 	sub	r3, r3, #48	@ 0x30
   15b84:	e3530009 	cmp	r3, #9
   15b88:	8a00014a 	bhi	160b8 <printf_parse+0xd78>
   15b8c:	e5f23001 	ldrb	r3, [r2, #1]!
   15b90:	e2433030 	sub	r3, r3, #48	@ 0x30
   15b94:	e3530009 	cmp	r3, #9
   15b98:	9afffffb 	bls	15b8c <printf_parse+0x84c>
                  precision_length = dp->precision_end - dp->precision_start;
   15b9c:	e0423004 	sub	r3, r2, r4
   15ba0:	e1a04002 	mov	r4, r2
                  dp->precision_end = cp;
   15ba4:	e586201c 	str	r2, [r6, #28]
            if (*cp == 'h')
   15ba8:	e5d27000 	ldrb	r7, [r2]
                  if (max_precision_length < precision_length)
   15bac:	e59d2014 	ldr	r2, [sp, #20]
   15bb0:	e1520003 	cmp	r2, r3
   15bb4:	21a03002 	movcs	r3, r2
   15bb8:	e58d3014 	str	r3, [sp, #20]
   15bbc:	eafffe36 	b	1549c <printf_parse+0x15c>
                type = floatingpoint_type;
   15bc0:	e1a03000 	mov	r3, r0
   15bc4:	eaffff7b 	b	159b8 <printf_parse+0x678>
                                      : malloc (memory_size));
   15bc8:	e1a00001 	mov	r0, r1
   15bcc:	ebffe290 	bl	e614 <rpl_malloc>
   15bd0:	e1a06000 	mov	r6, r0
   15bd4:	eaffffdd 	b	15b50 <printf_parse+0x810>
                if (cp[1] == 'h')
   15bd8:	e5d47001 	ldrb	r7, [r4, #1]
            arg_type floatingpoint_type = TYPE_DOUBLE;
   15bdc:	e3a0001b 	mov	r0, #27
                cp++;
   15be0:	e2844001 	add	r4, r4, #1
            arg_type pointer_type = TYPE_COUNT_INT_POINTER;
   15be4:	e3a05024 	mov	r5, #36	@ 0x24
            arg_type unsigned_type = TYPE_UINT;
   15be8:	e3a03006 	mov	r3, #6
            arg_type signed_type = TYPE_INT;
   15bec:	e3a01005 	mov	r1, #5
   15bf0:	eafffe74 	b	155c8 <printf_parse+0x288>
                  for (np = cp; *np >= '0' && *np <= '9'; np++)
   15bf4:	e1a00003 	mov	r0, r3
   15bf8:	e5f01001 	ldrb	r1, [r0, #1]!
   15bfc:	e241c030 	sub	ip, r1, #48	@ 0x30
   15c00:	e35c0009 	cmp	ip, #9
   15c04:	9afffffb 	bls	15bf8 <printf_parse+0x8b8>
                  if (*np == '$')
   15c08:	e3510024 	cmp	r1, #36	@ 0x24
   15c0c:	1afffee4 	bne	157a4 <printf_parse+0x464>
                        n = xsum (xtimes (n, 10), *np - '0');
   15c10:	e3090999 	movw	r0, #39321	@ 0x9999
                      size_t n = 0;
   15c14:	e3a01000 	mov	r1, #0
                        n = xsum (xtimes (n, 10), *np - '0');
   15c18:	e3410999 	movt	r0, #6553	@ 0x1999
   15c1c:	ea000005 	b	15c38 <printf_parse+0x8f8>
                      for (np = cp; *np >= '0' && *np <= '9'; np++)
   15c20:	e5d42001 	ldrb	r2, [r4, #1]
   15c24:	e284e001 	add	lr, r4, #1
   15c28:	e2422030 	sub	r2, r2, #48	@ 0x30
   15c2c:	e6efc072 	uxtb	ip, r2
   15c30:	e35c0009 	cmp	ip, #9
   15c34:	8a000122 	bhi	160c4 <printf_parse+0xd84>
                        n = xsum (xtimes (n, 10), *np - '0');
   15c38:	e1510000 	cmp	r1, r0
   15c3c:	e1a0400e 	mov	r4, lr
   15c40:	90811101 	addls	r1, r1, r1, lsl #2
   15c44:	83e03000 	mvnhi	r3, #0
   15c48:	91a03081 	lslls	r3, r1, #1
   15c4c:	e0923003 	adds	r3, r2, r3
   15c50:	e1a01003 	mov	r1, r3
  return (sum >= size1 ? sum : SIZE_MAX);
   15c54:	3afffff1 	bcc	15c20 <printf_parse+0x8e0>
                      for (np = cp; *np >= '0' && *np <= '9'; np++)
   15c58:	e5f42001 	ldrb	r2, [r4, #1]!
                        n = xsum (xtimes (n, 10), *np - '0');
   15c5c:	e3e03000 	mvn	r3, #0
                      for (np = cp; *np >= '0' && *np <= '9'; np++)
   15c60:	e2422030 	sub	r2, r2, #48	@ 0x30
   15c64:	e6ef1072 	uxtb	r1, r2
   15c68:	e3510009 	cmp	r1, #9
   15c6c:	9afffff6 	bls	15c4c <printf_parse+0x90c>
   15c70:	eafffeb1 	b	1573c <printf_parse+0x3fc>
                if (cp[1] == 'h')
   15c74:	e5d47001 	ldrb	r7, [r4, #1]
                floatingpoint_type = TYPE_LONGDOUBLE;
   15c78:	e3a0001c 	mov	r0, #28
                cp++;
   15c7c:	e2844001 	add	r4, r4, #1
                pointer_type = TYPE_COUNT_LONGLONGINT_POINTER;
   15c80:	e3a05026 	mov	r5, #38	@ 0x26
                unsigned_type = TYPE_ULONGLONGINT;
   15c84:	e3a0300a 	mov	r3, #10
                signed_type = TYPE_LONGLONGINT;
   15c88:	e3a01009 	mov	r1, #9
   15c8c:	eafffe4d 	b	155c8 <printf_parse+0x288>
                if (cp[1] == 'h')
   15c90:	e5d47001 	ldrb	r7, [r4, #1]
   15c94:	e3570068 	cmp	r7, #104	@ 0x68
   15c98:	0a0000de 	beq	16018 <printf_parse+0xcd8>
                    cp++;
   15c9c:	e2844001 	add	r4, r4, #1
            arg_type floatingpoint_type = TYPE_DOUBLE;
   15ca0:	e3a0001b 	mov	r0, #27
                    pointer_type = TYPE_COUNT_SHORT_POINTER;
   15ca4:	e3a05023 	mov	r5, #35	@ 0x23
                    unsigned_type = TYPE_USHORT;
   15ca8:	e3a03004 	mov	r3, #4
                    signed_type = TYPE_SHORT;
   15cac:	e3a01003 	mov	r1, #3
   15cb0:	eafffe44 	b	155c8 <printf_parse+0x288>
                if (cp[1] == 'f')
   15cb4:	e5d43001 	ldrb	r3, [r4, #1]
   15cb8:	e3530066 	cmp	r3, #102	@ 0x66
   15cbc:	0a0000c2 	beq	15fcc <printf_parse+0xc8c>
                    if (cp[1] == '8')
   15cc0:	e3530038 	cmp	r3, #56	@ 0x38
   15cc4:	0a000081 	beq	15ed0 <printf_parse+0xb90>
                    else if (cp[1] == '1' && cp[2] == '6')
   15cc8:	e3530031 	cmp	r3, #49	@ 0x31
   15ccc:	0a0000e5 	beq	16068 <printf_parse+0xd28>
                    else if (cp[1] == '3' && cp[2] == '2')
   15cd0:	e3530033 	cmp	r3, #51	@ 0x33
   15cd4:	0a0000ed 	beq	16090 <printf_parse+0xd50>
                    else if (cp[1] == '6' && cp[2] == '4')
   15cd8:	e3530036 	cmp	r3, #54	@ 0x36
   15cdc:	1afffe96 	bne	1573c <printf_parse+0x3fc>
   15ce0:	e5d43002 	ldrb	r3, [r4, #2]
   15ce4:	e3530034 	cmp	r3, #52	@ 0x34
   15ce8:	1afffe93 	bne	1573c <printf_parse+0x3fc>
                    else if (cp[2] == '1' && cp[3] == '6')
   15cec:	e5d47003 	ldrb	r7, [r4, #3]
            arg_type floatingpoint_type = TYPE_DOUBLE;
   15cf0:	e3a0001b 	mov	r0, #27
                        cp += 3;
   15cf4:	e2844003 	add	r4, r4, #3
                        pointer_type = TYPE_COUNT_INT64_T_POINTER;
   15cf8:	e3a0502a 	mov	r5, #42	@ 0x2a
                        unsigned_type = TYPE_UINT64_T;
   15cfc:	e3a03012 	mov	r3, #18
                        signed_type = TYPE_INT64_T;
   15d00:	e3a01011 	mov	r1, #17
   15d04:	eafffe2f 	b	155c8 <printf_parse+0x288>
                if (cp[1] == 'l')
   15d08:	e5d47001 	ldrb	r7, [r4, #1]
   15d0c:	e357006c 	cmp	r7, #108	@ 0x6c
                    if (cp[2] == '8')
   15d10:	05d47002 	ldrbeq	r7, [r4, #2]
                    floatingpoint_type = TYPE_LONGDOUBLE;
   15d14:	03a0001c 	moveq	r0, #28
                    cp += 2;
   15d18:	02844002 	addeq	r4, r4, #2
                    pointer_type = TYPE_COUNT_LONGLONGINT_POINTER;
   15d1c:	03a05026 	moveq	r5, #38	@ 0x26
                    unsigned_type = TYPE_ULONGLONGINT;
   15d20:	03a0300a 	moveq	r3, #10
                    signed_type = TYPE_LONGLONGINT;
   15d24:	03a01009 	moveq	r1, #9
                    cp++;
   15d28:	12844001 	addne	r4, r4, #1
            arg_type floatingpoint_type = TYPE_DOUBLE;
   15d2c:	13a0001b 	movne	r0, #27
                    unsigned_type = TYPE_ULONGINT;
   15d30:	13a03008 	movne	r3, #8
                    signed_type = TYPE_LONGINT;
   15d34:	13a01007 	movne	r1, #7
   15d38:	eafffe22 	b	155c8 <printf_parse+0x288>
                  type = TYPE_WIDE_CHAR;
   15d3c:	e3a0301e 	mov	r3, #30
            c = *cp++;
   15d40:	e3a07063 	mov	r7, #99	@ 0x63
   15d44:	eaffff1b 	b	159b8 <printf_parse+0x678>
                if (signed_type == TYPE_LONGINT
   15d48:	e2411007 	sub	r1, r1, #7
   15d4c:	e31100fd 	tst	r1, #253	@ 0xfd
   15d50:	03a03001 	moveq	r3, #1
   15d54:	13a03000 	movne	r3, #0
   15d58:	e283301d 	add	r3, r3, #29
   15d5c:	eaffff15 	b	159b8 <printf_parse+0x678>
                type = pointer_type;
   15d60:	e1a03005 	mov	r3, r5
   15d64:	eaffff13 	b	159b8 <printf_parse+0x678>
                if (signed_type == TYPE_LONGINT
   15d68:	e2411007 	sub	r1, r1, #7
   15d6c:	e31100fd 	tst	r1, #253	@ 0xfd
   15d70:	03a03001 	moveq	r3, #1
   15d74:	13a03000 	movne	r3, #0
   15d78:	e283301f 	add	r3, r3, #31
   15d7c:	eaffff0d 	b	159b8 <printf_parse+0x678>
                type = TYPE_POINTER;
   15d80:	e3a03021 	mov	r3, #33	@ 0x21
   15d84:	eaffff0b 	b	159b8 <printf_parse+0x678>
              for (np = cp; *np >= '0' && *np <= '9'; np++)
   15d88:	e1a02004 	mov	r2, r4
   15d8c:	e5f23001 	ldrb	r3, [r2, #1]!
   15d90:	e2431030 	sub	r1, r3, #48	@ 0x30
   15d94:	e3510009 	cmp	r1, #9
   15d98:	9afffffb 	bls	15d8c <printf_parse+0xa4c>
              if (*np == '$')
   15d9c:	e3530024 	cmp	r3, #36	@ 0x24
          size_t arg_index = ARG_NONE;
   15da0:	13e0b000 	mvnne	fp, #0
              if (*np == '$')
   15da4:	1afffd9e 	bne	15424 <printf_parse+0xe4>
                    n = xsum (xtimes (n, 10), *np - '0');
   15da8:	e3091999 	movw	r1, #39321	@ 0x9999
                  size_t n = 0;
   15dac:	e3a03000 	mov	r3, #0
                    n = xsum (xtimes (n, 10), *np - '0');
   15db0:	e3411999 	movt	r1, #6553	@ 0x1999
   15db4:	ea000005 	b	15dd0 <printf_parse+0xa90>
                  for (np = cp; *np >= '0' && *np <= '9'; np++)
   15db8:	e5d20001 	ldrb	r0, [r2, #1]
   15dbc:	e2824001 	add	r4, r2, #1
   15dc0:	e2400030 	sub	r0, r0, #48	@ 0x30
   15dc4:	e6efc070 	uxtb	ip, r0
   15dc8:	e35c0009 	cmp	ip, #9
   15dcc:	8a000078 	bhi	15fb4 <printf_parse+0xc74>
                    n = xsum (xtimes (n, 10), *np - '0');
   15dd0:	e1530001 	cmp	r3, r1
   15dd4:	e1a02004 	mov	r2, r4
   15dd8:	90833103 	addls	r3, r3, r3, lsl #2
   15ddc:	83e03000 	mvnhi	r3, #0
   15de0:	91a03083 	lslls	r3, r3, #1
  size_t sum = size1 + size2;
   15de4:	e093b000 	adds	fp, r3, r0
   15de8:	e1a0300b 	mov	r3, fp
  return (sum >= size1 ? sum : SIZE_MAX);
   15dec:	3afffff1 	bcc	15db8 <printf_parse+0xa78>
                  for (np = cp; *np >= '0' && *np <= '9'; np++)
   15df0:	e5f20001 	ldrb	r0, [r2, #1]!
                    n = xsum (xtimes (n, 10), *np - '0');
   15df4:	e3e03000 	mvn	r3, #0
                  for (np = cp; *np >= '0' && *np <= '9'; np++)
   15df8:	e2400030 	sub	r0, r0, #48	@ 0x30
   15dfc:	e6efc070 	uxtb	ip, r0
   15e00:	e35c0009 	cmp	ip, #9
   15e04:	9afffff6 	bls	15de4 <printf_parse+0xaa4>
   15e08:	eafffe4b 	b	1573c <printf_parse+0x3fc>
              dp->width_start = cp;
   15e0c:	e586400c 	str	r4, [r6, #12]
              for (; *cp >= '0' && *cp <= '9'; cp++)
   15e10:	e5d43000 	ldrb	r3, [r4]
   15e14:	e2433030 	sub	r3, r3, #48	@ 0x30
   15e18:	e3530009 	cmp	r3, #9
   15e1c:	8a00000a 	bhi	15e4c <printf_parse+0xb0c>
   15e20:	e1a02004 	mov	r2, r4
   15e24:	e5f23001 	ldrb	r3, [r2, #1]!
   15e28:	e2433030 	sub	r3, r3, #48	@ 0x30
   15e2c:	e3530009 	cmp	r3, #9
   15e30:	9afffffb 	bls	15e24 <printf_parse+0xae4>
              width_length = dp->width_end - dp->width_start;
   15e34:	e0423004 	sub	r3, r2, r4
              if (max_width_length < width_length)
   15e38:	e1a04002 	mov	r4, r2
   15e3c:	e59d2010 	ldr	r2, [sp, #16]
   15e40:	e1520003 	cmp	r2, r3
   15e44:	21a03002 	movcs	r3, r2
   15e48:	e58d3010 	str	r3, [sp, #16]
              dp->width_end = cp;
   15e4c:	e5864010 	str	r4, [r6, #16]
          if (*cp == '.')
   15e50:	e5d47000 	ldrb	r7, [r4]
   15e54:	eafffd8e 	b	15494 <printf_parse+0x154>
              REGISTER_ARG (dp->width_arg_index, TYPE_INT);
   15e58:	e3530005 	cmp	r3, #5
   15e5c:	0afffffb 	beq	15e50 <printf_parse+0xb10>
   15e60:	eafffe36 	b	15740 <printf_parse+0x400>
                REGISTER_ARG (dp->arg_index, type);
   15e64:	e1a00001 	mov	r0, r1
   15e68:	ebffe1e9 	bl	e614 <rpl_malloc>
   15e6c:	e59d301c 	ldr	r3, [sp, #28]
   15e70:	e1a0b000 	mov	fp, r0
   15e74:	eafffeeb 	b	15a28 <printf_parse+0x6e8>
   15e78:	e5982000 	ldr	r2, [r8]
   15e7c:	e1a0000b 	mov	r0, fp
   15e80:	e59d1008 	ldr	r1, [sp, #8]
   15e84:	e58d301c 	str	r3, [sp, #28]
   15e88:	e1a02202 	lsl	r2, r2, #4
   15e8c:	eb0027fb 	bl	1fe80 <memcpy>
   15e90:	e59d301c 	ldr	r3, [sp, #28]
   15e94:	eafffee9 	b	15a40 <printf_parse+0x700>
                memcpy (memory, d->dir, d->count * sizeof (DIRECTIVE));
   15e98:	e5993000 	ldr	r3, [r9]
   15e9c:	e3a0202c 	mov	r2, #44	@ 0x2c
   15ea0:	e59d1018 	ldr	r1, [sp, #24]
   15ea4:	e1a00006 	mov	r0, r6
   15ea8:	e0020392 	mul	r2, r2, r3
   15eac:	eb0027f3 	bl	1fe80 <memcpy>
   15eb0:	eaffff2c 	b	15b68 <printf_parse+0x828>
                  REGISTER_ARG (dp->precision_arg_index, TYPE_INT);
   15eb4:	e3520005 	cmp	r2, #5
   15eb8:	1afffe20 	bne	15740 <printf_parse+0x400>
            if (*cp == 'h')
   15ebc:	e5d37000 	ldrb	r7, [r3]
   15ec0:	e1a04003 	mov	r4, r3
   15ec4:	eafffd74 	b	1549c <printf_parse+0x15c>
                type = signed_type;
   15ec8:	e1a03001 	mov	r3, r1
   15ecc:	eafffeb9 	b	159b8 <printf_parse+0x678>
                    if (cp[2] == '8')
   15ed0:	e5d47002 	ldrb	r7, [r4, #2]
            arg_type floatingpoint_type = TYPE_DOUBLE;
   15ed4:	e3a0001b 	mov	r0, #27
                        cp += 2;
   15ed8:	e2844002 	add	r4, r4, #2
                        pointer_type = TYPE_COUNT_INT8_T_POINTER;
   15edc:	e3a05027 	mov	r5, #39	@ 0x27
                        unsigned_type = TYPE_UINT8_T;
   15ee0:	e3a0300c 	mov	r3, #12
                        signed_type = TYPE_INT8_T;
   15ee4:	e3a0100b 	mov	r1, #11
   15ee8:	eafffdb6 	b	155c8 <printf_parse+0x288>
                      if (dp->precision_arg_index == ARG_NONE)
   15eec:	e37a0001 	cmn	sl, #1
                      dp->precision_arg_index = arg_posn++;
   15ef0:	e28a2001 	add	r2, sl, #1
   15ef4:	e586a020 	str	sl, [r6, #32]
                      if (dp->precision_arg_index == ARG_NONE)
   15ef8:	0afffe0f 	beq	1573c <printf_parse+0x3fc>
   15efc:	e1a0400a 	mov	r4, sl
                      dp->precision_arg_index = arg_posn++;
   15f00:	e1a0a002 	mov	sl, r2
   15f04:	eafffe73 	b	158d8 <printf_parse+0x598>
              REGISTER_ARG (dp->width_arg_index, TYPE_INT);
   15f08:	e1a00001 	mov	r0, r1
   15f0c:	ebffe1c0 	bl	e614 <rpl_malloc>
   15f10:	e1a03000 	mov	r3, r0
   15f14:	eafffe3e 	b	15814 <printf_parse+0x4d4>
   15f18:	e5982000 	ldr	r2, [r8]
   15f1c:	e1a00003 	mov	r0, r3
   15f20:	e59d1008 	ldr	r1, [sp, #8]
   15f24:	e1a02202 	lsl	r2, r2, #4
   15f28:	eb0027d4 	bl	1fe80 <memcpy>
   15f2c:	e1a03000 	mov	r3, r0
   15f30:	eafffe3d 	b	1582c <printf_parse+0x4ec>
                      for (np = cp; *np >= '0' && *np <= '9'; np++)
   15f34:	e1a00003 	mov	r0, r3
   15f38:	e5f01001 	ldrb	r1, [r0, #1]!
   15f3c:	e241c030 	sub	ip, r1, #48	@ 0x30
   15f40:	e35c0009 	cmp	ip, #9
   15f44:	9afffffb 	bls	15f38 <printf_parse+0xbf8>
                      if (*np == '$')
   15f48:	e3510024 	cmp	r1, #36	@ 0x24
   15f4c:	1afffe5e 	bne	158cc <printf_parse+0x58c>
                            n = xsum (xtimes (n, 10), *np - '0');
   15f50:	e309e999 	movw	lr, #39321	@ 0x9999
                          size_t n = 0;
   15f54:	e3a00000 	mov	r0, #0
                            n = xsum (xtimes (n, 10), *np - '0');
   15f58:	e341e999 	movt	lr, #6553	@ 0x1999
   15f5c:	ea000005 	b	15f78 <printf_parse+0xc38>
                          for (np = cp; *np >= '0' && *np <= '9'; np++)
   15f60:	e5dc2001 	ldrb	r2, [ip, #1]
   15f64:	e28c3001 	add	r3, ip, #1
   15f68:	e2422030 	sub	r2, r2, #48	@ 0x30
   15f6c:	e6ef4072 	uxtb	r4, r2
   15f70:	e3540009 	cmp	r4, #9
   15f74:	8a000073 	bhi	16148 <printf_parse+0xe08>
                            n = xsum (xtimes (n, 10), *np - '0');
   15f78:	e150000e 	cmp	r0, lr
   15f7c:	e1a0c003 	mov	ip, r3
   15f80:	90800100 	addls	r0, r0, r0, lsl #2
   15f84:	83e01000 	mvnhi	r1, #0
   15f88:	91a01080 	lslls	r1, r0, #1
  size_t sum = size1 + size2;
   15f8c:	e0921001 	adds	r1, r2, r1
   15f90:	e1a00001 	mov	r0, r1
  return (sum >= size1 ? sum : SIZE_MAX);
   15f94:	3afffff1 	bcc	15f60 <printf_parse+0xc20>
                          for (np = cp; *np >= '0' && *np <= '9'; np++)
   15f98:	e5fc2001 	ldrb	r2, [ip, #1]!
                            n = xsum (xtimes (n, 10), *np - '0');
   15f9c:	e3e01000 	mvn	r1, #0
                          for (np = cp; *np >= '0' && *np <= '9'; np++)
   15fa0:	e2422030 	sub	r2, r2, #48	@ 0x30
   15fa4:	e6ef3072 	uxtb	r3, r2
   15fa8:	e3530009 	cmp	r3, #9
   15fac:	9afffff6 	bls	15f8c <printf_parse+0xc4c>
   15fb0:	eafffde1 	b	1573c <printf_parse+0x3fc>
                  if (size_overflow_p (n))
   15fb4:	e24bb001 	sub	fp, fp, #1
   15fb8:	e37b0003 	cmn	fp, #3
   15fbc:	8afffdde 	bhi	1573c <printf_parse+0x3fc>
              if (*cp == '\'')
   15fc0:	e5d27002 	ldrb	r7, [r2, #2]
                  cp = np + 1;
   15fc4:	e2824002 	add	r4, r2, #2
   15fc8:	eafffd15 	b	15424 <printf_parse+0xe4>
                    if (cp[2] == '8')
   15fcc:	e5d43002 	ldrb	r3, [r4, #2]
   15fd0:	e3530038 	cmp	r3, #56	@ 0x38
   15fd4:	0a000040 	beq	160dc <printf_parse+0xd9c>
                    else if (cp[2] == '1' && cp[3] == '6')
   15fd8:	e3530031 	cmp	r3, #49	@ 0x31
   15fdc:	0a000045 	beq	160f8 <printf_parse+0xdb8>
                    else if (cp[2] == '3' && cp[3] == '2')
   15fe0:	e3530033 	cmp	r3, #51	@ 0x33
   15fe4:	0a00004d 	beq	16120 <printf_parse+0xde0>
                    else if (cp[2] == '6' && cp[3] == '4')
   15fe8:	e3530036 	cmp	r3, #54	@ 0x36
   15fec:	1afffdd2 	bne	1573c <printf_parse+0x3fc>
   15ff0:	e5d43003 	ldrb	r3, [r4, #3]
   15ff4:	e3530034 	cmp	r3, #52	@ 0x34
   15ff8:	1afffdcf 	bne	1573c <printf_parse+0x3fc>
            c = *cp++;
   15ffc:	e5d47004 	ldrb	r7, [r4, #4]
            arg_type floatingpoint_type = TYPE_DOUBLE;
   16000:	e3a0001b 	mov	r0, #27
                        cp += 4;
   16004:	e2844004 	add	r4, r4, #4
                        pointer_type = TYPE_COUNT_INT_FAST64_T_POINTER;
   16008:	e3a0502e 	mov	r5, #46	@ 0x2e
                        unsigned_type = TYPE_UINT_FAST64_T;
   1600c:	e3a0301a 	mov	r3, #26
                        signed_type = TYPE_INT_FAST64_T;
   16010:	e3a01019 	mov	r1, #25
   16014:	eafffd6b 	b	155c8 <printf_parse+0x288>
                    if (cp[2] == '8')
   16018:	e5d47002 	ldrb	r7, [r4, #2]
            arg_type floatingpoint_type = TYPE_DOUBLE;
   1601c:	e3a0001b 	mov	r0, #27
                    cp += 2;
   16020:	e2844002 	add	r4, r4, #2
                    pointer_type = TYPE_COUNT_SCHAR_POINTER;
   16024:	e3a05022 	mov	r5, #34	@ 0x22
                    unsigned_type = TYPE_UCHAR;
   16028:	e3a03002 	mov	r3, #2
                    signed_type = TYPE_SCHAR;
   1602c:	e3a01001 	mov	r1, #1
   16030:	eafffd64 	b	155c8 <printf_parse+0x288>
                  REGISTER_ARG (dp->precision_arg_index, TYPE_INT);
   16034:	e5982000 	ldr	r2, [r8]
   16038:	e1a00007 	mov	r0, r7
   1603c:	e59d1008 	ldr	r1, [sp, #8]
   16040:	e58d301c 	str	r3, [sp, #28]
   16044:	e1a02202 	lsl	r2, r2, #4
   16048:	eb00278c 	bl	1fe80 <memcpy>
   1604c:	e59d301c 	ldr	r3, [sp, #28]
   16050:	eafffe3d 	b	1594c <printf_parse+0x60c>
   16054:	e1a00001 	mov	r0, r1
   16058:	ebffe16d 	bl	e614 <rpl_malloc>
   1605c:	e59d301c 	ldr	r3, [sp, #28]
   16060:	e1a07000 	mov	r7, r0
   16064:	eafffe32 	b	15934 <printf_parse+0x5f4>
                    else if (cp[1] == '1' && cp[2] == '6')
   16068:	e5d43002 	ldrb	r3, [r4, #2]
   1606c:	e3530036 	cmp	r3, #54	@ 0x36
   16070:	1afffdb1 	bne	1573c <printf_parse+0x3fc>
                    else if (cp[2] == '1' && cp[3] == '6')
   16074:	e5d47003 	ldrb	r7, [r4, #3]
            arg_type floatingpoint_type = TYPE_DOUBLE;
   16078:	e3a0001b 	mov	r0, #27
                        cp += 3;
   1607c:	e2844003 	add	r4, r4, #3
                        pointer_type = TYPE_COUNT_INT16_T_POINTER;
   16080:	e3a05028 	mov	r5, #40	@ 0x28
                        unsigned_type = TYPE_UINT16_T;
   16084:	e3a0300e 	mov	r3, #14
                        signed_type = TYPE_INT16_T;
   16088:	e3a0100d 	mov	r1, #13
                        cp += 3;
   1608c:	eafffd4d 	b	155c8 <printf_parse+0x288>
                    else if (cp[1] == '3' && cp[2] == '2')
   16090:	e5d43002 	ldrb	r3, [r4, #2]
   16094:	e3530032 	cmp	r3, #50	@ 0x32
   16098:	1afffda7 	bne	1573c <printf_parse+0x3fc>
                    else if (cp[2] == '1' && cp[3] == '6')
   1609c:	e5d47003 	ldrb	r7, [r4, #3]
            arg_type floatingpoint_type = TYPE_DOUBLE;
   160a0:	e3a0001b 	mov	r0, #27
                        cp += 3;
   160a4:	e2844003 	add	r4, r4, #3
                        pointer_type = TYPE_COUNT_INT32_T_POINTER;
   160a8:	e3a05029 	mov	r5, #41	@ 0x29
                        unsigned_type = TYPE_UINT32_T;
   160ac:	e3a03010 	mov	r3, #16
                        signed_type = TYPE_INT32_T;
   160b0:	e3a0100f 	mov	r1, #15
                        cp += 3;
   160b4:	eafffd43 	b	155c8 <printf_parse+0x288>
              cp++;
   160b8:	e1a04002 	mov	r4, r2
                  for (; *cp >= '0' && *cp <= '9'; cp++)
   160bc:	e3a03001 	mov	r3, #1
   160c0:	eafffeb7 	b	15ba4 <printf_parse+0x864>
                      if (size_overflow_p (n))
   160c4:	e2437001 	sub	r7, r3, #1
   160c8:	e3770003 	cmn	r7, #3
   160cc:	8afffd9a 	bhi	1573c <printf_parse+0x3fc>
                      cp = np + 1;
   160d0:	e2844002 	add	r4, r4, #2
                      dp->width_arg_index = n - 1;
   160d4:	e5867014 	str	r7, [r6, #20]
              if (dp->width_arg_index == ARG_NONE)
   160d8:	eafffdb8 	b	157c0 <printf_parse+0x480>
                    else if (cp[2] == '1' && cp[3] == '6')
   160dc:	e5d47003 	ldrb	r7, [r4, #3]
            arg_type floatingpoint_type = TYPE_DOUBLE;
   160e0:	e3a0001b 	mov	r0, #27
                        cp += 3;
   160e4:	e2844003 	add	r4, r4, #3
                        pointer_type = TYPE_COUNT_INT_FAST8_T_POINTER;
   160e8:	e3a0502b 	mov	r5, #43	@ 0x2b
                        unsigned_type = TYPE_UINT_FAST8_T;
   160ec:	e3a03014 	mov	r3, #20
                        signed_type = TYPE_INT_FAST8_T;
   160f0:	e3a01013 	mov	r1, #19
   160f4:	eafffd33 	b	155c8 <printf_parse+0x288>
                    else if (cp[2] == '1' && cp[3] == '6')
   160f8:	e5d43003 	ldrb	r3, [r4, #3]
   160fc:	e3530036 	cmp	r3, #54	@ 0x36
   16100:	1afffd8d 	bne	1573c <printf_parse+0x3fc>
            c = *cp++;
   16104:	e5d47004 	ldrb	r7, [r4, #4]
            arg_type floatingpoint_type = TYPE_DOUBLE;
   16108:	e3a0001b 	mov	r0, #27
                        cp += 4;
   1610c:	e2844004 	add	r4, r4, #4
                        pointer_type = TYPE_COUNT_INT_FAST16_T_POINTER;
   16110:	e3a0502c 	mov	r5, #44	@ 0x2c
                        unsigned_type = TYPE_UINT_FAST16_T;
   16114:	e3a03016 	mov	r3, #22
                        signed_type = TYPE_INT_FAST16_T;
   16118:	e3a01015 	mov	r1, #21
                        cp += 4;
   1611c:	eafffd29 	b	155c8 <printf_parse+0x288>
                    else if (cp[2] == '3' && cp[3] == '2')
   16120:	e5d43003 	ldrb	r3, [r4, #3]
   16124:	e3530032 	cmp	r3, #50	@ 0x32
   16128:	1afffd83 	bne	1573c <printf_parse+0x3fc>
            c = *cp++;
   1612c:	e5d47004 	ldrb	r7, [r4, #4]
            arg_type floatingpoint_type = TYPE_DOUBLE;
   16130:	e3a0001b 	mov	r0, #27
                        cp += 4;
   16134:	e2844004 	add	r4, r4, #4
                        pointer_type = TYPE_COUNT_INT_FAST32_T_POINTER;
   16138:	e3a0502d 	mov	r5, #45	@ 0x2d
                        unsigned_type = TYPE_UINT_FAST32_T;
   1613c:	e3a03018 	mov	r3, #24
                        signed_type = TYPE_INT_FAST32_T;
   16140:	e3a01017 	mov	r1, #23
                        cp += 4;
   16144:	eafffd1f 	b	155c8 <printf_parse+0x288>
                          if (size_overflow_p (n))
   16148:	e2414001 	sub	r4, r1, #1
   1614c:	e3740003 	cmn	r4, #3
   16150:	8afffd79 	bhi	1573c <printf_parse+0x3fc>
                          cp = np + 1;
   16154:	e28c3002 	add	r3, ip, #2
                          dp->precision_arg_index = n - 1;
   16158:	e5864020 	str	r4, [r6, #32]
                  if (dp->precision_arg_index == ARG_NONE)
   1615c:	eafffddd 	b	158d8 <printf_parse+0x598>

00016160 <__udivsi3>:
   16160:	e2512001 	subs	r2, r1, #1
   16164:	012fff1e 	bxeq	lr
   16168:	3a000074 	bcc	16340 <__udivsi3+0x1e0>
   1616c:	e1500001 	cmp	r0, r1
   16170:	9a00006b 	bls	16324 <__udivsi3+0x1c4>
   16174:	e1110002 	tst	r1, r2
   16178:	0a00006c 	beq	16330 <__udivsi3+0x1d0>
   1617c:	e16f3f10 	clz	r3, r0
   16180:	e16f2f11 	clz	r2, r1
   16184:	e0423003 	sub	r3, r2, r3
   16188:	e273301f 	rsbs	r3, r3, #31
   1618c:	10833083 	addne	r3, r3, r3, lsl #1
   16190:	e3a02000 	mov	r2, #0
   16194:	108ff103 	addne	pc, pc, r3, lsl #2
   16198:	e320f000 	nop	{0}
   1619c:	e1500f81 	cmp	r0, r1, lsl #31
   161a0:	e0a22002 	adc	r2, r2, r2
   161a4:	20400f81 	subcs	r0, r0, r1, lsl #31
   161a8:	e1500f01 	cmp	r0, r1, lsl #30
   161ac:	e0a22002 	adc	r2, r2, r2
   161b0:	20400f01 	subcs	r0, r0, r1, lsl #30
   161b4:	e1500e81 	cmp	r0, r1, lsl #29
   161b8:	e0a22002 	adc	r2, r2, r2
   161bc:	20400e81 	subcs	r0, r0, r1, lsl #29
   161c0:	e1500e01 	cmp	r0, r1, lsl #28
   161c4:	e0a22002 	adc	r2, r2, r2
   161c8:	20400e01 	subcs	r0, r0, r1, lsl #28
   161cc:	e1500d81 	cmp	r0, r1, lsl #27
   161d0:	e0a22002 	adc	r2, r2, r2
   161d4:	20400d81 	subcs	r0, r0, r1, lsl #27
   161d8:	e1500d01 	cmp	r0, r1, lsl #26
   161dc:	e0a22002 	adc	r2, r2, r2
   161e0:	20400d01 	subcs	r0, r0, r1, lsl #26
   161e4:	e1500c81 	cmp	r0, r1, lsl #25
   161e8:	e0a22002 	adc	r2, r2, r2
   161ec:	20400c81 	subcs	r0, r0, r1, lsl #25
   161f0:	e1500c01 	cmp	r0, r1, lsl #24
   161f4:	e0a22002 	adc	r2, r2, r2
   161f8:	20400c01 	subcs	r0, r0, r1, lsl #24
   161fc:	e1500b81 	cmp	r0, r1, lsl #23
   16200:	e0a22002 	adc	r2, r2, r2
   16204:	20400b81 	subcs	r0, r0, r1, lsl #23
   16208:	e1500b01 	cmp	r0, r1, lsl #22
   1620c:	e0a22002 	adc	r2, r2, r2
   16210:	20400b01 	subcs	r0, r0, r1, lsl #22
   16214:	e1500a81 	cmp	r0, r1, lsl #21
   16218:	e0a22002 	adc	r2, r2, r2
   1621c:	20400a81 	subcs	r0, r0, r1, lsl #21
   16220:	e1500a01 	cmp	r0, r1, lsl #20
   16224:	e0a22002 	adc	r2, r2, r2
   16228:	20400a01 	subcs	r0, r0, r1, lsl #20
   1622c:	e1500981 	cmp	r0, r1, lsl #19
   16230:	e0a22002 	adc	r2, r2, r2
   16234:	20400981 	subcs	r0, r0, r1, lsl #19
   16238:	e1500901 	cmp	r0, r1, lsl #18
   1623c:	e0a22002 	adc	r2, r2, r2
   16240:	20400901 	subcs	r0, r0, r1, lsl #18
   16244:	e1500881 	cmp	r0, r1, lsl #17
   16248:	e0a22002 	adc	r2, r2, r2
   1624c:	20400881 	subcs	r0, r0, r1, lsl #17
   16250:	e1500801 	cmp	r0, r1, lsl #16
   16254:	e0a22002 	adc	r2, r2, r2
   16258:	20400801 	subcs	r0, r0, r1, lsl #16
   1625c:	e1500781 	cmp	r0, r1, lsl #15
   16260:	e0a22002 	adc	r2, r2, r2
   16264:	20400781 	subcs	r0, r0, r1, lsl #15
   16268:	e1500701 	cmp	r0, r1, lsl #14
   1626c:	e0a22002 	adc	r2, r2, r2
   16270:	20400701 	subcs	r0, r0, r1, lsl #14
   16274:	e1500681 	cmp	r0, r1, lsl #13
   16278:	e0a22002 	adc	r2, r2, r2
   1627c:	20400681 	subcs	r0, r0, r1, lsl #13
   16280:	e1500601 	cmp	r0, r1, lsl #12
   16284:	e0a22002 	adc	r2, r2, r2
   16288:	20400601 	subcs	r0, r0, r1, lsl #12
   1628c:	e1500581 	cmp	r0, r1, lsl #11
   16290:	e0a22002 	adc	r2, r2, r2
   16294:	20400581 	subcs	r0, r0, r1, lsl #11
   16298:	e1500501 	cmp	r0, r1, lsl #10
   1629c:	e0a22002 	adc	r2, r2, r2
   162a0:	20400501 	subcs	r0, r0, r1, lsl #10
   162a4:	e1500481 	cmp	r0, r1, lsl #9
   162a8:	e0a22002 	adc	r2, r2, r2
   162ac:	20400481 	subcs	r0, r0, r1, lsl #9
   162b0:	e1500401 	cmp	r0, r1, lsl #8
   162b4:	e0a22002 	adc	r2, r2, r2
   162b8:	20400401 	subcs	r0, r0, r1, lsl #8
   162bc:	e1500381 	cmp	r0, r1, lsl #7
   162c0:	e0a22002 	adc	r2, r2, r2
   162c4:	20400381 	subcs	r0, r0, r1, lsl #7
   162c8:	e1500301 	cmp	r0, r1, lsl #6
   162cc:	e0a22002 	adc	r2, r2, r2
   162d0:	20400301 	subcs	r0, r0, r1, lsl #6
   162d4:	e1500281 	cmp	r0, r1, lsl #5
   162d8:	e0a22002 	adc	r2, r2, r2
   162dc:	20400281 	subcs	r0, r0, r1, lsl #5
   162e0:	e1500201 	cmp	r0, r1, lsl #4
   162e4:	e0a22002 	adc	r2, r2, r2
   162e8:	20400201 	subcs	r0, r0, r1, lsl #4
   162ec:	e1500181 	cmp	r0, r1, lsl #3
   162f0:	e0a22002 	adc	r2, r2, r2
   162f4:	20400181 	subcs	r0, r0, r1, lsl #3
   162f8:	e1500101 	cmp	r0, r1, lsl #2
   162fc:	e0a22002 	adc	r2, r2, r2
   16300:	20400101 	subcs	r0, r0, r1, lsl #2
   16304:	e1500081 	cmp	r0, r1, lsl #1
   16308:	e0a22002 	adc	r2, r2, r2
   1630c:	20400081 	subcs	r0, r0, r1, lsl #1
   16310:	e1500001 	cmp	r0, r1
   16314:	e0a22002 	adc	r2, r2, r2
   16318:	20400001 	subcs	r0, r0, r1
   1631c:	e1a00002 	mov	r0, r2
   16320:	e12fff1e 	bx	lr
   16324:	03a00001 	moveq	r0, #1
   16328:	13a00000 	movne	r0, #0
   1632c:	e12fff1e 	bx	lr
   16330:	e16f2f11 	clz	r2, r1
   16334:	e262201f 	rsb	r2, r2, #31
   16338:	e1a00230 	lsr	r0, r0, r2
   1633c:	e12fff1e 	bx	lr
   16340:	e3500000 	cmp	r0, #0
   16344:	13e00000 	mvnne	r0, #0
   16348:	ea000097 	b	165ac <__aeabi_idiv0>

0001634c <__aeabi_uidivmod>:
   1634c:	e3510000 	cmp	r1, #0
   16350:	0afffffa 	beq	16340 <__udivsi3+0x1e0>
   16354:	e92d4003 	push	{r0, r1, lr}
   16358:	ebffff80 	bl	16160 <__udivsi3>
   1635c:	e8bd4006 	pop	{r1, r2, lr}
   16360:	e0030092 	mul	r3, r2, r0
   16364:	e0411003 	sub	r1, r1, r3
   16368:	e12fff1e 	bx	lr

0001636c <__divsi3>:
   1636c:	e3510000 	cmp	r1, #0
   16370:	0a000081 	beq	1657c <.divsi3_skip_div0_test+0x208>

00016374 <.divsi3_skip_div0_test>:
   16374:	e020c001 	eor	ip, r0, r1
   16378:	42611000 	rsbmi	r1, r1, #0
   1637c:	e2512001 	subs	r2, r1, #1
   16380:	0a000070 	beq	16548 <.divsi3_skip_div0_test+0x1d4>
   16384:	e1b03000 	movs	r3, r0
   16388:	42603000 	rsbmi	r3, r0, #0
   1638c:	e1530001 	cmp	r3, r1
   16390:	9a00006f 	bls	16554 <.divsi3_skip_div0_test+0x1e0>
   16394:	e1110002 	tst	r1, r2
   16398:	0a000071 	beq	16564 <.divsi3_skip_div0_test+0x1f0>
   1639c:	e16f2f13 	clz	r2, r3
   163a0:	e16f0f11 	clz	r0, r1
   163a4:	e0402002 	sub	r2, r0, r2
   163a8:	e272201f 	rsbs	r2, r2, #31
   163ac:	10822082 	addne	r2, r2, r2, lsl #1
   163b0:	e3a00000 	mov	r0, #0
   163b4:	108ff102 	addne	pc, pc, r2, lsl #2
   163b8:	e320f000 	nop	{0}
   163bc:	e1530f81 	cmp	r3, r1, lsl #31
   163c0:	e0a00000 	adc	r0, r0, r0
   163c4:	20433f81 	subcs	r3, r3, r1, lsl #31
   163c8:	e1530f01 	cmp	r3, r1, lsl #30
   163cc:	e0a00000 	adc	r0, r0, r0
   163d0:	20433f01 	subcs	r3, r3, r1, lsl #30
   163d4:	e1530e81 	cmp	r3, r1, lsl #29
   163d8:	e0a00000 	adc	r0, r0, r0
   163dc:	20433e81 	subcs	r3, r3, r1, lsl #29
   163e0:	e1530e01 	cmp	r3, r1, lsl #28
   163e4:	e0a00000 	adc	r0, r0, r0
   163e8:	20433e01 	subcs	r3, r3, r1, lsl #28
   163ec:	e1530d81 	cmp	r3, r1, lsl #27
   163f0:	e0a00000 	adc	r0, r0, r0
   163f4:	20433d81 	subcs	r3, r3, r1, lsl #27
   163f8:	e1530d01 	cmp	r3, r1, lsl #26
   163fc:	e0a00000 	adc	r0, r0, r0
   16400:	20433d01 	subcs	r3, r3, r1, lsl #26
   16404:	e1530c81 	cmp	r3, r1, lsl #25
   16408:	e0a00000 	adc	r0, r0, r0
   1640c:	20433c81 	subcs	r3, r3, r1, lsl #25
   16410:	e1530c01 	cmp	r3, r1, lsl #24
   16414:	e0a00000 	adc	r0, r0, r0
   16418:	20433c01 	subcs	r3, r3, r1, lsl #24
   1641c:	e1530b81 	cmp	r3, r1, lsl #23
   16420:	e0a00000 	adc	r0, r0, r0
   16424:	20433b81 	subcs	r3, r3, r1, lsl #23
   16428:	e1530b01 	cmp	r3, r1, lsl #22
   1642c:	e0a00000 	adc	r0, r0, r0
   16430:	20433b01 	subcs	r3, r3, r1, lsl #22
   16434:	e1530a81 	cmp	r3, r1, lsl #21
   16438:	e0a00000 	adc	r0, r0, r0
   1643c:	20433a81 	subcs	r3, r3, r1, lsl #21
   16440:	e1530a01 	cmp	r3, r1, lsl #20
   16444:	e0a00000 	adc	r0, r0, r0
   16448:	20433a01 	subcs	r3, r3, r1, lsl #20
   1644c:	e1530981 	cmp	r3, r1, lsl #19
   16450:	e0a00000 	adc	r0, r0, r0
   16454:	20433981 	subcs	r3, r3, r1, lsl #19
   16458:	e1530901 	cmp	r3, r1, lsl #18
   1645c:	e0a00000 	adc	r0, r0, r0
   16460:	20433901 	subcs	r3, r3, r1, lsl #18
   16464:	e1530881 	cmp	r3, r1, lsl #17
   16468:	e0a00000 	adc	r0, r0, r0
   1646c:	20433881 	subcs	r3, r3, r1, lsl #17
   16470:	e1530801 	cmp	r3, r1, lsl #16
   16474:	e0a00000 	adc	r0, r0, r0
   16478:	20433801 	subcs	r3, r3, r1, lsl #16
   1647c:	e1530781 	cmp	r3, r1, lsl #15
   16480:	e0a00000 	adc	r0, r0, r0
   16484:	20433781 	subcs	r3, r3, r1, lsl #15
   16488:	e1530701 	cmp	r3, r1, lsl #14
   1648c:	e0a00000 	adc	r0, r0, r0
   16490:	20433701 	subcs	r3, r3, r1, lsl #14
   16494:	e1530681 	cmp	r3, r1, lsl #13
   16498:	e0a00000 	adc	r0, r0, r0
   1649c:	20433681 	subcs	r3, r3, r1, lsl #13
   164a0:	e1530601 	cmp	r3, r1, lsl #12
   164a4:	e0a00000 	adc	r0, r0, r0
   164a8:	20433601 	subcs	r3, r3, r1, lsl #12
   164ac:	e1530581 	cmp	r3, r1, lsl #11
   164b0:	e0a00000 	adc	r0, r0, r0
   164b4:	20433581 	subcs	r3, r3, r1, lsl #11
   164b8:	e1530501 	cmp	r3, r1, lsl #10
   164bc:	e0a00000 	adc	r0, r0, r0
   164c0:	20433501 	subcs	r3, r3, r1, lsl #10
   164c4:	e1530481 	cmp	r3, r1, lsl #9
   164c8:	e0a00000 	adc	r0, r0, r0
   164cc:	20433481 	subcs	r3, r3, r1, lsl #9
   164d0:	e1530401 	cmp	r3, r1, lsl #8
   164d4:	e0a00000 	adc	r0, r0, r0
   164d8:	20433401 	subcs	r3, r3, r1, lsl #8
   164dc:	e1530381 	cmp	r3, r1, lsl #7
   164e0:	e0a00000 	adc	r0, r0, r0
   164e4:	20433381 	subcs	r3, r3, r1, lsl #7
   164e8:	e1530301 	cmp	r3, r1, lsl #6
   164ec:	e0a00000 	adc	r0, r0, r0
   164f0:	20433301 	subcs	r3, r3, r1, lsl #6
   164f4:	e1530281 	cmp	r3, r1, lsl #5
   164f8:	e0a00000 	adc	r0, r0, r0
   164fc:	20433281 	subcs	r3, r3, r1, lsl #5
   16500:	e1530201 	cmp	r3, r1, lsl #4
   16504:	e0a00000 	adc	r0, r0, r0
   16508:	20433201 	subcs	r3, r3, r1, lsl #4
   1650c:	e1530181 	cmp	r3, r1, lsl #3
   16510:	e0a00000 	adc	r0, r0, r0
   16514:	20433181 	subcs	r3, r3, r1, lsl #3
   16518:	e1530101 	cmp	r3, r1, lsl #2
   1651c:	e0a00000 	adc	r0, r0, r0
   16520:	20433101 	subcs	r3, r3, r1, lsl #2
   16524:	e1530081 	cmp	r3, r1, lsl #1
   16528:	e0a00000 	adc	r0, r0, r0
   1652c:	20433081 	subcs	r3, r3, r1, lsl #1
   16530:	e1530001 	cmp	r3, r1
   16534:	e0a00000 	adc	r0, r0, r0
   16538:	20433001 	subcs	r3, r3, r1
   1653c:	e35c0000 	cmp	ip, #0
   16540:	42600000 	rsbmi	r0, r0, #0
   16544:	e12fff1e 	bx	lr
   16548:	e13c0000 	teq	ip, r0
   1654c:	42600000 	rsbmi	r0, r0, #0
   16550:	e12fff1e 	bx	lr
   16554:	33a00000 	movcc	r0, #0
   16558:	01a00fcc 	asreq	r0, ip, #31
   1655c:	03800001 	orreq	r0, r0, #1
   16560:	e12fff1e 	bx	lr
   16564:	e16f2f11 	clz	r2, r1
   16568:	e262201f 	rsb	r2, r2, #31
   1656c:	e35c0000 	cmp	ip, #0
   16570:	e1a00233 	lsr	r0, r3, r2
   16574:	42600000 	rsbmi	r0, r0, #0
   16578:	e12fff1e 	bx	lr
   1657c:	e3500000 	cmp	r0, #0
   16580:	c3e00102 	mvngt	r0, #-2147483648	@ 0x80000000
   16584:	b3a00102 	movlt	r0, #-2147483648	@ 0x80000000
   16588:	ea000007 	b	165ac <__aeabi_idiv0>

0001658c <__aeabi_idivmod>:
   1658c:	e3510000 	cmp	r1, #0
   16590:	0afffff9 	beq	1657c <.divsi3_skip_div0_test+0x208>
   16594:	e92d4003 	push	{r0, r1, lr}
   16598:	ebffff75 	bl	16374 <.divsi3_skip_div0_test>
   1659c:	e8bd4006 	pop	{r1, r2, lr}
   165a0:	e0030092 	mul	r3, r2, r0
   165a4:	e0411003 	sub	r1, r1, r3
   165a8:	e12fff1e 	bx	lr

000165ac <__aeabi_idiv0>:
   165ac:	e12fff1e 	bx	lr

000165b0 <__aeabi_uldivmod>:
   165b0:	e3530000 	cmp	r3, #0
   165b4:	03520000 	cmpeq	r2, #0
   165b8:	1a000004 	bne	165d0 <__aeabi_uldivmod+0x20>
   165bc:	e3510000 	cmp	r1, #0
   165c0:	03500000 	cmpeq	r0, #0
   165c4:	13e01000 	mvnne	r1, #0
   165c8:	13e00000 	mvnne	r0, #0
   165cc:	eafffff6 	b	165ac <__aeabi_idiv0>
   165d0:	e24dd008 	sub	sp, sp, #8
   165d4:	e92d6000 	push	{sp, lr}
   165d8:	eb000003 	bl	165ec <__udivmoddi4>
   165dc:	e59de004 	ldr	lr, [sp, #4]
   165e0:	e28dd008 	add	sp, sp, #8
   165e4:	e8bd000c 	pop	{r2, r3}
   165e8:	e12fff1e 	bx	lr

000165ec <__udivmoddi4>:
   165ec:	e1500002 	cmp	r0, r2
   165f0:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
   165f4:	e1a0e001 	mov	lr, r1
   165f8:	e1a0c000 	mov	ip, r0
   165fc:	e0de1003 	sbcs	r1, lr, r3
   16600:	33a00000 	movcc	r0, #0
   16604:	e59d501c 	ldr	r5, [sp, #28]
   16608:	31a01000 	movcc	r1, r0
   1660c:	3a00003b 	bcc	16700 <__udivmoddi4+0x114>
   16610:	e3530000 	cmp	r3, #0
   16614:	016f4f12 	clzeq	r4, r2
   16618:	116f4f13 	clzne	r4, r3
   1661c:	02844020 	addeq	r4, r4, #32
   16620:	e35e0000 	cmp	lr, #0
   16624:	016f1f1c 	clzeq	r1, ip
   16628:	116f1f1e 	clzne	r1, lr
   1662c:	02811020 	addeq	r1, r1, #32
   16630:	e0444001 	sub	r4, r4, r1
   16634:	e1a03413 	lsl	r3, r3, r4
   16638:	e2447020 	sub	r7, r4, #32
   1663c:	e1a08412 	lsl	r8, r2, r4
   16640:	e2646020 	rsb	r6, r4, #32
   16644:	e1833712 	orr	r3, r3, r2, lsl r7
   16648:	e15c0008 	cmp	ip, r8
   1664c:	e1833632 	orr	r3, r3, r2, lsr r6
   16650:	e0de2003 	sbcs	r2, lr, r3
   16654:	33a00000 	movcc	r0, #0
   16658:	31a01000 	movcc	r1, r0
   1665c:	3a000005 	bcc	16678 <__udivmoddi4+0x8c>
   16660:	e3a00001 	mov	r0, #1
   16664:	e05cc008 	subs	ip, ip, r8
   16668:	e1a01710 	lsl	r1, r0, r7
   1666c:	e0cee003 	sbc	lr, lr, r3
   16670:	e1811630 	orr	r1, r1, r0, lsr r6
   16674:	e1a00410 	lsl	r0, r0, r4
   16678:	e3540000 	cmp	r4, #0
   1667c:	0a00001f 	beq	16700 <__udivmoddi4+0x114>
   16680:	e1a020a8 	lsr	r2, r8, #1
   16684:	e1a08004 	mov	r8, r4
   16688:	e1822f83 	orr	r2, r2, r3, lsl #31
   1668c:	e1a030a3 	lsr	r3, r3, #1
   16690:	ea000007 	b	166b4 <__udivmoddi4+0xc8>
   16694:	e05cc002 	subs	ip, ip, r2
   16698:	e0cee003 	sbc	lr, lr, r3
   1669c:	e09cc00c 	adds	ip, ip, ip
   166a0:	e0aee00e 	adc	lr, lr, lr
   166a4:	e29cc001 	adds	ip, ip, #1
   166a8:	e2aee000 	adc	lr, lr, #0
   166ac:	e2588001 	subs	r8, r8, #1
   166b0:	0a000006 	beq	166d0 <__udivmoddi4+0xe4>
   166b4:	e15c0002 	cmp	ip, r2
   166b8:	e0de9003 	sbcs	r9, lr, r3
   166bc:	2afffff4 	bcs	16694 <__udivmoddi4+0xa8>
   166c0:	e09cc00c 	adds	ip, ip, ip
   166c4:	e0aee00e 	adc	lr, lr, lr
   166c8:	e2588001 	subs	r8, r8, #1
   166cc:	1afffff8 	bne	166b4 <__udivmoddi4+0xc8>
   166d0:	e090000c 	adds	r0, r0, ip
   166d4:	e1a0c43c 	lsr	ip, ip, r4
   166d8:	e0a1100e 	adc	r1, r1, lr
   166dc:	e18cc61e 	orr	ip, ip, lr, lsl r6
   166e0:	e18cc73e 	orr	ip, ip, lr, lsr r7
   166e4:	e1a0e43e 	lsr	lr, lr, r4
   166e8:	e1a0341e 	lsl	r3, lr, r4
   166ec:	e1a0441c 	lsl	r4, ip, r4
   166f0:	e183371c 	orr	r3, r3, ip, lsl r7
   166f4:	e0500004 	subs	r0, r0, r4
   166f8:	e183363c 	orr	r3, r3, ip, lsr r6
   166fc:	e0c11003 	sbc	r1, r1, r3
   16700:	e3550000 	cmp	r5, #0
   16704:	18855000 	stmne	r5, {ip, lr}
   16708:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}

0001670c <abort>:
  write (2, "Abort called\n", sizeof ("Abort called\n")-1);
#endif

  while (1)
    {
      raise (SIGABRT);
   1670c:	e3a00006 	mov	r0, #6
{
   16710:	e92d4010 	push	{r4, lr}
      raise (SIGABRT);
   16714:	eb0011c9 	bl	1ae40 <raise>
      _exit (1);
   16718:	e3a00001 	mov	r0, #1
   1671c:	eb0023e4 	bl	1f6b4 <_exit>

00016720 <__assert_func>:
void
__assert_func (const char *file,
	int line,
	const char *func,
	const char *failedexpr)
{
   16720:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
  fiprintf(stderr,
   16724:	e30be1e8 	movw	lr, #45544	@ 0xb1e8
   16728:	e340e002 	movt	lr, #2
   1672c:	e252c000 	subs	ip, r2, #0
{
   16730:	e1a02003 	mov	r2, r3
   16734:	e1a03000 	mov	r3, r0
  fiprintf(stderr,
   16738:	e59ee000 	ldr	lr, [lr]
{
   1673c:	e24dd014 	sub	sp, sp, #20
   16740:	e1a04001 	mov	r4, r1
  fiprintf(stderr,
   16744:	e3091174 	movw	r1, #37236	@ 0x9174
   16748:	e3401002 	movt	r1, #2
   1674c:	e59e000c 	ldr	r0, [lr, #12]
   16750:	0308ed5c 	movweq	lr, #36188	@ 0x8d5c
   16754:	1309e164 	movwne	lr, #37220	@ 0x9164
   16758:	0340e002 	movteq	lr, #2
   1675c:	1340e002 	movtne	lr, #2
   16760:	01a0c00e 	moveq	ip, lr
   16764:	e58dc008 	str	ip, [sp, #8]
   16768:	e58de004 	str	lr, [sp, #4]
   1676c:	e58d4000 	str	r4, [sp]
   16770:	eb0000d4 	bl	16ac8 <fiprintf>
	   "assertion \"%s\" failed: file \"%s\", line %d%s%s\n",
	   failedexpr, file, line,
	   func ? ", function: " : "", func ? func : "");
  abort();
   16774:	ebffffe4 	bl	1670c <abort>

00016778 <__assert>:

void
__assert (const char *file,
	int line,
	const char *failedexpr)
{
   16778:	e1a03002 	mov	r3, r2
   1677c:	e92d4010 	push	{r4, lr}
   __assert_func (file, line, NULL, failedexpr);
   16780:	e3a02000 	mov	r2, #0
   16784:	ebffffe5 	bl	16720 <__assert_func>

00016788 <atexit>:
 */

int
atexit (void (*fn) (void))
{
  return __register_exitproc (__et_atexit, fn, NULL, NULL);
   16788:	e3a03000 	mov	r3, #0
{
   1678c:	e1a01000 	mov	r1, r0
  return __register_exitproc (__et_atexit, fn, NULL, NULL);
   16790:	e1a02003 	mov	r2, r3
   16794:	e1a00003 	mov	r0, r3
   16798:	ea002803 	b	207ac <__register_exitproc>

0001679c <exit>:
 * Exit, flushing stdio buffers if necessary.
 */

void
exit (int code)
{
   1679c:	e92d4010 	push	{r4, lr}
#ifdef _LITE_EXIT
  /* Refer to comments in __atexit.c for more details of lite exit.  */
  void __call_exitprocs (int, void *) __attribute__((weak));
  if (__call_exitprocs)
#endif
    __call_exitprocs (code, NULL);
   167a0:	e3a01000 	mov	r1, #0
{
   167a4:	e1a04000 	mov	r4, r0
    __call_exitprocs (code, NULL);
   167a8:	eb002831 	bl	20874 <__call_exitprocs>

  if (__stdio_exit_handler != NULL)
   167ac:	e30b365c 	movw	r3, #46684	@ 0xb65c
   167b0:	e3403002 	movt	r3, #2
   167b4:	e5933000 	ldr	r3, [r3]
   167b8:	e3530000 	cmp	r3, #0
   167bc:	0a000000 	beq	167c4 <exit+0x28>
    (*__stdio_exit_handler) ();
   167c0:	e12fff33 	blx	r3

  _exit (code);
   167c4:	e1a00004 	mov	r0, r4
   167c8:	eb0023b9 	bl	1f6b4 <_exit>

000167cc <_findenv>:

char *
_findenv (register const char *name,
	int *offset)
{
  return _findenv_r (_REENT, name, offset);
   167cc:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
{
   167d0:	e1a0c000 	mov	ip, r0
  return _findenv_r (_REENT, name, offset);
   167d4:	e3403002 	movt	r3, #2
{
   167d8:	e1a02001 	mov	r2, r1
  return _findenv_r (_REENT, name, offset);
   167dc:	e5930000 	ldr	r0, [r3]
   167e0:	e1a0100c 	mov	r1, ip
   167e4:	ea000009 	b	16810 <_findenv_r>

000167e8 <getenv>:
char *
getenv (const char *name)
{
  int offset;

  return _findenv_r (_REENT, name, &offset);
   167e8:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
{
   167ec:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
  return _findenv_r (_REENT, name, &offset);
   167f0:	e3403002 	movt	r3, #2
{
   167f4:	e24dd00c 	sub	sp, sp, #12
   167f8:	e1a01000 	mov	r1, r0
  return _findenv_r (_REENT, name, &offset);
   167fc:	e28d2004 	add	r2, sp, #4
   16800:	e5930000 	ldr	r0, [r3]
   16804:	eb000001 	bl	16810 <_findenv_r>
}
   16808:	e28dd00c 	add	sp, sp, #12
   1680c:	e49df004 	pop	{pc}		@ (ldr pc, [sp], #4)

00016810 <_findenv_r>:

char *
_findenv_r (struct _reent *reent_ptr,
	register const char *name,
	int *offset)
{
   16810:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}

  ENV_LOCK;

  /* In some embedded systems, this does not get set.  This protects
     newlib from dereferencing a bad pointer.  */
  if (!*p_environ)
   16814:	e30b8068 	movw	r8, #45160	@ 0xb068
   16818:	e3408002 	movt	r8, #2
{
   1681c:	e1a09000 	mov	r9, r0
   16820:	e1a06001 	mov	r6, r1
   16824:	e1a07002 	mov	r7, r2
  ENV_LOCK;
   16828:	eb002861 	bl	209b4 <__env_lock>
  if (!*p_environ)
   1682c:	e5985000 	ldr	r5, [r8]
   16830:	e3550000 	cmp	r5, #0
   16834:	0a00001b 	beq	168a8 <_findenv_r+0x98>
      ENV_UNLOCK;
      return NULL;
    }

  c = name;
  while (*c && *c != '=')  c++;
   16838:	e5d63000 	ldrb	r3, [r6]
  c = name;
   1683c:	e1a04006 	mov	r4, r6
  while (*c && *c != '=')  c++;
   16840:	e3530000 	cmp	r3, #0
   16844:	1353003d 	cmpne	r3, #61	@ 0x3d
   16848:	0a000003 	beq	1685c <_findenv_r+0x4c>
   1684c:	e5f43001 	ldrb	r3, [r4, #1]!
   16850:	e3530000 	cmp	r3, #0
   16854:	1353003d 	cmpne	r3, #61	@ 0x3d
   16858:	1afffffb 	bne	1684c <_findenv_r+0x3c>
 
  /* Identifiers may not contain an '=', so cannot match if does */
  if(*c != '=')
   1685c:	e353003d 	cmp	r3, #61	@ 0x3d
   16860:	0a000010 	beq	168a8 <_findenv_r+0x98>
    {
    len = c - name;
    for (p = *p_environ; *p; ++p)
   16864:	e5950000 	ldr	r0, [r5]
    len = c - name;
   16868:	e0444006 	sub	r4, r4, r6
    for (p = *p_environ; *p; ++p)
   1686c:	e3500000 	cmp	r0, #0
   16870:	0a00000c 	beq	168a8 <_findenv_r+0x98>
      if (!strncmp (*p, name, len))
   16874:	e1a02004 	mov	r2, r4
   16878:	e1a01006 	mov	r1, r6
   1687c:	eb00102c 	bl	1a934 <strncmp>
   16880:	e3500000 	cmp	r0, #0
   16884:	1a000004 	bne	1689c <_findenv_r+0x8c>
        if (*(c = *p + len) == '=')
   16888:	e5950000 	ldr	r0, [r5]
   1688c:	e7d03004 	ldrb	r3, [r0, r4]
   16890:	e080a004 	add	sl, r0, r4
   16894:	e353003d 	cmp	r3, #61	@ 0x3d
   16898:	0a000006 	beq	168b8 <_findenv_r+0xa8>
    for (p = *p_environ; *p; ++p)
   1689c:	e5b50004 	ldr	r0, [r5, #4]!
   168a0:	e3500000 	cmp	r0, #0
   168a4:	1afffff2 	bne	16874 <_findenv_r+0x64>
      ENV_UNLOCK;
   168a8:	e1a00009 	mov	r0, r9
   168ac:	eb002841 	bl	209b8 <__env_unlock>
      return NULL;
   168b0:	e3a00000 	mov	r0, #0
   168b4:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
	{
	  *offset = p - *p_environ;
   168b8:	e5983000 	ldr	r3, [r8]
	  ENV_UNLOCK;
   168bc:	e1a00009 	mov	r0, r9
	  *offset = p - *p_environ;
   168c0:	e0455003 	sub	r5, r5, r3
   168c4:	e1a05145 	asr	r5, r5, #2
   168c8:	e5875000 	str	r5, [r7]
	  ENV_UNLOCK;
   168cc:	eb002839 	bl	209b8 <__env_unlock>
	  return (char *) (++c);
   168d0:	e28a0001 	add	r0, sl, #1
	}
    }
  ENV_UNLOCK;
  return NULL;
}
   168d4:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}

000168d8 <_getenv_r>:
 */

char *
_getenv_r (struct _reent *reent_ptr,
	const char *name)
{
   168d8:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
   168dc:	e24dd00c 	sub	sp, sp, #12
  int offset;

  return _findenv_r (reent_ptr, name, &offset);
   168e0:	e28d2004 	add	r2, sp, #4
   168e4:	ebffffc9 	bl	16810 <_findenv_r>
}
   168e8:	e28dd00c 	add	sp, sp, #12
   168ec:	e49df004 	pop	{pc}		@ (ldr pc, [sp], #4)

000168f0 <_mbrtowc_r>:
_mbrtowc_r (struct _reent *ptr,
	wchar_t *pwc,
	const char *s,
	size_t n,
	mbstate_t *ps)
{
   168f0:	e92d4070 	push	{r4, r5, r6, lr}
   168f4:	e24dd008 	sub	sp, sp, #8
   168f8:	e59d5018 	ldr	r5, [sp, #24]
      _REENT_CHECK_MISC(ptr);
      ps = &(_REENT_MBRTOWC_STATE(ptr));
    }
#endif

  if (s == NULL)
   168fc:	e252c000 	subs	ip, r2, #0
    retval = __MBTOWC (ptr, NULL, "", 1, ps);
   16900:	e30be078 	movw	lr, #45176	@ 0xb078
   16904:	03082d5c 	movweq	r2, #36188	@ 0x8d5c
   16908:	e340e002 	movt	lr, #2
   1690c:	03402002 	movteq	r2, #2
   16910:	03a03001 	moveq	r3, #1
   16914:	e59e60e4 	ldr	r6, [lr, #228]	@ 0xe4
   16918:	01a0100c 	moveq	r1, ip
   1691c:	058d5000 	streq	r5, [sp]
  else
    retval = __MBTOWC (ptr, pwc, s, n, ps);
   16920:	158d5000 	strne	r5, [sp]
{
   16924:	e1a04000 	mov	r4, r0
    retval = __MBTOWC (ptr, pwc, s, n, ps);
   16928:	e12fff36 	blx	r6

  if (retval == -1)
   1692c:	e3700001 	cmn	r0, #1
    {
      ps->__count = 0;
   16930:	03a02000 	moveq	r2, #0
      _REENT_ERRNO(ptr) = EILSEQ;
   16934:	03a0308a 	moveq	r3, #138	@ 0x8a
      ps->__count = 0;
   16938:	05852000 	streq	r2, [r5]
      _REENT_ERRNO(ptr) = EILSEQ;
   1693c:	05843000 	streq	r3, [r4]
      return (size_t)(-1);
    }
  else
    return (size_t)retval;
}
   16940:	e28dd008 	add	sp, sp, #8
   16944:	e8bd8070 	pop	{r4, r5, r6, pc}

00016948 <mbrtowc>:
size_t
mbrtowc (wchar_t *__restrict pwc,
	const char *__restrict s,
	size_t n,
	mbstate_t *__restrict ps)
{
   16948:	e92d4070 	push	{r4, r5, r6, lr}
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  return _mbrtowc_r (_REENT, pwc, s, n, ps);
#else
  int retval = 0;
  struct _reent *reent = _REENT;
   1694c:	e30be1e8 	movw	lr, #45544	@ 0xb1e8
   16950:	e340e002 	movt	lr, #2
      _REENT_CHECK_MISC(reent);
      ps = &(_REENT_MBRTOWC_STATE(reent));
    }
#endif

  if (s == NULL)
   16954:	e251c000 	subs	ip, r1, #0
{
   16958:	e1a04003 	mov	r4, r3
   1695c:	e24dd008 	sub	sp, sp, #8
  struct _reent *reent = _REENT;
   16960:	e59e5000 	ldr	r5, [lr]
    retval = __MBTOWC (reent, NULL, "", 1, ps);
   16964:	e30be078 	movw	lr, #45176	@ 0xb078
   16968:	03082d5c 	movweq	r2, #36188	@ 0x8d5c
   1696c:	e340e002 	movt	lr, #2
   16970:	03a03001 	moveq	r3, #1
   16974:	03402002 	movteq	r2, #2
   16978:	e59e60e4 	ldr	r6, [lr, #228]	@ 0xe4
  else
    retval = __MBTOWC (reent, pwc, s, n, ps);
   1697c:	11a03002 	movne	r3, r2
   16980:	11a01000 	movne	r1, r0
   16984:	11a0200c 	movne	r2, ip
    retval = __MBTOWC (reent, NULL, "", 1, ps);
   16988:	058d4000 	streq	r4, [sp]
    retval = __MBTOWC (reent, pwc, s, n, ps);
   1698c:	e1a00005 	mov	r0, r5
   16990:	158d4000 	strne	r4, [sp]
   16994:	e12fff36 	blx	r6

  if (retval == -1)
   16998:	e3700001 	cmn	r0, #1
    {
      ps->__count = 0;
   1699c:	03a02000 	moveq	r2, #0
      _REENT_ERRNO(reent) = EILSEQ;
   169a0:	03a0308a 	moveq	r3, #138	@ 0x8a
      ps->__count = 0;
   169a4:	05842000 	streq	r2, [r4]
      _REENT_ERRNO(reent) = EILSEQ;
   169a8:	05853000 	streq	r3, [r5]
      return (size_t)(-1);
    }
  else
    return (size_t)retval;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   169ac:	e28dd008 	add	sp, sp, #8
   169b0:	e8bd8070 	pop	{r4, r5, r6, pc}

000169b4 <mbsinit>:
#include <errno.h>

int
mbsinit(const mbstate_t *ps)
{
  if (ps == NULL || ps->__count == 0)
   169b4:	e3500000 	cmp	r0, #0
   169b8:	15900000 	ldrne	r0, [r0]
   169bc:	116f0f10 	clzne	r0, r0
   169c0:	11a002a0 	lsrne	r0, r0, #5
    return 1;
   169c4:	03a00001 	moveq	r0, #1
  else
    return 0;
}
   169c8:	e12fff1e 	bx	lr

000169cc <_wcrtomb_r>:
size_t
_wcrtomb_r (struct _reent *ptr,
	char *s,
	wchar_t wc,
	mbstate_t *ps)
{
   169cc:	e92d4070 	push	{r4, r5, r6, lr}
      ps = &(_REENT_WCRTOMB_STATE(ptr));
    }
#endif

  if (s == NULL)
    retval = __WCTOMB (ptr, buf, L'\0', ps);
   169d0:	e30be078 	movw	lr, #45176	@ 0xb078
{
   169d4:	e24dd010 	sub	sp, sp, #16
  if (s == NULL)
   169d8:	e251c000 	subs	ip, r1, #0
    retval = __WCTOMB (ptr, buf, L'\0', ps);
   169dc:	e340e002 	movt	lr, #2
   169e0:	01a0200c 	moveq	r2, ip
   169e4:	028d1004 	addeq	r1, sp, #4
   169e8:	e59e50e0 	ldr	r5, [lr, #224]	@ 0xe0
{
   169ec:	e1a06003 	mov	r6, r3
   169f0:	e1a04000 	mov	r4, r0
  else
    retval = __WCTOMB (ptr, s, wc, ps);
   169f4:	e12fff35 	blx	r5

  if (retval == -1)
   169f8:	e3700001 	cmn	r0, #1
    {
      ps->__count = 0;
   169fc:	03a02000 	moveq	r2, #0
      _REENT_ERRNO(ptr) = EILSEQ;
   16a00:	03a0308a 	moveq	r3, #138	@ 0x8a
      ps->__count = 0;
   16a04:	05862000 	streq	r2, [r6]
      _REENT_ERRNO(ptr) = EILSEQ;
   16a08:	05843000 	streq	r3, [r4]
      return (size_t)(-1);
    }
  else
    return (size_t)retval;
}
   16a0c:	e28dd010 	add	sp, sp, #16
   16a10:	e8bd8070 	pop	{r4, r5, r6, pc}

00016a14 <wcrtomb>:
{
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  return _wcrtomb_r (_REENT, s, wc, ps);
#else
  int retval = 0;
  struct _reent *reent = _REENT;
   16a14:	e30bc1e8 	movw	ip, #45544	@ 0xb1e8
{
   16a18:	e92d4070 	push	{r4, r5, r6, lr}
  struct _reent *reent = _REENT;
   16a1c:	e340c002 	movt	ip, #2
      ps = &(_REENT_WCRTOMB_STATE(reent));
    }
#endif

  if (s == NULL)
    retval = __WCTOMB (reent, buf, L'\0', ps);
   16a20:	e30b3078 	movw	r3, #45176	@ 0xb078
  if (s == NULL)
   16a24:	e3500000 	cmp	r0, #0
    retval = __WCTOMB (reent, buf, L'\0', ps);
   16a28:	e3403002 	movt	r3, #2
  struct _reent *reent = _REENT;
   16a2c:	e59c5000 	ldr	r5, [ip]
{
   16a30:	e1a04002 	mov	r4, r2
   16a34:	e24dd010 	sub	sp, sp, #16
    retval = __WCTOMB (reent, buf, L'\0', ps);
   16a38:	e59360e0 	ldr	r6, [r3, #224]	@ 0xe0
  else
    retval = __WCTOMB (reent, s, wc, ps);
   16a3c:	11a02001 	movne	r2, r1
    retval = __WCTOMB (reent, buf, L'\0', ps);
   16a40:	01a03002 	moveq	r3, r2
    retval = __WCTOMB (reent, s, wc, ps);
   16a44:	11a01000 	movne	r1, r0
    retval = __WCTOMB (reent, buf, L'\0', ps);
   16a48:	01a02000 	moveq	r2, r0
   16a4c:	028d1004 	addeq	r1, sp, #4
    retval = __WCTOMB (reent, s, wc, ps);
   16a50:	11a03004 	movne	r3, r4
   16a54:	e1a00005 	mov	r0, r5
   16a58:	e12fff36 	blx	r6

  if (retval == -1)
   16a5c:	e3700001 	cmn	r0, #1
    {
      ps->__count = 0;
   16a60:	03a02000 	moveq	r2, #0
      _REENT_ERRNO(reent) = EILSEQ;
   16a64:	03a0308a 	moveq	r3, #138	@ 0x8a
      ps->__count = 0;
   16a68:	05842000 	streq	r2, [r4]
      _REENT_ERRNO(reent) = EILSEQ;
   16a6c:	05853000 	streq	r3, [r5]
      return (size_t)(-1);
    }
  else
    return (size_t)retval;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   16a70:	e28dd010 	add	sp, sp, #16
   16a74:	e8bd8070 	pop	{r4, r5, r6, pc}

00016a78 <iswprint>:
#include <wctype.h>

int
iswprint (wint_t c)
{
  return iswprint_l (c, 0);
   16a78:	e3a01000 	mov	r1, #0
   16a7c:	eaffffff 	b	16a80 <iswprint_l>

00016a80 <iswprint_l>:
  return cat != -1
      && cat != CAT_Cc && cat != CAT_Cf
      && cat != CAT_Cs // Surrogate
      ;
#else
  return c < (wint_t)0x100 ? isprint (c) : 0;
   16a80:	e35000ff 	cmp	r0, #255	@ 0xff
   16a84:	959f300c 	ldrls	r3, [pc, #12]	@ 16a98 <iswprint_l+0x18>
   16a88:	97d30000 	ldrbls	r0, [r3, r0]
   16a8c:	92000097 	andls	r0, r0, #151	@ 0x97
   16a90:	83a00000 	movhi	r0, #0
#endif /* _MB_CAPABLE */
}
   16a94:	e12fff1e 	bx	lr
   16a98:	00029e51 	.word	0x00029e51

00016a9c <_fiprintf_r>:

int
_fiprintf_r (struct _reent *ptr,
       FILE * fp,
       const char *fmt, ...)
{
   16a9c:	e92d000c 	push	{r2, r3}
   16aa0:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
   16aa4:	e24dd00c 	sub	sp, sp, #12
  int ret;
  va_list ap;

  va_start (ap, fmt);
   16aa8:	e28d3014 	add	r3, sp, #20
  ret = _vfiprintf_r (ptr, fp, fmt, ap);
   16aac:	e59d2010 	ldr	r2, [sp, #16]
  va_start (ap, fmt);
   16ab0:	e58d3004 	str	r3, [sp, #4]
  ret = _vfiprintf_r (ptr, fp, fmt, ap);
   16ab4:	eb000012 	bl	16b04 <_vfiprintf_r>
  va_end (ap);
  return ret;
}
   16ab8:	e28dd00c 	add	sp, sp, #12
   16abc:	e49de004 	pop	{lr}		@ (ldr lr, [sp], #4)
   16ac0:	e28dd008 	add	sp, sp, #8
   16ac4:	e12fff1e 	bx	lr

00016ac8 <fiprintf>:
{
  int ret;
  va_list ap;

  va_start (ap, fmt);
  ret = _vfiprintf_r (_REENT, fp, fmt, ap);
   16ac8:	e30bc1e8 	movw	ip, #45544	@ 0xb1e8
{
   16acc:	e92d000e 	push	{r1, r2, r3}
  ret = _vfiprintf_r (_REENT, fp, fmt, ap);
   16ad0:	e340c002 	movt	ip, #2
{
   16ad4:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
   16ad8:	e24dd008 	sub	sp, sp, #8
   16adc:	e1a01000 	mov	r1, r0
  va_start (ap, fmt);
   16ae0:	e28d3010 	add	r3, sp, #16
  ret = _vfiprintf_r (_REENT, fp, fmt, ap);
   16ae4:	e59d200c 	ldr	r2, [sp, #12]
   16ae8:	e59c0000 	ldr	r0, [ip]
  va_start (ap, fmt);
   16aec:	e58d3004 	str	r3, [sp, #4]
  ret = _vfiprintf_r (_REENT, fp, fmt, ap);
   16af0:	eb000003 	bl	16b04 <_vfiprintf_r>
  va_end (ap);
  return ret;
}
   16af4:	e28dd008 	add	sp, sp, #8
   16af8:	e49de004 	pop	{lr}		@ (ldr lr, [sp], #4)
   16afc:	e28dd00c 	add	sp, sp, #12
   16b00:	e12fff1e 	bx	lr

00016b04 <_vfiprintf_r>:
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
   16b04:	e250c000 	subs	ip, r0, #0
{
   16b08:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   16b0c:	e24dd0ec 	sub	sp, sp, #236	@ 0xec
   16b10:	e1a04003 	mov	r4, r3
   16b14:	e1a09002 	mov	r9, r2
	CHECK_INIT (data, fp);
   16b18:	e58dc010 	str	ip, [sp, #16]
{
   16b1c:	e58d1004 	str	r1, [sp, #4]
   16b20:	e58d3014 	str	r3, [sp, #20]
	CHECK_INIT (data, fp);
   16b24:	0a000002 	beq	16b34 <_vfiprintf_r+0x30>
   16b28:	e59c3034 	ldr	r3, [ip, #52]	@ 0x34
   16b2c:	e3530000 	cmp	r3, #0
   16b30:	0a0003cc 	beq	17a68 <_vfiprintf_r+0xf64>
	_newlib_flockfile_start (fp);

	if (ORIENT(fp, -1) != -1) {
   16b34:	e59d1004 	ldr	r1, [sp, #4]
   16b38:	e1d120fc 	ldrsh	r2, [r1, #12]
	_newlib_flockfile_start (fp);
   16b3c:	e5913064 	ldr	r3, [r1, #100]	@ 0x64
	if (ORIENT(fp, -1) != -1) {
   16b40:	e3120a02 	tst	r2, #8192	@ 0x2000
   16b44:	03822a02 	orreq	r2, r2, #8192	@ 0x2000
   16b48:	03c33a02 	biceq	r3, r3, #8192	@ 0x2000
   16b4c:	01c120bc 	strheq	r2, [r1, #12]
   16b50:	05813064 	streq	r3, [r1, #100]	@ 0x64
   16b54:	e3130a02 	tst	r3, #8192	@ 0x2000
   16b58:	1a0003eb 	bne	17b0c <_vfiprintf_r+0x1008>
		_newlib_flockfile_exit (fp);
		return (EOF);
	}

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
   16b5c:	e59d3004 	ldr	r3, [sp, #4]
   16b60:	e1d320fc 	ldrsh	r2, [r3, #12]
   16b64:	e3120008 	tst	r2, #8
   16b68:	0a0000b2 	beq	16e38 <_vfiprintf_r+0x334>
   16b6c:	e5933010 	ldr	r3, [r3, #16]
   16b70:	e3530000 	cmp	r3, #0
   16b74:	0a0000af 	beq	16e38 <_vfiprintf_r+0x334>
		return (EOF);
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   16b78:	e202201a 	and	r2, r2, #26
   16b7c:	e352000a 	cmp	r2, #10
   16b80:	0a0000b6 	beq	16e60 <_vfiprintf_r+0x35c>
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
   16b84:	e28d3044 	add	r3, sp, #68	@ 0x44
   16b88:	e28db044 	add	fp, sp, #68	@ 0x44
   16b8c:	e58d3038 	str	r3, [sp, #56]	@ 0x38
	uio.uio_resid = 0;
   16b90:	e3a03000 	mov	r3, #0
   16b94:	e58d3040 	str	r3, [sp, #64]	@ 0x40
	uio.uio_iovcnt = 0;
   16b98:	e58d303c 	str	r3, [sp, #60]	@ 0x3c
	const char *grouping = NULL;
   16b9c:	e58d3020 	str	r3, [sp, #32]
	size_t thsnd_len = 0;
   16ba0:	e58d3028 	str	r3, [sp, #40]	@ 0x28
	char *thousands_sep = NULL;
   16ba4:	e58d3024 	str	r3, [sp, #36]	@ 0x24
#endif
	ret = 0;
   16ba8:	e58d3008 	str	r3, [sp, #8]
   16bac:	e58d301c 	str	r3, [sp, #28]
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   16bb0:	e5d93000 	ldrb	r3, [r9]
   16bb4:	e1a04009 	mov	r4, r9
   16bb8:	e3530025 	cmp	r3, #37	@ 0x25
   16bbc:	13530000 	cmpne	r3, #0
   16bc0:	0a000015 	beq	16c1c <_vfiprintf_r+0x118>
                    fmt += 1;
   16bc4:	e1a05004 	mov	r5, r4
                while (*fmt != '\0' && *fmt != '%')
   16bc8:	e5f43001 	ldrb	r3, [r4, #1]!
   16bcc:	e3530000 	cmp	r3, #0
   16bd0:	13530025 	cmpne	r3, #37	@ 0x25
   16bd4:	1afffffa 	bne	16bc4 <_vfiprintf_r+0xc0>
#endif
		if ((m = fmt - cp) != 0) {
   16bd8:	e0546009 	subs	r6, r4, r9
   16bdc:	0a00000e 	beq	16c1c <_vfiprintf_r+0x118>
			PRINT (cp, m);
   16be0:	e59d303c 	ldr	r3, [sp, #60]	@ 0x3c
   16be4:	e58b9000 	str	r9, [fp]
   16be8:	e58b6004 	str	r6, [fp, #4]
   16bec:	e2833001 	add	r3, r3, #1
   16bf0:	e3530007 	cmp	r3, #7
   16bf4:	e58d303c 	str	r3, [sp, #60]	@ 0x3c
   16bf8:	e59d3040 	ldr	r3, [sp, #64]	@ 0x40
   16bfc:	d28bb008 	addle	fp, fp, #8
   16c00:	e0833006 	add	r3, r3, r6
   16c04:	e58d3040 	str	r3, [sp, #64]	@ 0x40
   16c08:	ca00009f 	bgt	16e8c <_vfiprintf_r+0x388>
			ret += m;
   16c0c:	e59d3008 	ldr	r3, [sp, #8]
   16c10:	e0833006 	add	r3, r3, r6
   16c14:	e58d3008 	str	r3, [sp, #8]
		}
#ifdef _MB_CAPABLE
		if (n <= 0)
                    goto done;
#else
                if (*fmt == '\0')
   16c18:	e5d53001 	ldrb	r3, [r5, #1]
   16c1c:	e3530000 	cmp	r3, #0
   16c20:	0a0000a1 	beq	16eac <_vfiprintf_r+0x3a8>

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';
   16c24:	e3a03000 	mov	r3, #0
		width = 0;
   16c28:	e3a07000 	mov	r7, #0
		sign = '\0';
   16c2c:	e5cd3033 	strb	r3, [sp, #51]	@ 0x33
		fmt++;		/* skip over '%' */
   16c30:	e2849001 	add	r9, r4, #1
#ifndef _NO_POS_ARGS
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
   16c34:	e5d43001 	ldrb	r3, [r4, #1]
		prec = -1;
   16c38:	e3e08000 	mvn	r8, #0
		flags = 0;
   16c3c:	e1a0a007 	mov	sl, r7
rflag:		ch = *fmt++;
   16c40:	e2899001 	add	r9, r9, #1
reswitch:	switch (ch) {
   16c44:	e2432020 	sub	r2, r3, #32
   16c48:	e352005a 	cmp	r2, #90	@ 0x5a
   16c4c:	979ff102 	ldrls	pc, [pc, r2, lsl #2]
   16c50:	ea00009f 	b	16ed4 <_vfiprintf_r+0x3d0>
   16c54:	00017168 	.word	0x00017168
   16c58:	00016ed4 	.word	0x00016ed4
   16c5c:	00016ed4 	.word	0x00016ed4
   16c60:	0001715c 	.word	0x0001715c
   16c64:	00016ed4 	.word	0x00016ed4
   16c68:	00016ed4 	.word	0x00016ed4
   16c6c:	00016ed4 	.word	0x00016ed4
   16c70:	00016de4 	.word	0x00016de4
   16c74:	00016ed4 	.word	0x00016ed4
   16c78:	00016ed4 	.word	0x00016ed4
   16c7c:	000170d0 	.word	0x000170d0
   16c80:	000170f4 	.word	0x000170f4
   16c84:	00016ed4 	.word	0x00016ed4
   16c88:	000170e8 	.word	0x000170e8
   16c8c:	00017110 	.word	0x00017110
   16c90:	00016ed4 	.word	0x00016ed4
   16c94:	00017104 	.word	0x00017104
   16c98:	00016dc0 	.word	0x00016dc0
   16c9c:	00016dc0 	.word	0x00016dc0
   16ca0:	00016dc0 	.word	0x00016dc0
   16ca4:	00016dc0 	.word	0x00016dc0
   16ca8:	00016dc0 	.word	0x00016dc0
   16cac:	00016dc0 	.word	0x00016dc0
   16cb0:	00016dc0 	.word	0x00016dc0
   16cb4:	00016dc0 	.word	0x00016dc0
   16cb8:	00016dc0 	.word	0x00016dc0
   16cbc:	00016ed4 	.word	0x00016ed4
   16cc0:	00016ed4 	.word	0x00016ed4
   16cc4:	00016ed4 	.word	0x00016ed4
   16cc8:	00016ed4 	.word	0x00016ed4
   16ccc:	00016ed4 	.word	0x00016ed4
   16cd0:	00016ed4 	.word	0x00016ed4
   16cd4:	00016ed4 	.word	0x00016ed4
   16cd8:	00016ed4 	.word	0x00016ed4
   16cdc:	00016ed4 	.word	0x00016ed4
   16ce0:	000170a8 	.word	0x000170a8
   16ce4:	00017180 	.word	0x00017180
   16ce8:	00016ed4 	.word	0x00016ed4
   16cec:	00016ed4 	.word	0x00016ed4
   16cf0:	00016ed4 	.word	0x00016ed4
   16cf4:	00016ed4 	.word	0x00016ed4
   16cf8:	00016ed4 	.word	0x00016ed4
   16cfc:	00016ed4 	.word	0x00016ed4
   16d00:	00016ed4 	.word	0x00016ed4
   16d04:	00016ed4 	.word	0x00016ed4
   16d08:	00016ed4 	.word	0x00016ed4
   16d0c:	00016ed4 	.word	0x00016ed4
   16d10:	00017200 	.word	0x00017200
   16d14:	00016ed4 	.word	0x00016ed4
   16d18:	00016ed4 	.word	0x00016ed4
   16d1c:	00016ed4 	.word	0x00016ed4
   16d20:	00017044 	.word	0x00017044
   16d24:	00016ed4 	.word	0x00016ed4
   16d28:	00017274 	.word	0x00017274
   16d2c:	00016ed4 	.word	0x00016ed4
   16d30:	00016ed4 	.word	0x00016ed4
   16d34:	00017920 	.word	0x00017920
   16d38:	00016ed4 	.word	0x00016ed4
   16d3c:	00016ed4 	.word	0x00016ed4
   16d40:	00016ed4 	.word	0x00016ed4
   16d44:	00016ed4 	.word	0x00016ed4
   16d48:	00016ed4 	.word	0x00016ed4
   16d4c:	00016ed4 	.word	0x00016ed4
   16d50:	00016ed4 	.word	0x00016ed4
   16d54:	00016ed4 	.word	0x00016ed4
   16d58:	00016ed4 	.word	0x00016ed4
   16d5c:	00016ed4 	.word	0x00016ed4
   16d60:	000170a8 	.word	0x000170a8
   16d64:	00017014 	.word	0x00017014
   16d68:	00016ed4 	.word	0x00016ed4
   16d6c:	00016ed4 	.word	0x00016ed4
   16d70:	00016ed4 	.word	0x00016ed4
   16d74:	000172d8 	.word	0x000172d8
   16d78:	00017014 	.word	0x00017014
   16d7c:	00016e2c 	.word	0x00016e2c
   16d80:	00016ed4 	.word	0x00016ed4
   16d84:	000173e8 	.word	0x000173e8
   16d88:	00016ed4 	.word	0x00016ed4
   16d8c:	00017394 	.word	0x00017394
   16d90:	000173bc 	.word	0x000173bc
   16d94:	0001731c 	.word	0x0001731c
   16d98:	00016e2c 	.word	0x00016e2c
   16d9c:	00016ed4 	.word	0x00016ed4
   16da0:	00017044 	.word	0x00017044
   16da4:	00016e24 	.word	0x00016e24
   16da8:	000172f4 	.word	0x000172f4
   16dac:	00016ed4 	.word	0x00016ed4
   16db0:	00016ed4 	.word	0x00016ed4
   16db4:	0001797c 	.word	0x0001797c
   16db8:	00016ed4 	.word	0x00016ed4
   16dbc:	00016e24 	.word	0x00016e24
   16dc0:	e2432030 	sub	r2, r3, #48	@ 0x30
   16dc4:	e3a07000 	mov	r7, #0
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
   16dc8:	e4d93001 	ldrb	r3, [r9], #1
				n = 10 * n + to_digit (ch);
   16dcc:	e0877107 	add	r7, r7, r7, lsl #2
   16dd0:	e0827087 	add	r7, r2, r7, lsl #1
			} while (is_digit (ch));
   16dd4:	e2432030 	sub	r2, r3, #48	@ 0x30
   16dd8:	e3520009 	cmp	r2, #9
   16ddc:	9afffff9 	bls	16dc8 <_vfiprintf_r+0x2c4>
   16de0:	eaffff97 	b	16c44 <_vfiprintf_r+0x140>
			thousands_sep = _localeconv_r (data)->thousands_sep;
   16de4:	e59d5010 	ldr	r5, [sp, #16]
   16de8:	e1a00005 	mov	r0, r5
   16dec:	eb0010d7 	bl	1b150 <_localeconv_r>
   16df0:	e5903004 	ldr	r3, [r0, #4]
			thsnd_len = strlen (thousands_sep);
   16df4:	e1a00003 	mov	r0, r3
			thousands_sep = _localeconv_r (data)->thousands_sep;
   16df8:	e58d3024 	str	r3, [sp, #36]	@ 0x24
			thsnd_len = strlen (thousands_sep);
   16dfc:	fa00259f 	blx	20480 <strlen>
   16e00:	e1a04000 	mov	r4, r0
   16e04:	e58d0028 	str	r0, [sp, #40]	@ 0x28
			grouping = _localeconv_r (data)->grouping;
   16e08:	e1a00005 	mov	r0, r5
   16e0c:	eb0010cf 	bl	1b150 <_localeconv_r>
   16e10:	e5903008 	ldr	r3, [r0, #8]
			if (thsnd_len > 0 && grouping && *grouping)
   16e14:	e3540000 	cmp	r4, #0
   16e18:	13530000 	cmpne	r3, #0
			grouping = _localeconv_r (data)->grouping;
   16e1c:	e58d3020 	str	r3, [sp, #32]
			if (thsnd_len > 0 && grouping && *grouping)
   16e20:	1a0002b8 	bne	17908 <_vfiprintf_r+0xe04>
			if ((ch = *fmt++) == '*') {
   16e24:	e5d93000 	ldrb	r3, [r9]
   16e28:	eaffff84 	b	16c40 <_vfiprintf_r+0x13c>
   16e2c:	e5d93000 	ldrb	r3, [r9]
#ifdef _WANT_IO_C99_FORMATS
		case 'j':
		  if (sizeof (intmax_t) == sizeof (long))
		    flags |= LONGINT;
		  else
		    flags |= QUADINT;
   16e30:	e38aa010 	orr	sl, sl, #16
		  goto rflag;
   16e34:	eaffff81 	b	16c40 <_vfiprintf_r+0x13c>
	if (cantwrite (data, fp)) {
   16e38:	e59d5004 	ldr	r5, [sp, #4]
   16e3c:	e59d0010 	ldr	r0, [sp, #16]
   16e40:	e1a01005 	mov	r1, r5
   16e44:	eb000ab0 	bl	1990c <__swsetup_r>
   16e48:	e3500000 	cmp	r0, #0
   16e4c:	1a00032e 	bne	17b0c <_vfiprintf_r+0x1008>
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   16e50:	e1d520fc 	ldrsh	r2, [r5, #12]
   16e54:	e202201a 	and	r2, r2, #26
   16e58:	e352000a 	cmp	r2, #10
   16e5c:	1affff48 	bne	16b84 <_vfiprintf_r+0x80>
   16e60:	e59d3004 	ldr	r3, [sp, #4]
   16e64:	e1d330fe 	ldrsh	r3, [r3, #14]
   16e68:	e3530000 	cmp	r3, #0
   16e6c:	baffff44 	blt	16b84 <_vfiprintf_r+0x80>
		return (__sbprintf (data, fp, fmt0, ap));
   16e70:	e59d1004 	ldr	r1, [sp, #4]
   16e74:	e1a03004 	mov	r3, r4
   16e78:	e59d0010 	ldr	r0, [sp, #16]
   16e7c:	e1a02009 	mov	r2, r9
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
#endif
	return (__sferror (fp) ? EOF : ret);
	/* NOTREACHED */
}
   16e80:	e28dd0ec 	add	sp, sp, #236	@ 0xec
   16e84:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
		return (__sbprintf (data, fp, fmt0, ap));
   16e88:	ea000334 	b	17b60 <__sbprintf>
			PRINT (cp, m);
   16e8c:	e59d1004 	ldr	r1, [sp, #4]
   16e90:	e28d2038 	add	r2, sp, #56	@ 0x38
   16e94:	e59d0010 	ldr	r0, [sp, #16]
   16e98:	eb00035b 	bl	17c0c <__sprint_r>
   16e9c:	e3500000 	cmp	r0, #0
   16ea0:	1a000004 	bne	16eb8 <_vfiprintf_r+0x3b4>
   16ea4:	e28db044 	add	fp, sp, #68	@ 0x44
   16ea8:	eaffff57 	b	16c0c <_vfiprintf_r+0x108>
	FLUSH ();
   16eac:	e59d3040 	ldr	r3, [sp, #64]	@ 0x40
   16eb0:	e3530000 	cmp	r3, #0
   16eb4:	1a0002fc 	bne	17aac <_vfiprintf_r+0xfa8>
	return (__sferror (fp) ? EOF : ret);
   16eb8:	e59d3004 	ldr	r3, [sp, #4]
   16ebc:	e1d330bc 	ldrh	r3, [r3, #12]
   16ec0:	e3130040 	tst	r3, #64	@ 0x40
   16ec4:	1a000310 	bne	17b0c <_vfiprintf_r+0x1008>
}
   16ec8:	e59d0008 	ldr	r0, [sp, #8]
   16ecc:	e28dd0ec 	add	sp, sp, #236	@ 0xec
   16ed0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (ch == '\0')
   16ed4:	e3530000 	cmp	r3, #0
   16ed8:	0afffff3 	beq	16eac <_vfiprintf_r+0x3a8>
			*cp = ch;
   16edc:	e5cd3084 	strb	r3, [sp, #132]	@ 0x84
			cp = buf;
   16ee0:	e28d4084 	add	r4, sp, #132	@ 0x84
			sign = '\0';
   16ee4:	e3a03000 	mov	r3, #0
   16ee8:	e5cd3033 	strb	r3, [sp, #51]	@ 0x33
			break;
   16eec:	e3a03001 	mov	r3, #1
   16ef0:	e58d3000 	str	r3, [sp]
		if (flags & HEXPREFIX)
   16ef4:	e3a08000 	mov	r8, #0
   16ef8:	e58d800c 	str	r8, [sp, #12]
		if ((flags & (LADJUST|ZEROPAD)) == 0)
   16efc:	e21a2084 	ands	r2, sl, #132	@ 0x84
			PRINT (&sign, 1);
   16f00:	e59d1040 	ldr	r1, [sp, #64]	@ 0x40
		if ((flags & (LADJUST|ZEROPAD)) == 0)
   16f04:	e58d2018 	str	r2, [sp, #24]
			PRINT (&sign, 1);
   16f08:	e59d203c 	ldr	r2, [sp, #60]	@ 0x3c
		if ((flags & (LADJUST|ZEROPAD)) == 0)
   16f0c:	1a000003 	bne	16f20 <_vfiprintf_r+0x41c>
			PAD (width - realsz, blanks);
   16f10:	e59d0000 	ldr	r0, [sp]
   16f14:	e0475000 	sub	r5, r7, r0
   16f18:	e3550000 	cmp	r5, #0
   16f1c:	ca0001ca 	bgt	1764c <_vfiprintf_r+0xb48>
		if (sign)
   16f20:	e5dd0033 	ldrb	r0, [sp, #51]	@ 0x33
   16f24:	e3500000 	cmp	r0, #0
   16f28:	0a00000a 	beq	16f58 <_vfiprintf_r+0x454>
			PRINT (&sign, 1);
   16f2c:	e2822001 	add	r2, r2, #1
   16f30:	e28d0033 	add	r0, sp, #51	@ 0x33
   16f34:	e3520007 	cmp	r2, #7
   16f38:	e58b0000 	str	r0, [fp]
   16f3c:	e2811001 	add	r1, r1, #1
   16f40:	e3a00001 	mov	r0, #1
   16f44:	e58b0004 	str	r0, [fp, #4]
   16f48:	d28bb008 	addle	fp, fp, #8
   16f4c:	e58d1040 	str	r1, [sp, #64]	@ 0x40
   16f50:	e58d203c 	str	r2, [sp, #60]	@ 0x3c
   16f54:	ca000208 	bgt	1777c <_vfiprintf_r+0xc78>
		if (flags & HEXPREFIX)
   16f58:	e59d000c 	ldr	r0, [sp, #12]
   16f5c:	e3500000 	cmp	r0, #0
   16f60:	0a00000a 	beq	16f90 <_vfiprintf_r+0x48c>
			PRINT (ox, 2);
   16f64:	e2822001 	add	r2, r2, #1
   16f68:	e28d0034 	add	r0, sp, #52	@ 0x34
   16f6c:	e3520007 	cmp	r2, #7
   16f70:	e58b0000 	str	r0, [fp]
   16f74:	e2811002 	add	r1, r1, #2
   16f78:	e3a00002 	mov	r0, #2
   16f7c:	e58b0004 	str	r0, [fp, #4]
   16f80:	d28bb008 	addle	fp, fp, #8
   16f84:	e58d1040 	str	r1, [sp, #64]	@ 0x40
   16f88:	e58d203c 	str	r2, [sp, #60]	@ 0x3c
   16f8c:	ca0001ee 	bgt	1774c <_vfiprintf_r+0xc48>
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   16f90:	e59d0018 	ldr	r0, [sp, #24]
   16f94:	e3500080 	cmp	r0, #128	@ 0x80
   16f98:	0a000118 	beq	17400 <_vfiprintf_r+0x8fc>
		PAD (dprec - size, zeroes);
   16f9c:	e0485003 	sub	r5, r8, r3
   16fa0:	e3550000 	cmp	r5, #0
   16fa4:	ca00015d 	bgt	17520 <_vfiprintf_r+0xa1c>
		PRINT (cp, size);
   16fa8:	e2822001 	add	r2, r2, #1
   16fac:	e0831001 	add	r1, r3, r1
   16fb0:	e3520007 	cmp	r2, #7
   16fb4:	e58b4000 	str	r4, [fp]
   16fb8:	e58b3004 	str	r3, [fp, #4]
   16fbc:	d28bb008 	addle	fp, fp, #8
   16fc0:	e58d203c 	str	r2, [sp, #60]	@ 0x3c
   16fc4:	e58d1040 	str	r1, [sp, #64]	@ 0x40
   16fc8:	ca00018f 	bgt	1760c <_vfiprintf_r+0xb08>
		if (flags & LADJUST)
   16fcc:	e31a0004 	tst	sl, #4
   16fd0:	0a000003 	beq	16fe4 <_vfiprintf_r+0x4e0>
			PAD (width - realsz, blanks);
   16fd4:	e59d3000 	ldr	r3, [sp]
   16fd8:	e0474003 	sub	r4, r7, r3
   16fdc:	e3540000 	cmp	r4, #0
   16fe0:	ca0001f1 	bgt	177ac <_vfiprintf_r+0xca8>
		ret += width > realsz ? width : realsz;
   16fe4:	e59d3008 	ldr	r3, [sp, #8]
   16fe8:	e59d2000 	ldr	r2, [sp]
   16fec:	e1570002 	cmp	r7, r2
   16ff0:	a0833007 	addge	r3, r3, r7
   16ff4:	b0833002 	addlt	r3, r3, r2
		FLUSH ();	/* copy out the I/O vectors */
   16ff8:	e3510000 	cmp	r1, #0
		ret += width > realsz ? width : realsz;
   16ffc:	e58d3008 	str	r3, [sp, #8]
		FLUSH ();	/* copy out the I/O vectors */
   17000:	1a00018a 	bne	17630 <_vfiprintf_r+0xb2c>
   17004:	e3a03000 	mov	r3, #0
   17008:	e28db044 	add	fp, sp, #68	@ 0x44
   1700c:	e58d303c 	str	r3, [sp, #60]	@ 0x3c
                if (malloc_buf != NULL) {
   17010:	eafffee6 	b	16bb0 <_vfiprintf_r+0xac>
			width = GET_ARG (n, ap, int);
   17014:	e59d2014 	ldr	r2, [sp, #20]
			_uquad = SARG ();
   17018:	e31a0010 	tst	sl, #16
			width = GET_ARG (n, ap, int);
   1701c:	e4923004 	ldr	r3, [r2], #4
   17020:	e58d2014 	str	r2, [sp, #20]
			_uquad = SARG ();
   17024:	1a000059 	bne	17190 <_vfiprintf_r+0x68c>
   17028:	e31a0040 	tst	sl, #64	@ 0x40
   1702c:	1a000226 	bne	178cc <_vfiprintf_r+0xdc8>
   17030:	e31a0c02 	tst	sl, #512	@ 0x200
   17034:	0a000055 	beq	17190 <_vfiprintf_r+0x68c>
   17038:	e6af3073 	sxtb	r3, r3
			if ((long) _uquad < 0)
   1703c:	e1a05003 	mov	r5, r3
   17040:	ea000053 	b	17194 <_vfiprintf_r+0x690>
			cp = GET_ARG (N, ap, char_ptr_t);
   17044:	e59d5014 	ldr	r5, [sp, #20]
			sign = '\0';
   17048:	e3a01000 	mov	r1, #0
   1704c:	e5cd1033 	strb	r1, [sp, #51]	@ 0x33
			cp = GET_ARG (N, ap, char_ptr_t);
   17050:	e4954004 	ldr	r4, [r5], #4
			if (cp == NULL) {
   17054:	e1540001 	cmp	r4, r1
   17058:	0a000284 	beq	17a70 <_vfiprintf_r+0xf6c>
			if (prec >= 0) {
   1705c:	e3580000 	cmp	r8, #0
   17060:	ba000249 	blt	1798c <_vfiprintf_r+0xe88>
				char *p = memchr (cp, 0, prec);
   17064:	e1a02008 	mov	r2, r8
   17068:	e1a00004 	mov	r0, r4
   1706c:	fa002353 	blx	1fdc0 <memchr>
				if (p != NULL)
   17070:	e3500000 	cmp	r0, #0
					size = p - cp;
   17074:	10403004 	subne	r3, r0, r4
				if (p != NULL)
   17078:	0a0002a1 	beq	17b04 <_vfiprintf_r+0x1000>
		if (sign)
   1707c:	e5dd2033 	ldrb	r2, [sp, #51]	@ 0x33
		realsz = dprec > size ? dprec : size;
   17080:	e1c31fc3 	bic	r1, r3, r3, asr #31
   17084:	e58d1000 	str	r1, [sp]
		if (sign)
   17088:	e3520000 	cmp	r2, #0
   1708c:	13a08000 	movne	r8, #0
   17090:	158d5014 	strne	r5, [sp, #20]
   17094:	1a00004e 	bne	171d4 <_vfiprintf_r+0x6d0>
   17098:	e1a08002 	mov	r8, r2
   1709c:	e58d5014 	str	r5, [sp, #20]
		if (flags & HEXPREFIX)
   170a0:	e58d200c 	str	r2, [sp, #12]
   170a4:	eaffff94 	b	16efc <_vfiprintf_r+0x3f8>
				*cp = GET_ARG (N, ap, int);
   170a8:	e59d3014 	ldr	r3, [sp, #20]
			sign = '\0';
   170ac:	e3a02000 	mov	r2, #0
   170b0:	e5cd2033 	strb	r2, [sp, #51]	@ 0x33
			cp = buf;
   170b4:	e28d4084 	add	r4, sp, #132	@ 0x84
				*cp = GET_ARG (N, ap, int);
   170b8:	e4932004 	ldr	r2, [r3], #4
   170bc:	e58d3014 	str	r3, [sp, #20]
			break;
   170c0:	e3a03001 	mov	r3, #1
				*cp = GET_ARG (N, ap, int);
   170c4:	e5cd2084 	strb	r2, [sp, #132]	@ 0x84
			break;
   170c8:	e58d3000 	str	r3, [sp]
   170cc:	eaffff88 	b	16ef4 <_vfiprintf_r+0x3f0>
			width = GET_ARG (n, ap, int);
   170d0:	e59d3014 	ldr	r3, [sp, #20]
   170d4:	e4937004 	ldr	r7, [r3], #4
			if (width >= 0)
   170d8:	e3570000 	cmp	r7, #0
   170dc:	aa0001f7 	bge	178c0 <_vfiprintf_r+0xdbc>
			width = -width;
   170e0:	e2677000 	rsb	r7, r7, #0
			width = GET_ARG (n, ap, int);
   170e4:	e58d3014 	str	r3, [sp, #20]
			if ((ch = *fmt++) == '*') {
   170e8:	e5d93000 	ldrb	r3, [r9]
			flags |= LADJUST;
   170ec:	e38aa004 	orr	sl, sl, #4
			goto rflag;
   170f0:	eafffed2 	b	16c40 <_vfiprintf_r+0x13c>
			sign = '+';
   170f4:	e3a0302b 	mov	r3, #43	@ 0x2b
   170f8:	e5cd3033 	strb	r3, [sp, #51]	@ 0x33
			if ((ch = *fmt++) == '*') {
   170fc:	e5d93000 	ldrb	r3, [r9]
			goto rflag;
   17100:	eafffece 	b	16c40 <_vfiprintf_r+0x13c>
			if ((ch = *fmt++) == '*') {
   17104:	e5d93000 	ldrb	r3, [r9]
			flags |= ZEROPAD;
   17108:	e38aa080 	orr	sl, sl, #128	@ 0x80
			goto rflag;
   1710c:	eafffecb 	b	16c40 <_vfiprintf_r+0x13c>
			if ((ch = *fmt++) == '*') {
   17110:	e1a01009 	mov	r1, r9
   17114:	e4d13001 	ldrb	r3, [r1], #1
   17118:	e353002a 	cmp	r3, #42	@ 0x2a
   1711c:	0a00027d 	beq	17b18 <_vfiprintf_r+0x1014>
			while (is_digit (ch)) {
   17120:	e2432030 	sub	r2, r3, #48	@ 0x30
   17124:	e3520009 	cmp	r2, #9
			if ((ch = *fmt++) == '*') {
   17128:	81a09001 	movhi	r9, r1
			while (is_digit (ch)) {
   1712c:	83a08000 	movhi	r8, #0
   17130:	8afffec3 	bhi	16c44 <_vfiprintf_r+0x140>
			n = 0;
   17134:	e3a08000 	mov	r8, #0
				ch = *fmt++;
   17138:	e4d13001 	ldrb	r3, [r1], #1
				n = 10 * n + to_digit (ch);
   1713c:	e0888108 	add	r8, r8, r8, lsl #2
   17140:	e0828088 	add	r8, r2, r8, lsl #1
			while (is_digit (ch)) {
   17144:	e2432030 	sub	r2, r3, #48	@ 0x30
   17148:	e3520009 	cmp	r2, #9
   1714c:	9afffff9 	bls	17138 <_vfiprintf_r+0x634>
			prec = n < 0 ? -1 : n;
   17150:	e1888fc8 	orr	r8, r8, r8, asr #31
   17154:	e1a09001 	mov	r9, r1
			goto reswitch;
   17158:	eafffeb9 	b	16c44 <_vfiprintf_r+0x140>
			if ((ch = *fmt++) == '*') {
   1715c:	e5d93000 	ldrb	r3, [r9]
			flags |= ALT;
   17160:	e38aa001 	orr	sl, sl, #1
			goto rflag;
   17164:	eafffeb5 	b	16c40 <_vfiprintf_r+0x13c>
			if (!sign)
   17168:	e5dd3033 	ldrb	r3, [sp, #51]	@ 0x33
   1716c:	e3530000 	cmp	r3, #0
			if ((ch = *fmt++) == '*') {
   17170:	e5d93000 	ldrb	r3, [r9]
				sign = ' ';
   17174:	03a02020 	moveq	r2, #32
   17178:	05cd2033 	strbeq	r2, [sp, #51]	@ 0x33
   1717c:	eafffeaf 	b	16c40 <_vfiprintf_r+0x13c>
			width = GET_ARG (n, ap, int);
   17180:	e59d2014 	ldr	r2, [sp, #20]
			flags |= LONGINT;
   17184:	e38aa010 	orr	sl, sl, #16
			width = GET_ARG (n, ap, int);
   17188:	e4923004 	ldr	r3, [r2], #4
   1718c:	e58d2014 	str	r2, [sp, #20]
   17190:	e1a05003 	mov	r5, r3
			if ((long) _uquad < 0)
   17194:	e3530000 	cmp	r3, #0
   17198:	ba0001b9 	blt	17884 <_vfiprintf_r+0xd80>
number:			if ((dprec = prec) >= 0)
   1719c:	e3580000 	cmp	r8, #0
   171a0:	ba0001bc 	blt	17898 <_vfiprintf_r+0xd94>
			if (_uquad != 0 || prec != 0) {
   171a4:	e1983003 	orrs	r3, r8, r3
				flags &= ~ZEROPAD;
   171a8:	e3caa080 	bic	sl, sl, #128	@ 0x80
			if (_uquad != 0 || prec != 0) {
   171ac:	1a0001b9 	bne	17898 <_vfiprintf_r+0xd94>
			if (!sign)
   171b0:	e5dd2033 	ldrb	r2, [sp, #51]	@ 0x33
   171b4:	e1a08003 	mov	r8, r3
			cp = buf + BUF;
   171b8:	e28d40e8 	add	r4, sp, #232	@ 0xe8
		realsz = dprec > size ? dprec : size;
   171bc:	e1580003 	cmp	r8, r3
   171c0:	a1a01008 	movge	r1, r8
   171c4:	b1a01003 	movlt	r1, r3
		if (sign)
   171c8:	e3520000 	cmp	r2, #0
		realsz = dprec > size ? dprec : size;
   171cc:	e58d1000 	str	r1, [sp]
		if (sign)
   171d0:	0a000002 	beq	171e0 <_vfiprintf_r+0x6dc>
			realsz++;
   171d4:	e59d2000 	ldr	r2, [sp]
   171d8:	e2822001 	add	r2, r2, #1
   171dc:	e58d2000 	str	r2, [sp]
		if (flags & HEXPREFIX)
   171e0:	e21a2002 	ands	r2, sl, #2
   171e4:	e58d200c 	str	r2, [sp, #12]
			realsz+= 2;
   171e8:	159d2000 	ldrne	r2, [sp]
   171ec:	12822002 	addne	r2, r2, #2
   171f0:	158d2000 	strne	r2, [sp]
   171f4:	13a02002 	movne	r2, #2
   171f8:	158d200c 	strne	r2, [sp, #12]
   171fc:	eaffff3e 	b	16efc <_vfiprintf_r+0x3f8>
			width = GET_ARG (n, ap, int);
   17200:	e59d3014 	ldr	r3, [sp, #20]
			flags |= LONGINT;
   17204:	e38aa010 	orr	sl, sl, #16
			width = GET_ARG (n, ap, int);
   17208:	e4935004 	ldr	r5, [r3], #4
   1720c:	e58d3014 	str	r3, [sp, #20]
number:			if ((dprec = prec) >= 0)
   17210:	e3580000 	cmp	r8, #0
nosign:			sign = '\0';
   17214:	e3a03000 	mov	r3, #0
			flags &= ~GROUPING;
   17218:	e3ca2b01 	bic	r2, sl, #1024	@ 0x400
nosign:			sign = '\0';
   1721c:	e5cd3033 	strb	r3, [sp, #51]	@ 0x33
number:			if ((dprec = prec) >= 0)
   17220:	aa0001a4 	bge	178b8 <_vfiprintf_r+0xdb4>
   17224:	e28d40e8 	add	r4, sp, #232	@ 0xe8
						*--cp = to_char (_uquad & 7);
   17228:	e2053007 	and	r3, r5, #7
					} while (_uquad);
   1722c:	e1b051a5 	lsrs	r5, r5, #3
						*--cp = to_char (_uquad & 7);
   17230:	e2833030 	add	r3, r3, #48	@ 0x30
   17234:	e1a01004 	mov	r1, r4
   17238:	e5643001 	strb	r3, [r4, #-1]!
					} while (_uquad);
   1723c:	1afffff9 	bne	17228 <_vfiprintf_r+0x724>
					if (flags & ALT && *cp != '0')
   17240:	e3530030 	cmp	r3, #48	@ 0x30
   17244:	03a00000 	moveq	r0, #0
   17248:	12020001 	andne	r0, r2, #1
   1724c:	e3500000 	cmp	r0, #0
   17250:	1a0001d1 	bne	1799c <_vfiprintf_r+0xe98>
			size = buf + BUF - cp;
   17254:	e28d30e8 	add	r3, sp, #232	@ 0xe8
   17258:	e1a0a002 	mov	sl, r2
   1725c:	e0433004 	sub	r3, r3, r4
		realsz = dprec > size ? dprec : size;
   17260:	e1530008 	cmp	r3, r8
   17264:	a1a02003 	movge	r2, r3
   17268:	b1a02008 	movlt	r2, r8
   1726c:	e58d2000 	str	r2, [sp]
		if (sign)
   17270:	eaffffda 	b	171e0 <_vfiprintf_r+0x6dc>
			width = GET_ARG (n, ap, int);
   17274:	e59d3014 	ldr	r3, [sp, #20]
			flags |= LONGINT;
   17278:	e38a2010 	orr	r2, sl, #16
			width = GET_ARG (n, ap, int);
   1727c:	e4935004 	ldr	r5, [r3], #4
   17280:	e58d3014 	str	r3, [sp, #20]
number:			if ((dprec = prec) >= 0)
   17284:	e3580000 	cmp	r8, #0
nosign:			sign = '\0';
   17288:	e3a03000 	mov	r3, #0
number:			if ((dprec = prec) >= 0)
   1728c:	b1a0a002 	movlt	sl, r2
nosign:			sign = '\0';
   17290:	e5cd3033 	strb	r3, [sp, #51]	@ 0x33
number:			if ((dprec = prec) >= 0)
   17294:	ba00017f 	blt	17898 <_vfiprintf_r+0xd94>
   17298:	e3a00001 	mov	r0, #1
			if (_uquad != 0 || prec != 0) {
   1729c:	e1981005 	orrs	r1, r8, r5
				flags &= ~ZEROPAD;
   172a0:	e3c2a080 	bic	sl, r2, #128	@ 0x80
			if (_uquad != 0 || prec != 0) {
   172a4:	1a00002d 	bne	17360 <_vfiprintf_r+0x85c>
                       else if (base == OCT && (flags & ALT))
   172a8:	e3500000 	cmp	r0, #0
   172ac:	1a00016f 	bne	17870 <_vfiprintf_r+0xd6c>
   172b0:	e2123001 	ands	r3, r2, #1
                         *--cp = '0';
   172b4:	e1a08000 	mov	r8, r0
                       else if (base == OCT && (flags & ALT))
   172b8:	e58d3000 	str	r3, [sp]
			cp = buf + BUF;
   172bc:	028d40e8 	addeq	r4, sp, #232	@ 0xe8
   172c0:	01a03000 	moveq	r3, r0
                       else if (base == OCT && (flags & ALT))
   172c4:	0affffc5 	beq	171e0 <_vfiprintf_r+0x6dc>
                         *--cp = '0';
   172c8:	e3a02030 	mov	r2, #48	@ 0x30
						*--cp = to_char(_uquad);
   172cc:	e28d40e7 	add	r4, sp, #231	@ 0xe7
                         *--cp = '0';
   172d0:	e5cd20e7 	strb	r2, [sp, #231]	@ 0xe7
   172d4:	eaffffe1 	b	17260 <_vfiprintf_r+0x75c>
			if (*fmt == 'h') {
   172d8:	e5d93000 	ldrb	r3, [r9]
   172dc:	e3530068 	cmp	r3, #104	@ 0x68
rflag:		ch = *fmt++;
   172e0:	05d93001 	ldrbeq	r3, [r9, #1]
				flags |= CHARINT;
   172e4:	038aac02 	orreq	sl, sl, #512	@ 0x200
				fmt++;
   172e8:	02899001 	addeq	r9, r9, #1
				flags |= SHORTINT;
   172ec:	138aa040 	orrne	sl, sl, #64	@ 0x40
   172f0:	eafffe52 	b	16c40 <_vfiprintf_r+0x13c>
			width = GET_ARG (n, ap, int);
   172f4:	e59d3014 	ldr	r3, [sp, #20]
			_uquad = UARG ();
   172f8:	e31a0010 	tst	sl, #16
			width = GET_ARG (n, ap, int);
   172fc:	e4935004 	ldr	r5, [r3], #4
   17300:	e58d3014 	str	r3, [sp, #20]
			_uquad = UARG ();
   17304:	1a000002 	bne	17314 <_vfiprintf_r+0x810>
   17308:	e31a0040 	tst	sl, #64	@ 0x40
   1730c:	0a000178 	beq	178f4 <_vfiprintf_r+0xdf0>
   17310:	e6ff5075 	uxth	r5, r5
   17314:	e1a0200a 	mov	r2, sl
   17318:	eaffffd9 	b	17284 <_vfiprintf_r+0x780>
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   1731c:	e59d3014 	ldr	r3, [sp, #20]
			flags |= HEXPREFIX;
   17320:	e38a2002 	orr	r2, sl, #2
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   17324:	e4935004 	ldr	r5, [r3], #4
   17328:	e58d3014 	str	r3, [sp, #20]
			ox[0] = '0';
   1732c:	e3073830 	movw	r3, #30768	@ 0x7830
   17330:	e1cd33b4 	strh	r3, [sp, #52]	@ 0x34
			xdigs = "0123456789abcdef";
   17334:	e30931b8 	movw	r3, #37304	@ 0x91b8
   17338:	e3403002 	movt	r3, #2
   1733c:	e58d301c 	str	r3, [sp, #28]
number:			if ((dprec = prec) >= 0)
   17340:	e3580000 	cmp	r8, #0
nosign:			sign = '\0';
   17344:	e3a03000 	mov	r3, #0
   17348:	e5cd3033 	strb	r3, [sp, #51]	@ 0x33
number:			if ((dprec = prec) >= 0)
   1734c:	ba000008 	blt	17374 <_vfiprintf_r+0x870>
			if (_uquad != 0 || prec != 0) {
   17350:	e1981005 	orrs	r1, r8, r5
number:			if ((dprec = prec) >= 0)
   17354:	e3a00002 	mov	r0, #2
				flags &= ~ZEROPAD;
   17358:	e3c2a080 	bic	sl, r2, #128	@ 0x80
			if (_uquad != 0 || prec != 0) {
   1735c:	0affffd1 	beq	172a8 <_vfiprintf_r+0x7a4>
				switch (base) {
   17360:	e3500001 	cmp	r0, #1
   17364:	0a00014b 	beq	17898 <_vfiprintf_r+0xd94>
   17368:	e3500002 	cmp	r0, #2
   1736c:	e1a0200a 	mov	r2, sl
   17370:	1affffab 	bne	17224 <_vfiprintf_r+0x720>
   17374:	e59d101c 	ldr	r1, [sp, #28]
   17378:	e28d40e8 	add	r4, sp, #232	@ 0xe8
						*--cp = xdigs[_uquad & 15];
   1737c:	e205300f 	and	r3, r5, #15
					} while (_uquad);
   17380:	e1b05225 	lsrs	r5, r5, #4
						*--cp = xdigs[_uquad & 15];
   17384:	e7d13003 	ldrb	r3, [r1, r3]
   17388:	e5643001 	strb	r3, [r4, #-1]!
					} while (_uquad);
   1738c:	1afffffa 	bne	1737c <_vfiprintf_r+0x878>
   17390:	eaffffaf 	b	17254 <_vfiprintf_r+0x750>
			if (flags & LONGINT)
   17394:	e31a0010 	tst	sl, #16
   17398:	0a00014e 	beq	178d8 <_vfiprintf_r+0xdd4>
				*GET_ARG (N, ap, int_ptr_t) = ret;
   1739c:	e59d3014 	ldr	r3, [sp, #20]
   173a0:	e59d2008 	ldr	r2, [sp, #8]
   173a4:	e5933000 	ldr	r3, [r3]
   173a8:	e5832000 	str	r2, [r3]
			width = GET_ARG (n, ap, int);
   173ac:	e59d3014 	ldr	r3, [sp, #20]
   173b0:	e2833004 	add	r3, r3, #4
   173b4:	e58d3014 	str	r3, [sp, #20]
   173b8:	eafffdfc 	b	16bb0 <_vfiprintf_r+0xac>
   173bc:	e59d3014 	ldr	r3, [sp, #20]
			_uquad = UARG ();
   173c0:	e31a0010 	tst	sl, #16
			width = GET_ARG (n, ap, int);
   173c4:	e4935004 	ldr	r5, [r3], #4
   173c8:	e58d3014 	str	r3, [sp, #20]
			_uquad = UARG ();
   173cc:	1affff8f 	bne	17210 <_vfiprintf_r+0x70c>
   173d0:	e31a0040 	tst	sl, #64	@ 0x40
   173d4:	16ff5075 	uxthne	r5, r5
   173d8:	1affff8c 	bne	17210 <_vfiprintf_r+0x70c>
   173dc:	e31a0c02 	tst	sl, #512	@ 0x200
   173e0:	16ef5075 	uxtbne	r5, r5
   173e4:	eaffff89 	b	17210 <_vfiprintf_r+0x70c>
			if (*fmt == 'l') {
   173e8:	e5d93000 	ldrb	r3, [r9]
				flags |= QUADINT;
   173ec:	e38aa010 	orr	sl, sl, #16
			if (*fmt == 'l') {
   173f0:	e353006c 	cmp	r3, #108	@ 0x6c
rflag:		ch = *fmt++;
   173f4:	05d93001 	ldrbeq	r3, [r9, #1]
				fmt++;
   173f8:	02899001 	addeq	r9, r9, #1
   173fc:	eafffe0f 	b	16c40 <_vfiprintf_r+0x13c>
			PAD (width - realsz, zeroes);
   17400:	e59d0000 	ldr	r0, [sp]
   17404:	e0475000 	sub	r5, r7, r0
   17408:	e3550000 	cmp	r5, #0
   1740c:	dafffee2 	ble	16f9c <_vfiprintf_r+0x498>
   17410:	e3550010 	cmp	r5, #16
   17414:	e59f6718 	ldr	r6, [pc, #1816]	@ 17b34 <_vfiprintf_r+0x1030>
   17418:	da000029 	ble	174c4 <_vfiprintf_r+0x9c0>
   1741c:	e1a0000b 	mov	r0, fp
   17420:	e58d4018 	str	r4, [sp, #24]
   17424:	e1a0b009 	mov	fp, r9
   17428:	e59d4010 	ldr	r4, [sp, #16]
   1742c:	e1a09008 	mov	r9, r8
   17430:	e58d300c 	str	r3, [sp, #12]
   17434:	e1a08007 	mov	r8, r7
   17438:	e1a07006 	mov	r7, r6
   1743c:	e59d6004 	ldr	r6, [sp, #4]
   17440:	ea000002 	b	17450 <_vfiprintf_r+0x94c>
   17444:	e2455010 	sub	r5, r5, #16
   17448:	e3550010 	cmp	r5, #16
   1744c:	da000015 	ble	174a8 <_vfiprintf_r+0x9a4>
   17450:	e2822001 	add	r2, r2, #1
   17454:	e2811010 	add	r1, r1, #16
   17458:	e3520007 	cmp	r2, #7
   1745c:	e3a03010 	mov	r3, #16
   17460:	e5807000 	str	r7, [r0]
   17464:	e5803004 	str	r3, [r0, #4]
   17468:	d2800008 	addle	r0, r0, #8
   1746c:	e58d1040 	str	r1, [sp, #64]	@ 0x40
   17470:	e58d203c 	str	r2, [sp, #60]	@ 0x3c
   17474:	dafffff2 	ble	17444 <_vfiprintf_r+0x940>
   17478:	e28d2038 	add	r2, sp, #56	@ 0x38
   1747c:	e1a01006 	mov	r1, r6
   17480:	e1a00004 	mov	r0, r4
   17484:	eb0001e0 	bl	17c0c <__sprint_r>
   17488:	e3500000 	cmp	r0, #0
   1748c:	e28d0044 	add	r0, sp, #68	@ 0x44
   17490:	1afffe88 	bne	16eb8 <_vfiprintf_r+0x3b4>
   17494:	e2455010 	sub	r5, r5, #16
   17498:	e59d1040 	ldr	r1, [sp, #64]	@ 0x40
   1749c:	e3550010 	cmp	r5, #16
   174a0:	e59d203c 	ldr	r2, [sp, #60]	@ 0x3c
   174a4:	caffffe9 	bgt	17450 <_vfiprintf_r+0x94c>
   174a8:	e59d300c 	ldr	r3, [sp, #12]
   174ac:	e1a06007 	mov	r6, r7
   174b0:	e59d4018 	ldr	r4, [sp, #24]
   174b4:	e1a07008 	mov	r7, r8
   174b8:	e1a08009 	mov	r8, r9
   174bc:	e1a0900b 	mov	r9, fp
   174c0:	e1a0b000 	mov	fp, r0
   174c4:	e2822001 	add	r2, r2, #1
   174c8:	e0811005 	add	r1, r1, r5
   174cc:	e3520007 	cmp	r2, #7
   174d0:	e58b6000 	str	r6, [fp]
   174d4:	e58b5004 	str	r5, [fp, #4]
   174d8:	d28bb008 	addle	fp, fp, #8
   174dc:	e58d1040 	str	r1, [sp, #64]	@ 0x40
   174e0:	e58d203c 	str	r2, [sp, #60]	@ 0x3c
   174e4:	dafffeac 	ble	16f9c <_vfiprintf_r+0x498>
   174e8:	e59d1004 	ldr	r1, [sp, #4]
   174ec:	e28d2038 	add	r2, sp, #56	@ 0x38
   174f0:	e59d0010 	ldr	r0, [sp, #16]
   174f4:	e58d300c 	str	r3, [sp, #12]
   174f8:	eb0001c3 	bl	17c0c <__sprint_r>
   174fc:	e3500000 	cmp	r0, #0
   17500:	1afffe6c 	bne	16eb8 <_vfiprintf_r+0x3b4>
   17504:	e59d300c 	ldr	r3, [sp, #12]
   17508:	e28db044 	add	fp, sp, #68	@ 0x44
		PAD (dprec - size, zeroes);
   1750c:	e59d1040 	ldr	r1, [sp, #64]	@ 0x40
   17510:	e59d203c 	ldr	r2, [sp, #60]	@ 0x3c
   17514:	e0485003 	sub	r5, r8, r3
   17518:	e3550000 	cmp	r5, #0
   1751c:	dafffea1 	ble	16fa8 <_vfiprintf_r+0x4a4>
   17520:	e3550010 	cmp	r5, #16
   17524:	e59f6608 	ldr	r6, [pc, #1544]	@ 17b34 <_vfiprintf_r+0x1030>
   17528:	da000022 	ble	175b8 <_vfiprintf_r+0xab4>
   1752c:	e1a0000b 	mov	r0, fp
   17530:	e3a08010 	mov	r8, #16
   17534:	e1a0b006 	mov	fp, r6
   17538:	e58d300c 	str	r3, [sp, #12]
   1753c:	e1a06004 	mov	r6, r4
   17540:	e59d4010 	ldr	r4, [sp, #16]
   17544:	ea000002 	b	17554 <_vfiprintf_r+0xa50>
   17548:	e2455010 	sub	r5, r5, #16
   1754c:	e3550010 	cmp	r5, #16
   17550:	da000014 	ble	175a8 <_vfiprintf_r+0xaa4>
   17554:	e2822001 	add	r2, r2, #1
   17558:	e59f35d4 	ldr	r3, [pc, #1492]	@ 17b34 <_vfiprintf_r+0x1030>
   1755c:	e3520007 	cmp	r2, #7
   17560:	e2811010 	add	r1, r1, #16
   17564:	e58d1040 	str	r1, [sp, #64]	@ 0x40
   17568:	e8800108 	stm	r0, {r3, r8}
   1756c:	d2800008 	addle	r0, r0, #8
   17570:	e58d203c 	str	r2, [sp, #60]	@ 0x3c
   17574:	dafffff3 	ble	17548 <_vfiprintf_r+0xa44>
   17578:	e59d1004 	ldr	r1, [sp, #4]
   1757c:	e28d2038 	add	r2, sp, #56	@ 0x38
   17580:	e1a00004 	mov	r0, r4
   17584:	eb0001a0 	bl	17c0c <__sprint_r>
   17588:	e3500000 	cmp	r0, #0
   1758c:	e28d0044 	add	r0, sp, #68	@ 0x44
   17590:	1afffe48 	bne	16eb8 <_vfiprintf_r+0x3b4>
   17594:	e2455010 	sub	r5, r5, #16
   17598:	e59d1040 	ldr	r1, [sp, #64]	@ 0x40
   1759c:	e3550010 	cmp	r5, #16
   175a0:	e59d203c 	ldr	r2, [sp, #60]	@ 0x3c
   175a4:	caffffea 	bgt	17554 <_vfiprintf_r+0xa50>
   175a8:	e59d300c 	ldr	r3, [sp, #12]
   175ac:	e1a04006 	mov	r4, r6
   175b0:	e1a0600b 	mov	r6, fp
   175b4:	e1a0b000 	mov	fp, r0
   175b8:	e2822001 	add	r2, r2, #1
   175bc:	e0811005 	add	r1, r1, r5
   175c0:	e3520007 	cmp	r2, #7
   175c4:	e58b6000 	str	r6, [fp]
   175c8:	e58b5004 	str	r5, [fp, #4]
   175cc:	d28bb008 	addle	fp, fp, #8
   175d0:	e58d1040 	str	r1, [sp, #64]	@ 0x40
   175d4:	e58d203c 	str	r2, [sp, #60]	@ 0x3c
   175d8:	dafffe72 	ble	16fa8 <_vfiprintf_r+0x4a4>
   175dc:	e59d1004 	ldr	r1, [sp, #4]
   175e0:	e28d2038 	add	r2, sp, #56	@ 0x38
   175e4:	e59d0010 	ldr	r0, [sp, #16]
   175e8:	e58d300c 	str	r3, [sp, #12]
   175ec:	eb000186 	bl	17c0c <__sprint_r>
   175f0:	e3500000 	cmp	r0, #0
   175f4:	1afffe2f 	bne	16eb8 <_vfiprintf_r+0x3b4>
		PRINT (cp, size);
   175f8:	e59d1040 	ldr	r1, [sp, #64]	@ 0x40
		PAD (dprec - size, zeroes);
   175fc:	e28db044 	add	fp, sp, #68	@ 0x44
		PRINT (cp, size);
   17600:	e59d203c 	ldr	r2, [sp, #60]	@ 0x3c
		PAD (dprec - size, zeroes);
   17604:	e59d300c 	ldr	r3, [sp, #12]
   17608:	eafffe66 	b	16fa8 <_vfiprintf_r+0x4a4>
		PRINT (cp, size);
   1760c:	e59d1004 	ldr	r1, [sp, #4]
   17610:	e28d2038 	add	r2, sp, #56	@ 0x38
   17614:	e59d0010 	ldr	r0, [sp, #16]
   17618:	eb00017b 	bl	17c0c <__sprint_r>
   1761c:	e3500000 	cmp	r0, #0
   17620:	1afffe24 	bne	16eb8 <_vfiprintf_r+0x3b4>
			PAD (width - realsz, blanks);
   17624:	e59d1040 	ldr	r1, [sp, #64]	@ 0x40
		PRINT (cp, size);
   17628:	e28db044 	add	fp, sp, #68	@ 0x44
   1762c:	eafffe66 	b	16fcc <_vfiprintf_r+0x4c8>
		FLUSH ();	/* copy out the I/O vectors */
   17630:	e59d1004 	ldr	r1, [sp, #4]
   17634:	e28d2038 	add	r2, sp, #56	@ 0x38
   17638:	e59d0010 	ldr	r0, [sp, #16]
   1763c:	eb000172 	bl	17c0c <__sprint_r>
   17640:	e3500000 	cmp	r0, #0
   17644:	0afffe6e 	beq	17004 <_vfiprintf_r+0x500>
   17648:	eafffe1a 	b	16eb8 <_vfiprintf_r+0x3b4>
			PAD (width - realsz, blanks);
   1764c:	e3550010 	cmp	r5, #16
   17650:	e3096f54 	movw	r6, #40788	@ 0x9f54
   17654:	e3406002 	movt	r6, #2
   17658:	da000026 	ble	176f8 <_vfiprintf_r+0xbf4>
   1765c:	e1a0000b 	mov	r0, fp
   17660:	e58d302c 	str	r3, [sp, #44]	@ 0x2c
   17664:	e1a0b009 	mov	fp, r9
   17668:	e1a09008 	mov	r9, r8
   1766c:	e1a08007 	mov	r8, r7
   17670:	e1a07004 	mov	r7, r4
   17674:	e59d4010 	ldr	r4, [sp, #16]
   17678:	ea000002 	b	17688 <_vfiprintf_r+0xb84>
   1767c:	e2455010 	sub	r5, r5, #16
   17680:	e3550010 	cmp	r5, #16
   17684:	da000015 	ble	176e0 <_vfiprintf_r+0xbdc>
   17688:	e2822001 	add	r2, r2, #1
   1768c:	e2811010 	add	r1, r1, #16
   17690:	e3520007 	cmp	r2, #7
   17694:	e3a03010 	mov	r3, #16
   17698:	e5806000 	str	r6, [r0]
   1769c:	e5803004 	str	r3, [r0, #4]
   176a0:	d2800008 	addle	r0, r0, #8
   176a4:	e58d1040 	str	r1, [sp, #64]	@ 0x40
   176a8:	e58d203c 	str	r2, [sp, #60]	@ 0x3c
   176ac:	dafffff2 	ble	1767c <_vfiprintf_r+0xb78>
   176b0:	e59d1004 	ldr	r1, [sp, #4]
   176b4:	e28d2038 	add	r2, sp, #56	@ 0x38
   176b8:	e1a00004 	mov	r0, r4
   176bc:	eb000152 	bl	17c0c <__sprint_r>
   176c0:	e3500000 	cmp	r0, #0
   176c4:	e28d0044 	add	r0, sp, #68	@ 0x44
   176c8:	1afffdfa 	bne	16eb8 <_vfiprintf_r+0x3b4>
   176cc:	e2455010 	sub	r5, r5, #16
   176d0:	e59d1040 	ldr	r1, [sp, #64]	@ 0x40
   176d4:	e3550010 	cmp	r5, #16
   176d8:	e59d203c 	ldr	r2, [sp, #60]	@ 0x3c
   176dc:	caffffe9 	bgt	17688 <_vfiprintf_r+0xb84>
   176e0:	e59d302c 	ldr	r3, [sp, #44]	@ 0x2c
   176e4:	e1a04007 	mov	r4, r7
   176e8:	e1a07008 	mov	r7, r8
   176ec:	e1a08009 	mov	r8, r9
   176f0:	e1a0900b 	mov	r9, fp
   176f4:	e1a0b000 	mov	fp, r0
   176f8:	e2822001 	add	r2, r2, #1
   176fc:	e0811005 	add	r1, r1, r5
   17700:	e3520007 	cmp	r2, #7
   17704:	e58b6000 	str	r6, [fp]
   17708:	e58b5004 	str	r5, [fp, #4]
   1770c:	d28bb008 	addle	fp, fp, #8
   17710:	e58d1040 	str	r1, [sp, #64]	@ 0x40
   17714:	e58d203c 	str	r2, [sp, #60]	@ 0x3c
   17718:	dafffe00 	ble	16f20 <_vfiprintf_r+0x41c>
   1771c:	e59d1004 	ldr	r1, [sp, #4]
   17720:	e28d2038 	add	r2, sp, #56	@ 0x38
   17724:	e59d0010 	ldr	r0, [sp, #16]
   17728:	e58d302c 	str	r3, [sp, #44]	@ 0x2c
   1772c:	eb000136 	bl	17c0c <__sprint_r>
   17730:	e3500000 	cmp	r0, #0
   17734:	1afffddf 	bne	16eb8 <_vfiprintf_r+0x3b4>
			PRINT (&sign, 1);
   17738:	e59d1040 	ldr	r1, [sp, #64]	@ 0x40
			PAD (width - realsz, blanks);
   1773c:	e28db044 	add	fp, sp, #68	@ 0x44
			PRINT (&sign, 1);
   17740:	e59d203c 	ldr	r2, [sp, #60]	@ 0x3c
			PAD (width - realsz, blanks);
   17744:	e59d302c 	ldr	r3, [sp, #44]	@ 0x2c
   17748:	eafffdf4 	b	16f20 <_vfiprintf_r+0x41c>
			PRINT (ox, 2);
   1774c:	e59d1004 	ldr	r1, [sp, #4]
   17750:	e28d2038 	add	r2, sp, #56	@ 0x38
   17754:	e59d0010 	ldr	r0, [sp, #16]
   17758:	e58d300c 	str	r3, [sp, #12]
   1775c:	eb00012a 	bl	17c0c <__sprint_r>
   17760:	e3500000 	cmp	r0, #0
   17764:	1afffdd3 	bne	16eb8 <_vfiprintf_r+0x3b4>
		PAD (dprec - size, zeroes);
   17768:	e59d1040 	ldr	r1, [sp, #64]	@ 0x40
			PRINT (ox, 2);
   1776c:	e28db044 	add	fp, sp, #68	@ 0x44
		PAD (dprec - size, zeroes);
   17770:	e59d203c 	ldr	r2, [sp, #60]	@ 0x3c
			PRINT (ox, 2);
   17774:	e59d300c 	ldr	r3, [sp, #12]
   17778:	eafffe04 	b	16f90 <_vfiprintf_r+0x48c>
			PRINT (&sign, 1);
   1777c:	e59d1004 	ldr	r1, [sp, #4]
   17780:	e28d2038 	add	r2, sp, #56	@ 0x38
   17784:	e59d0010 	ldr	r0, [sp, #16]
   17788:	e58d302c 	str	r3, [sp, #44]	@ 0x2c
   1778c:	eb00011e 	bl	17c0c <__sprint_r>
   17790:	e3500000 	cmp	r0, #0
   17794:	1afffdc7 	bne	16eb8 <_vfiprintf_r+0x3b4>
			PRINT (ox, 2);
   17798:	e59d1040 	ldr	r1, [sp, #64]	@ 0x40
			PRINT (&sign, 1);
   1779c:	e28db044 	add	fp, sp, #68	@ 0x44
			PRINT (ox, 2);
   177a0:	e59d203c 	ldr	r2, [sp, #60]	@ 0x3c
			PRINT (&sign, 1);
   177a4:	e59d302c 	ldr	r3, [sp, #44]	@ 0x2c
   177a8:	eafffdea 	b	16f58 <_vfiprintf_r+0x454>
			PAD (width - realsz, blanks);
   177ac:	e3540010 	cmp	r4, #16
   177b0:	e3096f54 	movw	r6, #40788	@ 0x9f54
   177b4:	e59d303c 	ldr	r3, [sp, #60]	@ 0x3c
   177b8:	e3406002 	movt	r6, #2
   177bc:	da00001b 	ble	17830 <_vfiprintf_r+0xd2c>
   177c0:	e59d8010 	ldr	r8, [sp, #16]
   177c4:	e3a05010 	mov	r5, #16
   177c8:	e59da004 	ldr	sl, [sp, #4]
   177cc:	ea000002 	b	177dc <_vfiprintf_r+0xcd8>
   177d0:	e2444010 	sub	r4, r4, #16
   177d4:	e3540010 	cmp	r4, #16
   177d8:	da000014 	ble	17830 <_vfiprintf_r+0xd2c>
   177dc:	e2833001 	add	r3, r3, #1
   177e0:	e2811010 	add	r1, r1, #16
   177e4:	e3530007 	cmp	r3, #7
   177e8:	e58b6000 	str	r6, [fp]
   177ec:	e58b5004 	str	r5, [fp, #4]
   177f0:	d28bb008 	addle	fp, fp, #8
   177f4:	e58d1040 	str	r1, [sp, #64]	@ 0x40
   177f8:	e58d303c 	str	r3, [sp, #60]	@ 0x3c
   177fc:	dafffff3 	ble	177d0 <_vfiprintf_r+0xccc>
   17800:	e28d2038 	add	r2, sp, #56	@ 0x38
   17804:	e1a0100a 	mov	r1, sl
   17808:	e1a00008 	mov	r0, r8
   1780c:	e28db044 	add	fp, sp, #68	@ 0x44
   17810:	eb0000fd 	bl	17c0c <__sprint_r>
   17814:	e3500000 	cmp	r0, #0
   17818:	1afffda6 	bne	16eb8 <_vfiprintf_r+0x3b4>
   1781c:	e2444010 	sub	r4, r4, #16
   17820:	e59d1040 	ldr	r1, [sp, #64]	@ 0x40
   17824:	e3540010 	cmp	r4, #16
   17828:	e59d303c 	ldr	r3, [sp, #60]	@ 0x3c
   1782c:	caffffea 	bgt	177dc <_vfiprintf_r+0xcd8>
   17830:	e2833001 	add	r3, r3, #1
   17834:	e0811004 	add	r1, r1, r4
   17838:	e3530007 	cmp	r3, #7
   1783c:	e58b6000 	str	r6, [fp]
   17840:	e58b4004 	str	r4, [fp, #4]
   17844:	e58d303c 	str	r3, [sp, #60]	@ 0x3c
   17848:	e58d1040 	str	r1, [sp, #64]	@ 0x40
   1784c:	dafffde4 	ble	16fe4 <_vfiprintf_r+0x4e0>
   17850:	e59d1004 	ldr	r1, [sp, #4]
   17854:	e28d2038 	add	r2, sp, #56	@ 0x38
   17858:	e59d0010 	ldr	r0, [sp, #16]
   1785c:	eb0000ea 	bl	17c0c <__sprint_r>
   17860:	e3500000 	cmp	r0, #0
   17864:	1afffd93 	bne	16eb8 <_vfiprintf_r+0x3b4>
		FLUSH ();	/* copy out the I/O vectors */
   17868:	e59d1040 	ldr	r1, [sp, #64]	@ 0x40
   1786c:	eafffddc 	b	16fe4 <_vfiprintf_r+0x4e0>
   17870:	e1a08001 	mov	r8, r1
			cp = buf + BUF;
   17874:	e28d40e8 	add	r4, sp, #232	@ 0xe8
   17878:	e1a03001 	mov	r3, r1
		realsz = dprec > size ? dprec : size;
   1787c:	e58d1000 	str	r1, [sp]
   17880:	eafffe56 	b	171e0 <_vfiprintf_r+0x6dc>
number:			if ((dprec = prec) >= 0)
   17884:	e3580000 	cmp	r8, #0
				_uquad = -_uquad;
   17888:	e2635000 	rsb	r5, r3, #0
				flags &= ~ZEROPAD;
   1788c:	a3caa080 	bicge	sl, sl, #128	@ 0x80
				sign = '-';
   17890:	e3a0302d 	mov	r3, #45	@ 0x2d
   17894:	e5cd3033 	strb	r3, [sp, #51]	@ 0x33
					if (_uquad < 10) {
   17898:	e3550009 	cmp	r5, #9
   1789c:	8a000046 	bhi	179bc <_vfiprintf_r+0xeb8>
						*--cp = to_char(_uquad);
   178a0:	e2855030 	add	r5, r5, #48	@ 0x30
		if (sign)
   178a4:	e5dd2033 	ldrb	r2, [sp, #51]	@ 0x33
						break;
   178a8:	e3a03001 	mov	r3, #1
						*--cp = to_char(_uquad);
   178ac:	e28d40e7 	add	r4, sp, #231	@ 0xe7
   178b0:	e5cd50e7 	strb	r5, [sp, #231]	@ 0xe7
						break;
   178b4:	eafffe40 	b	171bc <_vfiprintf_r+0x6b8>
			base = OCT;
   178b8:	e1a00003 	mov	r0, r3
   178bc:	eafffe76 	b	1729c <_vfiprintf_r+0x798>
			width = GET_ARG (n, ap, int);
   178c0:	e58d3014 	str	r3, [sp, #20]
			if ((ch = *fmt++) == '*') {
   178c4:	e5d93000 	ldrb	r3, [r9]
   178c8:	eafffcdc 	b	16c40 <_vfiprintf_r+0x13c>
			_uquad = SARG ();
   178cc:	e6bf3073 	sxth	r3, r3
			if ((long) _uquad < 0)
   178d0:	e1a05003 	mov	r5, r3
   178d4:	eafffe2e 	b	17194 <_vfiprintf_r+0x690>
			else if (flags & SHORTINT)
   178d8:	e31a0040 	tst	sl, #64	@ 0x40
   178dc:	0a00006b 	beq	17a90 <_vfiprintf_r+0xf8c>
				*GET_ARG (N, ap, short_ptr_t) = ret;
   178e0:	e59d3014 	ldr	r3, [sp, #20]
   178e4:	e59d2008 	ldr	r2, [sp, #8]
   178e8:	e5933000 	ldr	r3, [r3]
   178ec:	e1c320b0 	strh	r2, [r3]
   178f0:	eafffead 	b	173ac <_vfiprintf_r+0x8a8>
			_uquad = UARG ();
   178f4:	e31a0c02 	tst	sl, #512	@ 0x200
   178f8:	16ef5075 	uxtbne	r5, r5
   178fc:	11a0200a 	movne	r2, sl
   17900:	1afffe5f 	bne	17284 <_vfiprintf_r+0x780>
   17904:	eafffe82 	b	17314 <_vfiprintf_r+0x810>
			if (thsnd_len > 0 && grouping && *grouping)
   17908:	e59d3020 	ldr	r3, [sp, #32]
   1790c:	e5d33000 	ldrb	r3, [r3]
   17910:	e3530000 	cmp	r3, #0
rflag:		ch = *fmt++;
   17914:	e5d93000 	ldrb	r3, [r9]
			  flags |= GROUPING;
   17918:	138aab01 	orrne	sl, sl, #1024	@ 0x400
   1791c:	eafffcc7 	b	16c40 <_vfiprintf_r+0x13c>
reswitch:	switch (ch) {
   17920:	e30921a4 	movw	r2, #37284	@ 0x91a4
   17924:	e3402002 	movt	r2, #2
   17928:	e58d201c 	str	r2, [sp, #28]
			width = GET_ARG (n, ap, int);
   1792c:	e59d2014 	ldr	r2, [sp, #20]
hex:			_uquad = UARG ();
   17930:	e31a0010 	tst	sl, #16
			width = GET_ARG (n, ap, int);
   17934:	e4925004 	ldr	r5, [r2], #4
   17938:	e58d2014 	str	r2, [sp, #20]
hex:			_uquad = UARG ();
   1793c:	1a000004 	bne	17954 <_vfiprintf_r+0xe50>
   17940:	e31a0040 	tst	sl, #64	@ 0x40
   17944:	16ff5075 	uxthne	r5, r5
   17948:	1a000001 	bne	17954 <_vfiprintf_r+0xe50>
   1794c:	e31a0c02 	tst	sl, #512	@ 0x200
   17950:	16ef5075 	uxtbne	r5, r5
			if (flags & ALT && _uquad != 0) {
   17954:	e3550000 	cmp	r5, #0
   17958:	03a02000 	moveq	r2, #0
   1795c:	120a2001 	andne	r2, sl, #1
   17960:	e3520000 	cmp	r2, #0
				flags |= HEXPREFIX;
   17964:	138aa002 	orrne	sl, sl, #2
				ox[1] = ch;
   17968:	15cd3035 	strbne	r3, [sp, #53]	@ 0x35
				ox[0] = '0';
   1796c:	13a03030 	movne	r3, #48	@ 0x30
			flags &= ~GROUPING;
   17970:	e3ca2b01 	bic	r2, sl, #1024	@ 0x400
				ox[0] = '0';
   17974:	15cd3034 	strbne	r3, [sp, #52]	@ 0x34
			flags &= ~GROUPING;
   17978:	eafffe70 	b	17340 <_vfiprintf_r+0x83c>
			xdigs = "0123456789abcdef";
   1797c:	e30921b8 	movw	r2, #37304	@ 0x91b8
   17980:	e3402002 	movt	r2, #2
   17984:	e58d201c 	str	r2, [sp, #28]
   17988:	eaffffe7 	b	1792c <_vfiprintf_r+0xe28>
				size = strlen (cp);
   1798c:	e1a00004 	mov	r0, r4
   17990:	fa0022ba 	blx	20480 <strlen>
   17994:	e1a03000 	mov	r3, r0
   17998:	eafffdb7 	b	1707c <_vfiprintf_r+0x578>
						*--cp = '0';
   1799c:	e3a03030 	mov	r3, #48	@ 0x30
   179a0:	e2411002 	sub	r1, r1, #2
   179a4:	e5443001 	strb	r3, [r4, #-1]
			size = buf + BUF - cp;
   179a8:	e28d30e8 	add	r3, sp, #232	@ 0xe8
   179ac:	e1a0a002 	mov	sl, r2
   179b0:	e0433001 	sub	r3, r3, r1
						*--cp = '0';
   179b4:	e1a04001 	mov	r4, r1
   179b8:	eafffe28 	b	17260 <_vfiprintf_r+0x75c>
					  *--cp = to_char (_uquad % 10);
   179bc:	e30c6ccd 	movw	r6, #52429	@ 0xcccd
					  if ((flags & GROUPING)
   179c0:	e20a2b01 	and	r2, sl, #1024	@ 0x400
			cp = buf + BUF;
   179c4:	e58d9000 	str	r9, [sp]
					  *--cp = to_char (_uquad % 10);
   179c8:	e34c6ccc 	movt	r6, #52428	@ 0xcccc
			cp = buf + BUF;
   179cc:	e1a09008 	mov	r9, r8
   179d0:	e59d3020 	ldr	r3, [sp, #32]
   179d4:	e1a08007 	mov	r8, r7
					ndig = 0;
   179d8:	e3a00000 	mov	r0, #0
			cp = buf + BUF;
   179dc:	e28d10e8 	add	r1, sp, #232	@ 0xe8
   179e0:	e1a07002 	mov	r7, r2
   179e4:	ea000003 	b	179f8 <_vfiprintf_r+0xef4>
					} while (_uquad != 0);
   179e8:	e3550009 	cmp	r5, #9
   179ec:	9a000015 	bls	17a48 <_vfiprintf_r+0xf44>
					  _uquad /= 10;
   179f0:	e1a0500c 	mov	r5, ip
   179f4:	e1a01004 	mov	r1, r4
					  *--cp = to_char (_uquad % 10);
   179f8:	e082c596 	umull	ip, r2, r6, r5
					  if ((flags & GROUPING)
   179fc:	e3570000 	cmp	r7, #0
					  *--cp = to_char (_uquad % 10);
   17a00:	e2414001 	sub	r4, r1, #1
					  ndig++;
   17a04:	e2800001 	add	r0, r0, #1
					  *--cp = to_char (_uquad % 10);
   17a08:	e1a021a2 	lsr	r2, r2, #3
					  _uquad /= 10;
   17a0c:	e1a0c002 	mov	ip, r2
					  *--cp = to_char (_uquad % 10);
   17a10:	e0822102 	add	r2, r2, r2, lsl #2
   17a14:	e0452082 	sub	r2, r5, r2, lsl #1
   17a18:	e2822030 	add	r2, r2, #48	@ 0x30
   17a1c:	e5412001 	strb	r2, [r1, #-1]
					  if ((flags & GROUPING)
   17a20:	0afffff0 	beq	179e8 <_vfiprintf_r+0xee4>
					      && ndig == *grouping
   17a24:	e5d32000 	ldrb	r2, [r3]
					      && *grouping != CHAR_MAX
   17a28:	e25210ff 	subs	r1, r2, #255	@ 0xff
   17a2c:	13a01001 	movne	r1, #1
   17a30:	e1520000 	cmp	r2, r0
   17a34:	13a01000 	movne	r1, #0
   17a38:	e3510000 	cmp	r1, #0
   17a3c:	0affffe9 	beq	179e8 <_vfiprintf_r+0xee4>
					      && _uquad > 9) {
   17a40:	e3550009 	cmp	r5, #9
   17a44:	8a00001d 	bhi	17ac0 <_vfiprintf_r+0xfbc>
		if (sign)
   17a48:	e58d3020 	str	r3, [sp, #32]
			size = buf + BUF - cp;
   17a4c:	e28d30e8 	add	r3, sp, #232	@ 0xe8
		if (sign)
   17a50:	e1a07008 	mov	r7, r8
   17a54:	e5dd2033 	ldrb	r2, [sp, #51]	@ 0x33
   17a58:	e1a08009 	mov	r8, r9
			size = buf + BUF - cp;
   17a5c:	e0433004 	sub	r3, r3, r4
		if (sign)
   17a60:	e59d9000 	ldr	r9, [sp]
   17a64:	eafffdd4 	b	171bc <_vfiprintf_r+0x6b8>
	CHECK_INIT (data, fp);
   17a68:	eb00029c 	bl	184e0 <__sinit>
   17a6c:	eafffc30 	b	16b34 <_vfiprintf_r+0x30>
				size = ((unsigned) prec > 6U) ? 6 : prec;
   17a70:	e3580006 	cmp	r8, #6
				cp = "(null)";
   17a74:	e30941cc 	movw	r4, #37324	@ 0x91cc
				size = ((unsigned) prec > 6U) ? 6 : prec;
   17a78:	31a03008 	movcc	r3, r8
   17a7c:	23a03006 	movcs	r3, #6
				cp = "(null)";
   17a80:	e3404002 	movt	r4, #2
			cp = GET_ARG (N, ap, char_ptr_t);
   17a84:	e58d5014 	str	r5, [sp, #20]
   17a88:	e58d3000 	str	r3, [sp]
   17a8c:	eafffd18 	b	16ef4 <_vfiprintf_r+0x3f0>
			else if (flags & CHARINT)
   17a90:	e31a0c02 	tst	sl, #512	@ 0x200
   17a94:	0afffe40 	beq	1739c <_vfiprintf_r+0x898>
				*GET_ARG (N, ap, char_ptr_t) = ret;
   17a98:	e59d3014 	ldr	r3, [sp, #20]
   17a9c:	e59d2008 	ldr	r2, [sp, #8]
   17aa0:	e5933000 	ldr	r3, [r3]
   17aa4:	e5c32000 	strb	r2, [r3]
   17aa8:	eafffe3f 	b	173ac <_vfiprintf_r+0x8a8>
	FLUSH ();
   17aac:	e59d1004 	ldr	r1, [sp, #4]
   17ab0:	e28d2038 	add	r2, sp, #56	@ 0x38
   17ab4:	e59d0010 	ldr	r0, [sp, #16]
   17ab8:	eb000053 	bl	17c0c <__sprint_r>
   17abc:	eafffcfd 	b	16eb8 <_vfiprintf_r+0x3b4>
   17ac0:	e58d300c 	str	r3, [sp, #12]
					    cp -= thsnd_len;
   17ac4:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
					    strncpy (cp, thousands_sep,
   17ac8:	e59d1024 	ldr	r1, [sp, #36]	@ 0x24
					    cp -= thsnd_len;
   17acc:	e0444003 	sub	r4, r4, r3
					    strncpy (cp, thousands_sep,
   17ad0:	e1a02003 	mov	r2, r3
   17ad4:	e1a00004 	mov	r0, r4
   17ad8:	eb000bcd 	bl	1aa14 <strncpy>
					    if (grouping[1] != '\0')
   17adc:	e59d300c 	ldr	r3, [sp, #12]
					  _uquad /= 10;
   17ae0:	e3a00000 	mov	r0, #0
					    if (grouping[1] != '\0')
   17ae4:	e5d32001 	ldrb	r2, [r3, #1]
   17ae8:	e3520000 	cmp	r2, #0
					  _uquad /= 10;
   17aec:	e30c2ccd 	movw	r2, #52429	@ 0xcccd
   17af0:	e34c2ccc 	movt	r2, #52428	@ 0xcccc
					      grouping++;
   17af4:	12833001 	addne	r3, r3, #1
					  _uquad /= 10;
   17af8:	e0825592 	umull	r5, r2, r2, r5
   17afc:	e1a0c1a2 	lsr	ip, r2, #3
					} while (_uquad != 0);
   17b00:	eaffffba 	b	179f0 <_vfiprintf_r+0xeec>
					size = prec;
   17b04:	e1a03008 	mov	r3, r8
   17b08:	eafffd5b 	b	1707c <_vfiprintf_r+0x578>
		return (EOF);
   17b0c:	e3e03000 	mvn	r3, #0
   17b10:	e58d3008 	str	r3, [sp, #8]
   17b14:	eafffceb 	b	16ec8 <_vfiprintf_r+0x3c4>
				prec = GET_ARG (n, ap, int);
   17b18:	e59d2014 	ldr	r2, [sp, #20]
rflag:		ch = *fmt++;
   17b1c:	e5d93001 	ldrb	r3, [r9, #1]
			if ((ch = *fmt++) == '*') {
   17b20:	e1a09001 	mov	r9, r1
				if (prec < 0)
   17b24:	e4928004 	ldr	r8, [r2], #4
				prec = GET_ARG (n, ap, int);
   17b28:	e58d2014 	str	r2, [sp, #20]
				if (prec < 0)
   17b2c:	e1888fc8 	orr	r8, r8, r8, asr #31
				goto rflag;
   17b30:	eafffc42 	b	16c40 <_vfiprintf_r+0x13c>
   17b34:	00029f64 	.word	0x00029f64

00017b38 <vfiprintf>:
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
   17b38:	e30bc1e8 	movw	ip, #45544	@ 0xb1e8
{
   17b3c:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
   17b40:	e340c002 	movt	ip, #2
{
   17b44:	e1a0e000 	mov	lr, r0
   17b48:	e1a03002 	mov	r3, r2
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
   17b4c:	e1a02001 	mov	r2, r1
   17b50:	e59c0000 	ldr	r0, [ip]
   17b54:	e1a0100e 	mov	r1, lr
}
   17b58:	e49de004 	pop	{lr}		@ (ldr lr, [sp], #4)
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
   17b5c:	eafffbe8 	b	16b04 <_vfiprintf_r>

00017b60 <__sbprintf>:
{
   17b60:	e92d40f0 	push	{r4, r5, r6, r7, lr}
   17b64:	e1a04001 	mov	r4, r1
	fake._flags = fp->_flags & ~__SNBF;
   17b68:	e1d110bc 	ldrh	r1, [r1, #12]
{
   17b6c:	e24dde46 	sub	sp, sp, #1120	@ 0x460
   17b70:	e24dd00c 	sub	sp, sp, #12
   17b74:	e1a06000 	mov	r6, r0
	fake._bf._base = fake._p = buf;
   17b78:	e28dc068 	add	ip, sp, #104	@ 0x68
	fake._flags = fp->_flags & ~__SNBF;
   17b7c:	e1a0700d 	mov	r7, sp
   17b80:	e3c11002 	bic	r1, r1, #2
	fake._bf._base = fake._p = buf;
   17b84:	e58dc000 	str	ip, [sp]
	fake._flags = fp->_flags & ~__SNBF;
   17b88:	e1cd10bc 	strh	r1, [sp, #12]
	fake._flags2 = fp->_flags2;
   17b8c:	e5941064 	ldr	r1, [r4, #100]	@ 0x64
	fake._bf._base = fake._p = buf;
   17b90:	e58dc010 	str	ip, [sp, #16]
	fake._bf._size = fake._w = sizeof (buf);
   17b94:	e3a0cb01 	mov	ip, #1024	@ 0x400
   17b98:	e58dc008 	str	ip, [sp, #8]
	fake._flags2 = fp->_flags2;
   17b9c:	e58d1064 	str	r1, [sp, #100]	@ 0x64
	fake._file = fp->_file;
   17ba0:	e1d410be 	ldrh	r1, [r4, #14]
	fake._bf._size = fake._w = sizeof (buf);
   17ba4:	e58dc014 	str	ip, [sp, #20]
	fake._file = fp->_file;
   17ba8:	e1cd10be 	strh	r1, [sp, #14]
	fake._cookie = fp->_cookie;
   17bac:	e594101c 	ldr	r1, [r4, #28]
   17bb0:	e58d101c 	str	r1, [sp, #28]
	fake._write = fp->_write;
   17bb4:	e5941024 	ldr	r1, [r4, #36]	@ 0x24
   17bb8:	e58d1024 	str	r1, [sp, #36]	@ 0x24
	fake._bf._size = fake._w = sizeof (buf);
   17bbc:	e3a01000 	mov	r1, #0
   17bc0:	e58d1018 	str	r1, [sp, #24]
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
   17bc4:	e1a01007 	mov	r1, r7
   17bc8:	ebfffbcd 	bl	16b04 <_vfiprintf_r>
	if (ret >= 0 && _fflush_r (rptr, &fake))
   17bcc:	e2505000 	subs	r5, r0, #0
   17bd0:	ba000004 	blt	17be8 <__sbprintf+0x88>
   17bd4:	e1a01007 	mov	r1, r7
   17bd8:	e1a00006 	mov	r0, r6
   17bdc:	eb000116 	bl	1803c <_fflush_r>
		ret = EOF;
   17be0:	e3500000 	cmp	r0, #0
   17be4:	13e05000 	mvnne	r5, #0
	if (fake._flags & __SERR)
   17be8:	e1dd30bc 	ldrh	r3, [sp, #12]
}
   17bec:	e1a00005 	mov	r0, r5
	if (fake._flags & __SERR)
   17bf0:	e3130040 	tst	r3, #64	@ 0x40
		fp->_flags |= __SERR;
   17bf4:	11d430bc 	ldrhne	r3, [r4, #12]
   17bf8:	13833040 	orrne	r3, r3, #64	@ 0x40
   17bfc:	11c430bc 	strhne	r3, [r4, #12]
}
   17c00:	e28dde46 	add	sp, sp, #1120	@ 0x460
   17c04:	e28dd00c 	add	sp, sp, #12
   17c08:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

00017c0c <__sprint_r>:
       FILE *fp,
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   17c0c:	e5923008 	ldr	r3, [r2, #8]
{
   17c10:	e92d4010 	push	{r4, lr}
   17c14:	e1a04002 	mov	r4, r2
	if (uio->uio_resid == 0) {
   17c18:	e3530000 	cmp	r3, #0
		uio->uio_iovcnt = 0;
		return (0);
   17c1c:	01a00003 	moveq	r0, r3
	if (uio->uio_resid == 0) {
   17c20:	0a000002 	beq	17c30 <__sprint_r+0x24>
	}
	err = __sfvwrite_r(ptr, fp, uio);
   17c24:	eb000301 	bl	18830 <__sfvwrite_r>
	uio->uio_resid = 0;
   17c28:	e3a03000 	mov	r3, #0
   17c2c:	e5843008 	str	r3, [r4, #8]
		uio->uio_iovcnt = 0;
   17c30:	e3a03000 	mov	r3, #0
   17c34:	e5843004 	str	r3, [r4, #4]
	uio->uio_iovcnt = 0;
	return (err);
}
   17c38:	e8bd8010 	pop	{r4, pc}

00017c3c <_fclose_r>:
#include "local.h"

int
_fclose_r (struct _reent *rptr,
      register FILE * fp)
{
   17c3c:	e92d4070 	push	{r4, r5, r6, lr}
  int r;

  if (fp == NULL)
   17c40:	e2514000 	subs	r4, r1, #0
   17c44:	0a000008 	beq	17c6c <_fclose_r+0x30>
    return (0);			/* on NULL */

  CHECK_INIT (rptr, fp);
   17c48:	e3500000 	cmp	r0, #0
   17c4c:	e1a05000 	mov	r5, r0
   17c50:	0a000002 	beq	17c60 <_fclose_r+0x24>
   17c54:	e5903034 	ldr	r3, [r0, #52]	@ 0x34
   17c58:	e3530000 	cmp	r3, #0
   17c5c:	0a00002b 	beq	17d10 <_fclose_r+0xd4>
  pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &__oldcancel);
#endif
  if (!(fp->_flags2 & __SNLK))
    _flockfile (fp);

  if (fp->_flags == 0)		/* not open! */
   17c60:	e1d430fc 	ldrsh	r3, [r4, #12]
   17c64:	e3530000 	cmp	r3, #0
   17c68:	1a000002 	bne	17c78 <_fclose_r+0x3c>
    return (0);			/* on NULL */
   17c6c:	e3a06000 	mov	r6, #0
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif

  return (r);
}
   17c70:	e1a00006 	mov	r0, r6
   17c74:	e8bd8070 	pop	{r4, r5, r6, pc}
  r = __sflush_r (rptr, fp);
   17c78:	e1a01004 	mov	r1, r4
   17c7c:	e1a00005 	mov	r0, r5
   17c80:	eb00006c 	bl	17e38 <__sflush_r>
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
   17c84:	e594302c 	ldr	r3, [r4, #44]	@ 0x2c
  r = __sflush_r (rptr, fp);
   17c88:	e1a06000 	mov	r6, r0
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
   17c8c:	e3530000 	cmp	r3, #0
   17c90:	0a000004 	beq	17ca8 <_fclose_r+0x6c>
   17c94:	e594101c 	ldr	r1, [r4, #28]
   17c98:	e1a00005 	mov	r0, r5
   17c9c:	e12fff33 	blx	r3
    r = EOF;
   17ca0:	e3500000 	cmp	r0, #0
   17ca4:	b3e06000 	mvnlt	r6, #0
  if (fp->_flags & __SMBF)
   17ca8:	e1d430bc 	ldrh	r3, [r4, #12]
   17cac:	e3130080 	tst	r3, #128	@ 0x80
   17cb0:	1a000018 	bne	17d18 <_fclose_r+0xdc>
  if (HASUB (fp))
   17cb4:	e5941030 	ldr	r1, [r4, #48]	@ 0x30
   17cb8:	e3510000 	cmp	r1, #0
   17cbc:	0a000006 	beq	17cdc <_fclose_r+0xa0>
    FREEUB (rptr, fp);
   17cc0:	e2843040 	add	r3, r4, #64	@ 0x40
   17cc4:	e1510003 	cmp	r1, r3
   17cc8:	0a000001 	beq	17cd4 <_fclose_r+0x98>
   17ccc:	e1a00005 	mov	r0, r5
   17cd0:	eb001e1d 	bl	1f54c <_free_r>
   17cd4:	e3a03000 	mov	r3, #0
   17cd8:	e5843030 	str	r3, [r4, #48]	@ 0x30
  if (HASLB (fp))
   17cdc:	e5941044 	ldr	r1, [r4, #68]	@ 0x44
   17ce0:	e3510000 	cmp	r1, #0
   17ce4:	0a000003 	beq	17cf8 <_fclose_r+0xbc>
    FREELB (rptr, fp);
   17ce8:	e1a00005 	mov	r0, r5
   17cec:	eb001e16 	bl	1f54c <_free_r>
   17cf0:	e3a03000 	mov	r3, #0
   17cf4:	e5843044 	str	r3, [r4, #68]	@ 0x44
  __sfp_lock_acquire ();
   17cf8:	eb000204 	bl	18510 <__sfp_lock_acquire>
  fp->_flags = 0;		/* release this FILE for reuse */
   17cfc:	e3a03000 	mov	r3, #0
   17d00:	e1c430bc 	strh	r3, [r4, #12]
  __sfp_lock_release ();
   17d04:	eb000202 	bl	18514 <__sfp_lock_release>
}
   17d08:	e1a00006 	mov	r0, r6
   17d0c:	e8bd8070 	pop	{r4, r5, r6, pc}
  CHECK_INIT (rptr, fp);
   17d10:	eb0001f2 	bl	184e0 <__sinit>
   17d14:	eaffffd1 	b	17c60 <_fclose_r+0x24>
    _free_r (rptr, (char *) fp->_bf._base);
   17d18:	e5941010 	ldr	r1, [r4, #16]
   17d1c:	e1a00005 	mov	r0, r5
   17d20:	eb001e09 	bl	1f54c <_free_r>
   17d24:	eaffffe2 	b	17cb4 <_fclose_r+0x78>

00017d28 <fclose>:
#ifndef _REENT_ONLY

int
fclose (register FILE * fp)
{
  return _fclose_r(_REENT, fp);
   17d28:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
{
   17d2c:	e1a01000 	mov	r1, r0
  return _fclose_r(_REENT, fp);
   17d30:	e3403002 	movt	r3, #2
   17d34:	e5930000 	ldr	r0, [r3]
   17d38:	eaffffbf 	b	17c3c <_fclose_r>

00017d3c <_fdopen_r>:

FILE *
_fdopen_r (struct _reent *ptr,
       int fd,
       const char *mode)
{
   17d3c:	e92d4070 	push	{r4, r5, r6, lr}
   17d40:	e1a0c002 	mov	ip, r2
   17d44:	e24dd008 	sub	sp, sp, #8
   17d48:	e1a06001 	mov	r6, r1
  int flags, oflags;
#ifdef HAVE_FCNTL
  int fdflags, fdmode;
#endif

  if ((flags = __sflags (ptr, mode, &oflags)) == 0)
   17d4c:	e28d2004 	add	r2, sp, #4
   17d50:	e1a0100c 	mov	r1, ip
{
   17d54:	e1a05000 	mov	r5, r0
  if ((flags = __sflags (ptr, mode, &oflags)) == 0)
   17d58:	eb0001fa 	bl	18548 <__sflags>
   17d5c:	e2504000 	subs	r4, r0, #0
    return 0;
   17d60:	01a00004 	moveq	r0, r4
  if ((flags = __sflags (ptr, mode, &oflags)) == 0)
   17d64:	0a000011 	beq	17db0 <_fdopen_r+0x74>
      _REENT_ERRNO(ptr) = EBADF;
      return 0;
    }
#endif

  if ((fp = __sfp (ptr)) == 0)
   17d68:	e1a00005 	mov	r0, r5
   17d6c:	eb000198 	bl	183d4 <__sfp>
   17d70:	e3500000 	cmp	r0, #0
   17d74:	0a00000d 	beq	17db0 <_fdopen_r+0x74>
#undef _read
#undef _write
#undef _seek
#undef _close

  fp->_read = __sread;
   17d78:	e309c700 	movw	ip, #38656	@ 0x9700
  fp->_write = __swrite;
   17d7c:	e3091738 	movw	r1, #38712	@ 0x9738
  fp->_seek = __sseek;
   17d80:	e3092790 	movw	r2, #38800	@ 0x9790
  fp->_close = __sclose;
   17d84:	e30937bc 	movw	r3, #38844	@ 0x97bc
  fp->_read = __sread;
   17d88:	e340c001 	movt	ip, #1
  fp->_write = __swrite;
   17d8c:	e3401001 	movt	r1, #1
  fp->_seek = __sseek;
   17d90:	e3402001 	movt	r2, #1
  fp->_close = __sclose;
   17d94:	e3403001 	movt	r3, #1
  fp->_flags = flags;
   17d98:	e1c040bc 	strh	r4, [r0, #12]
  fp->_file = fd;
   17d9c:	e1c060be 	strh	r6, [r0, #14]
  fp->_cookie = (void *) fp;
   17da0:	e580001c 	str	r0, [r0, #28]
  fp->_read = __sread;
   17da4:	e580c020 	str	ip, [r0, #32]
  fp->_write = __swrite;
   17da8:	e5801024 	str	r1, [r0, #36]	@ 0x24
  fp->_close = __sclose;
   17dac:	e1c022f8 	strd	r2, [r0, #40]	@ 0x28
    fp->_flags |= __SCLE;
#endif

  _newlib_flockfile_end (fp);
  return fp;
}
   17db0:	e28dd008 	add	sp, sp, #8
   17db4:	e8bd8070 	pop	{r4, r5, r6, pc}

00017db8 <fdopen>:

FILE *
fdopen (int fd,
       const char *mode)
{
  return _fdopen_r (_REENT, fd, mode);
   17db8:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
{
   17dbc:	e92d4070 	push	{r4, r5, r6, lr}
  return _fdopen_r (_REENT, fd, mode);
   17dc0:	e3403002 	movt	r3, #2
{
   17dc4:	e24dd008 	sub	sp, sp, #8
  if ((flags = __sflags (ptr, mode, &oflags)) == 0)
   17dc8:	e28d2004 	add	r2, sp, #4
{
   17dcc:	e1a05000 	mov	r5, r0
  return _fdopen_r (_REENT, fd, mode);
   17dd0:	e5936000 	ldr	r6, [r3]
  if ((flags = __sflags (ptr, mode, &oflags)) == 0)
   17dd4:	e1a00006 	mov	r0, r6
   17dd8:	eb0001da 	bl	18548 <__sflags>
   17ddc:	e2504000 	subs	r4, r0, #0
    return 0;
   17de0:	01a00004 	moveq	r0, r4
  if ((flags = __sflags (ptr, mode, &oflags)) == 0)
   17de4:	0a000011 	beq	17e30 <fdopen+0x78>
  if ((fp = __sfp (ptr)) == 0)
   17de8:	e1a00006 	mov	r0, r6
   17dec:	eb000178 	bl	183d4 <__sfp>
   17df0:	e3500000 	cmp	r0, #0
   17df4:	0a00000d 	beq	17e30 <fdopen+0x78>
  fp->_read = __sread;
   17df8:	e309c700 	movw	ip, #38656	@ 0x9700
  fp->_write = __swrite;
   17dfc:	e3091738 	movw	r1, #38712	@ 0x9738
  fp->_seek = __sseek;
   17e00:	e3092790 	movw	r2, #38800	@ 0x9790
  fp->_close = __sclose;
   17e04:	e30937bc 	movw	r3, #38844	@ 0x97bc
  fp->_read = __sread;
   17e08:	e340c001 	movt	ip, #1
  fp->_write = __swrite;
   17e0c:	e3401001 	movt	r1, #1
  fp->_seek = __sseek;
   17e10:	e3402001 	movt	r2, #1
  fp->_close = __sclose;
   17e14:	e3403001 	movt	r3, #1
  fp->_flags = flags;
   17e18:	e1c040bc 	strh	r4, [r0, #12]
  fp->_file = fd;
   17e1c:	e1c050be 	strh	r5, [r0, #14]
  fp->_cookie = (void *) fp;
   17e20:	e580001c 	str	r0, [r0, #28]
  fp->_read = __sread;
   17e24:	e580c020 	str	ip, [r0, #32]
  fp->_write = __swrite;
   17e28:	e5801024 	str	r1, [r0, #36]	@ 0x24
  fp->_close = __sclose;
   17e2c:	e1c022f8 	strd	r2, [r0, #40]	@ 0x28
}
   17e30:	e28dd008 	add	sp, sp, #8
   17e34:	e8bd8070 	pop	{r4, r5, r6, pc}

00017e38 <__sflush_r>:
  register unsigned char *p;
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
   17e38:	e1d120fc 	ldrsh	r2, [r1, #12]
{
   17e3c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
   17e40:	e1a04001 	mov	r4, r1
   17e44:	e1a07000 	mov	r7, r0
  if ((flags & __SWR) == 0)
   17e48:	e3120008 	tst	r2, #8
   17e4c:	1a000043 	bne	17f60 <__sflush_r+0x128>
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
   17e50:	e5911004 	ldr	r1, [r1, #4]
      fp->_flags |= __SNPT;
   17e54:	e3823b02 	orr	r3, r2, #2048	@ 0x800
   17e58:	e1c430bc 	strh	r3, [r4, #12]
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
   17e5c:	e3510000 	cmp	r1, #0
   17e60:	da00005c 	ble	17fd8 <__sflush_r+0x1a0>
   17e64:	e5945028 	ldr	r5, [r4, #40]	@ 0x28
   17e68:	e3550000 	cmp	r5, #0
   17e6c:	0a000039 	beq	17f58 <__sflush_r+0x120>
	     returns with a valid position -1.  We restore the last errno if
	     no other error condition has been encountered. */
	  tmp_errno = _REENT_ERRNO(ptr);
	  _REENT_ERRNO(ptr) = 0;
	  /* Get the physical position we are at in the file.  */
	  if (fp->_flags & __SOFF)
   17e70:	e2122a01 	ands	r2, r2, #4096	@ 0x1000
	  _REENT_ERRNO(ptr) = 0;
   17e74:	e3a01000 	mov	r1, #0
	  tmp_errno = _REENT_ERRNO(ptr);
   17e78:	e5976000 	ldr	r6, [r7]
	  _REENT_ERRNO(ptr) = 0;
   17e7c:	e5871000 	str	r1, [r7]
#ifdef __LARGE64_FILES
	      if (fp->_flags & __SL64)
		curoff = fp->_seek64 (ptr, fp->_cookie, 0, SEEK_CUR);
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
   17e80:	e594101c 	ldr	r1, [r4, #28]
	  if (fp->_flags & __SOFF)
   17e84:	1a000057 	bne	17fe8 <__sflush_r+0x1b0>
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
   17e88:	e3a03001 	mov	r3, #1
   17e8c:	e1a00007 	mov	r0, r7
   17e90:	e12fff35 	blx	r5
	      if (curoff == -1L && _REENT_ERRNO(ptr) != 0)
   17e94:	e3700001 	cmn	r0, #1
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
   17e98:	e1a02000 	mov	r2, r0
	      if (curoff == -1L && _REENT_ERRNO(ptr) != 0)
   17e9c:	0a00005e 	beq	1801c <__sflush_r+0x1e4>
		    {
		      result = 0;
		      _REENT_ERRNO(ptr) = tmp_errno;
		    }
		  else
		    fp->_flags |= __SERR;
   17ea0:	e1d430fc 	ldrsh	r3, [r4, #12]
#ifdef __LARGE64_FILES
	  if (fp->_flags & __SL64)
	    curoff = fp->_seek64 (ptr, fp->_cookie, curoff, SEEK_SET);
	  else
#endif
	    curoff = fp->_seek (ptr, fp->_cookie, curoff, SEEK_SET);
   17ea4:	e5945028 	ldr	r5, [r4, #40]	@ 0x28
   17ea8:	e594101c 	ldr	r1, [r4, #28]
          if (fp->_flags & __SRD)
   17eac:	e3130004 	tst	r3, #4
   17eb0:	0a000005 	beq	17ecc <__sflush_r+0x94>
              if (HASUB (fp))
   17eb4:	e5943030 	ldr	r3, [r4, #48]	@ 0x30
   17eb8:	e3530000 	cmp	r3, #0
              curoff -= fp->_r;
   17ebc:	e5943004 	ldr	r3, [r4, #4]
   17ec0:	e0422003 	sub	r2, r2, r3
                curoff -= fp->_ur;
   17ec4:	1594303c 	ldrne	r3, [r4, #60]	@ 0x3c
   17ec8:	10422003 	subne	r2, r2, r3
	    curoff = fp->_seek (ptr, fp->_cookie, curoff, SEEK_SET);
   17ecc:	e3a03000 	mov	r3, #0
   17ed0:	e1a00007 	mov	r0, r7
   17ed4:	e12fff35 	blx	r5
	  if (curoff != -1 || _REENT_ERRNO(ptr) == 0
   17ed8:	e3700001 	cmn	r0, #1
   17edc:	1a000043 	bne	17ff0 <__sflush_r+0x1b8>
   17ee0:	e5971000 	ldr	r1, [r7]
	      || _REENT_ERRNO(ptr) == ESPIPE || _REENT_ERRNO(ptr) == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   17ee4:	e1d430fc 	ldrsh	r3, [r4, #12]
   17ee8:	e351001d 	cmp	r1, #29
   17eec:	8a000035 	bhi	17fc8 <__sflush_r+0x190>
   17ef0:	e3a02001 	mov	r2, #1
   17ef4:	e3422040 	movt	r2, #8256	@ 0x2040
   17ef8:	e1a02132 	lsr	r2, r2, r1
   17efc:	e3120001 	tst	r2, #1
   17f00:	0a000030 	beq	17fc8 <__sflush_r+0x190>
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
	      if ((fp->_flags & __SOFF) && (curoff != -1 || _REENT_ERRNO(ptr) == 0))
   17f04:	e3130a01 	tst	r3, #4096	@ 0x1000
	      fp->_flags &= ~__SNPT;
   17f08:	e3c33b02 	bic	r3, r3, #2048	@ 0x800
   17f0c:	e1c430bc 	strh	r3, [r4, #12]
	      fp->_p = fp->_bf._base;
   17f10:	e5943010 	ldr	r3, [r4, #16]
   17f14:	e5843000 	str	r3, [r4]
	      fp->_r = 0;
   17f18:	e3a03000 	mov	r3, #0
   17f1c:	e5843004 	str	r3, [r4, #4]
	      if ((fp->_flags & __SOFF) && (curoff != -1 || _REENT_ERRNO(ptr) == 0))
   17f20:	0a000001 	beq	17f2c <__sflush_r+0xf4>
   17f24:	e1510003 	cmp	r1, r3
   17f28:	0a000039 	beq	18014 <__sflush_r+0x1dc>
		fp->_offset = curoff;
	      _REENT_ERRNO(ptr) = tmp_errno;
	      if (HASUB (fp))
   17f2c:	e5941030 	ldr	r1, [r4, #48]	@ 0x30
	      _REENT_ERRNO(ptr) = tmp_errno;
   17f30:	e5876000 	str	r6, [r7]
	      if (HASUB (fp))
   17f34:	e3510000 	cmp	r1, #0
   17f38:	0a000006 	beq	17f58 <__sflush_r+0x120>
		FREEUB (ptr, fp);
   17f3c:	e2843040 	add	r3, r4, #64	@ 0x40
   17f40:	e1510003 	cmp	r1, r3
   17f44:	0a000001 	beq	17f50 <__sflush_r+0x118>
   17f48:	e1a00007 	mov	r0, r7
   17f4c:	eb001d7e 	bl	1f54c <_free_r>
   17f50:	e3a03000 	mov	r3, #0
   17f54:	e5843030 	str	r3, [r4, #48]	@ 0x30
	    {
	      fp->_flags |= __SERR;
	      return EOF;
	    }
	}
      return 0;
   17f58:	e3a00000 	mov	r0, #0
	}
      p += t;
      n -= t;
    }
  return 0;
}
   17f5c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  if ((p = fp->_bf._base) == NULL)
   17f60:	e5916010 	ldr	r6, [r1, #16]
   17f64:	e3560000 	cmp	r6, #0
   17f68:	0afffffa 	beq	17f58 <__sflush_r+0x120>
  n = fp->_p - p;		/* write this much */
   17f6c:	e5915000 	ldr	r5, [r1]
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
   17f70:	e3120003 	tst	r2, #3
   17f74:	05913014 	ldreq	r3, [r1, #20]
   17f78:	13a03000 	movne	r3, #0
  fp->_p = p;
   17f7c:	e5816000 	str	r6, [r1]
  n = fp->_p - p;		/* write this much */
   17f80:	e0455006 	sub	r5, r5, r6
  while (n > 0)
   17f84:	e3550000 	cmp	r5, #0
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
   17f88:	e5813008 	str	r3, [r1, #8]
  while (n > 0)
   17f8c:	ca000002 	bgt	17f9c <__sflush_r+0x164>
   17f90:	eafffff0 	b	17f58 <__sflush_r+0x120>
   17f94:	e3550000 	cmp	r5, #0
   17f98:	daffffee 	ble	17f58 <__sflush_r+0x120>
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
   17f9c:	e594c024 	ldr	ip, [r4, #36]	@ 0x24
   17fa0:	e1a03005 	mov	r3, r5
   17fa4:	e1a02006 	mov	r2, r6
   17fa8:	e594101c 	ldr	r1, [r4, #28]
   17fac:	e1a00007 	mov	r0, r7
   17fb0:	e12fff3c 	blx	ip
      if (t <= 0)
   17fb4:	e250c000 	subs	ip, r0, #0
      n -= t;
   17fb8:	e045500c 	sub	r5, r5, ip
      p += t;
   17fbc:	e086600c 	add	r6, r6, ip
      if (t <= 0)
   17fc0:	cafffff3 	bgt	17f94 <__sflush_r+0x15c>
		    fp->_flags |= __SERR;
   17fc4:	e1d430fc 	ldrsh	r3, [r4, #12]
   17fc8:	e3833040 	orr	r3, r3, #64	@ 0x40
		  int result = EOF;
   17fcc:	e3e00000 	mvn	r0, #0
		    fp->_flags |= __SERR;
   17fd0:	e1c430bc 	strh	r3, [r4, #12]
   17fd4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
   17fd8:	e594103c 	ldr	r1, [r4, #60]	@ 0x3c
   17fdc:	e3510000 	cmp	r1, #0
   17fe0:	caffff9f 	bgt	17e64 <__sflush_r+0x2c>
   17fe4:	eaffffdb 	b	17f58 <__sflush_r+0x120>
	    curoff = fp->_offset;
   17fe8:	e5942050 	ldr	r2, [r4, #80]	@ 0x50
   17fec:	eaffffae 	b	17eac <__sflush_r+0x74>
	      fp->_flags &= ~__SNPT;
   17ff0:	e1d430fc 	ldrsh	r3, [r4, #12]
	      if ((fp->_flags & __SOFF) && (curoff != -1 || _REENT_ERRNO(ptr) == 0))
   17ff4:	e3130a01 	tst	r3, #4096	@ 0x1000
	      fp->_flags &= ~__SNPT;
   17ff8:	e3c33b02 	bic	r3, r3, #2048	@ 0x800
   17ffc:	e1c430bc 	strh	r3, [r4, #12]
	      fp->_r = 0;
   18000:	e3a03000 	mov	r3, #0
   18004:	e5843004 	str	r3, [r4, #4]
	      fp->_p = fp->_bf._base;
   18008:	e5943010 	ldr	r3, [r4, #16]
   1800c:	e5843000 	str	r3, [r4]
	      if ((fp->_flags & __SOFF) && (curoff != -1 || _REENT_ERRNO(ptr) == 0))
   18010:	0affffc5 	beq	17f2c <__sflush_r+0xf4>
		fp->_offset = curoff;
   18014:	e5840050 	str	r0, [r4, #80]	@ 0x50
   18018:	eaffffc3 	b	17f2c <__sflush_r+0xf4>
	      if (curoff == -1L && _REENT_ERRNO(ptr) != 0)
   1801c:	e5973000 	ldr	r3, [r7]
   18020:	e3530000 	cmp	r3, #0
   18024:	0affff9d 	beq	17ea0 <__sflush_r+0x68>
		  if (_REENT_ERRNO(ptr) == ESPIPE || _REENT_ERRNO(ptr) == EINVAL)
   18028:	e3530016 	cmp	r3, #22
   1802c:	1353001d 	cmpne	r3, #29
		      _REENT_ERRNO(ptr) = tmp_errno;
   18030:	05876000 	streq	r6, [r7]
		  if (_REENT_ERRNO(ptr) == ESPIPE || _REENT_ERRNO(ptr) == EINVAL)
   18034:	0affffc7 	beq	17f58 <__sflush_r+0x120>
   18038:	eaffffe1 	b	17fc4 <__sflush_r+0x18c>

0001803c <_fflush_r>:
#endif /* __IMPL_UNLOCKED__ */

int
_fflush_r (struct _reent *ptr,
       register FILE * fp)
{
   1803c:	e92d4010 	push	{r4, lr}
     2 is implemented here due to its simplicity.  */
  if (fp->_bf._base == NULL)
    return 0;
#endif /* _REENT_SMALL  */

  CHECK_INIT (ptr, fp);
   18040:	e2504000 	subs	r4, r0, #0
{
   18044:	e24dd008 	sub	sp, sp, #8
  CHECK_INIT (ptr, fp);
   18048:	0a000002 	beq	18058 <_fflush_r+0x1c>
   1804c:	e5943034 	ldr	r3, [r4, #52]	@ 0x34
   18050:	e3530000 	cmp	r3, #0
   18054:	0a000008 	beq	1807c <_fflush_r+0x40>

  if (!fp->_flags)
   18058:	e1d100fc 	ldrsh	r0, [r1, #12]
   1805c:	e3500000 	cmp	r0, #0
   18060:	1a000001 	bne	1806c <_fflush_r+0x30>

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
  _newlib_flockfile_end (fp);
  return ret;
}
   18064:	e28dd008 	add	sp, sp, #8
   18068:	e8bd8010 	pop	{r4, pc}
  ret = __sflush_r (ptr, fp);
   1806c:	e1a00004 	mov	r0, r4
}
   18070:	e28dd008 	add	sp, sp, #8
   18074:	e8bd4010 	pop	{r4, lr}
  ret = __sflush_r (ptr, fp);
   18078:	eaffff6e 	b	17e38 <__sflush_r>
   1807c:	e58d1004 	str	r1, [sp, #4]
  CHECK_INIT (ptr, fp);
   18080:	eb000116 	bl	184e0 <__sinit>
   18084:	e59d1004 	ldr	r1, [sp, #4]
   18088:	eafffff2 	b	18058 <_fflush_r+0x1c>

0001808c <fflush>:

#ifndef _REENT_ONLY

int
fflush (register FILE * fp)
{
   1808c:	e92d4070 	push	{r4, r5, r6, lr}
  if (fp == NULL)
   18090:	e2504000 	subs	r4, r0, #0
   18094:	0a000011 	beq	180e0 <fflush+0x54>
    return _fwalk_sglue (_GLOBAL_REENT, _fflush_r, &__sglue);

  return _fflush_r (_REENT, fp);
   18098:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
   1809c:	e3403002 	movt	r3, #2
   180a0:	e5935000 	ldr	r5, [r3]
  CHECK_INIT (ptr, fp);
   180a4:	e3550000 	cmp	r5, #0
   180a8:	0a000002 	beq	180b8 <fflush+0x2c>
   180ac:	e5953034 	ldr	r3, [r5, #52]	@ 0x34
   180b0:	e3530000 	cmp	r3, #0
   180b4:	0a000006 	beq	180d4 <fflush+0x48>
  if (!fp->_flags)
   180b8:	e1d400fc 	ldrsh	r0, [r4, #12]
   180bc:	e3500000 	cmp	r0, #0
   180c0:	08bd8070 	popeq	{r4, r5, r6, pc}
  ret = __sflush_r (ptr, fp);
   180c4:	e1a01004 	mov	r1, r4
   180c8:	e1a00005 	mov	r0, r5
}
   180cc:	e8bd4070 	pop	{r4, r5, r6, lr}
  ret = __sflush_r (ptr, fp);
   180d0:	eaffff58 	b	17e38 <__sflush_r>
  CHECK_INIT (ptr, fp);
   180d4:	e1a00005 	mov	r0, r5
   180d8:	eb000100 	bl	184e0 <__sinit>
   180dc:	eafffff5 	b	180b8 <fflush+0x2c>
    return _fwalk_sglue (_GLOBAL_REENT, _fflush_r, &__sglue);
   180e0:	e30b206c 	movw	r2, #45164	@ 0xb06c
   180e4:	e308103c 	movw	r1, #32828	@ 0x803c
   180e8:	e30b01f0 	movw	r0, #45552	@ 0xb1f0
}
   180ec:	e8bd4070 	pop	{r4, r5, r6, lr}
    return _fwalk_sglue (_GLOBAL_REENT, _fflush_r, &__sglue);
   180f0:	e3402002 	movt	r2, #2
   180f4:	e3401001 	movt	r1, #1
   180f8:	e3400002 	movt	r0, #2
   180fc:	ea0002f9 	b	18ce8 <_fwalk_sglue>

00018100 <_fgetc_r>:
#include "local.h"

int
_fgetc_r (struct _reent * ptr,
       FILE * fp)
{
   18100:	e92d4020 	push	{r5, lr}
  int result;
  CHECK_INIT(ptr, fp);
   18104:	e2505000 	subs	r5, r0, #0
{
   18108:	e24dd008 	sub	sp, sp, #8
  CHECK_INIT(ptr, fp);
   1810c:	0a000002 	beq	1811c <_fgetc_r+0x1c>
   18110:	e5953034 	ldr	r3, [r5, #52]	@ 0x34
   18114:	e3530000 	cmp	r3, #0
   18118:	0a00000e 	beq	18158 <_fgetc_r+0x58>
  _newlib_flockfile_start (fp);
  result = __sgetc_r (ptr, fp);
   1811c:	e5913004 	ldr	r3, [r1, #4]
   18120:	e2433001 	sub	r3, r3, #1
   18124:	e3530000 	cmp	r3, #0
   18128:	e5813004 	str	r3, [r1, #4]
   1812c:	ba000005 	blt	18148 <_fgetc_r+0x48>
   18130:	e5913000 	ldr	r3, [r1]
   18134:	e2832001 	add	r2, r3, #1
   18138:	e5812000 	str	r2, [r1]
  _newlib_flockfile_end (fp);
  return result;
}
   1813c:	e5d30000 	ldrb	r0, [r3]
   18140:	e28dd008 	add	sp, sp, #8
   18144:	e8bd8020 	pop	{r5, pc}
  result = __sgetc_r (ptr, fp);
   18148:	e1a00005 	mov	r0, r5
}
   1814c:	e28dd008 	add	sp, sp, #8
   18150:	e8bd4020 	pop	{r5, lr}
  result = __sgetc_r (ptr, fp);
   18154:	ea000405 	b	19170 <__srget_r>
   18158:	e58d1004 	str	r1, [sp, #4]
  CHECK_INIT(ptr, fp);
   1815c:	eb0000df 	bl	184e0 <__sinit>
   18160:	e59d1004 	ldr	r1, [sp, #4]
   18164:	eaffffec 	b	1811c <_fgetc_r+0x1c>

00018168 <fgetc>:
int
fgetc (FILE * fp)
{
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  int result;
  struct _reent *reent = _REENT;
   18168:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
{
   1816c:	e92d4070 	push	{r4, r5, r6, lr}
  struct _reent *reent = _REENT;
   18170:	e3403002 	movt	r3, #2
{
   18174:	e1a04000 	mov	r4, r0
  struct _reent *reent = _REENT;
   18178:	e5935000 	ldr	r5, [r3]

  CHECK_INIT(reent, fp);
   1817c:	e3550000 	cmp	r5, #0
   18180:	0a000002 	beq	18190 <fgetc+0x28>
   18184:	e5953034 	ldr	r3, [r5, #52]	@ 0x34
   18188:	e3530000 	cmp	r3, #0
   1818c:	0a00000d 	beq	181c8 <fgetc+0x60>
  _newlib_flockfile_start (fp);
  result = __sgetc_r (reent, fp);
   18190:	e5943004 	ldr	r3, [r4, #4]
   18194:	e2433001 	sub	r3, r3, #1
   18198:	e3530000 	cmp	r3, #0
   1819c:	e5843004 	str	r3, [r4, #4]
   181a0:	ba000004 	blt	181b8 <fgetc+0x50>
   181a4:	e5943000 	ldr	r3, [r4]
   181a8:	e2832001 	add	r2, r3, #1
   181ac:	e5842000 	str	r2, [r4]
  _newlib_flockfile_end (fp);
  return result;
#else
  return _fgetc_r (_REENT, fp);
#endif
}
   181b0:	e5d30000 	ldrb	r0, [r3]
   181b4:	e8bd8070 	pop	{r4, r5, r6, pc}
  result = __sgetc_r (reent, fp);
   181b8:	e1a01004 	mov	r1, r4
   181bc:	e1a00005 	mov	r0, r5
}
   181c0:	e8bd4070 	pop	{r4, r5, r6, lr}
  result = __sgetc_r (reent, fp);
   181c4:	ea0003e9 	b	19170 <__srget_r>
  CHECK_INIT(reent, fp);
   181c8:	e1a00005 	mov	r0, r5
   181cc:	eb0000c3 	bl	184e0 <__sinit>
   181d0:	eaffffee 	b	18190 <fgetc+0x28>

000181d4 <fileno>:
#include <errno.h>
#include "local.h"

int
fileno (FILE * f)
{
   181d4:	e92d4070 	push	{r4, r5, r6, lr}
  int result;
  CHECK_INIT (_REENT, f);
   181d8:	e30b51e8 	movw	r5, #45544	@ 0xb1e8
   181dc:	e3405002 	movt	r5, #2
{
   181e0:	e1a04000 	mov	r4, r0
  CHECK_INIT (_REENT, f);
   181e4:	e5950000 	ldr	r0, [r5]
   181e8:	e3500000 	cmp	r0, #0
   181ec:	0a000002 	beq	181fc <fileno+0x28>
   181f0:	e5903034 	ldr	r3, [r0, #52]	@ 0x34
   181f4:	e3530000 	cmp	r3, #0
   181f8:	0a000007 	beq	1821c <fileno+0x48>
  _newlib_flockfile_start (f);
  if (f->_flags)
   181fc:	e1d430fc 	ldrsh	r3, [r4, #12]
   18200:	e3530000 	cmp	r3, #0
    result = __sfileno (f);
  else
    {
      result = -1;
      _REENT_ERRNO(_REENT) = EBADF;
   18204:	05953000 	ldreq	r3, [r5]
   18208:	03a02009 	moveq	r2, #9
    result = __sfileno (f);
   1820c:	11d400fe 	ldrshne	r0, [r4, #14]
      result = -1;
   18210:	03e00000 	mvneq	r0, #0
      _REENT_ERRNO(_REENT) = EBADF;
   18214:	05832000 	streq	r2, [r3]
    }
  _newlib_flockfile_end (f);
  return result;
}
   18218:	e8bd8070 	pop	{r4, r5, r6, pc}
  CHECK_INIT (_REENT, f);
   1821c:	eb0000af 	bl	184e0 <__sinit>
   18220:	eafffff5 	b	181fc <fileno+0x28>

00018224 <__fp_lock>:
{
  if (!(fp->_flags2 & __SNLK))
    _flockfile (fp);

  return 0;
}
   18224:	e3a00000 	mov	r0, #0
   18228:	e12fff1e 	bx	lr

0001822c <stdio_exit_handler>:
  (void) _fwalk_sglue (_GLOBAL_REENT, CLEANUP_FILE, &__sglue);
   1822c:	e30b206c 	movw	r2, #45164	@ 0xb06c
   18230:	e3071c3c 	movw	r1, #31804	@ 0x7c3c
   18234:	e30b01f0 	movw	r0, #45552	@ 0xb1f0
   18238:	e3402002 	movt	r2, #2
   1823c:	e3401001 	movt	r1, #1
   18240:	e3400002 	movt	r0, #2
   18244:	ea0002a7 	b	18ce8 <_fwalk_sglue>

00018248 <cleanup_stdio>:
  if (_REENT_STDIN(ptr) != &__sf[0])
   18248:	e5901004 	ldr	r1, [r0, #4]
   1824c:	e30b3524 	movw	r3, #46372	@ 0xb524
   18250:	e3403002 	movt	r3, #2
{
   18254:	e92d4010 	push	{r4, lr}
   18258:	e1a04000 	mov	r4, r0
  if (_REENT_STDIN(ptr) != &__sf[0])
   1825c:	e1510003 	cmp	r1, r3
   18260:	0a000000 	beq	18268 <cleanup_stdio+0x20>
    CLEANUP_FILE (ptr, _REENT_STDIN(ptr));
   18264:	ebfffe74 	bl	17c3c <_fclose_r>
  if (_REENT_STDOUT(ptr) != &__sf[1])
   18268:	e5941008 	ldr	r1, [r4, #8]
   1826c:	e59f3028 	ldr	r3, [pc, #40]	@ 1829c <cleanup_stdio+0x54>
   18270:	e1510003 	cmp	r1, r3
   18274:	0a000001 	beq	18280 <cleanup_stdio+0x38>
    CLEANUP_FILE (ptr, _REENT_STDOUT(ptr));
   18278:	e1a00004 	mov	r0, r4
   1827c:	ebfffe6e 	bl	17c3c <_fclose_r>
  if (_REENT_STDERR(ptr) != &__sf[2])
   18280:	e594100c 	ldr	r1, [r4, #12]
   18284:	e59f3014 	ldr	r3, [pc, #20]	@ 182a0 <cleanup_stdio+0x58>
   18288:	e1510003 	cmp	r1, r3
   1828c:	08bd8010 	popeq	{r4, pc}
    CLEANUP_FILE (ptr, _REENT_STDERR(ptr));
   18290:	e1a00004 	mov	r0, r4
}
   18294:	e8bd4010 	pop	{r4, lr}
    CLEANUP_FILE (ptr, _REENT_STDERR(ptr));
   18298:	eafffe67 	b	17c3c <_fclose_r>
   1829c:	0002b58c 	.word	0x0002b58c
   182a0:	0002b5f4 	.word	0x0002b5f4

000182a4 <__fp_unlock>:

/* Walkable file unlocking routine.  */
static int
__fp_unlock (struct _reent * ptr __unused, FILE * fp)
   182a4:	e3a00000 	mov	r0, #0
   182a8:	e12fff1e 	bx	lr

000182ac <global_stdio_init.part.0>:
global_stdio_init (void)
   182ac:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    __stdio_exit_handler = stdio_exit_handler;
   182b0:	e30b4524 	movw	r4, #46372	@ 0xb524
   182b4:	e3404002 	movt	r4, #2
  ptr->_p = 0;
   182b8:	e3a05000 	mov	r5, #0
  ptr->_flags = flags;
   182bc:	e3a01004 	mov	r1, #4
    __stdio_exit_handler = stdio_exit_handler;
   182c0:	e308322c 	movw	r3, #33324	@ 0x822c
   182c4:	e3403001 	movt	r3, #1
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   182c8:	e3a02008 	mov	r2, #8
  ptr->_flags = flags;
   182cc:	e584100c 	str	r1, [r4, #12]
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   182d0:	e284005c 	add	r0, r4, #92	@ 0x5c
   182d4:	e1a01005 	mov	r1, r5
    __stdio_exit_handler = stdio_exit_handler;
   182d8:	e5843138 	str	r3, [r4, #312]	@ 0x138
  ptr->_read = __sread;
   182dc:	e3099700 	movw	r9, #38656	@ 0x9700
  ptr->_write = __swrite;
   182e0:	e3098738 	movw	r8, #38712	@ 0x9738
  ptr->_seek = __sseek;
   182e4:	e3097790 	movw	r7, #38800	@ 0x9790
  ptr->_close = __sclose;
   182e8:	e30967bc 	movw	r6, #38844	@ 0x97bc
  ptr->_p = 0;
   182ec:	e5845000 	str	r5, [r4]
  ptr->_read = __sread;
   182f0:	e3409001 	movt	r9, #1
  ptr->_r = 0;
   182f4:	e5845004 	str	r5, [r4, #4]
  ptr->_write = __swrite;
   182f8:	e3408001 	movt	r8, #1
  ptr->_w = 0;
   182fc:	e5845008 	str	r5, [r4, #8]
  ptr->_seek = __sseek;
   18300:	e3407001 	movt	r7, #1
  ptr->_flags2 = 0;
   18304:	e5845064 	str	r5, [r4, #100]	@ 0x64
  ptr->_close = __sclose;
   18308:	e3406001 	movt	r6, #1
  ptr->_bf._base = 0;
   1830c:	e5845010 	str	r5, [r4, #16]
  ptr->_bf._size = 0;
   18310:	e5845014 	str	r5, [r4, #20]
  ptr->_lbfsize = 0;
   18314:	e5845018 	str	r5, [r4, #24]
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   18318:	eb0008e4 	bl	1a6b0 <memset>
  ptr->_flags = flags;
   1831c:	e3a03009 	mov	r3, #9
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   18320:	e3a02008 	mov	r2, #8
  ptr->_flags = flags;
   18324:	e3403001 	movt	r3, #1
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   18328:	e1a01005 	mov	r1, r5
   1832c:	e28400c4 	add	r0, r4, #196	@ 0xc4
  ptr->_flags = flags;
   18330:	e5843074 	str	r3, [r4, #116]	@ 0x74
  ptr->_cookie = ptr;
   18334:	e584401c 	str	r4, [r4, #28]
  ptr->_read = __sread;
   18338:	e5849020 	str	r9, [r4, #32]
  ptr->_write = __swrite;
   1833c:	e5848024 	str	r8, [r4, #36]	@ 0x24
  ptr->_seek = __sseek;
   18340:	e5847028 	str	r7, [r4, #40]	@ 0x28
  ptr->_p = 0;
   18344:	e5845068 	str	r5, [r4, #104]	@ 0x68
  ptr->_r = 0;
   18348:	e584506c 	str	r5, [r4, #108]	@ 0x6c
  ptr->_w = 0;
   1834c:	e5845070 	str	r5, [r4, #112]	@ 0x70
  ptr->_flags2 = 0;
   18350:	e58450cc 	str	r5, [r4, #204]	@ 0xcc
  ptr->_bf._base = 0;
   18354:	e5845078 	str	r5, [r4, #120]	@ 0x78
  ptr->_bf._size = 0;
   18358:	e584507c 	str	r5, [r4, #124]	@ 0x7c
  ptr->_lbfsize = 0;
   1835c:	e5845080 	str	r5, [r4, #128]	@ 0x80
  ptr->_close = __sclose;
   18360:	e584602c 	str	r6, [r4, #44]	@ 0x2c
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   18364:	eb0008d1 	bl	1a6b0 <memset>
  ptr->_flags = flags;
   18368:	e3a03012 	mov	r3, #18
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   1836c:	e1a01005 	mov	r1, r5
  ptr->_flags = flags;
   18370:	e3403002 	movt	r3, #2
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   18374:	e3a02008 	mov	r2, #8
  ptr->_flags = flags;
   18378:	e58430dc 	str	r3, [r4, #220]	@ 0xdc
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   1837c:	e2840f4b 	add	r0, r4, #300	@ 0x12c
  ptr->_cookie = ptr;
   18380:	e2843068 	add	r3, r4, #104	@ 0x68
  ptr->_read = __sread;
   18384:	e5849088 	str	r9, [r4, #136]	@ 0x88
  ptr->_cookie = ptr;
   18388:	e5843084 	str	r3, [r4, #132]	@ 0x84
  ptr->_write = __swrite;
   1838c:	e584808c 	str	r8, [r4, #140]	@ 0x8c
  ptr->_seek = __sseek;
   18390:	e5847090 	str	r7, [r4, #144]	@ 0x90
  ptr->_close = __sclose;
   18394:	e5846094 	str	r6, [r4, #148]	@ 0x94
  ptr->_p = 0;
   18398:	e58450d0 	str	r5, [r4, #208]	@ 0xd0
  ptr->_r = 0;
   1839c:	e58450d4 	str	r5, [r4, #212]	@ 0xd4
  ptr->_w = 0;
   183a0:	e58450d8 	str	r5, [r4, #216]	@ 0xd8
  ptr->_flags2 = 0;
   183a4:	e5845134 	str	r5, [r4, #308]	@ 0x134
  ptr->_bf._base = 0;
   183a8:	e58450e0 	str	r5, [r4, #224]	@ 0xe0
  ptr->_bf._size = 0;
   183ac:	e58450e4 	str	r5, [r4, #228]	@ 0xe4
  ptr->_lbfsize = 0;
   183b0:	e58450e8 	str	r5, [r4, #232]	@ 0xe8
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   183b4:	eb0008bd 	bl	1a6b0 <memset>
  ptr->_cookie = ptr;
   183b8:	e28430d0 	add	r3, r4, #208	@ 0xd0
  ptr->_read = __sread;
   183bc:	e58490f0 	str	r9, [r4, #240]	@ 0xf0
  ptr->_write = __swrite;
   183c0:	e58480f4 	str	r8, [r4, #244]	@ 0xf4
  ptr->_seek = __sseek;
   183c4:	e58470f8 	str	r7, [r4, #248]	@ 0xf8
  ptr->_close = __sclose;
   183c8:	e58460fc 	str	r6, [r4, #252]	@ 0xfc
  ptr->_cookie = ptr;
   183cc:	e58430ec 	str	r3, [r4, #236]	@ 0xec
}
   183d0:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}

000183d4 <__sfp>:
  if (__stdio_exit_handler == NULL) {
   183d4:	e30b3524 	movw	r3, #46372	@ 0xb524
{
   183d8:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  if (__stdio_exit_handler == NULL) {
   183dc:	e3403002 	movt	r3, #2
{
   183e0:	e1a06000 	mov	r6, r0
  if (__stdio_exit_handler == NULL) {
   183e4:	e5933138 	ldr	r3, [r3, #312]	@ 0x138
   183e8:	e3530000 	cmp	r3, #0
   183ec:	0a000035 	beq	184c8 <__sfp+0xf4>
{
   183f0:	e30b706c 	movw	r7, #45164	@ 0xb06c
   183f4:	e3407002 	movt	r7, #2
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   183f8:	e9970018 	ldmib	r7, {r3, r4}
   183fc:	e2533001 	subs	r3, r3, #1
   18400:	5a000003 	bpl	18414 <__sfp+0x40>
   18404:	ea00001a 	b	18474 <__sfp+0xa0>
   18408:	e3730001 	cmn	r3, #1
   1840c:	e2844068 	add	r4, r4, #104	@ 0x68
   18410:	0a000017 	beq	18474 <__sfp+0xa0>
	if (fp->_flags == 0)
   18414:	e1d450fc 	ldrsh	r5, [r4, #12]
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   18418:	e2433001 	sub	r3, r3, #1
	if (fp->_flags == 0)
   1841c:	e3550000 	cmp	r5, #0
   18420:	1afffff8 	bne	18408 <__sfp+0x34>
  fp->_flags = 1;		/* reserve this slot; caller sets real flags */
   18424:	e3a03001 	mov	r3, #1
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
   18428:	e3a02008 	mov	r2, #8
  fp->_flags = 1;		/* reserve this slot; caller sets real flags */
   1842c:	e34f3fff 	movt	r3, #65535	@ 0xffff
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
   18430:	e1a01005 	mov	r1, r5
   18434:	e284005c 	add	r0, r4, #92	@ 0x5c
  fp->_flags = 1;		/* reserve this slot; caller sets real flags */
   18438:	e584300c 	str	r3, [r4, #12]
  fp->_flags2 = 0;
   1843c:	e5845064 	str	r5, [r4, #100]	@ 0x64
  fp->_p = NULL;		/* no current pointer */
   18440:	e5845000 	str	r5, [r4]
  fp->_w = 0;			/* nothing to read or write */
   18444:	e5845008 	str	r5, [r4, #8]
  fp->_r = 0;
   18448:	e5845004 	str	r5, [r4, #4]
  fp->_bf._base = NULL;		/* no buffer */
   1844c:	e5845010 	str	r5, [r4, #16]
  fp->_bf._size = 0;
   18450:	e5845014 	str	r5, [r4, #20]
  fp->_lbfsize = 0;		/* not line buffered */
   18454:	e5845018 	str	r5, [r4, #24]
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
   18458:	eb000894 	bl	1a6b0 <memset>
  fp->_ub._base = NULL;		/* no ungetc buffer */
   1845c:	e5845030 	str	r5, [r4, #48]	@ 0x30
  fp->_ub._size = 0;
   18460:	e5845034 	str	r5, [r4, #52]	@ 0x34
  fp->_lb._base = NULL;		/* no line buffer */
   18464:	e5845044 	str	r5, [r4, #68]	@ 0x44
  fp->_lb._size = 0;
   18468:	e5845048 	str	r5, [r4, #72]	@ 0x48
}
   1846c:	e1a00004 	mov	r0, r4
   18470:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
      if (g->_next == NULL &&
   18474:	e5975000 	ldr	r5, [r7]
   18478:	e3550000 	cmp	r5, #0
   1847c:	0a000001 	beq	18488 <__sfp+0xb4>
  for (g = &__sglue;; g = g->_next)
   18480:	e1a07005 	mov	r7, r5
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   18484:	eaffffdb 	b	183f8 <__sfp+0x24>
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
   18488:	e3a01f6b 	mov	r1, #428	@ 0x1ac
   1848c:	e1a00006 	mov	r0, r6
   18490:	eb001c2b 	bl	1f544 <_malloc_r>
  if (g == NULL)
   18494:	e2504000 	subs	r4, r0, #0
   18498:	0a00000c 	beq	184d0 <__sfp+0xfc>
  g->glue._niobs = n;
   1849c:	e3a03004 	mov	r3, #4
  g->glue._iobs = &g->file;
   184a0:	e284000c 	add	r0, r4, #12
  memset (&g->file, 0, n * sizeof (FILE));
   184a4:	e1a01005 	mov	r1, r5
  g->glue._next = NULL;
   184a8:	e5845000 	str	r5, [r4]
  memset (&g->file, 0, n * sizeof (FILE));
   184ac:	e3a02e1a 	mov	r2, #416	@ 0x1a0
  g->glue._niobs = n;
   184b0:	e5843004 	str	r3, [r4, #4]
  g->glue._iobs = &g->file;
   184b4:	e5840008 	str	r0, [r4, #8]
  return &g->glue;
   184b8:	e1a05004 	mov	r5, r4
  memset (&g->file, 0, n * sizeof (FILE));
   184bc:	eb00087b 	bl	1a6b0 <memset>
	  (g->_next = sfmoreglue (d, NDYNAMIC)) == NULL)
   184c0:	e5874000 	str	r4, [r7]
   184c4:	eaffffed 	b	18480 <__sfp+0xac>
   184c8:	ebffff77 	bl	182ac <global_stdio_init.part.0>
   184cc:	eaffffc7 	b	183f0 <__sfp+0x1c>
  _REENT_ERRNO(d) = ENOMEM;
   184d0:	e3a0300c 	mov	r3, #12
	  (g->_next = sfmoreglue (d, NDYNAMIC)) == NULL)
   184d4:	e5874000 	str	r4, [r7]
  _REENT_ERRNO(d) = ENOMEM;
   184d8:	e5863000 	str	r3, [r6]
  return NULL;
   184dc:	eaffffe2 	b	1846c <__sfp+0x98>

000184e0 <__sinit>:
  if (_REENT_CLEANUP(s))
   184e0:	e5903034 	ldr	r3, [r0, #52]	@ 0x34
   184e4:	e3530000 	cmp	r3, #0
   184e8:	112fff1e 	bxne	lr
  if (__stdio_exit_handler == NULL) {
   184ec:	e30b2524 	movw	r2, #46372	@ 0xb524
  _REENT_CLEANUP(s) = cleanup_stdio;	/* conservative */
   184f0:	e3083248 	movw	r3, #33352	@ 0x8248
  if (__stdio_exit_handler == NULL) {
   184f4:	e3402002 	movt	r2, #2
  _REENT_CLEANUP(s) = cleanup_stdio;	/* conservative */
   184f8:	e3403001 	movt	r3, #1
  if (__stdio_exit_handler == NULL) {
   184fc:	e5922138 	ldr	r2, [r2, #312]	@ 0x138
  _REENT_CLEANUP(s) = cleanup_stdio;	/* conservative */
   18500:	e5803034 	str	r3, [r0, #52]	@ 0x34
  if (__stdio_exit_handler == NULL) {
   18504:	e3520000 	cmp	r2, #0
   18508:	112fff1e 	bxne	lr
   1850c:	eaffff66 	b	182ac <global_stdio_init.part.0>

00018510 <__sfp_lock_acquire>:
}
   18510:	e12fff1e 	bx	lr

00018514 <__sfp_lock_release>:
__sfp_lock_release (void)
   18514:	e12fff1e 	bx	lr

00018518 <__fp_lock_all>:

void
__fp_lock_all (void)
{
  __sfp_lock_acquire ();
  (void) _fwalk_sglue (NULL, __fp_lock, &__sglue);
   18518:	e30b206c 	movw	r2, #45164	@ 0xb06c
   1851c:	e3081224 	movw	r1, #33316	@ 0x8224
   18520:	e3402002 	movt	r2, #2
   18524:	e3401001 	movt	r1, #1
   18528:	e3a00000 	mov	r0, #0
   1852c:	ea0001ed 	b	18ce8 <_fwalk_sglue>

00018530 <__fp_unlock_all>:
}

void
__fp_unlock_all (void)
{
  (void) _fwalk_sglue (NULL, __fp_unlock, &__sglue);
   18530:	e30b206c 	movw	r2, #45164	@ 0xb06c
   18534:	e30812a4 	movw	r1, #33444	@ 0x82a4
   18538:	e3402002 	movt	r2, #2
   1853c:	e3401001 	movt	r1, #1
   18540:	e3a00000 	mov	r0, #0
   18544:	ea0001e7 	b	18ce8 <_fwalk_sglue>

00018548 <__sflags>:

int
__sflags (struct _reent *ptr,
       register char *mode,
       int *optr)
{
   18548:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
  register int ret, m, o;

  switch (mode[0])
   1854c:	e5d13000 	ldrb	r3, [r1]
   18550:	e3530072 	cmp	r3, #114	@ 0x72
   18554:	0a000021 	beq	185e0 <__sflags+0x98>
   18558:	e3530077 	cmp	r3, #119	@ 0x77
   1855c:	0a000006 	beq	1857c <__sflags+0x34>
   18560:	e3530061 	cmp	r3, #97	@ 0x61
   18564:	0a000021 	beq	185f0 <__sflags+0xa8>
   18568:	e1a0c000 	mov	ip, r0
      ret = __SWR | __SAPP;
      m = O_WRONLY;
      o = O_CREAT | O_APPEND;
      break;
    default:			/* illegal mode */
      _REENT_ERRNO(ptr) = EINVAL;
   1856c:	e3a03016 	mov	r3, #22
      return (0);
   18570:	e3a00000 	mov	r0, #0
      _REENT_ERRNO(ptr) = EINVAL;
   18574:	e58c3000 	str	r3, [ip]
      return (0);
   18578:	e49df004 	pop	{pc}		@ (ldr pc, [sp], #4)
  switch (mode[0])
   1857c:	e3a0ec06 	mov	lr, #1536	@ 0x600
   18580:	e3a0c001 	mov	ip, #1
   18584:	e3a00008 	mov	r0, #8
    }
  while (*++mode)
   18588:	e5d13001 	ldrb	r3, [r1, #1]
   1858c:	e2811001 	add	r1, r1, #1
   18590:	e3530000 	cmp	r3, #0
   18594:	1a000005 	bne	185b0 <__sflags+0x68>
   18598:	ea00000d 	b	185d4 <__sflags+0x8c>
    {
      switch (*mode)
   1859c:	e3530078 	cmp	r3, #120	@ 0x78
  while (*++mode)
   185a0:	e5f13001 	ldrb	r3, [r1, #1]!
	case 'e':
	  m |= O_CLOEXEC;
	  break;
#endif
	case 'x':
	  m |= O_EXCL;
   185a4:	038ccb02 	orreq	ip, ip, #2048	@ 0x800
  while (*++mode)
   185a8:	e3530000 	cmp	r3, #0
   185ac:	0a000008 	beq	185d4 <__sflags+0x8c>
      switch (*mode)
   185b0:	e353002b 	cmp	r3, #43	@ 0x2b
   185b4:	1afffff8 	bne	1859c <__sflags+0x54>
  while (*++mode)
   185b8:	e5f13001 	ldrb	r3, [r1, #1]!
	  ret = (ret & ~(__SRD | __SWR)) | __SRW;
   185bc:	e3c0001c 	bic	r0, r0, #28
	  m = (m & ~O_ACCMODE) | O_RDWR;
   185c0:	e3ccc003 	bic	ip, ip, #3
	  ret = (ret & ~(__SRD | __SWR)) | __SRW;
   185c4:	e3800010 	orr	r0, r0, #16
	  m = (m & ~O_ACCMODE) | O_RDWR;
   185c8:	e38cc002 	orr	ip, ip, #2
  while (*++mode)
   185cc:	e3530000 	cmp	r3, #0
   185d0:	1afffff6 	bne	185b0 <__sflags+0x68>
	  break;
	default:
	  break;
	}
    }
  *optr = m | o;
   185d4:	e18ee00c 	orr	lr, lr, ip
   185d8:	e582e000 	str	lr, [r2]
  return ret;
}
   185dc:	e49df004 	pop	{pc}		@ (ldr pc, [sp], #4)
      o = 0;
   185e0:	e3a0e000 	mov	lr, #0
      ret = __SRD;
   185e4:	e3a00004 	mov	r0, #4
      m = O_RDONLY;
   185e8:	e1a0c00e 	mov	ip, lr
   185ec:	eaffffe5 	b	18588 <__sflags+0x40>
      o = O_CREAT | O_APPEND;
   185f0:	e3a0ef82 	mov	lr, #520	@ 0x208
      m = O_WRONLY;
   185f4:	e3a0c001 	mov	ip, #1
      ret = __SWR | __SAPP;
   185f8:	e3a00f42 	mov	r0, #264	@ 0x108
   185fc:	eaffffe1 	b	18588 <__sflags+0x40>

00018600 <_fopen_r>:

FILE *
_fopen_r (struct _reent *ptr,
       const char *__restrict file,
       const char *__restrict mode)
{
   18600:	e92d40f0 	push	{r4, r5, r6, r7, lr}
   18604:	e1a0c002 	mov	ip, r2
   18608:	e24dd00c 	sub	sp, sp, #12
   1860c:	e1a07001 	mov	r7, r1
  register FILE *fp;
  register int f;
  int flags, oflags;

  if ((flags = __sflags (ptr, mode, &oflags)) == 0)
   18610:	e28d2004 	add	r2, sp, #4
   18614:	e1a0100c 	mov	r1, ip
{
   18618:	e1a06000 	mov	r6, r0
  if ((flags = __sflags (ptr, mode, &oflags)) == 0)
   1861c:	ebffffc9 	bl	18548 <__sflags>
   18620:	e2505000 	subs	r5, r0, #0
   18624:	0a00002a 	beq	186d4 <_fopen_r+0xd4>
    return NULL;
  if ((fp = __sfp (ptr)) == NULL)
   18628:	e1a00006 	mov	r0, r6
   1862c:	ebffff68 	bl	183d4 <__sfp>
   18630:	e2504000 	subs	r4, r0, #0
   18634:	0a000026 	beq	186d4 <_fopen_r+0xd4>
    return NULL;

  if ((f = _open_r (ptr, file, oflags, 0666)) < 0)
   18638:	e59d2004 	ldr	r2, [sp, #4]
   1863c:	e30031b6 	movw	r3, #438	@ 0x1b6
   18640:	e1a01007 	mov	r1, r7
   18644:	e1a00006 	mov	r0, r6
   18648:	eb000c2d 	bl	1b704 <_open_r>
   1864c:	e3500000 	cmp	r0, #0
   18650:	ba00001b 	blt	186c4 <_fopen_r+0xc4>
    }

  _newlib_flockfile_start (fp);

  fp->_file = f;
  fp->_flags = flags;
   18654:	e6bf3075 	sxth	r3, r5
  fp->_cookie = (void *) fp;
  fp->_read = __sread;
   18658:	e3091700 	movw	r1, #38656	@ 0x9700
  fp->_write = __swrite;
  fp->_seek = __sseek;
   1865c:	e3092790 	movw	r2, #38800	@ 0x9790
  fp->_file = f;
   18660:	e1c400be 	strh	r0, [r4, #14]
  fp->_close = __sclose;

  if (fp->_flags & __SAPP)
   18664:	e3130c01 	tst	r3, #256	@ 0x100
  fp->_flags = flags;
   18668:	e1c430bc 	strh	r3, [r4, #12]
  fp->_write = __swrite;
   1866c:	e3093738 	movw	r3, #38712	@ 0x9738
  fp->_read = __sread;
   18670:	e3401001 	movt	r1, #1
  fp->_write = __swrite;
   18674:	e3403001 	movt	r3, #1
  fp->_seek = __sseek;
   18678:	e3402001 	movt	r2, #1
  fp->_write = __swrite;
   1867c:	e5843024 	str	r3, [r4, #36]	@ 0x24
  fp->_close = __sclose;
   18680:	e30937bc 	movw	r3, #38844	@ 0x97bc
   18684:	e3403001 	movt	r3, #1
  fp->_cookie = (void *) fp;
   18688:	e584401c 	str	r4, [r4, #28]
  fp->_read = __sread;
   1868c:	e5841020 	str	r1, [r4, #32]
  fp->_close = __sclose;
   18690:	e1c422f8 	strd	r2, [r4, #40]	@ 0x28
  if (fp->_flags & __SAPP)
   18694:	1a000002 	bne	186a4 <_fopen_r+0xa4>
    fp->_flags |= __SCLE;
#endif

  _newlib_flockfile_end (fp);
  return fp;
}
   18698:	e1a00004 	mov	r0, r4
   1869c:	e28dd00c 	add	sp, sp, #12
   186a0:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    _fseek_r (ptr, fp, 0, SEEK_END);
   186a4:	e3a03002 	mov	r3, #2
   186a8:	e3a02000 	mov	r2, #0
   186ac:	e1a01004 	mov	r1, r4
   186b0:	e1a00006 	mov	r0, r6
   186b4:	eb000052 	bl	18804 <_fseek_r>
}
   186b8:	e1a00004 	mov	r0, r4
   186bc:	e28dd00c 	add	sp, sp, #12
   186c0:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
      _newlib_sfp_lock_start (); 
   186c4:	ebffff91 	bl	18510 <__sfp_lock_acquire>
      fp->_flags = 0;		/* release */
   186c8:	e3a03000 	mov	r3, #0
   186cc:	e1c430bc 	strh	r3, [r4, #12]
      _newlib_sfp_lock_end (); 
   186d0:	ebffff8f 	bl	18514 <__sfp_lock_release>
    return NULL;
   186d4:	e3a04000 	mov	r4, #0
   186d8:	eaffffee 	b	18698 <_fopen_r+0x98>

000186dc <fopen>:

FILE *
fopen (const char *file,
       const char *mode)
{
  return _fopen_r (_REENT, file, mode);
   186dc:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
{
   186e0:	e1a0c000 	mov	ip, r0
  return _fopen_r (_REENT, file, mode);
   186e4:	e3403002 	movt	r3, #2
{
   186e8:	e1a02001 	mov	r2, r1
  return _fopen_r (_REENT, file, mode);
   186ec:	e5930000 	ldr	r0, [r3]
   186f0:	e1a0100c 	mov	r1, ip
   186f4:	eaffffc1 	b	18600 <_fopen_r>

000186f8 <_fprintf_r>:

int
_fprintf_r (struct _reent *ptr,
       FILE *__restrict fp,
       const char *__restrict fmt, ...)
{
   186f8:	e92d000c 	push	{r2, r3}
   186fc:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
   18700:	e24dd00c 	sub	sp, sp, #12
  int ret;
  va_list ap;

  va_start (ap, fmt);
   18704:	e28d3014 	add	r3, sp, #20
  ret = _vfprintf_r (ptr, fp, fmt, ap);
   18708:	e59d2010 	ldr	r2, [sp, #16]
  va_start (ap, fmt);
   1870c:	e58d3004 	str	r3, [sp, #4]
  ret = _vfprintf_r (ptr, fp, fmt, ap);
   18710:	eb002986 	bl	22d30 <_vfprintf_r>
  va_end (ap);
  return ret;
}
   18714:	e28dd00c 	add	sp, sp, #12
   18718:	e49de004 	pop	{lr}		@ (ldr lr, [sp], #4)
   1871c:	e28dd008 	add	sp, sp, #8
   18720:	e12fff1e 	bx	lr

00018724 <fprintf>:
{
  int ret;
  va_list ap;

  va_start (ap, fmt);
  ret = _vfprintf_r (_REENT, fp, fmt, ap);
   18724:	e30bc1e8 	movw	ip, #45544	@ 0xb1e8
{
   18728:	e92d000e 	push	{r1, r2, r3}
  ret = _vfprintf_r (_REENT, fp, fmt, ap);
   1872c:	e340c002 	movt	ip, #2
{
   18730:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
   18734:	e24dd008 	sub	sp, sp, #8
   18738:	e1a01000 	mov	r1, r0
  va_start (ap, fmt);
   1873c:	e28d3010 	add	r3, sp, #16
  ret = _vfprintf_r (_REENT, fp, fmt, ap);
   18740:	e59d200c 	ldr	r2, [sp, #12]
   18744:	e59c0000 	ldr	r0, [ip]
  va_start (ap, fmt);
   18748:	e58d3004 	str	r3, [sp, #4]
  ret = _vfprintf_r (_REENT, fp, fmt, ap);
   1874c:	eb002977 	bl	22d30 <_vfprintf_r>
  va_end (ap);
  return ret;
}
   18750:	e28dd008 	add	sp, sp, #8
   18754:	e49de004 	pop	{lr}		@ (ldr lr, [sp], #4)
   18758:	e28dd00c 	add	sp, sp, #12
   1875c:	e12fff1e 	bx	lr

00018760 <_fputc_r>:

int
_fputc_r (struct _reent *ptr,
       int ch,
       FILE * file)
{
   18760:	e92d4010 	push	{r4, lr}
  int result;
  CHECK_INIT(ptr, file);
   18764:	e2504000 	subs	r4, r0, #0
{
   18768:	e24dd008 	sub	sp, sp, #8
  CHECK_INIT(ptr, file);
   1876c:	0a000002 	beq	1877c <_fputc_r+0x1c>
   18770:	e5943034 	ldr	r3, [r4, #52]	@ 0x34
   18774:	e3530000 	cmp	r3, #0
   18778:	0a000003 	beq	1878c <_fputc_r+0x2c>
   _newlib_flockfile_start (file);
  result = _putc_r (ptr, ch, file);
   1877c:	e1a00004 	mov	r0, r4
  _newlib_flockfile_end (file);
  return result;
}
   18780:	e28dd008 	add	sp, sp, #8
   18784:	e8bd4010 	pop	{r4, lr}
  result = _putc_r (ptr, ch, file);
   18788:	ea000206 	b	18fa8 <_putc_r>
   1878c:	e88d0006 	stm	sp, {r1, r2}
  CHECK_INIT(ptr, file);
   18790:	ebffff52 	bl	184e0 <__sinit>
   18794:	e89d0006 	ldm	sp, {r1, r2}
  result = _putc_r (ptr, ch, file);
   18798:	e1a00004 	mov	r0, r4
}
   1879c:	e28dd008 	add	sp, sp, #8
   187a0:	e8bd4010 	pop	{r4, lr}
  result = _putc_r (ptr, ch, file);
   187a4:	ea0001ff 	b	18fa8 <_putc_r>

000187a8 <fputc>:
fputc (int ch,
       FILE * file)
{
#if !defined(__OPTIMIZE_SIZE__) && !defined(PREFER_SIZE_OVER_SPEED)
  int result;
  struct _reent *reent = _REENT;
   187a8:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
{
   187ac:	e92d4010 	push	{r4, lr}
  struct _reent *reent = _REENT;
   187b0:	e3403002 	movt	r3, #2
{
   187b4:	e1a04000 	mov	r4, r0
   187b8:	e24dd008 	sub	sp, sp, #8
   187bc:	e1a02001 	mov	r2, r1
  struct _reent *reent = _REENT;
   187c0:	e5930000 	ldr	r0, [r3]

  CHECK_INIT(reent, file);
   187c4:	e3500000 	cmp	r0, #0
   187c8:	0a000002 	beq	187d8 <fputc+0x30>
   187cc:	e5903034 	ldr	r3, [r0, #52]	@ 0x34
   187d0:	e3530000 	cmp	r3, #0
   187d4:	0a000003 	beq	187e8 <fputc+0x40>
   _newlib_flockfile_start (file);
  result = _putc_r (reent, ch, file);
   187d8:	e1a01004 	mov	r1, r4
  _newlib_flockfile_end (file);
  return result;
#else
  return _fputc_r (_REENT, ch, file);
#endif
}
   187dc:	e28dd008 	add	sp, sp, #8
   187e0:	e8bd4010 	pop	{r4, lr}
  result = _putc_r (reent, ch, file);
   187e4:	ea0001ef 	b	18fa8 <_putc_r>
  CHECK_INIT(reent, file);
   187e8:	e88d0005 	stm	sp, {r0, r2}
   187ec:	ebffff3b 	bl	184e0 <__sinit>
   187f0:	e89d0005 	ldm	sp, {r0, r2}
  result = _putc_r (reent, ch, file);
   187f4:	e1a01004 	mov	r1, r4
}
   187f8:	e28dd008 	add	sp, sp, #8
   187fc:	e8bd4010 	pop	{r4, lr}
  result = _putc_r (reent, ch, file);
   18800:	ea0001e8 	b	18fa8 <_putc_r>

00018804 <_fseek_r>:
_fseek_r (struct _reent *ptr,
       register FILE *fp,
       long offset,
       int whence)
{
  return _fseeko_r (ptr, fp, offset, whence);
   18804:	ea000491 	b	19a50 <_fseeko_r>

00018808 <fseek>:
int
fseek (register FILE *fp,
       long offset,
       int whence)
{
  return _fseek_r (_REENT, fp, offset, whence);
   18808:	e30bc1e8 	movw	ip, #45544	@ 0xb1e8
{
   1880c:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
  return _fseek_r (_REENT, fp, offset, whence);
   18810:	e340c002 	movt	ip, #2
{
   18814:	e1a0e000 	mov	lr, r0
   18818:	e1a03002 	mov	r3, r2
  return _fseeko_r (ptr, fp, offset, whence);
   1881c:	e1a02001 	mov	r2, r1
   18820:	e59c0000 	ldr	r0, [ip]
   18824:	e1a0100e 	mov	r1, lr
}
   18828:	e49de004 	pop	{lr}		@ (ldr lr, [sp], #4)
  return _fseeko_r (ptr, fp, offset, whence);
   1882c:	ea000487 	b	19a50 <_fseeko_r>

00018830 <__sfvwrite_r>:
  register struct __siov *iov;
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
   18830:	e5923008 	ldr	r3, [r2, #8]
   18834:	e3530000 	cmp	r3, #0
   18838:	0a000096 	beq	18a98 <__sfvwrite_r+0x268>
{
   1883c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   18840:	e1a08002 	mov	r8, r2
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   18844:	e1d1e0fc 	ldrsh	lr, [r1, #12]
{
   18848:	e24dd00c 	sub	sp, sp, #12
   1884c:	e1a0b000 	mov	fp, r0
   18850:	e1a04001 	mov	r4, r1
  if (cantwrite (ptr, fp))
   18854:	e31e0008 	tst	lr, #8
   18858:	0a000026 	beq	188f8 <__sfvwrite_r+0xc8>
   1885c:	e5913010 	ldr	r3, [r1, #16]
   18860:	e3530000 	cmp	r3, #0
   18864:	0a000023 	beq	188f8 <__sfvwrite_r+0xc8>
	}
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
   18868:	e21e3002 	ands	r3, lr, #2
  iov = uio->uio_iov;
   1886c:	e5986000 	ldr	r6, [r8]
  if (fp->_flags & __SNBF)
   18870:	0a000029 	beq	1891c <__sfvwrite_r+0xec>
   18874:	e594a024 	ldr	sl, [r4, #36]	@ 0x24
  register const char *p = NULL;
   18878:	e3a07000 	mov	r7, #0
   1887c:	e594101c 	ldr	r1, [r4, #28]
       */
      do
	{
	  GETIOV (;);
	  w = fp->_write (ptr, fp->_cookie, p,
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
   18880:	e3a09b3f 	mov	r9, #64512	@ 0xfc00
   18884:	e3479fff 	movt	r9, #32767	@ 0x7fff
  len = 0;
   18888:	e1a05007 	mov	r5, r7
	  GETIOV (;);
   1888c:	e3550000 	cmp	r5, #0
	  w = fp->_write (ptr, fp->_cookie, p,
   18890:	e1a02007 	mov	r2, r7
   18894:	e1a0000b 	mov	r0, fp
	  GETIOV (;);
   18898:	0a000012 	beq	188e8 <__sfvwrite_r+0xb8>
	  w = fp->_write (ptr, fp->_cookie, p,
   1889c:	e1550009 	cmp	r5, r9
   188a0:	31a03005 	movcc	r3, r5
   188a4:	21a03009 	movcs	r3, r9
   188a8:	e12fff3a 	blx	sl
	  if (w <= 0)
   188ac:	e3500000 	cmp	r0, #0
	    goto err;
	  p += w;
   188b0:	e0877000 	add	r7, r7, r0
	  len -= w;
   188b4:	e0455000 	sub	r5, r5, r0
	  if (w <= 0)
   188b8:	da000070 	ble	18a80 <__sfvwrite_r+0x250>
	}
      while ((uio->uio_resid -= w) != 0);
   188bc:	e5983008 	ldr	r3, [r8, #8]
   188c0:	e0433000 	sub	r3, r3, r0
   188c4:	e3530000 	cmp	r3, #0
   188c8:	e5883008 	str	r3, [r8, #8]
   188cc:	0a000063 	beq	18a60 <__sfvwrite_r+0x230>
	  GETIOV (;);
   188d0:	e3550000 	cmp	r5, #0
   188d4:	e594a024 	ldr	sl, [r4, #36]	@ 0x24
   188d8:	e594101c 	ldr	r1, [r4, #28]
	  w = fp->_write (ptr, fp->_cookie, p,
   188dc:	e1a02007 	mov	r2, r7
   188e0:	e1a0000b 	mov	r0, fp
	  GETIOV (;);
   188e4:	1affffec 	bne	1889c <__sfvwrite_r+0x6c>
   188e8:	e5967000 	ldr	r7, [r6]
   188ec:	e2866008 	add	r6, r6, #8
   188f0:	e5165004 	ldr	r5, [r6, #-4]
   188f4:	eaffffe4 	b	1888c <__sfvwrite_r+0x5c>
  if (cantwrite (ptr, fp))
   188f8:	e1a01004 	mov	r1, r4
   188fc:	e1a0000b 	mov	r0, fp
   18900:	eb000401 	bl	1990c <__swsetup_r>
   18904:	e3500000 	cmp	r0, #0
   18908:	1a00005f 	bne	18a8c <__sfvwrite_r+0x25c>
  if (fp->_flags & __SNBF)
   1890c:	e1d4e0fc 	ldrsh	lr, [r4, #12]
  iov = uio->uio_iov;
   18910:	e5986000 	ldr	r6, [r8]
  if (fp->_flags & __SNBF)
   18914:	e21e3002 	ands	r3, lr, #2
   18918:	1affffd5 	bne	18874 <__sfvwrite_r+0x44>
    }
  else if ((fp->_flags & __SLBF) == 0)
   1891c:	e21e9001 	ands	r9, lr, #1
   18920:	1a00005e 	bne	18aa0 <__sfvwrite_r+0x270>
   18924:	e594c000 	ldr	ip, [r4]
  len = 0;
   18928:	e1a07009 	mov	r7, r9
   1892c:	e5943008 	ldr	r3, [r4, #8]
       * we are dealing with the asprintf routines, we will
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
   18930:	e3570000 	cmp	r7, #0
	  if (fp->_flags & __SSTR)
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
		{ /* must be asprintf family */
		  unsigned char *str;
		  int curpos = (fp->_p - fp->_bf._base);
   18934:	e1a0000c 	mov	r0, ip
	  w = fp->_w;
   18938:	e1a0a003 	mov	sl, r3
	  GETIOV (;);
   1893c:	0a000043 	beq	18a50 <__sfvwrite_r+0x220>
	  if (fp->_flags & __SSTR)
   18940:	e31e0c02 	tst	lr, #512	@ 0x200
   18944:	0a00008f 	beq	18b88 <__sfvwrite_r+0x358>
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
   18948:	e1530007 	cmp	r3, r7
   1894c:	e1a02003 	mov	r2, r3
   18950:	8a0000b6 	bhi	18c30 <__sfvwrite_r+0x400>
   18954:	e31e0d12 	tst	lr, #1152	@ 0x480
   18958:	0a000023 	beq	189ec <__sfvwrite_r+0x1bc>
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   1895c:	e5942014 	ldr	r2, [r4, #20]
		  int curpos = (fp->_p - fp->_bf._base);
   18960:	e5941010 	ldr	r1, [r4, #16]
		  int newsize = fp->_bf._size * 3 / 2;
   18964:	e0822082 	add	r2, r2, r2, lsl #1
		  int curpos = (fp->_p - fp->_bf._base);
   18968:	e04c5001 	sub	r5, ip, r1
		  if (newsize < curpos + len + 1)
   1896c:	e2853001 	add	r3, r5, #1
		  int newsize = fp->_bf._size * 3 / 2;
   18970:	e0822fa2 	add	r2, r2, r2, lsr #31
		  if (newsize < curpos + len + 1)
   18974:	e0833007 	add	r3, r3, r7
		  int newsize = fp->_bf._size * 3 / 2;
   18978:	e1a020c2 	asr	r2, r2, #1
		    newsize = curpos + len + 1;
   1897c:	e1530002 	cmp	r3, r2
   18980:	91a0a002 	movls	sl, r2
   18984:	81a0a003 	movhi	sl, r3
   18988:	81a02003 	movhi	r2, r3
		  if (fp->_flags & __SOPT)
   1898c:	e31e0b01 	tst	lr, #1024	@ 0x400
   18990:	0a0000c1 	beq	18c9c <__sfvwrite_r+0x46c>
		    {
		      /* asnprintf leaves original buffer alone.  */
		      str = (unsigned char *)_malloc_r (ptr, newsize);
   18994:	e1a01002 	mov	r1, r2
   18998:	e1a0000b 	mov	r0, fp
   1899c:	eb001ae8 	bl	1f544 <_malloc_r>
		      if (!str)
   189a0:	e2503000 	subs	r3, r0, #0
   189a4:	0a0000cb 	beq	18cd8 <__sfvwrite_r+0x4a8>
			{
			  _REENT_ERRNO(ptr) = ENOMEM;
			  goto err;
			}
		      memcpy (str, fp->_bf._base, curpos);
   189a8:	e1a02005 	mov	r2, r5
   189ac:	e5941010 	ldr	r1, [r4, #16]
   189b0:	e58d3004 	str	r3, [sp, #4]
   189b4:	eb001d31 	bl	1fe80 <memcpy>
		      fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
   189b8:	e1d420bc 	ldrh	r2, [r4, #12]
   189bc:	e59d3004 	ldr	r3, [sp, #4]
   189c0:	e3c22d12 	bic	r2, r2, #1152	@ 0x480
   189c4:	e3822080 	orr	r2, r2, #128	@ 0x80
   189c8:	e1c420bc 	strh	r2, [r4, #12]
		    }
		  fp->_bf._base = str;
		  fp->_p = str + curpos;
		  fp->_bf._size = newsize;
		  w = len;
		  fp->_w = newsize - curpos;
   189cc:	e04ac005 	sub	ip, sl, r5
		  fp->_bf._size = newsize;
   189d0:	e584a014 	str	sl, [r4, #20]
   189d4:	e1a02007 	mov	r2, r7
		  w = len;
   189d8:	e1a0a007 	mov	sl, r7
		  fp->_p = str + curpos;
   189dc:	e0830005 	add	r0, r3, r5
		  fp->_bf._base = str;
   189e0:	e5843010 	str	r3, [r4, #16]
		  fp->_w = newsize - curpos;
   189e4:	e584c008 	str	ip, [r4, #8]
		  fp->_p = str + curpos;
   189e8:	e5840000 	str	r0, [r4]
		}
	      if (len < w)
		w = len;
	      COPY (w);		/* copy MIN(fp->_w,len), */
   189ec:	e1a01009 	mov	r1, r9
   189f0:	e58d2004 	str	r2, [sp, #4]
   189f4:	eb0006d7 	bl	1a558 <memmove>
	      fp->_w -= w;
   189f8:	e5943008 	ldr	r3, [r4, #8]
   189fc:	e1a05007 	mov	r5, r7
	      fp->_p += w;
   18a00:	e594c000 	ldr	ip, [r4]
   18a04:	e3a07000 	mov	r7, #0
   18a08:	e59d2004 	ldr	r2, [sp, #4]
	      fp->_w -= w;
   18a0c:	e043a00a 	sub	sl, r3, sl
   18a10:	e584a008 	str	sl, [r4, #8]
	      fp->_p += w;
   18a14:	e08c2002 	add	r2, ip, r2
   18a18:	e5842000 	str	r2, [r4]
		goto err;
	    }
	  p += w;
	  len -= w;
	}
      while ((uio->uio_resid -= w) != 0);
   18a1c:	e5983008 	ldr	r3, [r8, #8]
	  p += w;
   18a20:	e0899005 	add	r9, r9, r5
      while ((uio->uio_resid -= w) != 0);
   18a24:	e0433005 	sub	r3, r3, r5
   18a28:	e3530000 	cmp	r3, #0
   18a2c:	e5883008 	str	r3, [r8, #8]
   18a30:	0a00000a 	beq	18a60 <__sfvwrite_r+0x230>
   18a34:	e594c000 	ldr	ip, [r4]
	  GETIOV (;);
   18a38:	e3570000 	cmp	r7, #0
   18a3c:	e5943008 	ldr	r3, [r4, #8]
	  if (fp->_flags & __SSTR)
   18a40:	e1d4e0fc 	ldrsh	lr, [r4, #12]
		  int curpos = (fp->_p - fp->_bf._base);
   18a44:	e1a0000c 	mov	r0, ip
	  w = fp->_w;
   18a48:	e1a0a003 	mov	sl, r3
	  GETIOV (;);
   18a4c:	1affffbb 	bne	18940 <__sfvwrite_r+0x110>
   18a50:	e5969000 	ldr	r9, [r6]
   18a54:	e2866008 	add	r6, r6, #8
   18a58:	e5167004 	ldr	r7, [r6, #-4]
   18a5c:	eaffffb3 	b	18930 <__sfvwrite_r+0x100>
    return 0;
   18a60:	e3a00000 	mov	r0, #0
  return 0;

err:
  fp->_flags |= __SERR;
  return EOF;
}
   18a64:	e28dd00c 	add	sp, sp, #12
   18a68:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
	      if (_fflush_r (ptr, fp))
   18a6c:	e1a01004 	mov	r1, r4
   18a70:	e1a0000b 	mov	r0, fp
   18a74:	ebfffd70 	bl	1803c <_fflush_r>
   18a78:	e3500000 	cmp	r0, #0
   18a7c:	0a000029 	beq	18b28 <__sfvwrite_r+0x2f8>
  fp->_flags |= __SERR;
   18a80:	e1d430fc 	ldrsh	r3, [r4, #12]
   18a84:	e3833040 	orr	r3, r3, #64	@ 0x40
   18a88:	e1c430bc 	strh	r3, [r4, #12]
    return EOF;
   18a8c:	e3e00000 	mvn	r0, #0
}
   18a90:	e28dd00c 	add	sp, sp, #12
   18a94:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return 0;
   18a98:	e3a00000 	mov	r0, #0
}
   18a9c:	e12fff1e 	bx	lr
      nldist = 0;
   18aa0:	e1a09003 	mov	r9, r3
      nlknown = 0;
   18aa4:	e1a00003 	mov	r0, r3
  register const char *p = NULL;
   18aa8:	e1a0a003 	mov	sl, r3
  len = 0;
   18aac:	e1a07003 	mov	r7, r3
   18ab0:	ea000023 	b	18b44 <__sfvwrite_r+0x314>
	  if (!nlknown)
   18ab4:	e3500000 	cmp	r0, #0
   18ab8:	0a000029 	beq	18b64 <__sfvwrite_r+0x334>
	  s = MIN (len, nldist);
   18abc:	e1a02009 	mov	r2, r9
	  if (fp->_p > fp->_bf._base && s > w)
   18ac0:	e5941010 	ldr	r1, [r4, #16]
	  s = MIN (len, nldist);
   18ac4:	e1570002 	cmp	r7, r2
	  w = fp->_w + fp->_bf._size;
   18ac8:	e5943014 	ldr	r3, [r4, #20]
	  s = MIN (len, nldist);
   18acc:	31a02007 	movcc	r2, r7
	  w = fp->_w + fp->_bf._size;
   18ad0:	e5945008 	ldr	r5, [r4, #8]
	  if (fp->_p > fp->_bf._base && s > w)
   18ad4:	e5940000 	ldr	r0, [r4]
	  w = fp->_w + fp->_bf._size;
   18ad8:	e0835005 	add	r5, r3, r5
	  if (fp->_p > fp->_bf._base && s > w)
   18adc:	e1500001 	cmp	r0, r1
   18ae0:	93a01000 	movls	r1, #0
   18ae4:	83a01001 	movhi	r1, #1
   18ae8:	e1520005 	cmp	r2, r5
   18aec:	d3a01000 	movle	r1, #0
   18af0:	e3510000 	cmp	r1, #0
   18af4:	1a00005c 	bne	18c6c <__sfvwrite_r+0x43c>
	  else if (s >= (w = fp->_bf._size))
   18af8:	e1530002 	cmp	r3, r2
   18afc:	ca00004e 	bgt	18c3c <__sfvwrite_r+0x40c>
	      w = fp->_write (ptr, fp->_cookie, p, w);
   18b00:	e5945024 	ldr	r5, [r4, #36]	@ 0x24
   18b04:	e1a0200a 	mov	r2, sl
   18b08:	e594101c 	ldr	r1, [r4, #28]
   18b0c:	e1a0000b 	mov	r0, fp
   18b10:	e12fff35 	blx	r5
	      if (w <= 0)
   18b14:	e2505000 	subs	r5, r0, #0
   18b18:	daffffd8 	ble	18a80 <__sfvwrite_r+0x250>
	  if ((nldist -= w) == 0)
   18b1c:	e0599005 	subs	r9, r9, r5
   18b20:	13a00001 	movne	r0, #1
   18b24:	0affffd0 	beq	18a6c <__sfvwrite_r+0x23c>
      while ((uio->uio_resid -= w) != 0);
   18b28:	e5983008 	ldr	r3, [r8, #8]
	  p += w;
   18b2c:	e08aa005 	add	sl, sl, r5
	  len -= w;
   18b30:	e0477005 	sub	r7, r7, r5
      while ((uio->uio_resid -= w) != 0);
   18b34:	e0433005 	sub	r3, r3, r5
   18b38:	e3530000 	cmp	r3, #0
   18b3c:	e5883008 	str	r3, [r8, #8]
   18b40:	0affffc6 	beq	18a60 <__sfvwrite_r+0x230>
	  GETIOV (nlknown = 0);
   18b44:	e3570000 	cmp	r7, #0
   18b48:	1affffd9 	bne	18ab4 <__sfvwrite_r+0x284>
   18b4c:	e5967004 	ldr	r7, [r6, #4]
   18b50:	e1a03006 	mov	r3, r6
   18b54:	e2866008 	add	r6, r6, #8
   18b58:	e3570000 	cmp	r7, #0
   18b5c:	0afffffa 	beq	18b4c <__sfvwrite_r+0x31c>
   18b60:	e593a000 	ldr	sl, [r3]
	      nl = memchr ((void *) p, '\n', len);
   18b64:	e1a02007 	mov	r2, r7
   18b68:	e3a0100a 	mov	r1, #10
   18b6c:	e1a0000a 	mov	r0, sl
   18b70:	fa001c92 	blx	1fdc0 <memchr>
	      nldist = nl ? nl + 1 - p : len + 1;
   18b74:	e3500000 	cmp	r0, #0
   18b78:	0a000053 	beq	18ccc <__sfvwrite_r+0x49c>
   18b7c:	e2800001 	add	r0, r0, #1
   18b80:	e040900a 	sub	r9, r0, sl
   18b84:	eaffffcc 	b	18abc <__sfvwrite_r+0x28c>
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
   18b88:	e5942010 	ldr	r2, [r4, #16]
   18b8c:	e152000c 	cmp	r2, ip
   18b90:	3a000011 	bcc	18bdc <__sfvwrite_r+0x3ac>
   18b94:	e5941014 	ldr	r1, [r4, #20]
   18b98:	e1510007 	cmp	r1, r7
   18b9c:	8a00000e 	bhi	18bdc <__sfvwrite_r+0x3ac>
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
   18ba0:	e3770106 	cmn	r7, #-2147483647	@ 0x80000001
   18ba4:	31a05007 	movcc	r5, r7
   18ba8:	23e05102 	mvncs	r5, #-2147483648	@ 0x80000000
   18bac:	e1a00005 	mov	r0, r5
   18bb0:	ebfff675 	bl	1658c <__aeabi_idivmod>
	      w = fp->_write (ptr, fp->_cookie, p, w);
   18bb4:	e1a02009 	mov	r2, r9
   18bb8:	e0453001 	sub	r3, r5, r1
   18bbc:	e1a0000b 	mov	r0, fp
   18bc0:	e5945024 	ldr	r5, [r4, #36]	@ 0x24
   18bc4:	e594101c 	ldr	r1, [r4, #28]
   18bc8:	e12fff35 	blx	r5
	      if (w <= 0)
   18bcc:	e2505000 	subs	r5, r0, #0
   18bd0:	daffffaa 	ble	18a80 <__sfvwrite_r+0x250>
	  len -= w;
   18bd4:	e0477005 	sub	r7, r7, r5
   18bd8:	eaffff8f 	b	18a1c <__sfvwrite_r+0x1ec>
	      w = MIN (len, w);
   18bdc:	e1530007 	cmp	r3, r7
	      COPY (w);
   18be0:	e1a0000c 	mov	r0, ip
	      w = MIN (len, w);
   18be4:	31a05003 	movcc	r5, r3
   18be8:	21a05007 	movcs	r5, r7
	      COPY (w);
   18bec:	e1a01009 	mov	r1, r9
   18bf0:	e1a02005 	mov	r2, r5
   18bf4:	eb000657 	bl	1a558 <memmove>
	      fp->_w -= w;
   18bf8:	e5943008 	ldr	r3, [r4, #8]
	      fp->_p += w;
   18bfc:	e594c000 	ldr	ip, [r4]
	      fp->_w -= w;
   18c00:	e0433005 	sub	r3, r3, r5
	      if (fp->_w == 0 && _fflush_r (ptr, fp))
   18c04:	e3530000 	cmp	r3, #0
	      fp->_p += w;
   18c08:	e08cc005 	add	ip, ip, r5
	      fp->_w -= w;
   18c0c:	e5843008 	str	r3, [r4, #8]
	      fp->_p += w;
   18c10:	e584c000 	str	ip, [r4]
	      if (fp->_w == 0 && _fflush_r (ptr, fp))
   18c14:	1affffee 	bne	18bd4 <__sfvwrite_r+0x3a4>
   18c18:	e1a01004 	mov	r1, r4
   18c1c:	e1a0000b 	mov	r0, fp
   18c20:	ebfffd05 	bl	1803c <_fflush_r>
   18c24:	e3500000 	cmp	r0, #0
   18c28:	0affffe9 	beq	18bd4 <__sfvwrite_r+0x3a4>
   18c2c:	eaffff93 	b	18a80 <__sfvwrite_r+0x250>
		w = len;
   18c30:	e1a0a007 	mov	sl, r7
   18c34:	e1a02007 	mov	r2, r7
   18c38:	eaffff6b 	b	189ec <__sfvwrite_r+0x1bc>
	      COPY (w);
   18c3c:	e1a0100a 	mov	r1, sl
   18c40:	e58d2004 	str	r2, [sp, #4]
   18c44:	eb000643 	bl	1a558 <memmove>
	      fp->_w -= w;
   18c48:	e59d2004 	ldr	r2, [sp, #4]
   18c4c:	e5943008 	ldr	r3, [r4, #8]
	      w = s;
   18c50:	e1a05002 	mov	r5, r2
	      fp->_w -= w;
   18c54:	e0433002 	sub	r3, r3, r2
   18c58:	e5843008 	str	r3, [r4, #8]
	      fp->_p += w;
   18c5c:	e5943000 	ldr	r3, [r4]
   18c60:	e0833002 	add	r3, r3, r2
   18c64:	e5843000 	str	r3, [r4]
   18c68:	eaffffab 	b	18b1c <__sfvwrite_r+0x2ec>
	      COPY (w);
   18c6c:	e1a02005 	mov	r2, r5
   18c70:	e1a0100a 	mov	r1, sl
   18c74:	eb000637 	bl	1a558 <memmove>
	      fp->_p += w;
   18c78:	e5943000 	ldr	r3, [r4]
	      if (_fflush_r (ptr, fp))
   18c7c:	e1a01004 	mov	r1, r4
   18c80:	e1a0000b 	mov	r0, fp
	      fp->_p += w;
   18c84:	e0833005 	add	r3, r3, r5
   18c88:	e5843000 	str	r3, [r4]
	      if (_fflush_r (ptr, fp))
   18c8c:	ebfffcea 	bl	1803c <_fflush_r>
   18c90:	e3500000 	cmp	r0, #0
   18c94:	0affffa0 	beq	18b1c <__sfvwrite_r+0x2ec>
   18c98:	eaffff78 	b	18a80 <__sfvwrite_r+0x250>
		      str = (unsigned char *)_realloc_r (ptr, fp->_bf._base,
   18c9c:	e1a0000b 	mov	r0, fp
   18ca0:	eb001a2b 	bl	1f554 <_realloc_r>
		      if (!str)
   18ca4:	e2503000 	subs	r3, r0, #0
   18ca8:	1affff47 	bne	189cc <__sfvwrite_r+0x19c>
			  _free_r (ptr, fp->_bf._base);
   18cac:	e5941010 	ldr	r1, [r4, #16]
   18cb0:	e1a0000b 	mov	r0, fp
   18cb4:	eb001a24 	bl	1f54c <_free_r>
			  fp->_flags &=  ~__SMBF;
   18cb8:	e1d430fc 	ldrsh	r3, [r4, #12]
			  _REENT_ERRNO(ptr) = ENOMEM;
   18cbc:	e3a0200c 	mov	r2, #12
   18cc0:	e58b2000 	str	r2, [fp]
			  fp->_flags &=  ~__SMBF;
   18cc4:	e3c33080 	bic	r3, r3, #128	@ 0x80
			  goto err;
   18cc8:	eaffff6d 	b	18a84 <__sfvwrite_r+0x254>
	      nldist = nl ? nl + 1 - p : len + 1;
   18ccc:	e2872001 	add	r2, r7, #1
   18cd0:	e1a09002 	mov	r9, r2
   18cd4:	eaffff79 	b	18ac0 <__sfvwrite_r+0x290>
			  _REENT_ERRNO(ptr) = ENOMEM;
   18cd8:	e3a0200c 	mov	r2, #12
  fp->_flags |= __SERR;
   18cdc:	e1d430fc 	ldrsh	r3, [r4, #12]
			  _REENT_ERRNO(ptr) = ENOMEM;
   18ce0:	e58b2000 	str	r2, [fp]
			  goto err;
   18ce4:	eaffff66 	b	18a84 <__sfvwrite_r+0x254>

00018ce8 <_fwalk_sglue>:
#include <errno.h>

int
_fwalk_sglue (struct _reent *ptr, int (*func) (struct _reent *, FILE *),
    struct _glue *g)
{
   18ce8:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
   18cec:	e1a07000 	mov	r7, r0
   18cf0:	e1a08001 	mov	r8, r1
   18cf4:	e1a06002 	mov	r6, r2
  FILE *fp;
  int n, ret = 0;
   18cf8:	e3a09000 	mov	r9, #0
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  do {
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   18cfc:	e5965004 	ldr	r5, [r6, #4]
   18d00:	e5964008 	ldr	r4, [r6, #8]
   18d04:	e2555001 	subs	r5, r5, #1
   18d08:	4a00000d 	bmi	18d44 <_fwalk_sglue+0x5c>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   18d0c:	e1d430bc 	ldrh	r3, [r4, #12]
   18d10:	e3530001 	cmp	r3, #1
   18d14:	9a000006 	bls	18d34 <_fwalk_sglue+0x4c>
   18d18:	e1d430fe 	ldrsh	r3, [r4, #14]
	ret |= (*func) (ptr, fp);
   18d1c:	e1a01004 	mov	r1, r4
   18d20:	e1a00007 	mov	r0, r7
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   18d24:	e3730001 	cmn	r3, #1
   18d28:	0a000001 	beq	18d34 <_fwalk_sglue+0x4c>
	ret |= (*func) (ptr, fp);
   18d2c:	e12fff38 	blx	r8
   18d30:	e1899000 	orr	r9, r9, r0
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   18d34:	e2455001 	sub	r5, r5, #1
   18d38:	e2844068 	add	r4, r4, #104	@ 0x68
   18d3c:	e3750001 	cmn	r5, #1
   18d40:	1afffff1 	bne	18d0c <_fwalk_sglue+0x24>
    g = g->_next;
   18d44:	e5966000 	ldr	r6, [r6]
  } while (g != NULL);
   18d48:	e3560000 	cmp	r6, #0
   18d4c:	1affffea 	bne	18cfc <_fwalk_sglue+0x14>

  return ret;
}
   18d50:	e1a00009 	mov	r0, r9
   18d54:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}

00018d58 <_fwrite_r>:
_fwrite_r (struct _reent * ptr,
       const void *__restrict buf,
       size_t size,
       size_t count,
       FILE * __restrict fp)
{
   18d58:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
#ifdef _FVWRITE_IN_STREAMIO
  struct __suio uio;
  struct __siov iov;

  iov.iov_base = buf;
  uio.uio_resid = iov.iov_len = n = count * size;
   18d5c:	e0080392 	mul	r8, r2, r3
{
   18d60:	e24dd018 	sub	sp, sp, #24
   18d64:	e1a04003 	mov	r4, r3
   * The usual case is success (__sfvwrite_r returns 0);
   * skip the divide if this happens, since divides are
   * generally slow and since this occurs whenever size==0.
   */

  CHECK_INIT(ptr, fp);
   18d68:	e2506000 	subs	r6, r0, #0
  uio.uio_iov = &iov;
   18d6c:	e28d3004 	add	r3, sp, #4
{
   18d70:	e59d5030 	ldr	r5, [sp, #48]	@ 0x30
  uio.uio_iov = &iov;
   18d74:	e58d300c 	str	r3, [sp, #12]
  uio.uio_iovcnt = 1;
   18d78:	e3a03001 	mov	r3, #1
{
   18d7c:	e1a07002 	mov	r7, r2
  iov.iov_base = buf;
   18d80:	e58d1004 	str	r1, [sp, #4]
  uio.uio_resid = iov.iov_len = n = count * size;
   18d84:	e58d8008 	str	r8, [sp, #8]
   18d88:	e58d8014 	str	r8, [sp, #20]
  uio.uio_iovcnt = 1;
   18d8c:	e58d3010 	str	r3, [sp, #16]
  CHECK_INIT(ptr, fp);
   18d90:	0a000002 	beq	18da0 <_fwrite_r+0x48>
   18d94:	e5963034 	ldr	r3, [r6, #52]	@ 0x34
   18d98:	e3530000 	cmp	r3, #0
   18d9c:	0a000018 	beq	18e04 <_fwrite_r+0xac>

  _newlib_flockfile_start (fp);
  if (ORIENT (fp, -1) != -1)
   18da0:	e1d5c0fc 	ldrsh	ip, [r5, #12]
  _newlib_flockfile_start (fp);
   18da4:	e5953064 	ldr	r3, [r5, #100]	@ 0x64
  if (ORIENT (fp, -1) != -1)
   18da8:	e31c0a02 	tst	ip, #8192	@ 0x2000
   18dac:	038cca02 	orreq	ip, ip, #8192	@ 0x2000
   18db0:	03c33a02 	biceq	r3, r3, #8192	@ 0x2000
   18db4:	01c5c0bc 	strheq	ip, [r5, #12]
   18db8:	05853064 	streq	r3, [r5, #100]	@ 0x64
   18dbc:	e3130a02 	tst	r3, #8192	@ 0x2000
    {
      _newlib_flockfile_exit (fp);
      return 0;
   18dc0:	13a00000 	movne	r0, #0
  if (ORIENT (fp, -1) != -1)
   18dc4:	0a000001 	beq	18dd0 <_fwrite_r+0x78>

ret:
  _newlib_flockfile_end (fp);
  return i / size;
#endif
}
   18dc8:	e28dd018 	add	sp, sp, #24
   18dcc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  if (__sfvwrite_r (ptr, fp, &uio) == 0)
   18dd0:	e1a01005 	mov	r1, r5
   18dd4:	e1a00006 	mov	r0, r6
   18dd8:	e28d200c 	add	r2, sp, #12
   18ddc:	ebfffe93 	bl	18830 <__sfvwrite_r>
   18de0:	e3500000 	cmp	r0, #0
      return count;
   18de4:	01a00004 	moveq	r0, r4
  if (__sfvwrite_r (ptr, fp, &uio) == 0)
   18de8:	0afffff6 	beq	18dc8 <_fwrite_r+0x70>
  return (n - uio.uio_resid) / size;
   18dec:	e59d0014 	ldr	r0, [sp, #20]
   18df0:	e1a01007 	mov	r1, r7
   18df4:	e0480000 	sub	r0, r8, r0
   18df8:	ebfff4d8 	bl	16160 <__udivsi3>
}
   18dfc:	e28dd018 	add	sp, sp, #24
   18e00:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  CHECK_INIT(ptr, fp);
   18e04:	ebfffdb5 	bl	184e0 <__sinit>
   18e08:	eaffffe4 	b	18da0 <_fwrite_r+0x48>

00018e0c <fwrite>:
fwrite (const void *__restrict buf,
       size_t size,
       size_t count,
       FILE * fp)
{
  return _fwrite_r (_REENT, buf, size, count, fp);
   18e0c:	e30bc1e8 	movw	ip, #45544	@ 0xb1e8
{
   18e10:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  return _fwrite_r (_REENT, buf, size, count, fp);
   18e14:	e340c002 	movt	ip, #2
  uio.uio_resid = iov.iov_len = n = count * size;
   18e18:	e0070192 	mul	r7, r2, r1
{
   18e1c:	e24dd018 	sub	sp, sp, #24
   18e20:	e1a05003 	mov	r5, r3
  return _fwrite_r (_REENT, buf, size, count, fp);
   18e24:	e59c8000 	ldr	r8, [ip]
  uio.uio_iov = &iov;
   18e28:	e28d3004 	add	r3, sp, #4
   18e2c:	e58d300c 	str	r3, [sp, #12]
  uio.uio_iovcnt = 1;
   18e30:	e3a03001 	mov	r3, #1
{
   18e34:	e1a06001 	mov	r6, r1
   18e38:	e1a04002 	mov	r4, r2
  CHECK_INIT(ptr, fp);
   18e3c:	e3580000 	cmp	r8, #0
  iov.iov_base = buf;
   18e40:	e58d0004 	str	r0, [sp, #4]
  uio.uio_resid = iov.iov_len = n = count * size;
   18e44:	e58d7008 	str	r7, [sp, #8]
   18e48:	e58d7014 	str	r7, [sp, #20]
  uio.uio_iovcnt = 1;
   18e4c:	e58d3010 	str	r3, [sp, #16]
  CHECK_INIT(ptr, fp);
   18e50:	0a000002 	beq	18e60 <fwrite+0x54>
   18e54:	e5983034 	ldr	r3, [r8, #52]	@ 0x34
   18e58:	e3530000 	cmp	r3, #0
   18e5c:	0a000018 	beq	18ec4 <fwrite+0xb8>
  if (ORIENT (fp, -1) != -1)
   18e60:	e1d520fc 	ldrsh	r2, [r5, #12]
  _newlib_flockfile_start (fp);
   18e64:	e5953064 	ldr	r3, [r5, #100]	@ 0x64
  if (ORIENT (fp, -1) != -1)
   18e68:	e3120a02 	tst	r2, #8192	@ 0x2000
   18e6c:	03822a02 	orreq	r2, r2, #8192	@ 0x2000
   18e70:	03c33a02 	biceq	r3, r3, #8192	@ 0x2000
   18e74:	01c520bc 	strheq	r2, [r5, #12]
   18e78:	05853064 	streq	r3, [r5, #100]	@ 0x64
   18e7c:	e3130a02 	tst	r3, #8192	@ 0x2000
      return 0;
   18e80:	13a00000 	movne	r0, #0
  if (ORIENT (fp, -1) != -1)
   18e84:	0a000001 	beq	18e90 <fwrite+0x84>
}
   18e88:	e28dd018 	add	sp, sp, #24
   18e8c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  if (__sfvwrite_r (ptr, fp, &uio) == 0)
   18e90:	e1a01005 	mov	r1, r5
   18e94:	e1a00008 	mov	r0, r8
   18e98:	e28d200c 	add	r2, sp, #12
   18e9c:	ebfffe63 	bl	18830 <__sfvwrite_r>
   18ea0:	e3500000 	cmp	r0, #0
      return count;
   18ea4:	01a00004 	moveq	r0, r4
  if (__sfvwrite_r (ptr, fp, &uio) == 0)
   18ea8:	0afffff6 	beq	18e88 <fwrite+0x7c>
  return (n - uio.uio_resid) / size;
   18eac:	e59d0014 	ldr	r0, [sp, #20]
   18eb0:	e1a01006 	mov	r1, r6
   18eb4:	e0470000 	sub	r0, r7, r0
   18eb8:	ebfff4a8 	bl	16160 <__udivsi3>
}
   18ebc:	e28dd018 	add	sp, sp, #24
   18ec0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  CHECK_INIT(ptr, fp);
   18ec4:	e1a00008 	mov	r0, r8
   18ec8:	ebfffd84 	bl	184e0 <__sinit>
   18ecc:	eaffffe3 	b	18e60 <fwrite+0x54>

00018ed0 <_getc_unlocked_r>:
_getc_unlocked_r (struct _reent *ptr,
       register FILE *fp)
{
  /* CHECK_INIT is called (eventually) by __srefill_r.  */

  return __sgetc_r (ptr, fp);
   18ed0:	e5912004 	ldr	r2, [r1, #4]
{
   18ed4:	e1a03001 	mov	r3, r1
  return __sgetc_r (ptr, fp);
   18ed8:	e2422001 	sub	r2, r2, #1
   18edc:	e3520000 	cmp	r2, #0
   18ee0:	e5812004 	str	r2, [r1, #4]
   18ee4:	ba000004 	blt	18efc <_getc_unlocked_r+0x2c>
   18ee8:	e5912000 	ldr	r2, [r1]
   18eec:	e2821001 	add	r1, r2, #1
   18ef0:	e5831000 	str	r1, [r3]
}
   18ef4:	e5d20000 	ldrb	r0, [r2]
   18ef8:	e12fff1e 	bx	lr
  return __sgetc_r (ptr, fp);
   18efc:	ea00009b 	b	19170 <__srget_r>

00018f00 <getc_unlocked>:
#ifndef _REENT_ONLY

int
getc_unlocked (register FILE *fp)
{
  return __sgetc_r (_REENT, fp);
   18f00:	e5903004 	ldr	r3, [r0, #4]
   18f04:	e2433001 	sub	r3, r3, #1
   18f08:	e3530000 	cmp	r3, #0
   18f0c:	e5803004 	str	r3, [r0, #4]
   18f10:	ba000004 	blt	18f28 <getc_unlocked+0x28>
   18f14:	e5903000 	ldr	r3, [r0]
   18f18:	e2832001 	add	r2, r3, #1
   18f1c:	e5802000 	str	r2, [r0]
}
   18f20:	e5d30000 	ldrb	r0, [r3]
   18f24:	e12fff1e 	bx	lr
  return __sgetc_r (_REENT, fp);
   18f28:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
   18f2c:	e1a01000 	mov	r1, r0
   18f30:	e3403002 	movt	r3, #2
   18f34:	e5930000 	ldr	r0, [r3]
   18f38:	ea00008c 	b	19170 <__srget_r>

00018f3c <_printf_r>:
#include "local.h"

int
_printf_r (struct _reent *ptr,
       const char *__restrict fmt, ...)
{
   18f3c:	e92d000e 	push	{r1, r2, r3}
   18f40:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
   18f44:	e24dd008 	sub	sp, sp, #8
  int ret;
  va_list ap;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
   18f48:	e28d3010 	add	r3, sp, #16
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   18f4c:	e59d200c 	ldr	r2, [sp, #12]
   18f50:	e5901008 	ldr	r1, [r0, #8]
  va_start (ap, fmt);
   18f54:	e58d3004 	str	r3, [sp, #4]
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   18f58:	eb002774 	bl	22d30 <_vfprintf_r>
  va_end (ap);
  return ret;
}
   18f5c:	e28dd008 	add	sp, sp, #8
   18f60:	e49de004 	pop	{lr}		@ (ldr lr, [sp], #4)
   18f64:	e28dd00c 	add	sp, sp, #12
   18f68:	e12fff1e 	bx	lr

00018f6c <printf>:

#ifndef _REENT_ONLY

int
printf (const char *__restrict fmt, ...)
{
   18f6c:	e92d000f 	push	{r0, r1, r2, r3}
  int ret;
  va_list ap;
  struct _reent *ptr = _REENT;
   18f70:	e30b11e8 	movw	r1, #45544	@ 0xb1e8
   18f74:	e3401002 	movt	r1, #2
{
   18f78:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
   18f7c:	e24dd00c 	sub	sp, sp, #12

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
   18f80:	e28d3014 	add	r3, sp, #20
  struct _reent *ptr = _REENT;
   18f84:	e5910000 	ldr	r0, [r1]
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   18f88:	e59d2010 	ldr	r2, [sp, #16]
  va_start (ap, fmt);
   18f8c:	e58d3004 	str	r3, [sp, #4]
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   18f90:	e5901008 	ldr	r1, [r0, #8]
   18f94:	eb002765 	bl	22d30 <_vfprintf_r>
  va_end (ap);
  return ret;
}
   18f98:	e28dd00c 	add	sp, sp, #12
   18f9c:	e49de004 	pop	{lr}		@ (ldr lr, [sp], #4)
   18fa0:	e28dd010 	add	sp, sp, #16
   18fa4:	e12fff1e 	bx	lr

00018fa8 <_putc_r>:

int
_putc_r (struct _reent *ptr,
       int c,
       register FILE *fp)
{
   18fa8:	e92d4050 	push	{r4, r6, lr}
  int result;
  CHECK_INIT (ptr, fp);
   18fac:	e2506000 	subs	r6, r0, #0
{
   18fb0:	e24dd00c 	sub	sp, sp, #12
   18fb4:	e1a04002 	mov	r4, r2
  CHECK_INIT (ptr, fp);
   18fb8:	0a000002 	beq	18fc8 <_putc_r+0x20>
   18fbc:	e5963034 	ldr	r3, [r6, #52]	@ 0x34
   18fc0:	e3530000 	cmp	r3, #0
   18fc4:	0a000016 	beq	19024 <_putc_r+0x7c>
_ELIDABLE_INLINE int __sputc_r(struct _reent *_ptr, int _c, FILE *_p) {
#ifdef __SCLE
	if ((_p->_flags & __SCLE) && _c == '\n')
	  __sputc_r (_ptr, '\r', _p);
#endif
	if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
   18fc8:	e5943008 	ldr	r3, [r4, #8]
   18fcc:	e2433001 	sub	r3, r3, #1
   18fd0:	e3530000 	cmp	r3, #0
   18fd4:	e5843008 	str	r3, [r4, #8]
   18fd8:	a6ef0071 	uxtbge	r0, r1
   18fdc:	aa000005 	bge	18ff8 <_putc_r+0x50>
   18fe0:	e5942018 	ldr	r2, [r4, #24]
   18fe4:	e1530002 	cmp	r3, r2
   18fe8:	ba000008 	blt	19010 <_putc_r+0x68>
   18fec:	e6ef0071 	uxtb	r0, r1
   18ff0:	e350000a 	cmp	r0, #10
   18ff4:	0a000005 	beq	19010 <_putc_r+0x68>
		return (*_p->_p++ = _c);
   18ff8:	e5943000 	ldr	r3, [r4]
   18ffc:	e2832001 	add	r2, r3, #1
   19000:	e5842000 	str	r2, [r4]
	if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
   19004:	e5c31000 	strb	r1, [r3]
  _newlib_flockfile_start (fp);
  result = __sputc_r (ptr, c, fp);
  _newlib_flockfile_end (fp);
  return result;
}
   19008:	e28dd00c 	add	sp, sp, #12
   1900c:	e8bd8050 	pop	{r4, r6, pc}
	else
		return (__swbuf_r(_ptr, _c, _p));
   19010:	e1a02004 	mov	r2, r4
   19014:	e1a00006 	mov	r0, r6
   19018:	e28dd00c 	add	sp, sp, #12
   1901c:	e8bd4050 	pop	{r4, r6, lr}
   19020:	ea0001e7 	b	197c4 <__swbuf_r>
   19024:	e58d1004 	str	r1, [sp, #4]
  CHECK_INIT (ptr, fp);
   19028:	ebfffd2c 	bl	184e0 <__sinit>
   1902c:	e59d1004 	ldr	r1, [sp, #4]
   19030:	eaffffe4 	b	18fc8 <_putc_r+0x20>

00019034 <putc>:
putc (int c,
       register FILE *fp)
{
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  int result;
  struct _reent *reent = _REENT;
   19034:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
{
   19038:	e92d4070 	push	{r4, r5, r6, lr}
  struct _reent *reent = _REENT;
   1903c:	e3403002 	movt	r3, #2
{
   19040:	e1a05000 	mov	r5, r0
   19044:	e1a04001 	mov	r4, r1
  struct _reent *reent = _REENT;
   19048:	e5936000 	ldr	r6, [r3]

  CHECK_INIT (reent, fp);
   1904c:	e3560000 	cmp	r6, #0
   19050:	0a000002 	beq	19060 <putc+0x2c>
   19054:	e5963034 	ldr	r3, [r6, #52]	@ 0x34
   19058:	e3530000 	cmp	r3, #0
   1905c:	0a000015 	beq	190b8 <putc+0x84>
	if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
   19060:	e5943008 	ldr	r3, [r4, #8]
   19064:	e2433001 	sub	r3, r3, #1
   19068:	e3530000 	cmp	r3, #0
   1906c:	e5843008 	str	r3, [r4, #8]
   19070:	a6ef0075 	uxtbge	r0, r5
   19074:	aa000005 	bge	19090 <putc+0x5c>
   19078:	e5942018 	ldr	r2, [r4, #24]
   1907c:	e1530002 	cmp	r3, r2
   19080:	ba000007 	blt	190a4 <putc+0x70>
   19084:	e6ef0075 	uxtb	r0, r5
   19088:	e350000a 	cmp	r0, #10
   1908c:	0a000004 	beq	190a4 <putc+0x70>
		return (*_p->_p++ = _c);
   19090:	e5943000 	ldr	r3, [r4]
   19094:	e2832001 	add	r2, r3, #1
   19098:	e5842000 	str	r2, [r4]
	if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
   1909c:	e5c35000 	strb	r5, [r3]
  _newlib_flockfile_end (fp);
  return result;
#else
  return _putc_r (_REENT, c, fp);
#endif
}
   190a0:	e8bd8070 	pop	{r4, r5, r6, pc}
		return (__swbuf_r(_ptr, _c, _p));
   190a4:	e1a02004 	mov	r2, r4
   190a8:	e1a01005 	mov	r1, r5
   190ac:	e1a00006 	mov	r0, r6
   190b0:	e8bd4070 	pop	{r4, r5, r6, lr}
   190b4:	ea0001c2 	b	197c4 <__swbuf_r>
  CHECK_INIT (reent, fp);
   190b8:	e1a00006 	mov	r0, r6
   190bc:	ebfffd07 	bl	184e0 <__sinit>
   190c0:	eaffffe6 	b	19060 <putc+0x2c>

000190c4 <_putc_unlocked_r>:
	if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
   190c4:	e5923008 	ldr	r3, [r2, #8]
   190c8:	e2433001 	sub	r3, r3, #1
   190cc:	e3530000 	cmp	r3, #0
   190d0:	e5823008 	str	r3, [r2, #8]
   190d4:	a6efc071 	uxtbge	ip, r1
   190d8:	aa000005 	bge	190f4 <_putc_unlocked_r+0x30>
   190dc:	e592c018 	ldr	ip, [r2, #24]
   190e0:	e153000c 	cmp	r3, ip
   190e4:	ba000008 	blt	1910c <_putc_unlocked_r+0x48>
   190e8:	e6efc071 	uxtb	ip, r1
   190ec:	e35c000a 	cmp	ip, #10
   190f0:	0a000005 	beq	1910c <_putc_unlocked_r+0x48>
		return (*_p->_p++ = _c);
   190f4:	e5923000 	ldr	r3, [r2]
   190f8:	e2830001 	add	r0, r3, #1
   190fc:	e5820000 	str	r0, [r2]
       register FILE *fp)
{
  /* CHECK_INIT is (eventually) called by __swbuf.  */

  return __sputc_r (ptr, c, fp);
}
   19100:	e1a0000c 	mov	r0, ip
	if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
   19104:	e5c31000 	strb	r1, [r3]
   19108:	e12fff1e 	bx	lr
		return (__swbuf_r(_ptr, _c, _p));
   1910c:	ea0001ac 	b	197c4 <__swbuf_r>

00019110 <putc_unlocked>:
	if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
   19110:	e5913008 	ldr	r3, [r1, #8]
putc_unlocked (int c,
       register FILE *fp)
{
  /* CHECK_INIT is (eventually) called by __swbuf.  */

  return __sputc_r (_REENT, c, fp);
   19114:	e30bc1e8 	movw	ip, #45544	@ 0xb1e8
{
   19118:	e1a02001 	mov	r2, r1
  return __sputc_r (_REENT, c, fp);
   1911c:	e340c002 	movt	ip, #2
{
   19120:	e1a01000 	mov	r1, r0
  return __sputc_r (_REENT, c, fp);
   19124:	e59cc000 	ldr	ip, [ip]
   19128:	e2433001 	sub	r3, r3, #1
   1912c:	e3530000 	cmp	r3, #0
   19130:	e5823008 	str	r3, [r2, #8]
   19134:	a6ef0070 	uxtbge	r0, r0
   19138:	aa000005 	bge	19154 <putc_unlocked+0x44>
   1913c:	e5920018 	ldr	r0, [r2, #24]
   19140:	e1530000 	cmp	r3, r0
   19144:	ba000007 	blt	19168 <putc_unlocked+0x58>
   19148:	e6ef0071 	uxtb	r0, r1
   1914c:	e350000a 	cmp	r0, #10
   19150:	0a000004 	beq	19168 <putc_unlocked+0x58>
		return (*_p->_p++ = _c);
   19154:	e5923000 	ldr	r3, [r2]
   19158:	e283c001 	add	ip, r3, #1
   1915c:	e582c000 	str	ip, [r2]
	if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
   19160:	e5c31000 	strb	r1, [r3]
}
   19164:	e12fff1e 	bx	lr
		return (__swbuf_r(_ptr, _c, _p));
   19168:	e1a0000c 	mov	r0, ip
   1916c:	ea000194 	b	197c4 <__swbuf_r>

00019170 <__srget_r>:
 */

int
__srget_r (struct _reent *ptr,
       register FILE *fp)
{
   19170:	e92d4070 	push	{r4, r5, r6, lr}
  /* Ensure that any fake std stream is resolved before
     we call __srefill_r so we may access the true read buffer. */
  CHECK_INIT(ptr, fp);
   19174:	e2505000 	subs	r5, r0, #0
{
   19178:	e1a04001 	mov	r4, r1
  CHECK_INIT(ptr, fp);
   1917c:	0a000002 	beq	1918c <__srget_r+0x1c>
   19180:	e5953034 	ldr	r3, [r5, #52]	@ 0x34
   19184:	e3530000 	cmp	r3, #0
   19188:	0a000013 	beq	191dc <__srget_r+0x6c>

  /* Have to set and check orientation here, otherwise the macros in
     stdio.h never set it. */
  if (ORIENT (fp, -1) != -1)
   1918c:	e1d420fc 	ldrsh	r2, [r4, #12]
   19190:	e5943064 	ldr	r3, [r4, #100]	@ 0x64
   19194:	e3120a02 	tst	r2, #8192	@ 0x2000
   19198:	03822a02 	orreq	r2, r2, #8192	@ 0x2000
   1919c:	03c33a02 	biceq	r3, r3, #8192	@ 0x2000
   191a0:	01c420bc 	strheq	r2, [r4, #12]
   191a4:	05843064 	streq	r3, [r4, #100]	@ 0x64
   191a8:	e3130a02 	tst	r3, #8192	@ 0x2000
   191ac:	1a00000c 	bne	191e4 <__srget_r+0x74>
    return EOF;

  if (__srefill_r (ptr, fp) == 0)
   191b0:	e1a01004 	mov	r1, r4
   191b4:	e1a00005 	mov	r0, r5
   191b8:	eb003099 	bl	25424 <__srefill_r>
   191bc:	e3500000 	cmp	r0, #0
   191c0:	1a000007 	bne	191e4 <__srget_r+0x74>
    {
      fp->_r--;
   191c4:	e1c420d0 	ldrd	r2, [r4]
      return *fp->_p++;
   191c8:	e2821001 	add	r1, r2, #1
      fp->_r--;
   191cc:	e2433001 	sub	r3, r3, #1
      return *fp->_p++;
   191d0:	e884000a 	stm	r4, {r1, r3}
   191d4:	e5d20000 	ldrb	r0, [r2]
    }
  return EOF;
}
   191d8:	e8bd8070 	pop	{r4, r5, r6, pc}
  CHECK_INIT(ptr, fp);
   191dc:	ebfffcbf 	bl	184e0 <__sinit>
   191e0:	eaffffe9 	b	1918c <__srget_r+0x1c>
    return EOF;
   191e4:	e3e00000 	mvn	r0, #0
   191e8:	e8bd8070 	pop	{r4, r5, r6, pc}

000191ec <__srget>:
   required for backward compatibility with applications built against
   earlier dynamically built newlib libraries. */
int
__srget (register FILE *fp)
{
  return __srget_r (_REENT, fp);
   191ec:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
{
   191f0:	e92d4010 	push	{r4, lr}
  return __srget_r (_REENT, fp);
   191f4:	e3403002 	movt	r3, #2
{
   191f8:	e1a04000 	mov	r4, r0
   191fc:	e24dd008 	sub	sp, sp, #8
  return __srget_r (_REENT, fp);
   19200:	e5930000 	ldr	r0, [r3]
  CHECK_INIT(ptr, fp);
   19204:	e3500000 	cmp	r0, #0
   19208:	0a000002 	beq	19218 <__srget+0x2c>
   1920c:	e5903034 	ldr	r3, [r0, #52]	@ 0x34
   19210:	e3530000 	cmp	r3, #0
   19214:	0a000013 	beq	19268 <__srget+0x7c>
  if (ORIENT (fp, -1) != -1)
   19218:	e1d420fc 	ldrsh	r2, [r4, #12]
   1921c:	e5943064 	ldr	r3, [r4, #100]	@ 0x64
   19220:	e3120a02 	tst	r2, #8192	@ 0x2000
   19224:	03822a02 	orreq	r2, r2, #8192	@ 0x2000
   19228:	03c33a02 	biceq	r3, r3, #8192	@ 0x2000
   1922c:	01c420bc 	strheq	r2, [r4, #12]
   19230:	05843064 	streq	r3, [r4, #100]	@ 0x64
   19234:	e3130a02 	tst	r3, #8192	@ 0x2000
   19238:	1a00000e 	bne	19278 <__srget+0x8c>
  if (__srefill_r (ptr, fp) == 0)
   1923c:	e1a01004 	mov	r1, r4
   19240:	eb003077 	bl	25424 <__srefill_r>
   19244:	e3500000 	cmp	r0, #0
   19248:	1a00000a 	bne	19278 <__srget+0x8c>
      fp->_r--;
   1924c:	e1c420d0 	ldrd	r2, [r4]
      return *fp->_p++;
   19250:	e2821001 	add	r1, r2, #1
      fp->_r--;
   19254:	e2433001 	sub	r3, r3, #1
      return *fp->_p++;
   19258:	e884000a 	stm	r4, {r1, r3}
   1925c:	e5d20000 	ldrb	r0, [r2]
}
   19260:	e28dd008 	add	sp, sp, #8
   19264:	e8bd8010 	pop	{r4, pc}
  CHECK_INIT(ptr, fp);
   19268:	e58d0004 	str	r0, [sp, #4]
   1926c:	ebfffc9b 	bl	184e0 <__sinit>
   19270:	e59d0004 	ldr	r0, [sp, #4]
   19274:	eaffffe7 	b	19218 <__srget+0x2c>
    return EOF;
   19278:	e3e00000 	mvn	r0, #0
   1927c:	eafffff7 	b	19260 <__srget+0x74>

00019280 <setvbuf>:
       char *buf,
       register int mode,
       register size_t size)
{
  int ret = 0;
  struct _reent *reent = _REENT;
   19280:	e30bc1e8 	movw	ip, #45544	@ 0xb1e8
{
   19284:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
  struct _reent *reent = _REENT;
   19288:	e340c002 	movt	ip, #2
{
   1928c:	e24dd00c 	sub	sp, sp, #12
   19290:	e1a04000 	mov	r4, r0
   19294:	e1a06001 	mov	r6, r1
  struct _reent *reent = _REENT;
   19298:	e59c8000 	ldr	r8, [ip]
{
   1929c:	e1a07002 	mov	r7, r2
   192a0:	e1a05003 	mov	r5, r3
  size_t iosize;
  int ttyflag;

  CHECK_INIT (reent, fp);
   192a4:	e3580000 	cmp	r8, #0
   192a8:	0a000002 	beq	192b8 <setvbuf+0x38>
   192ac:	e5983034 	ldr	r3, [r8, #52]	@ 0x34
   192b0:	e3530000 	cmp	r3, #0
   192b4:	0a000063 	beq	19448 <setvbuf+0x1c8>
  /*
   * Verify arguments.  The `int' limit on `size' is due to this
   * particular implementation.  Note, buf and size are ignored
   * when setting _IONBF.
   */
  if (mode != _IONBF)
   192b8:	e3570002 	cmp	r7, #2
   192bc:	0a000004 	beq	192d4 <setvbuf+0x54>
    if ((mode != _IOFBF && mode != _IOLBF) || (int)(_POINTER_INT) size < 0)
   192c0:	e3570001 	cmp	r7, #1
   192c4:	93a03000 	movls	r3, #0
   192c8:	83a03001 	movhi	r3, #1
   192cc:	e1933fa5 	orrs	r3, r3, r5, lsr #31
   192d0:	1a00005f 	bne	19454 <setvbuf+0x1d4>
   * Make sure putc() will not think fp is line buffered.
   * Free old buffer if it was from malloc().  Clear line and
   * non buffer flags, and clear malloc flag.
   */
  _newlib_flockfile_start (fp);
  _fflush_r (reent, fp);
   192d4:	e1a01004 	mov	r1, r4
   192d8:	e1a00008 	mov	r0, r8
   192dc:	ebfffb56 	bl	1803c <_fflush_r>
  if (HASUB(fp))
   192e0:	e5941030 	ldr	r1, [r4, #48]	@ 0x30
   192e4:	e3510000 	cmp	r1, #0
   192e8:	0a000006 	beq	19308 <setvbuf+0x88>
    FREEUB(reent, fp);
   192ec:	e2843040 	add	r3, r4, #64	@ 0x40
   192f0:	e1510003 	cmp	r1, r3
   192f4:	0a000001 	beq	19300 <setvbuf+0x80>
   192f8:	e1a00008 	mov	r0, r8
   192fc:	eb001892 	bl	1f54c <_free_r>
   19300:	e3a03000 	mov	r3, #0
   19304:	e5843030 	str	r3, [r4, #48]	@ 0x30
  fp->_r = fp->_lbfsize = 0;
  if (fp->_flags & __SMBF)
   19308:	e1d4c0fc 	ldrsh	ip, [r4, #12]
  fp->_r = fp->_lbfsize = 0;
   1930c:	e3a03000 	mov	r3, #0
   19310:	e5843018 	str	r3, [r4, #24]
   19314:	e5843004 	str	r3, [r4, #4]
  if (fp->_flags & __SMBF)
   19318:	e31c0080 	tst	ip, #128	@ 0x80
   1931c:	1a000038 	bne	19404 <setvbuf+0x184>
    _free_r (reent, (void *) fp->_bf._base);
  fp->_flags &= ~(__SLBF | __SNBF | __SMBF | __SOPT | __SNPT | __SEOF);
   19320:	e3ccceca 	bic	ip, ip, #3232	@ 0xca0

  if (mode == _IONBF)
   19324:	e3570002 	cmp	r7, #2
  fp->_flags &= ~(__SLBF | __SNBF | __SMBF | __SOPT | __SNPT | __SEOF);
   19328:	e3ccc003 	bic	ip, ip, #3
   1932c:	e1c4c0bc 	strh	ip, [r4, #12]
  if (mode == _IONBF)
   19330:	0a000038 	beq	19418 <setvbuf+0x198>
  /*
   * Find optimal I/O size for seek optimization.  This also returns
   * a `tty flag' to suggest that we check isatty(fd), but we do not
   * care since our caller told us how to buffer.
   */
  fp->_flags |= __swhatbuf_r (reent, fp, &iosize, &ttyflag);
   19334:	e28d3004 	add	r3, sp, #4
   19338:	e1a0200d 	mov	r2, sp
   1933c:	e1a01004 	mov	r1, r4
   19340:	e1a00008 	mov	r0, r8
   19344:	eb003009 	bl	25370 <__swhatbuf_r>
   19348:	e1d430bc 	ldrh	r3, [r4, #12]
  if (size == 0)
   1934c:	e3550000 	cmp	r5, #0
  fp->_flags |= __swhatbuf_r (reent, fp, &iosize, &ttyflag);
   19350:	e1833000 	orr	r3, r3, r0
   19354:	e1c430bc 	strh	r3, [r4, #12]
  if (size == 0)
   19358:	0a00001b 	beq	193cc <setvbuf+0x14c>
      buf = NULL;
      size = iosize;
    }

  /* Allocate buffer if needed. */
  if (buf == NULL)
   1935c:	e3560000 	cmp	r6, #0
   19360:	0a00001a 	beq	193d0 <setvbuf+0x150>

  /*
   * We're committed to buffering from here, so make sure we've
   * registered to flush buffers on exit.
   */
  if (!_REENT_CLEANUP(reent))
   19364:	e5983034 	ldr	r3, [r8, #52]	@ 0x34
   19368:	e3530000 	cmp	r3, #0
   1936c:	0a000021 	beq	193f8 <setvbuf+0x178>
   * Kill any seek optimization if the buffer is not the
   * right size.
   *
   * SHOULD WE ALLOW MULTIPLES HERE (i.e., ok iff (size % iosize) == 0)?
   */
  if (size != iosize)
   19370:	e59d2000 	ldr	r2, [sp]
     fp->_flags |= __SNPT;
   19374:	e1d430fc 	ldrsh	r3, [r4, #12]
   * Fix up the FILE fields, and set __cleanup for output flush on
   * exit (since we are buffered in some way).
   */
  if (mode == _IOLBF)
    fp->_flags |= __SLBF;
  fp->_bf._base = fp->_p = (unsigned char *) buf;
   19378:	e5846000 	str	r6, [r4]
  if (size != iosize)
   1937c:	e1520005 	cmp	r2, r5
  fp->_bf._base = fp->_p = (unsigned char *) buf;
   19380:	e5846010 	str	r6, [r4, #16]
     fp->_flags |= __SNPT;
   19384:	13833b02 	orrne	r3, r3, #2048	@ 0x800
  fp->_bf._size = size;
   19388:	e5845014 	str	r5, [r4, #20]
     fp->_flags |= __SNPT;
   1938c:	11c430bc 	strhne	r3, [r4, #12]
  if (mode == _IOLBF)
   19390:	e3570001 	cmp	r7, #1
    fp->_flags |= __SLBF;
   19394:	03833001 	orreq	r3, r3, #1
   19398:	01c430bc 	strheq	r3, [r4, #12]
  /* fp->_lbfsize is still 0 */
  if (fp->_flags & __SWR)
   1939c:	e2132008 	ands	r2, r3, #8
        fp->_w = size;
    }
  else
    {
      /* begin/continue reading, or stay in intermediate state */
      fp->_w = 0;
   193a0:	05842008 	streq	r2, [r4, #8]
  if (fp->_flags & __SWR)
   193a4:	0a000005 	beq	193c0 <setvbuf+0x140>
      if (fp->_flags & __SLBF)
   193a8:	e3130001 	tst	r3, #1
	  fp->_w = 0;
   193ac:	13a03000 	movne	r3, #0
	  fp->_lbfsize = -fp->_bf._size;
   193b0:	12655000 	rsbne	r5, r5, #0
	  fp->_w = 0;
   193b4:	15843008 	strne	r3, [r4, #8]
	  fp->_lbfsize = -fp->_bf._size;
   193b8:	15845018 	strne	r5, [r4, #24]
        fp->_w = size;
   193bc:	05845008 	streq	r5, [r4, #8]
    }

  _newlib_flockfile_end (fp);
  return 0;
   193c0:	e3a00000 	mov	r0, #0
}
   193c4:	e28dd00c 	add	sp, sp, #12
   193c8:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
      size = iosize;
   193cc:	e59d5000 	ldr	r5, [sp]
      if ((buf = malloc (size)) == NULL)
   193d0:	e1a00005 	mov	r0, r5
   193d4:	eb000e18 	bl	1cc3c <malloc>
   193d8:	e2506000 	subs	r6, r0, #0
   193dc:	0a00001e 	beq	1945c <setvbuf+0x1dc>
      fp->_flags |= __SMBF;
   193e0:	e1d430bc 	ldrh	r3, [r4, #12]
   193e4:	e3833080 	orr	r3, r3, #128	@ 0x80
   193e8:	e1c430bc 	strh	r3, [r4, #12]
  if (!_REENT_CLEANUP(reent))
   193ec:	e5983034 	ldr	r3, [r8, #52]	@ 0x34
   193f0:	e3530000 	cmp	r3, #0
   193f4:	1affffdd 	bne	19370 <setvbuf+0xf0>
    __sinit(reent);
   193f8:	e1a00008 	mov	r0, r8
   193fc:	ebfffc37 	bl	184e0 <__sinit>
   19400:	eaffffda 	b	19370 <setvbuf+0xf0>
    _free_r (reent, (void *) fp->_bf._base);
   19404:	e5941010 	ldr	r1, [r4, #16]
   19408:	e1a00008 	mov	r0, r8
   1940c:	eb00184e 	bl	1f54c <_free_r>
  fp->_flags &= ~(__SLBF | __SNBF | __SMBF | __SOPT | __SNPT | __SEOF);
   19410:	e1d4c0fc 	ldrsh	ip, [r4, #12]
   19414:	eaffffc1 	b	19320 <setvbuf+0xa0>
  int ret = 0;
   19418:	e3a00000 	mov	r0, #0
          fp->_bf._base = fp->_p = fp->_nbuf;
   1941c:	e2843043 	add	r3, r4, #67	@ 0x43
          fp->_flags |= __SNBF;
   19420:	e38cc002 	orr	ip, ip, #2
          fp->_w = 0;
   19424:	e3a01000 	mov	r1, #0
          fp->_bf._size = 1;
   19428:	e3a02001 	mov	r2, #1
          fp->_flags |= __SNBF;
   1942c:	e1c4c0bc 	strh	ip, [r4, #12]
          fp->_w = 0;
   19430:	e5841008 	str	r1, [r4, #8]
          fp->_bf._base = fp->_p = fp->_nbuf;
   19434:	e5843000 	str	r3, [r4]
   19438:	e5843010 	str	r3, [r4, #16]
          fp->_bf._size = 1;
   1943c:	e5842014 	str	r2, [r4, #20]
}
   19440:	e28dd00c 	add	sp, sp, #12
   19444:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
  CHECK_INIT (reent, fp);
   19448:	e1a00008 	mov	r0, r8
   1944c:	ebfffc23 	bl	184e0 <__sinit>
   19450:	eaffff98 	b	192b8 <setvbuf+0x38>
      return (EOF);
   19454:	e3e00000 	mvn	r0, #0
   19458:	eaffffd9 	b	193c4 <setvbuf+0x144>
	  if (size != iosize)
   1945c:	e59d9000 	ldr	r9, [sp]
   19460:	e1590005 	cmp	r9, r5
   19464:	0a000004 	beq	1947c <setvbuf+0x1fc>
	      buf = malloc (size);
   19468:	e1a00009 	mov	r0, r9
   1946c:	eb000df2 	bl	1cc3c <malloc>
      if (buf == NULL)
   19470:	e2506000 	subs	r6, r0, #0
   19474:	11a05009 	movne	r5, r9
   19478:	1affffd8 	bne	193e0 <setvbuf+0x160>
      fp->_flags |= __SMBF;
   1947c:	e1d4c0fc 	ldrsh	ip, [r4, #12]
   19480:	e3e00000 	mvn	r0, #0
   19484:	eaffffe4 	b	1941c <setvbuf+0x19c>

00019488 <_snprintf_r>:
{
  int ret;
  va_list ap;
  FILE f;

  if (size > INT_MAX)
   19488:	e3520000 	cmp	r2, #0
{
   1948c:	e52d3004 	push	{r3}		@ (str r3, [sp, #-4]!)
    {
      _REENT_ERRNO(ptr) = EOVERFLOW;
   19490:	b3a0308b 	movlt	r3, #139	@ 0x8b
{
   19494:	e92d4010 	push	{r4, lr}
   19498:	e1a04000 	mov	r4, r0
   1949c:	e24dd074 	sub	sp, sp, #116	@ 0x74
      return EOF;
   194a0:	b3e00000 	mvnlt	r0, #0
      _REENT_ERRNO(ptr) = EOVERFLOW;
   194a4:	b5843000 	strlt	r3, [r4]
  if (size > INT_MAX)
   194a8:	ba000012 	blt	194f8 <_snprintf_r+0x70>
    }
  f._flags = __SWR | __SSTR;
   194ac:	e3a03f82 	mov	r3, #520	@ 0x208
  f._flags2 = 0;
  f._bf._base = f._p = (unsigned char *) str;
   194b0:	e58d1008 	str	r1, [sp, #8]
  f._flags = __SWR | __SSTR;
   194b4:	e1cd31b4 	strh	r3, [sp, #20]
  f._flags2 = 0;
   194b8:	e3a03000 	mov	r3, #0
   194bc:	e58d306c 	str	r3, [sp, #108]	@ 0x6c
  f._bf._size = f._w = (size > 0 ? size - 1 : 0);
  f._file = -1;  /* No file. */
  va_start (ap, fmt);
   194c0:	e28d3080 	add	r3, sp, #128	@ 0x80
  f._bf._base = f._p = (unsigned char *) str;
   194c4:	e58d1018 	str	r1, [sp, #24]
  f._bf._size = f._w = (size > 0 ? size - 1 : 0);
   194c8:	1a00000e 	bne	19508 <_snprintf_r+0x80>
  f._file = -1;  /* No file. */
   194cc:	e3e01000 	mvn	r1, #0
  f._bf._size = f._w = (size > 0 ? size - 1 : 0);
   194d0:	e58d2010 	str	r2, [sp, #16]
   194d4:	e58d201c 	str	r2, [sp, #28]
  f._file = -1;  /* No file. */
   194d8:	e1cd11b6 	strh	r1, [sp, #22]
  ret = _svfprintf_r (ptr, &f, fmt, ap);
   194dc:	e28d1008 	add	r1, sp, #8
   194e0:	e59d207c 	ldr	r2, [sp, #124]	@ 0x7c
  va_start (ap, fmt);
   194e4:	e58d3004 	str	r3, [sp, #4]
  ret = _svfprintf_r (ptr, &f, fmt, ap);
   194e8:	eb001d5e 	bl	20a68 <_svfprintf_r>
  va_end (ap);
  if (ret < EOF)
   194ec:	e3700001 	cmn	r0, #1
    _REENT_ERRNO(ptr) = EOVERFLOW;
   194f0:	b3a0308b 	movlt	r3, #139	@ 0x8b
   194f4:	b5843000 	strlt	r3, [r4]
  if (size > 0)
    *f._p = 0;
  return (ret);
}
   194f8:	e28dd074 	add	sp, sp, #116	@ 0x74
   194fc:	e8bd4010 	pop	{r4, lr}
   19500:	e28dd004 	add	sp, sp, #4
   19504:	e12fff1e 	bx	lr
  f._bf._size = f._w = (size > 0 ? size - 1 : 0);
   19508:	e2422001 	sub	r2, r2, #1
  f._file = -1;  /* No file. */
   1950c:	e3e01000 	mvn	r1, #0
  f._bf._size = f._w = (size > 0 ? size - 1 : 0);
   19510:	e58d2010 	str	r2, [sp, #16]
   19514:	e58d201c 	str	r2, [sp, #28]
  f._file = -1;  /* No file. */
   19518:	e1cd11b6 	strh	r1, [sp, #22]
  ret = _svfprintf_r (ptr, &f, fmt, ap);
   1951c:	e28d1008 	add	r1, sp, #8
   19520:	e59d207c 	ldr	r2, [sp, #124]	@ 0x7c
  va_start (ap, fmt);
   19524:	e58d3004 	str	r3, [sp, #4]
  ret = _svfprintf_r (ptr, &f, fmt, ap);
   19528:	eb001d4e 	bl	20a68 <_svfprintf_r>
  if (ret < EOF)
   1952c:	e3700001 	cmn	r0, #1
    *f._p = 0;
   19530:	e3a02000 	mov	r2, #0
    _REENT_ERRNO(ptr) = EOVERFLOW;
   19534:	b3a0308b 	movlt	r3, #139	@ 0x8b
   19538:	b5843000 	strlt	r3, [r4]
    *f._p = 0;
   1953c:	e59d3008 	ldr	r3, [sp, #8]
   19540:	e5c32000 	strb	r2, [r3]
}
   19544:	e28dd074 	add	sp, sp, #116	@ 0x74
   19548:	e8bd4010 	pop	{r4, lr}
   1954c:	e28dd004 	add	sp, sp, #4
   19550:	e12fff1e 	bx	lr

00019554 <snprintf>:

int
snprintf (char *__restrict str,
       size_t size,
       const char *__restrict fmt, ...)
{
   19554:	e92d000c 	push	{r2, r3}
  int ret;
  va_list ap;
  FILE f;
  struct _reent *ptr = _REENT;
   19558:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
   1955c:	e3403002 	movt	r3, #2
{
   19560:	e92d4010 	push	{r4, lr}

  if (size > INT_MAX)
   19564:	e3510000 	cmp	r1, #0
{
   19568:	e24dd070 	sub	sp, sp, #112	@ 0x70
    {
      _REENT_ERRNO(ptr) = EOVERFLOW;
      return EOF;
   1956c:	b3e00000 	mvnlt	r0, #0
  struct _reent *ptr = _REENT;
   19570:	e5934000 	ldr	r4, [r3]
      _REENT_ERRNO(ptr) = EOVERFLOW;
   19574:	b3a0308b 	movlt	r3, #139	@ 0x8b
   19578:	b5843000 	strlt	r3, [r4]
  if (size > INT_MAX)
   1957c:	ba000013 	blt	195d0 <snprintf+0x7c>
    }
  f._flags = __SWR | __SSTR;
  f._flags2 = 0;
   19580:	e3a03000 	mov	r3, #0
  f._flags = __SWR | __SSTR;
   19584:	e3a02f82 	mov	r2, #520	@ 0x208
  f._flags2 = 0;
   19588:	e58d306c 	str	r3, [sp, #108]	@ 0x6c
  f._bf._base = f._p = (unsigned char *) str;
  f._bf._size = f._w = (size > 0 ? size - 1 : 0);
  f._file = -1;  /* No file. */
  va_start (ap, fmt);
   1958c:	e28d307c 	add	r3, sp, #124	@ 0x7c
  f._flags = __SWR | __SSTR;
   19590:	e1cd21b4 	strh	r2, [sp, #20]
  f._bf._base = f._p = (unsigned char *) str;
   19594:	e58d0008 	str	r0, [sp, #8]
   19598:	e58d0018 	str	r0, [sp, #24]
  f._bf._size = f._w = (size > 0 ? size - 1 : 0);
   1959c:	1a00000f 	bne	195e0 <snprintf+0x8c>
  f._file = -1;  /* No file. */
   195a0:	e3e02000 	mvn	r2, #0
  f._bf._size = f._w = (size > 0 ? size - 1 : 0);
   195a4:	e58d1010 	str	r1, [sp, #16]
   195a8:	e58d101c 	str	r1, [sp, #28]
  ret = _svfprintf_r (ptr, &f, fmt, ap);
   195ac:	e1a00004 	mov	r0, r4
  f._file = -1;  /* No file. */
   195b0:	e1cd21b6 	strh	r2, [sp, #22]
  ret = _svfprintf_r (ptr, &f, fmt, ap);
   195b4:	e28d1008 	add	r1, sp, #8
   195b8:	e59d2078 	ldr	r2, [sp, #120]	@ 0x78
  va_start (ap, fmt);
   195bc:	e58d3004 	str	r3, [sp, #4]
  ret = _svfprintf_r (ptr, &f, fmt, ap);
   195c0:	eb001d28 	bl	20a68 <_svfprintf_r>
  va_end (ap);
  if (ret < EOF)
   195c4:	e3700001 	cmn	r0, #1
    _REENT_ERRNO(ptr) = EOVERFLOW;
   195c8:	b3a0308b 	movlt	r3, #139	@ 0x8b
   195cc:	b5843000 	strlt	r3, [r4]
  if (size > 0)
    *f._p = 0;
  return (ret);
}
   195d0:	e28dd070 	add	sp, sp, #112	@ 0x70
   195d4:	e8bd4010 	pop	{r4, lr}
   195d8:	e28dd008 	add	sp, sp, #8
   195dc:	e12fff1e 	bx	lr
  f._bf._size = f._w = (size > 0 ? size - 1 : 0);
   195e0:	e2411001 	sub	r1, r1, #1
  f._file = -1;  /* No file. */
   195e4:	e3e02000 	mvn	r2, #0
  f._bf._size = f._w = (size > 0 ? size - 1 : 0);
   195e8:	e58d1010 	str	r1, [sp, #16]
  ret = _svfprintf_r (ptr, &f, fmt, ap);
   195ec:	e1a00004 	mov	r0, r4
  f._bf._size = f._w = (size > 0 ? size - 1 : 0);
   195f0:	e58d101c 	str	r1, [sp, #28]
  ret = _svfprintf_r (ptr, &f, fmt, ap);
   195f4:	e28d1008 	add	r1, sp, #8
  f._file = -1;  /* No file. */
   195f8:	e1cd21b6 	strh	r2, [sp, #22]
  ret = _svfprintf_r (ptr, &f, fmt, ap);
   195fc:	e59d2078 	ldr	r2, [sp, #120]	@ 0x78
  va_start (ap, fmt);
   19600:	e58d3004 	str	r3, [sp, #4]
  ret = _svfprintf_r (ptr, &f, fmt, ap);
   19604:	eb001d17 	bl	20a68 <_svfprintf_r>
  if (ret < EOF)
   19608:	e3700001 	cmn	r0, #1
    *f._p = 0;
   1960c:	e3a02000 	mov	r2, #0
    _REENT_ERRNO(ptr) = EOVERFLOW;
   19610:	b3a0308b 	movlt	r3, #139	@ 0x8b
   19614:	b5843000 	strlt	r3, [r4]
    *f._p = 0;
   19618:	e59d3008 	ldr	r3, [sp, #8]
   1961c:	e5c32000 	strb	r2, [r3]
}
   19620:	e28dd070 	add	sp, sp, #112	@ 0x70
   19624:	e8bd4010 	pop	{r4, lr}
   19628:	e28dd008 	add	sp, sp, #8
   1962c:	e12fff1e 	bx	lr

00019630 <_sprintf_r>:

int
_sprintf_r (struct _reent *ptr,
       char *__restrict str,
       const char *__restrict fmt, ...)
{
   19630:	e92d000c 	push	{r2, r3}
  int ret;
  va_list ap;
  FILE f;

  f._flags = __SWR | __SSTR;
   19634:	e3a0cf82 	mov	ip, #520	@ 0x208
{
   19638:	e92d4010 	push	{r4, lr}
  f._flags2 = 0;
  f._bf._base = f._p = (unsigned char *) str;
  f._bf._size = f._w = INT_MAX;
   1963c:	e3e02102 	mvn	r2, #-2147483648	@ 0x80000000
{
   19640:	e24dd070 	sub	sp, sp, #112	@ 0x70
  f._flags2 = 0;
   19644:	e3a04000 	mov	r4, #0
  f._file = -1;  /* No file. */
  va_start (ap, fmt);
   19648:	e28d307c 	add	r3, sp, #124	@ 0x7c
  f._flags = __SWR | __SSTR;
   1964c:	e34fcfff 	movt	ip, #65535	@ 0xffff
  f._bf._base = f._p = (unsigned char *) str;
   19650:	e58d1008 	str	r1, [sp, #8]
   19654:	e58d1018 	str	r1, [sp, #24]
  ret = _svfprintf_r (ptr, &f, fmt, ap);
   19658:	e28d1008 	add	r1, sp, #8
  f._bf._size = f._w = INT_MAX;
   1965c:	e58d2010 	str	r2, [sp, #16]
   19660:	e58d201c 	str	r2, [sp, #28]
  ret = _svfprintf_r (ptr, &f, fmt, ap);
   19664:	e59d2078 	ldr	r2, [sp, #120]	@ 0x78
  va_start (ap, fmt);
   19668:	e58d3004 	str	r3, [sp, #4]
  f._flags = __SWR | __SSTR;
   1966c:	e58dc014 	str	ip, [sp, #20]
  f._flags2 = 0;
   19670:	e58d406c 	str	r4, [sp, #108]	@ 0x6c
  ret = _svfprintf_r (ptr, &f, fmt, ap);
   19674:	eb001cfb 	bl	20a68 <_svfprintf_r>
  va_end (ap);
  *f._p = '\0';	/* terminate the string */
   19678:	e59d3008 	ldr	r3, [sp, #8]
   1967c:	e5c34000 	strb	r4, [r3]
  return (ret);
}
   19680:	e28dd070 	add	sp, sp, #112	@ 0x70
   19684:	e8bd4010 	pop	{r4, lr}
   19688:	e28dd008 	add	sp, sp, #8
   1968c:	e12fff1e 	bx	lr

00019690 <sprintf>:
#ifndef _REENT_ONLY

int
sprintf (char *__restrict str,
       const char *__restrict fmt, ...)
{
   19690:	e92d000e 	push	{r1, r2, r3}
  f._flags2 = 0;
  f._bf._base = f._p = (unsigned char *) str;
  f._bf._size = f._w = INT_MAX;
  f._file = -1;  /* No file. */
  va_start (ap, fmt);
  ret = _svfprintf_r (_REENT, &f, fmt, ap);
   19694:	e30b11e8 	movw	r1, #45544	@ 0xb1e8
{
   19698:	e92d4010 	push	{r4, lr}
   1969c:	e1a02000 	mov	r2, r0
   196a0:	e24dd074 	sub	sp, sp, #116	@ 0x74
  ret = _svfprintf_r (_REENT, &f, fmt, ap);
   196a4:	e3401002 	movt	r1, #2
  f._flags = __SWR | __SSTR;
   196a8:	e3a0ef82 	mov	lr, #520	@ 0x208
  va_start (ap, fmt);
   196ac:	e28d3080 	add	r3, sp, #128	@ 0x80
  f._bf._size = f._w = INT_MAX;
   196b0:	e3e0c102 	mvn	ip, #-2147483648	@ 0x80000000
  f._flags2 = 0;
   196b4:	e3a04000 	mov	r4, #0
  f._flags = __SWR | __SSTR;
   196b8:	e34fefff 	movt	lr, #65535	@ 0xffff
  f._bf._base = f._p = (unsigned char *) str;
   196bc:	e58d2008 	str	r2, [sp, #8]
   196c0:	e58d2018 	str	r2, [sp, #24]
  ret = _svfprintf_r (_REENT, &f, fmt, ap);
   196c4:	e5910000 	ldr	r0, [r1]
   196c8:	e28d1008 	add	r1, sp, #8
   196cc:	e59d207c 	ldr	r2, [sp, #124]	@ 0x7c
  va_start (ap, fmt);
   196d0:	e58d3004 	str	r3, [sp, #4]
  f._flags = __SWR | __SSTR;
   196d4:	e58de014 	str	lr, [sp, #20]
  f._flags2 = 0;
   196d8:	e58d406c 	str	r4, [sp, #108]	@ 0x6c
  f._bf._size = f._w = INT_MAX;
   196dc:	e58dc010 	str	ip, [sp, #16]
   196e0:	e58dc01c 	str	ip, [sp, #28]
  ret = _svfprintf_r (_REENT, &f, fmt, ap);
   196e4:	eb001cdf 	bl	20a68 <_svfprintf_r>
  va_end (ap);
  *f._p = '\0';	/* terminate the string */
   196e8:	e59d3008 	ldr	r3, [sp, #8]
   196ec:	e5c34000 	strb	r4, [r3]
  return (ret);
}
   196f0:	e28dd074 	add	sp, sp, #116	@ 0x74
   196f4:	e8bd4010 	pop	{r4, lr}
   196f8:	e28dd00c 	add	sp, sp, #12
   196fc:	e12fff1e 	bx	lr

00019700 <__sread>:
_READ_WRITE_RETURN_TYPE
__sread (struct _reent *ptr,
       void *cookie,
       char *buf,
       _READ_WRITE_BUFSIZE_TYPE n)
{
   19700:	e92d4010 	push	{r4, lr}
   19704:	e1a04001 	mov	r4, r1
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
   19708:	e1d110fe 	ldrsh	r1, [r1, #14]
   1970c:	eb00080d 	bl	1b748 <_read_r>
    setmode (fp->_file, oldmode);
#endif

  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
   19710:	e3500000 	cmp	r0, #0
    fp->_offset += ret;
   19714:	a5943050 	ldrge	r3, [r4, #80]	@ 0x50
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
   19718:	b1d430bc 	ldrhlt	r3, [r4, #12]
    fp->_offset += ret;
   1971c:	a0833000 	addge	r3, r3, r0
    fp->_flags &= ~__SOFF;	/* paranoia */
   19720:	b3c33a01 	biclt	r3, r3, #4096	@ 0x1000
    fp->_offset += ret;
   19724:	a5843050 	strge	r3, [r4, #80]	@ 0x50
    fp->_flags &= ~__SOFF;	/* paranoia */
   19728:	b1c430bc 	strhlt	r3, [r4, #12]
  return ret;
}
   1972c:	e8bd8010 	pop	{r4, pc}

00019730 <__seofread>:
       void *cookie,
       char *buf,
       _READ_WRITE_BUFSIZE_TYPE len)
{
  return 0;
}
   19730:	e3a00000 	mov	r0, #0
   19734:	e12fff1e 	bx	lr

00019738 <__swrite>:
_READ_WRITE_RETURN_TYPE
__swrite (struct _reent *ptr,
       void *cookie,
       char const *buf,
       _READ_WRITE_BUFSIZE_TYPE n)
{
   19738:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
   1973c:	e1a04001 	mov	r4, r1
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
   19740:	e1d110fc 	ldrsh	r1, [r1, #12]
{
   19744:	e1a05000 	mov	r5, r0
   19748:	e1a06002 	mov	r6, r2
   1974c:	e1a07003 	mov	r7, r3
  if (fp->_flags & __SAPP)
   19750:	e3110c01 	tst	r1, #256	@ 0x100
   19754:	1a000007 	bne	19778 <__swrite+0x40>
    _lseek_r (ptr, fp->_file, (_off_t) 0, SEEK_END);
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
   19758:	e3c11a01 	bic	r1, r1, #4096	@ 0x1000
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
   1975c:	e1a03007 	mov	r3, r7
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
   19760:	e1c410bc 	strh	r1, [r4, #12]
  w = _write_r (ptr, fp->_file, buf, n);
   19764:	e1a02006 	mov	r2, r6
   19768:	e1d410fe 	ldrsh	r1, [r4, #14]
   1976c:	e1a00005 	mov	r0, r5
  if (oldmode)
    setmode (fp->_file, oldmode);
#endif

  return w;
}
   19770:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
  w = _write_r (ptr, fp->_file, buf, n);
   19774:	ea000815 	b	1b7d0 <_write_r>
    _lseek_r (ptr, fp->_file, (_off_t) 0, SEEK_END);
   19778:	e1d410fe 	ldrsh	r1, [r4, #14]
   1977c:	e3a03002 	mov	r3, #2
   19780:	e3a02000 	mov	r2, #0
   19784:	eb0007cd 	bl	1b6c0 <_lseek_r>
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
   19788:	e1d410fc 	ldrsh	r1, [r4, #12]
   1978c:	eafffff1 	b	19758 <__swrite+0x20>

00019790 <__sseek>:
_fpos_t
__sseek (struct _reent *ptr,
       void *cookie,
       _fpos_t offset,
       int whence)
{
   19790:	e92d4010 	push	{r4, lr}
   19794:	e1a04001 	mov	r4, r1
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
   19798:	e1d110fe 	ldrsh	r1, [r1, #14]
   1979c:	eb0007c7 	bl	1b6c0 <_lseek_r>
  if (ret == -1L)
    fp->_flags &= ~__SOFF;
   197a0:	e1d430fc 	ldrsh	r3, [r4, #12]
  if (ret == -1L)
   197a4:	e3700001 	cmn	r0, #1
  else
    {
      fp->_flags |= __SOFF;
      fp->_offset = ret;
   197a8:	15840050 	strne	r0, [r4, #80]	@ 0x50
    fp->_flags &= ~__SOFF;
   197ac:	03c33a01 	biceq	r3, r3, #4096	@ 0x1000
      fp->_flags |= __SOFF;
   197b0:	13833a01 	orrne	r3, r3, #4096	@ 0x1000
      fp->_offset = ret;
   197b4:	e1c430bc 	strh	r3, [r4, #12]
    }
  return ret;
}
   197b8:	e8bd8010 	pop	{r4, pc}

000197bc <__sclose>:
__sclose (struct _reent *ptr,
       void *cookie)
{
  FILE *fp = (FILE *) cookie;

  return _close_r (ptr, fp->_file);
   197bc:	e1d110fe 	ldrsh	r1, [r1, #14]
   197c0:	ea00076d 	b	1b57c <_close_r>

000197c4 <__swbuf_r>:

int
__swbuf_r (struct _reent *ptr,
       register int c,
       register FILE *fp)
{
   197c4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  register int n;

  /* Ensure stdio has been initialized.  */

  CHECK_INIT (ptr, fp);
   197c8:	e2506000 	subs	r6, r0, #0
{
   197cc:	e1a05001 	mov	r5, r1
   197d0:	e1a04002 	mov	r4, r2
  CHECK_INIT (ptr, fp);
   197d4:	0a000002 	beq	197e4 <__swbuf_r+0x20>
   197d8:	e5963034 	ldr	r3, [r6, #52]	@ 0x34
   197dc:	e3530000 	cmp	r3, #0
   197e0:	0a000040 	beq	198e8 <__swbuf_r+0x124>
   * If we did not do this, a sufficient number of putc()
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
   197e4:	e1d430fc 	ldrsh	r3, [r4, #12]
  fp->_w = fp->_lbfsize;
   197e8:	e5942018 	ldr	r2, [r4, #24]
  if (cantwrite (ptr, fp))
   197ec:	e3130008 	tst	r3, #8
  fp->_w = fp->_lbfsize;
   197f0:	e5842008 	str	r2, [r4, #8]
  if (cantwrite (ptr, fp))
   197f4:	0a000024 	beq	1988c <__swbuf_r+0xc8>
   197f8:	e5942010 	ldr	r2, [r4, #16]
   197fc:	e3520000 	cmp	r2, #0
   19800:	0a000021 	beq	1988c <__swbuf_r+0xc8>
    return EOF;
  c = (unsigned char) c;

  if (ORIENT (fp, -1) != -1)
   19804:	e5942064 	ldr	r2, [r4, #100]	@ 0x64
   19808:	e3130a02 	tst	r3, #8192	@ 0x2000
   1980c:	03833a02 	orreq	r3, r3, #8192	@ 0x2000
  c = (unsigned char) c;
   19810:	e6ef5075 	uxtb	r5, r5
  if (ORIENT (fp, -1) != -1)
   19814:	01c430bc 	strheq	r3, [r4, #12]
   19818:	03c22a02 	biceq	r2, r2, #8192	@ 0x2000
   1981c:	e1a07005 	mov	r7, r5
   19820:	05842064 	streq	r2, [r4, #100]	@ 0x64
   19824:	e3120a02 	tst	r2, #8192	@ 0x2000
   19828:	1a00001d 	bne	198a4 <__swbuf_r+0xe0>
   * happen on unbuffered streams, where _bf._size==1; fflush()
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
   1982c:	e5942000 	ldr	r2, [r4]
   19830:	e5943010 	ldr	r3, [r4, #16]
  if (n >= fp->_bf._size)
   19834:	e5941014 	ldr	r1, [r4, #20]
  n = fp->_p - fp->_bf._base;
   19838:	e0423003 	sub	r3, r2, r3
  if (n >= fp->_bf._size)
   1983c:	e1510003 	cmp	r1, r3
	return EOF;
      n = 0;
    }
  fp->_w--;
  *fp->_p++ = c;
  if (++n == fp->_bf._size || (fp->_flags & __SLBF && c == '\n'))
   19840:	c2833001 	addgt	r3, r3, #1
  if (n >= fp->_bf._size)
   19844:	da00001f 	ble	198c8 <__swbuf_r+0x104>
  fp->_w--;
   19848:	e5941008 	ldr	r1, [r4, #8]
   1984c:	e2411001 	sub	r1, r1, #1
   19850:	e5841008 	str	r1, [r4, #8]
  *fp->_p++ = c;
   19854:	e2821001 	add	r1, r2, #1
   19858:	e5841000 	str	r1, [r4]
   1985c:	e5c25000 	strb	r5, [r2]
  if (++n == fp->_bf._size || (fp->_flags & __SLBF && c == '\n'))
   19860:	e5942014 	ldr	r2, [r4, #20]
   19864:	e1520003 	cmp	r2, r3
   19868:	0a00000f 	beq	198ac <__swbuf_r+0xe8>
   1986c:	e1d430bc 	ldrh	r3, [r4, #12]
   19870:	e355000a 	cmp	r5, #10
   19874:	13a03000 	movne	r3, #0
   19878:	02033001 	andeq	r3, r3, #1
   1987c:	e3530000 	cmp	r3, #0
   19880:	1a000009 	bne	198ac <__swbuf_r+0xe8>
    if (_fflush_r (ptr, fp))
      return EOF;
  return c;
}
   19884:	e1a00007 	mov	r0, r7
   19888:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  if (cantwrite (ptr, fp))
   1988c:	e1a01004 	mov	r1, r4
   19890:	e1a00006 	mov	r0, r6
   19894:	eb00001c 	bl	1990c <__swsetup_r>
   19898:	e3500000 	cmp	r0, #0
  if (ORIENT (fp, -1) != -1)
   1989c:	01d430fc 	ldrsheq	r3, [r4, #12]
  if (cantwrite (ptr, fp))
   198a0:	0affffd7 	beq	19804 <__swbuf_r+0x40>
    return EOF;
   198a4:	e3e07000 	mvn	r7, #0
   198a8:	eafffff5 	b	19884 <__swbuf_r+0xc0>
    if (_fflush_r (ptr, fp))
   198ac:	e1a01004 	mov	r1, r4
   198b0:	e1a00006 	mov	r0, r6
   198b4:	ebfff9e0 	bl	1803c <_fflush_r>
   198b8:	e3500000 	cmp	r0, #0
   198bc:	1afffff8 	bne	198a4 <__swbuf_r+0xe0>
}
   198c0:	e1a00007 	mov	r0, r7
   198c4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
      if (_fflush_r (ptr, fp))
   198c8:	e1a01004 	mov	r1, r4
   198cc:	e1a00006 	mov	r0, r6
   198d0:	ebfff9d9 	bl	1803c <_fflush_r>
   198d4:	e3500000 	cmp	r0, #0
   198d8:	1afffff1 	bne	198a4 <__swbuf_r+0xe0>
  *fp->_p++ = c;
   198dc:	e5942000 	ldr	r2, [r4]
   198e0:	e3a03001 	mov	r3, #1
   198e4:	eaffffd7 	b	19848 <__swbuf_r+0x84>
  CHECK_INIT (ptr, fp);
   198e8:	ebfffafc 	bl	184e0 <__sinit>
   198ec:	eaffffbc 	b	197e4 <__swbuf_r+0x20>

000198f0 <__swbuf>:
   earlier dynamically built newlib libraries. */
int
__swbuf (register int c,
       register FILE *fp)
{
  return __swbuf_r (_REENT, c, fp);
   198f0:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
{
   198f4:	e1a0c000 	mov	ip, r0
  return __swbuf_r (_REENT, c, fp);
   198f8:	e3403002 	movt	r3, #2
{
   198fc:	e1a02001 	mov	r2, r1
  return __swbuf_r (_REENT, c, fp);
   19900:	e5930000 	ldr	r0, [r3]
   19904:	e1a0100c 	mov	r1, ip
   19908:	eaffffad 	b	197c4 <__swbuf_r>

0001990c <__swsetup_r>:
__swsetup_r (struct _reent *ptr,
       register FILE * fp)
{
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
   1990c:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
{
   19910:	e92d4070 	push	{r4, r5, r6, lr}
  CHECK_INIT (_REENT, fp);
   19914:	e3403002 	movt	r3, #2
{
   19918:	e1a05000 	mov	r5, r0
   1991c:	e1a04001 	mov	r4, r1
  CHECK_INIT (_REENT, fp);
   19920:	e5933000 	ldr	r3, [r3]
   19924:	e3530000 	cmp	r3, #0
   19928:	0a000002 	beq	19938 <__swsetup_r+0x2c>
   1992c:	e5932034 	ldr	r2, [r3, #52]	@ 0x34
   19930:	e3520000 	cmp	r2, #0
   19934:	0a000042 	beq	19a44 <__swsetup_r+0x138>

  /*
   * If we are not writing, we had better be reading and writing.
   */

  if ((fp->_flags & __SWR) == 0)
   19938:	e1d430fc 	ldrsh	r3, [r4, #12]
   1993c:	e3130008 	tst	r3, #8
   19940:	0a000018 	beq	199a8 <__swsetup_r+0x9c>
	  /* clobber any ungetc data */
	  if (HASUB (fp))
	    FREEUB (ptr, fp);
	  fp->_flags &= ~(__SRD | __SEOF);
	  fp->_r = 0;
	  fp->_p = fp->_bf._base;
   19944:	e5942010 	ldr	r2, [r4, #16]
  /*
   * Make a buffer if necessary, then set _w.
   * A string I/O file should not explicitly allocate a buffer
   * unless asprintf is being used.
   */
  if (fp->_bf._base == NULL
   19948:	e3520000 	cmp	r2, #0
   1994c:	0a000022 	beq	199dc <__swsetup_r+0xd0>
        && (!(fp->_flags & __SSTR) || (fp->_flags & __SMBF)))
    __smakebuf_r (ptr, fp);

  if (fp->_flags & __SLBF)
   19950:	e2131001 	ands	r1, r3, #1
   19954:	1a000006 	bne	19974 <__swsetup_r+0x68>
       */
      fp->_w = 0;
      fp->_lbfsize = -fp->_bf._size;
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;
   19958:	e3130002 	tst	r3, #2
   1995c:	05941014 	ldreq	r1, [r4, #20]

  if (!fp->_bf._base && (fp->_flags & __SMBF))
   19960:	e3520000 	cmp	r2, #0
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;
   19964:	e5841008 	str	r1, [r4, #8]
  if (!fp->_bf._base && (fp->_flags & __SMBF))
   19968:	0a000008 	beq	19990 <__swsetup_r+0x84>
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
      return EOF;
    }
  return 0;
   1996c:	e3a00000 	mov	r0, #0
   19970:	e8bd8070 	pop	{r4, r5, r6, pc}
      fp->_lbfsize = -fp->_bf._size;
   19974:	e5941014 	ldr	r1, [r4, #20]
  if (!fp->_bf._base && (fp->_flags & __SMBF))
   19978:	e3520000 	cmp	r2, #0
      fp->_w = 0;
   1997c:	e3a00000 	mov	r0, #0
   19980:	e5840008 	str	r0, [r4, #8]
      fp->_lbfsize = -fp->_bf._size;
   19984:	e2611000 	rsb	r1, r1, #0
   19988:	e5841018 	str	r1, [r4, #24]
  if (!fp->_bf._base && (fp->_flags & __SMBF))
   1998c:	1afffff6 	bne	1996c <__swsetup_r+0x60>
   19990:	e3130080 	tst	r3, #128	@ 0x80
   19994:	0afffff4 	beq	1996c <__swsetup_r+0x60>
      fp->_flags |= __SERR;
   19998:	e3833040 	orr	r3, r3, #64	@ 0x40
   1999c:	e1c430bc 	strh	r3, [r4, #12]
	  return EOF;
   199a0:	e3e00000 	mvn	r0, #0
   199a4:	e8bd8070 	pop	{r4, r5, r6, pc}
      if ((fp->_flags & __SRW) == 0)
   199a8:	e3130010 	tst	r3, #16
	  _REENT_ERRNO(ptr) = EBADF;
   199ac:	03a02009 	moveq	r2, #9
	  fp->_flags |= __SERR;
   199b0:	03833040 	orreq	r3, r3, #64	@ 0x40
	  _REENT_ERRNO(ptr) = EBADF;
   199b4:	05852000 	streq	r2, [r5]
	  fp->_flags |= __SERR;
   199b8:	01c430bc 	strheq	r3, [r4, #12]
      if ((fp->_flags & __SRW) == 0)
   199bc:	0afffff7 	beq	199a0 <__swsetup_r+0x94>
      if (fp->_flags & __SRD)
   199c0:	e3130004 	tst	r3, #4
   199c4:	1a00000d 	bne	19a00 <__swsetup_r+0xf4>
	  fp->_p = fp->_bf._base;
   199c8:	e5942010 	ldr	r2, [r4, #16]
  if (fp->_bf._base == NULL
   199cc:	e3520000 	cmp	r2, #0
      fp->_flags |= __SWR;
   199d0:	e3833008 	orr	r3, r3, #8
   199d4:	e1c430bc 	strh	r3, [r4, #12]
  if (fp->_bf._base == NULL
   199d8:	1affffdc 	bne	19950 <__swsetup_r+0x44>
        && (!(fp->_flags & __SSTR) || (fp->_flags & __SMBF)))
   199dc:	e2031d0a 	and	r1, r3, #640	@ 0x280
   199e0:	e3510c02 	cmp	r1, #512	@ 0x200
   199e4:	0affffd9 	beq	19950 <__swsetup_r+0x44>
    __smakebuf_r (ptr, fp);
   199e8:	e1a01004 	mov	r1, r4
   199ec:	e1a00005 	mov	r0, r5
   199f0:	eb002e13 	bl	25244 <__smakebuf_r>
  if (fp->_flags & __SLBF)
   199f4:	e1d430fc 	ldrsh	r3, [r4, #12]
  if (!fp->_bf._base && (fp->_flags & __SMBF))
   199f8:	e5942010 	ldr	r2, [r4, #16]
   199fc:	eaffffd3 	b	19950 <__swsetup_r+0x44>
	  if (HASUB (fp))
   19a00:	e5941030 	ldr	r1, [r4, #48]	@ 0x30
   19a04:	e3510000 	cmp	r1, #0
   19a08:	0a000007 	beq	19a2c <__swsetup_r+0x120>
	    FREEUB (ptr, fp);
   19a0c:	e2842040 	add	r2, r4, #64	@ 0x40
   19a10:	e1510002 	cmp	r1, r2
   19a14:	0a000002 	beq	19a24 <__swsetup_r+0x118>
   19a18:	e1a00005 	mov	r0, r5
   19a1c:	eb0016ca 	bl	1f54c <_free_r>
	  fp->_flags &= ~(__SRD | __SEOF);
   19a20:	e1d430fc 	ldrsh	r3, [r4, #12]
	    FREEUB (ptr, fp);
   19a24:	e3a02000 	mov	r2, #0
   19a28:	e5842030 	str	r2, [r4, #48]	@ 0x30
	  fp->_p = fp->_bf._base;
   19a2c:	e5942010 	ldr	r2, [r4, #16]
	  fp->_r = 0;
   19a30:	e3a01000 	mov	r1, #0
	  fp->_flags &= ~(__SRD | __SEOF);
   19a34:	e3c33024 	bic	r3, r3, #36	@ 0x24
	  fp->_r = 0;
   19a38:	e5841004 	str	r1, [r4, #4]
	  fp->_p = fp->_bf._base;
   19a3c:	e5842000 	str	r2, [r4]
   19a40:	eaffffe1 	b	199cc <__swsetup_r+0xc0>
  CHECK_INIT (_REENT, fp);
   19a44:	e1a00003 	mov	r0, r3
   19a48:	ebfffaa4 	bl	184e0 <__sinit>
   19a4c:	eaffffb9 	b	19938 <__swsetup_r+0x2c>

00019a50 <_fseeko_r>:
int
_fseeko_r (struct _reent *ptr,
       register FILE *fp,
       _off_t offset,
       int whence)
{
   19a50:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
#endif
  int havepos;

  /* Make sure stdio is set up.  */

  CHECK_INIT (ptr, fp);
   19a54:	e2505000 	subs	r5, r0, #0
{
   19a58:	e24dd05c 	sub	sp, sp, #92	@ 0x5c
   19a5c:	e1a04001 	mov	r4, r1
   19a60:	e1a09002 	mov	r9, r2
   19a64:	e1a08003 	mov	r8, r3
  CHECK_INIT (ptr, fp);
   19a68:	0a000002 	beq	19a78 <_fseeko_r+0x28>
   19a6c:	e5953034 	ldr	r3, [r5, #52]	@ 0x34
   19a70:	e3530000 	cmp	r3, #0
   19a74:	0a0000dd 	beq	19df0 <_fseeko_r+0x3a0>
  _newlib_flockfile_start (fp);

  /* If we've been doing some writing, and we're in append mode
     then we don't really know where the filepos is.  */

  if (fp->_flags & __SAPP && fp->_flags & __SWR)
   19a78:	e1d410bc 	ldrh	r1, [r4, #12]
   19a7c:	e2011f42 	and	r1, r1, #264	@ 0x108
   19a80:	e3510f42 	cmp	r1, #264	@ 0x108
   19a84:	0a0000b5 	beq	19d60 <_fseeko_r+0x310>
      _fflush_r (ptr, fp);
    }

  /* Have to be able to seek.  */

  if ((seekfn = fp->_seek) == NULL)
   19a88:	e5947028 	ldr	r7, [r4, #40]	@ 0x28
   19a8c:	e3570000 	cmp	r7, #0
    {
      _REENT_ERRNO(ptr) = ESPIPE;	/* ??? */
   19a90:	03a0301d 	moveq	r3, #29
   19a94:	05853000 	streq	r3, [r5]
  if ((seekfn = fp->_seek) == NULL)
   19a98:	0a000005 	beq	19ab4 <_fseeko_r+0x64>
  /*
   * Change any SEEK_CUR to SEEK_SET, and check `whence' argument.
   * After this, whence is either SEEK_SET or SEEK_END.
   */

  switch (whence)
   19a9c:	e3580001 	cmp	r8, #1
   19aa0:	0a000038 	beq	19b88 <_fseeko_r+0x138>
   19aa4:	e3d86002 	bics	r6, r8, #2
    case SEEK_END:
      havepos = 0;
      break;

    default:
      _REENT_ERRNO(ptr) = EINVAL;
   19aa8:	13a03016 	movne	r3, #22
   19aac:	15853000 	strne	r3, [r5]
  switch (whence)
   19ab0:	0a000002 	beq	19ac0 <_fseeko_r+0x70>
      return EOF;
   19ab4:	e3e00000 	mvn	r0, #0
     is performed.  */
  fp->_flags &= ~__SNPT;
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
  _newlib_flockfile_end (fp);
  return 0;
}
   19ab8:	e28dd05c 	add	sp, sp, #92	@ 0x5c
   19abc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (fp->_bf._base == NULL)
   19ac0:	e5942010 	ldr	r2, [r4, #16]
      havepos = 0;
   19ac4:	e1a0a006 	mov	sl, r6
  if (fp->_bf._base == NULL)
   19ac8:	e3520000 	cmp	r2, #0
   19acc:	0a000049 	beq	19bf8 <_fseeko_r+0x1a8>
  if (fp->_flags & (__SWR | __SRW | __SNBF | __SNPT))
   19ad0:	e1d430fc 	ldrsh	r3, [r4, #12]
   19ad4:	e300281a 	movw	r2, #2074	@ 0x81a
   19ad8:	e1130002 	tst	r3, r2
   19adc:	1a000007 	bne	19b00 <_fseeko_r+0xb0>
  if ((fp->_flags & __SOPT) == 0)
   19ae0:	e3130b01 	tst	r3, #1024	@ 0x400
   19ae4:	1a000059 	bne	19c50 <_fseeko_r+0x200>
      if (seekfn != __sseek
   19ae8:	e3092790 	movw	r2, #38800	@ 0x9790
   19aec:	e3402001 	movt	r2, #1
   19af0:	e1570002 	cmp	r7, r2
   19af4:	0a000043 	beq	19c08 <_fseeko_r+0x1b8>
	  fp->_flags |= __SNPT;
   19af8:	e3833b02 	orr	r3, r3, #2048	@ 0x800
   19afc:	e1c430bc 	strh	r3, [r4, #12]
  if (_fflush_r (ptr, fp)
   19b00:	e1a01004 	mov	r1, r4
   19b04:	e1a00005 	mov	r0, r5
   19b08:	ebfff94b 	bl	1803c <_fflush_r>
   19b0c:	e3500000 	cmp	r0, #0
   19b10:	1affffe7 	bne	19ab4 <_fseeko_r+0x64>
      || seekfn (ptr, fp->_cookie, offset, whence) == POS_ERR)
   19b14:	e594101c 	ldr	r1, [r4, #28]
   19b18:	e1a03008 	mov	r3, r8
   19b1c:	e1a02009 	mov	r2, r9
   19b20:	e1a00005 	mov	r0, r5
   19b24:	e12fff37 	blx	r7
   19b28:	e3700001 	cmn	r0, #1
   19b2c:	0affffe0 	beq	19ab4 <_fseeko_r+0x64>
  if (HASUB (fp))
   19b30:	e5941030 	ldr	r1, [r4, #48]	@ 0x30
   19b34:	e3510000 	cmp	r1, #0
   19b38:	0a000006 	beq	19b58 <_fseeko_r+0x108>
    FREEUB (ptr, fp);
   19b3c:	e2843040 	add	r3, r4, #64	@ 0x40
   19b40:	e1510003 	cmp	r1, r3
   19b44:	0a000001 	beq	19b50 <_fseeko_r+0x100>
   19b48:	e1a00005 	mov	r0, r5
   19b4c:	eb00167e 	bl	1f54c <_free_r>
   19b50:	e3a03000 	mov	r3, #0
   19b54:	e5843030 	str	r3, [r4, #48]	@ 0x30
  fp->_flags &= ~__SNPT;
   19b58:	e1d430bc 	ldrh	r3, [r4, #12]
  fp->_r = 0;
   19b5c:	e3a01000 	mov	r1, #0
  fp->_p = fp->_bf._base;
   19b60:	e5940010 	ldr	r0, [r4, #16]
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
   19b64:	e3a02008 	mov	r2, #8
  fp->_r = 0;
   19b68:	e5841004 	str	r1, [r4, #4]
  fp->_flags &= ~__SNPT;
   19b6c:	e3c33e82 	bic	r3, r3, #2080	@ 0x820
  fp->_p = fp->_bf._base;
   19b70:	e5840000 	str	r0, [r4]
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
   19b74:	e284005c 	add	r0, r4, #92	@ 0x5c
  fp->_flags &= ~__SNPT;
   19b78:	e1c430bc 	strh	r3, [r4, #12]
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
   19b7c:	eb0002cb 	bl	1a6b0 <memset>
      return 0;
   19b80:	e3a00000 	mov	r0, #0
   19b84:	eaffffcb 	b	19ab8 <_fseeko_r+0x68>
      _fflush_r (ptr, fp);   /* may adjust seek offset on append stream */
   19b88:	e1a01004 	mov	r1, r4
   19b8c:	e1a00005 	mov	r0, r5
   19b90:	ebfff929 	bl	1803c <_fflush_r>
      if (fp->_flags & __SOFF)
   19b94:	e1d430fc 	ldrsh	r3, [r4, #12]
   19b98:	e2132a01 	ands	r2, r3, #4096	@ 0x1000
   19b9c:	1a000073 	bne	19d70 <_fseeko_r+0x320>
	  curoff = seekfn (ptr, fp->_cookie, (_fpos_t) 0, SEEK_CUR);
   19ba0:	e594101c 	ldr	r1, [r4, #28]
   19ba4:	e1a03008 	mov	r3, r8
   19ba8:	e1a00005 	mov	r0, r5
   19bac:	e12fff37 	blx	r7
	  if (curoff == -1L)
   19bb0:	e3700001 	cmn	r0, #1
	  curoff = seekfn (ptr, fp->_cookie, (_fpos_t) 0, SEEK_CUR);
   19bb4:	e1a06000 	mov	r6, r0
	  if (curoff == -1L)
   19bb8:	0affffbd 	beq	19ab4 <_fseeko_r+0x64>
      if (fp->_flags & __SRD)
   19bbc:	e1d430fc 	ldrsh	r3, [r4, #12]
	curoff += fp->_p - fp->_bf._base;
   19bc0:	e5942010 	ldr	r2, [r4, #16]
      if (fp->_flags & __SRD)
   19bc4:	e3130004 	tst	r3, #4
   19bc8:	0a00006c 	beq	19d80 <_fseeko_r+0x330>
	  if (HASUB (fp))
   19bcc:	e5943030 	ldr	r3, [r4, #48]	@ 0x30
   19bd0:	e3530000 	cmp	r3, #0
	  curoff -= fp->_r;
   19bd4:	e5943004 	ldr	r3, [r4, #4]
   19bd8:	e0466003 	sub	r6, r6, r3
	    curoff -= fp->_ur;
   19bdc:	1594303c 	ldrne	r3, [r4, #60]	@ 0x3c
   19be0:	10466003 	subne	r6, r6, r3
  if (fp->_bf._base == NULL)
   19be4:	e3520000 	cmp	r2, #0
      offset += curoff;
   19be8:	e0899006 	add	r9, r9, r6
      havepos = 1;
   19bec:	e3a0a001 	mov	sl, #1
      whence = SEEK_SET;
   19bf0:	e3a08000 	mov	r8, #0
  if (fp->_bf._base == NULL)
   19bf4:	1affffb5 	bne	19ad0 <_fseeko_r+0x80>
    __smakebuf_r (ptr, fp);
   19bf8:	e1a01004 	mov	r1, r4
   19bfc:	e1a00005 	mov	r0, r5
   19c00:	eb002d8f 	bl	25244 <__smakebuf_r>
   19c04:	eaffffb1 	b	19ad0 <_fseeko_r+0x80>
	  || fp->_file < 0
   19c08:	e1d410fe 	ldrsh	r1, [r4, #14]
   19c0c:	e3510000 	cmp	r1, #0
   19c10:	baffffb8 	blt	19af8 <_fseeko_r+0xa8>
	  || _fstat_r (ptr, fp->_file, &st)
   19c14:	e1a0200d 	mov	r2, sp
   19c18:	e1a00005 	mov	r0, r5
   19c1c:	eb000697 	bl	1b680 <_fstat_r>
   19c20:	e3500000 	cmp	r0, #0
	  fp->_flags |= __SNPT;
   19c24:	11d430fc 	ldrshne	r3, [r4, #12]
	  || _fstat_r (ptr, fp->_file, &st)
   19c28:	1affffb2 	bne	19af8 <_fseeko_r+0xa8>
	  || (st.st_mode & S_IFMT) != S_IFREG)
   19c2c:	e59d3004 	ldr	r3, [sp, #4]
   19c30:	e2033a0f 	and	r3, r3, #61440	@ 0xf000
   19c34:	e3530902 	cmp	r3, #32768	@ 0x8000
      fp->_flags |= __SOPT;
   19c38:	e1d430fc 	ldrsh	r3, [r4, #12]
	  || (st.st_mode & S_IFMT) != S_IFREG)
   19c3c:	1affffad 	bne	19af8 <_fseeko_r+0xa8>
      fp->_flags |= __SOPT;
   19c40:	e3833b01 	orr	r3, r3, #1024	@ 0x400
   19c44:	e1c430bc 	strh	r3, [r4, #12]
      fp->_blksize = 1024;
   19c48:	e3a03b01 	mov	r3, #1024	@ 0x400
   19c4c:	e584304c 	str	r3, [r4, #76]	@ 0x4c
  if (whence == SEEK_SET)
   19c50:	e3580000 	cmp	r8, #0
    target = offset;
   19c54:	01a0b009 	moveq	fp, r9
  if (whence == SEEK_SET)
   19c58:	1a00005b 	bne	19dcc <_fseeko_r+0x37c>
  if (!havepos)
   19c5c:	e35a0000 	cmp	sl, #0
   19c60:	0a00004d 	beq	19d9c <_fseeko_r+0x34c>
  if (HASUB (fp))
   19c64:	e5941030 	ldr	r1, [r4, #48]	@ 0x30
      curoff += fp->_r;       /* kill off ungetc */
   19c68:	e5942004 	ldr	r2, [r4, #4]
  if (HASUB (fp))
   19c6c:	e3510000 	cmp	r1, #0
   19c70:	0a000060 	beq	19df8 <_fseeko_r+0x3a8>
      n += fp->_ur;
   19c74:	e594303c 	ldr	r3, [r4, #60]	@ 0x3c
      curoff += fp->_r;       /* kill off ungetc */
   19c78:	e0866002 	add	r6, r6, r2
      n = fp->_up - fp->_bf._base;
   19c7c:	e5940010 	ldr	r0, [r4, #16]
   19c80:	e5942038 	ldr	r2, [r4, #56]	@ 0x38
   19c84:	e0422000 	sub	r2, r2, r0
      curoff -= n;
   19c88:	e0466002 	sub	r6, r6, r2
      n += fp->_ur;
   19c8c:	e0833002 	add	r3, r3, r2
  if (target >= curoff && target < curoff + n)
   19c90:	e15b0006 	cmp	fp, r6
   19c94:	ba000002 	blt	19ca4 <_fseeko_r+0x254>
   19c98:	e0862003 	add	r2, r6, r3
   19c9c:	e152000b 	cmp	r2, fp
   19ca0:	8a000063 	bhi	19e34 <_fseeko_r+0x3e4>
  curoff = target & ~(fp->_blksize - 1);
   19ca4:	e594604c 	ldr	r6, [r4, #76]	@ 0x4c
  if (seekfn (ptr, fp->_cookie, curoff, SEEK_SET) == POS_ERR)
   19ca8:	e3a03000 	mov	r3, #0
   19cac:	e594101c 	ldr	r1, [r4, #28]
   19cb0:	e1a00005 	mov	r0, r5
  curoff = target & ~(fp->_blksize - 1);
   19cb4:	e2666000 	rsb	r6, r6, #0
   19cb8:	e006600b 	and	r6, r6, fp
  if (seekfn (ptr, fp->_cookie, curoff, SEEK_SET) == POS_ERR)
   19cbc:	e1a02006 	mov	r2, r6
   19cc0:	e12fff37 	blx	r7
   19cc4:	e3700001 	cmn	r0, #1
   19cc8:	0affff8c 	beq	19b00 <_fseeko_r+0xb0>
  if (HASUB (fp))
   19ccc:	e5941030 	ldr	r1, [r4, #48]	@ 0x30
  fp->_p = fp->_bf._base;
   19cd0:	e5943010 	ldr	r3, [r4, #16]
  if (HASUB (fp))
   19cd4:	e3510000 	cmp	r1, #0
  fp->_p = fp->_bf._base;
   19cd8:	e5843000 	str	r3, [r4]
  fp->_r = 0;
   19cdc:	e3a03000 	mov	r3, #0
   19ce0:	e5843004 	str	r3, [r4, #4]
  if (HASUB (fp))
   19ce4:	0a000006 	beq	19d04 <_fseeko_r+0x2b4>
    FREEUB (ptr, fp);
   19ce8:	e2843040 	add	r3, r4, #64	@ 0x40
   19cec:	e1510003 	cmp	r1, r3
   19cf0:	0a000001 	beq	19cfc <_fseeko_r+0x2ac>
   19cf4:	e1a00005 	mov	r0, r5
   19cf8:	eb001613 	bl	1f54c <_free_r>
   19cfc:	e3a03000 	mov	r3, #0
   19d00:	e5843030 	str	r3, [r4, #48]	@ 0x30
  fp->_flags &= ~__SEOF;
   19d04:	e1d430bc 	ldrh	r3, [r4, #12]
  if (n)
   19d08:	e05b6006 	subs	r6, fp, r6
  fp->_flags &= ~__SEOF;
   19d0c:	e3c33020 	bic	r3, r3, #32
   19d10:	e1c430bc 	strh	r3, [r4, #12]
  if (n)
   19d14:	0a00000c 	beq	19d4c <_fseeko_r+0x2fc>
      if (__srefill_r (ptr, fp) || fp->_r < n)
   19d18:	e1a01004 	mov	r1, r4
   19d1c:	e1a00005 	mov	r0, r5
   19d20:	eb002dbf 	bl	25424 <__srefill_r>
   19d24:	e3500000 	cmp	r0, #0
   19d28:	1affff74 	bne	19b00 <_fseeko_r+0xb0>
   19d2c:	e5943004 	ldr	r3, [r4, #4]
   19d30:	e1530006 	cmp	r3, r6
   19d34:	3affff71 	bcc	19b00 <_fseeko_r+0xb0>
      fp->_p += n;
   19d38:	e5942000 	ldr	r2, [r4]
      fp->_r -= n;
   19d3c:	e0433006 	sub	r3, r3, r6
   19d40:	e5843004 	str	r3, [r4, #4]
      fp->_p += n;
   19d44:	e0823006 	add	r3, r2, r6
   19d48:	e5843000 	str	r3, [r4]
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
   19d4c:	e3a02008 	mov	r2, #8
   19d50:	e3a01000 	mov	r1, #0
   19d54:	e284005c 	add	r0, r4, #92	@ 0x5c
   19d58:	eb000254 	bl	1a6b0 <memset>
  return 0;
   19d5c:	eaffff87 	b	19b80 <_fseeko_r+0x130>
      _fflush_r (ptr, fp);
   19d60:	e1a01004 	mov	r1, r4
   19d64:	e1a00005 	mov	r0, r5
   19d68:	ebfff8b3 	bl	1803c <_fflush_r>
   19d6c:	eaffff45 	b	19a88 <_fseeko_r+0x38>
      if (fp->_flags & __SRD)
   19d70:	e3130004 	tst	r3, #4
	curoff = fp->_offset;
   19d74:	e5946050 	ldr	r6, [r4, #80]	@ 0x50
	curoff += fp->_p - fp->_bf._base;
   19d78:	e5942010 	ldr	r2, [r4, #16]
      if (fp->_flags & __SRD)
   19d7c:	1affff92 	bne	19bcc <_fseeko_r+0x17c>
      else if (fp->_flags & __SWR && fp->_p != NULL)
   19d80:	e3130008 	tst	r3, #8
   19d84:	0affff96 	beq	19be4 <_fseeko_r+0x194>
   19d88:	e5943000 	ldr	r3, [r4]
   19d8c:	e3530000 	cmp	r3, #0
	curoff += fp->_p - fp->_bf._base;
   19d90:	10433002 	subne	r3, r3, r2
   19d94:	10866003 	addne	r6, r6, r3
   19d98:	eaffff91 	b	19be4 <_fseeko_r+0x194>
      if (fp->_flags & __SOFF)
   19d9c:	e1d430bc 	ldrh	r3, [r4, #12]
   19da0:	e3130a01 	tst	r3, #4096	@ 0x1000
   19da4:	0a00001a 	beq	19e14 <_fseeko_r+0x3c4>
	curoff = fp->_offset;
   19da8:	e5940050 	ldr	r0, [r4, #80]	@ 0x50
      if (HASUB (fp))
   19dac:	e5941030 	ldr	r1, [r4, #48]	@ 0x30
      curoff -= fp->_r;
   19db0:	e5942004 	ldr	r2, [r4, #4]
      if (HASUB (fp))
   19db4:	e3510000 	cmp	r1, #0
      curoff -= fp->_r;
   19db8:	e0406002 	sub	r6, r0, r2
      if (HASUB (fp))
   19dbc:	0a00000d 	beq	19df8 <_fseeko_r+0x3a8>
	curoff -= fp->_ur;
   19dc0:	e594303c 	ldr	r3, [r4, #60]	@ 0x3c
   19dc4:	e0466003 	sub	r6, r6, r3
  if (HASUB (fp))
   19dc8:	eaffffaa 	b	19c78 <_fseeko_r+0x228>
      if (_fstat_r (ptr, fp->_file, &st))
   19dcc:	e1d410fe 	ldrsh	r1, [r4, #14]
   19dd0:	e1a0200d 	mov	r2, sp
   19dd4:	e1a00005 	mov	r0, r5
   19dd8:	eb000628 	bl	1b680 <_fstat_r>
   19ddc:	e3500000 	cmp	r0, #0
   19de0:	1affff46 	bne	19b00 <_fseeko_r+0xb0>
      target = st.st_size + offset;
   19de4:	e59db010 	ldr	fp, [sp, #16]
   19de8:	e089b00b 	add	fp, r9, fp
   19dec:	eaffff9a 	b	19c5c <_fseeko_r+0x20c>
  CHECK_INIT (ptr, fp);
   19df0:	ebfff9ba 	bl	184e0 <__sinit>
   19df4:	eaffff1f 	b	19a78 <_fseeko_r+0x28>
      n = fp->_p - fp->_bf._base;
   19df8:	e5943000 	ldr	r3, [r4]
      n += fp->_r;
   19dfc:	e3a01000 	mov	r1, #0
      n = fp->_p - fp->_bf._base;
   19e00:	e5940010 	ldr	r0, [r4, #16]
   19e04:	e0433000 	sub	r3, r3, r0
      curoff -= n;
   19e08:	e0466003 	sub	r6, r6, r3
      n += fp->_r;
   19e0c:	e0823003 	add	r3, r2, r3
   19e10:	eaffff9e 	b	19c90 <_fseeko_r+0x240>
	  curoff = seekfn (ptr, fp->_cookie, 0L, SEEK_CUR);
   19e14:	e594101c 	ldr	r1, [r4, #28]
   19e18:	e1a0200a 	mov	r2, sl
   19e1c:	e3a03001 	mov	r3, #1
   19e20:	e1a00005 	mov	r0, r5
   19e24:	e12fff37 	blx	r7
	  if (curoff == POS_ERR)
   19e28:	e3700001 	cmn	r0, #1
   19e2c:	1affffde 	bne	19dac <_fseeko_r+0x35c>
   19e30:	eaffff32 	b	19b00 <_fseeko_r+0xb0>
      register int o = target - curoff;
   19e34:	e04b6006 	sub	r6, fp, r6
      if (HASUB (fp))
   19e38:	e3510000 	cmp	r1, #0
      fp->_p = fp->_bf._base + o;
   19e3c:	e0800006 	add	r0, r0, r6
      fp->_r = n - o;
   19e40:	e0433006 	sub	r3, r3, r6
   19e44:	e8840009 	stm	r4, {r0, r3}
      if (HASUB (fp))
   19e48:	0a000006 	beq	19e68 <_fseeko_r+0x418>
	FREEUB (ptr, fp);
   19e4c:	e2843040 	add	r3, r4, #64	@ 0x40
   19e50:	e1510003 	cmp	r1, r3
   19e54:	0a000001 	beq	19e60 <_fseeko_r+0x410>
   19e58:	e1a00005 	mov	r0, r5
   19e5c:	eb0015ba 	bl	1f54c <_free_r>
   19e60:	e3a03000 	mov	r3, #0
   19e64:	e5843030 	str	r3, [r4, #48]	@ 0x30
      fp->_flags &= ~__SEOF;
   19e68:	e1d430bc 	ldrh	r3, [r4, #12]
      memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
   19e6c:	e3a02008 	mov	r2, #8
   19e70:	e3a01000 	mov	r1, #0
   19e74:	e284005c 	add	r0, r4, #92	@ 0x5c
      fp->_flags &= ~__SEOF;
   19e78:	e3c33020 	bic	r3, r3, #32
   19e7c:	e1c430bc 	strh	r3, [r4, #12]
      memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
   19e80:	eb00020a 	bl	1a6b0 <memset>
      return 0;
   19e84:	eaffff3d 	b	19b80 <_fseeko_r+0x130>

00019e88 <fseeko>:
int
fseeko (register FILE *fp,
       _off_t offset,
       int whence)
{
  return _fseeko_r (_REENT, fp, offset, whence);
   19e88:	e30bc1e8 	movw	ip, #45544	@ 0xb1e8
{
   19e8c:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
  return _fseeko_r (_REENT, fp, offset, whence);
   19e90:	e340c002 	movt	ip, #2
{
   19e94:	e1a0e000 	mov	lr, r0
   19e98:	e1a03002 	mov	r3, r2
  return _fseeko_r (_REENT, fp, offset, whence);
   19e9c:	e1a02001 	mov	r2, r1
   19ea0:	e59c0000 	ldr	r0, [ip]
   19ea4:	e1a0100e 	mov	r1, lr
}
   19ea8:	e49de004 	pop	{lr}		@ (ldr lr, [sp], #4)
  return _fseeko_r (_REENT, fp, offset, whence);
   19eac:	eafffee7 	b	19a50 <_fseeko_r>

00019eb0 <_ftello_r>:
#include "local.h"

_off_t
_ftello_r (struct _reent * ptr,
       register FILE * fp)
{
   19eb0:	e92d4070 	push	{r4, r5, r6, lr}
  _fpos_t pos;

  /* Ensure stdio is set up.  */

  CHECK_INIT (ptr, fp);
   19eb4:	e2505000 	subs	r5, r0, #0
{
   19eb8:	e1a04001 	mov	r4, r1
  CHECK_INIT (ptr, fp);
   19ebc:	0a000002 	beq	19ecc <_ftello_r+0x1c>
   19ec0:	e5953034 	ldr	r3, [r5, #52]	@ 0x34
   19ec4:	e3530000 	cmp	r3, #0
   19ec8:	0a000031 	beq	19f94 <_ftello_r+0xe4>

  _newlib_flockfile_start (fp);

  if (fp->_seek == NULL)
   19ecc:	e5946028 	ldr	r6, [r4, #40]	@ 0x28
   19ed0:	e3560000 	cmp	r6, #0
    {
      _REENT_ERRNO(ptr) = ESPIPE;
   19ed4:	03a0301d 	moveq	r3, #29
   19ed8:	05853000 	streq	r3, [r5]
  if (fp->_seek == NULL)
   19edc:	0a00002e 	beq	19f9c <_ftello_r+0xec>
      _newlib_flockfile_exit (fp);
      return (_off_t) -1;
    }

  /* Find offset of underlying I/O object, then adjust for buffered bytes. */
  if (!(fp->_flags & __SRD) && (fp->_flags & __SWR) &&
   19ee0:	e1d430fc 	ldrsh	r3, [r4, #12]
   19ee4:	e203200c 	and	r2, r3, #12
   19ee8:	e3520008 	cmp	r2, #8
   19eec:	0a00001c 	beq	19f64 <_ftello_r+0xb4>
	{
          _newlib_flockfile_exit (fp);
          return (_off_t) -1;
	}
    }
  else if (fp->_flags & __SOFF)
   19ef0:	e2132a01 	ands	r2, r3, #4096	@ 0x1000
   19ef4:	1a00000f 	bne	19f38 <_ftello_r+0x88>
    pos = fp->_offset;
  else
    {
      pos = fp->_seek (ptr, fp->_cookie, (_fpos_t) 0, SEEK_CUR);
   19ef8:	e3a03001 	mov	r3, #1
      pos = fp->_seek (ptr, fp->_cookie, (_fpos_t) 0, SEEK_END);
   19efc:	e594101c 	ldr	r1, [r4, #28]
   19f00:	e1a00005 	mov	r0, r5
   19f04:	e12fff36 	blx	r6
      if (pos == (_fpos_t) -1)
   19f08:	e3700001 	cmn	r0, #1
        {
          _newlib_flockfile_exit (fp);
          return (_off_t) -1;
        }
    }
  if (fp->_flags & __SRD)
   19f0c:	11d430fc 	ldrshne	r3, [r4, #12]
      if (pos == (_fpos_t) -1)
   19f10:	0a000021 	beq	19f9c <_ftello_r+0xec>
  if (fp->_flags & __SRD)
   19f14:	e3130004 	tst	r3, #4
   19f18:	0a000009 	beq	19f44 <_ftello_r+0x94>
       * Reading.  Any unread characters (including
       * those from ungetc) cause the position to be
       * smaller than that in the underlying object.
       */
      pos -= fp->_r;
      if (HASUB (fp))
   19f1c:	e5942030 	ldr	r2, [r4, #48]	@ 0x30
      pos -= fp->_r;
   19f20:	e5943004 	ldr	r3, [r4, #4]
      if (HASUB (fp))
   19f24:	e3520000 	cmp	r2, #0
      pos -= fp->_r;
   19f28:	e0400003 	sub	r0, r0, r3
	pos -= fp->_ur;
   19f2c:	1594303c 	ldrne	r3, [r4, #60]	@ 0x3c
   19f30:	10400003 	subne	r0, r0, r3
   19f34:	e8bd8070 	pop	{r4, r5, r6, pc}
  if (fp->_flags & __SRD)
   19f38:	e3130004 	tst	r3, #4
    pos = fp->_offset;
   19f3c:	e5940050 	ldr	r0, [r4, #80]	@ 0x50
  if (fp->_flags & __SRD)
   19f40:	1afffff5 	bne	19f1c <_ftello_r+0x6c>
    }
  else if ((fp->_flags & __SWR) && fp->_p != NULL)
   19f44:	e3130008 	tst	r3, #8
   19f48:	08bd8070 	popeq	{r4, r5, r6, pc}
   19f4c:	e5943000 	ldr	r3, [r4]
   19f50:	e3530000 	cmp	r3, #0
      /*
       * Writing.  Any buffered characters cause the
       * position to be greater than that in the
       * underlying object.
       */
      pos += fp->_p - fp->_bf._base;
   19f54:	15942010 	ldrne	r2, [r4, #16]
   19f58:	10433002 	subne	r3, r3, r2
   19f5c:	10800003 	addne	r0, r0, r3
    }

  _newlib_flockfile_end (fp);
  return (_off_t) pos;
}
   19f60:	e8bd8070 	pop	{r4, r5, r6, pc}
      fp->_p != NULL && fp->_p - fp->_bf._base > 0 &&
   19f64:	e5942000 	ldr	r2, [r4]
  if (!(fp->_flags & __SRD) && (fp->_flags & __SWR) &&
   19f68:	e3520000 	cmp	r2, #0
   19f6c:	0affffdf 	beq	19ef0 <_ftello_r+0x40>
      fp->_p != NULL && fp->_p - fp->_bf._base > 0 &&
   19f70:	e5941010 	ldr	r1, [r4, #16]
   19f74:	e0422001 	sub	r2, r2, r1
   19f78:	e3520000 	cmp	r2, #0
   19f7c:	daffffdb 	ble	19ef0 <_ftello_r+0x40>
   19f80:	e3130c01 	tst	r3, #256	@ 0x100
   19f84:	0affffd9 	beq	19ef0 <_ftello_r+0x40>
      pos = fp->_seek (ptr, fp->_cookie, (_fpos_t) 0, SEEK_END);
   19f88:	e3a03002 	mov	r3, #2
   19f8c:	e3a02000 	mov	r2, #0
   19f90:	eaffffd9 	b	19efc <_ftello_r+0x4c>
  CHECK_INIT (ptr, fp);
   19f94:	ebfff951 	bl	184e0 <__sinit>
   19f98:	eaffffcb 	b	19ecc <_ftello_r+0x1c>
      return (_off_t) -1;
   19f9c:	e3e00000 	mvn	r0, #0
   19fa0:	e8bd8070 	pop	{r4, r5, r6, pc}

00019fa4 <ftello>:
#ifndef _REENT_ONLY

_off_t
ftello (register FILE * fp)
{
  return _ftello_r (_REENT, fp);
   19fa4:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
{
   19fa8:	e1a01000 	mov	r1, r0
  return _ftello_r (_REENT, fp);
   19fac:	e3403002 	movt	r3, #2
   19fb0:	e5930000 	ldr	r0, [r3]
   19fb4:	eaffffbd 	b	19eb0 <_ftello_r>

00019fb8 <_fflush_unlocked_r>:
{
   19fb8:	e92d4010 	push	{r4, lr}
  CHECK_INIT (ptr, fp);
   19fbc:	e2504000 	subs	r4, r0, #0
{
   19fc0:	e24dd008 	sub	sp, sp, #8
  CHECK_INIT (ptr, fp);
   19fc4:	0a000002 	beq	19fd4 <_fflush_unlocked_r+0x1c>
   19fc8:	e5943034 	ldr	r3, [r4, #52]	@ 0x34
   19fcc:	e3530000 	cmp	r3, #0
   19fd0:	0a000008 	beq	19ff8 <_fflush_unlocked_r+0x40>
  if (!fp->_flags)
   19fd4:	e1d100fc 	ldrsh	r0, [r1, #12]
   19fd8:	e3500000 	cmp	r0, #0
   19fdc:	1a000001 	bne	19fe8 <_fflush_unlocked_r+0x30>
}
   19fe0:	e28dd008 	add	sp, sp, #8
   19fe4:	e8bd8010 	pop	{r4, pc}
  ret = __sflush_r (ptr, fp);
   19fe8:	e1a00004 	mov	r0, r4
}
   19fec:	e28dd008 	add	sp, sp, #8
   19ff0:	e8bd4010 	pop	{r4, lr}
  ret = __sflush_r (ptr, fp);
   19ff4:	eafff78f 	b	17e38 <__sflush_r>
   19ff8:	e58d1004 	str	r1, [sp, #4]
  CHECK_INIT (ptr, fp);
   19ffc:	ebfff937 	bl	184e0 <__sinit>
   1a000:	e59d1004 	ldr	r1, [sp, #4]
   1a004:	eafffff2 	b	19fd4 <_fflush_unlocked_r+0x1c>

0001a008 <fflush_unlocked>:
{
   1a008:	e92d4070 	push	{r4, r5, r6, lr}
  if (fp == NULL)
   1a00c:	e2504000 	subs	r4, r0, #0
   1a010:	0a000011 	beq	1a05c <fflush_unlocked+0x54>
  return _fflush_r (_REENT, fp);
   1a014:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
   1a018:	e3403002 	movt	r3, #2
   1a01c:	e5935000 	ldr	r5, [r3]
  CHECK_INIT (ptr, fp);
   1a020:	e3550000 	cmp	r5, #0
   1a024:	0a000002 	beq	1a034 <fflush_unlocked+0x2c>
   1a028:	e5953034 	ldr	r3, [r5, #52]	@ 0x34
   1a02c:	e3530000 	cmp	r3, #0
   1a030:	0a000006 	beq	1a050 <fflush_unlocked+0x48>
  if (!fp->_flags)
   1a034:	e1d400fc 	ldrsh	r0, [r4, #12]
   1a038:	e3500000 	cmp	r0, #0
   1a03c:	08bd8070 	popeq	{r4, r5, r6, pc}
  ret = __sflush_r (ptr, fp);
   1a040:	e1a01004 	mov	r1, r4
   1a044:	e1a00005 	mov	r0, r5
}
   1a048:	e8bd4070 	pop	{r4, r5, r6, lr}
  ret = __sflush_r (ptr, fp);
   1a04c:	eafff779 	b	17e38 <__sflush_r>
  CHECK_INIT (ptr, fp);
   1a050:	e1a00005 	mov	r0, r5
   1a054:	ebfff921 	bl	184e0 <__sinit>
   1a058:	eafffff5 	b	1a034 <fflush_unlocked+0x2c>
    return _fwalk_sglue (_GLOBAL_REENT, _fflush_r, &__sglue);
   1a05c:	e30b206c 	movw	r2, #45164	@ 0xb06c
   1a060:	e3091fb8 	movw	r1, #40888	@ 0x9fb8
   1a064:	e30b01f0 	movw	r0, #45552	@ 0xb1f0
}
   1a068:	e8bd4070 	pop	{r4, r5, r6, lr}
    return _fwalk_sglue (_GLOBAL_REENT, _fflush_r, &__sglue);
   1a06c:	e3402002 	movt	r2, #2
   1a070:	e3401001 	movt	r1, #1
   1a074:	e3400002 	movt	r0, #2
   1a078:	eafffb1a 	b	18ce8 <_fwalk_sglue>

0001a07c <_fpurge_r>:
/* Discard I/O from a single file.  */

int
_fpurge_r (struct _reent *ptr,
       register FILE * fp)
{
   1a07c:	e92d4070 	push	{r4, r5, r6, lr}
  int t;

  CHECK_INIT (ptr, fp);
   1a080:	e2505000 	subs	r5, r0, #0
{
   1a084:	e1a04001 	mov	r4, r1
  CHECK_INIT (ptr, fp);
   1a088:	0a000002 	beq	1a098 <_fpurge_r+0x1c>
   1a08c:	e5953034 	ldr	r3, [r5, #52]	@ 0x34
   1a090:	e3530000 	cmp	r3, #0
   1a094:	0a000019 	beq	1a100 <_fpurge_r+0x84>

  _newlib_flockfile_start (fp);

  t = fp->_flags;
   1a098:	e1d430fc 	ldrsh	r3, [r4, #12]
  if (!t)
   1a09c:	e3530000 	cmp	r3, #0
   1a0a0:	0a000018 	beq	1a108 <_fpurge_r+0x8c>
    {
      _REENT_ERRNO(ptr) = EBADF;
      _newlib_flockfile_exit (fp);
      return EOF;
    }
  fp->_p = fp->_bf._base;
   1a0a4:	e5942010 	ldr	r2, [r4, #16]
  if ((t & __SWR) == 0)
   1a0a8:	e2130008 	ands	r0, r3, #8
  fp->_p = fp->_bf._base;
   1a0ac:	e5842000 	str	r2, [r4]
  if ((t & __SWR) == 0)
   1a0b0:	1a00000c 	bne	1a0e8 <_fpurge_r+0x6c>
    {
      fp->_r = 0;
      if (HASUB (fp))
   1a0b4:	e5941030 	ldr	r1, [r4, #48]	@ 0x30
      fp->_r = 0;
   1a0b8:	e5840004 	str	r0, [r4, #4]
      if (HASUB (fp))
   1a0bc:	e3510000 	cmp	r1, #0
   1a0c0:	0a00000c 	beq	1a0f8 <_fpurge_r+0x7c>
	FREEUB (ptr, fp);
   1a0c4:	e2843040 	add	r3, r4, #64	@ 0x40
   1a0c8:	e1510003 	cmp	r1, r3
   1a0cc:	0a000001 	beq	1a0d8 <_fpurge_r+0x5c>
   1a0d0:	e1a00005 	mov	r0, r5
   1a0d4:	eb00151c 	bl	1f54c <_free_r>
   1a0d8:	e3a03000 	mov	r3, #0
    }
  else
    fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
  _newlib_flockfile_end (fp);
  return 0;
   1a0dc:	e3a00000 	mov	r0, #0
	FREEUB (ptr, fp);
   1a0e0:	e5843030 	str	r3, [r4, #48]	@ 0x30
}
   1a0e4:	e8bd8070 	pop	{r4, r5, r6, pc}
    fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
   1a0e8:	e3130003 	tst	r3, #3
   1a0ec:	05943014 	ldreq	r3, [r4, #20]
   1a0f0:	13a03000 	movne	r3, #0
   1a0f4:	e5843008 	str	r3, [r4, #8]
  return 0;
   1a0f8:	e3a00000 	mov	r0, #0
}
   1a0fc:	e8bd8070 	pop	{r4, r5, r6, pc}
  CHECK_INIT (ptr, fp);
   1a100:	ebfff8f6 	bl	184e0 <__sinit>
   1a104:	eaffffe3 	b	1a098 <_fpurge_r+0x1c>
      _REENT_ERRNO(ptr) = EBADF;
   1a108:	e3a03009 	mov	r3, #9
      return EOF;
   1a10c:	e3e00000 	mvn	r0, #0
      _REENT_ERRNO(ptr) = EBADF;
   1a110:	e5853000 	str	r3, [r5]
      return EOF;
   1a114:	e8bd8070 	pop	{r4, r5, r6, pc}

0001a118 <fpurge>:
#ifndef _REENT_ONLY

int
fpurge (register FILE * fp)
{
  return _fpurge_r (_REENT, fp);
   1a118:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
{
   1a11c:	e92d4070 	push	{r4, r5, r6, lr}
  return _fpurge_r (_REENT, fp);
   1a120:	e3403002 	movt	r3, #2
{
   1a124:	e1a04000 	mov	r4, r0
  return _fpurge_r (_REENT, fp);
   1a128:	e5935000 	ldr	r5, [r3]
  CHECK_INIT (ptr, fp);
   1a12c:	e3550000 	cmp	r5, #0
   1a130:	0a000002 	beq	1a140 <fpurge+0x28>
   1a134:	e5953034 	ldr	r3, [r5, #52]	@ 0x34
   1a138:	e3530000 	cmp	r3, #0
   1a13c:	0a000019 	beq	1a1a8 <fpurge+0x90>
  t = fp->_flags;
   1a140:	e1d430fc 	ldrsh	r3, [r4, #12]
  if (!t)
   1a144:	e3530000 	cmp	r3, #0
   1a148:	0a000019 	beq	1a1b4 <fpurge+0x9c>
  fp->_p = fp->_bf._base;
   1a14c:	e5942010 	ldr	r2, [r4, #16]
  if ((t & __SWR) == 0)
   1a150:	e2130008 	ands	r0, r3, #8
  fp->_p = fp->_bf._base;
   1a154:	e5842000 	str	r2, [r4]
  if ((t & __SWR) == 0)
   1a158:	1a00000c 	bne	1a190 <fpurge+0x78>
      if (HASUB (fp))
   1a15c:	e5941030 	ldr	r1, [r4, #48]	@ 0x30
      fp->_r = 0;
   1a160:	e5840004 	str	r0, [r4, #4]
      if (HASUB (fp))
   1a164:	e3510000 	cmp	r1, #0
   1a168:	0a00000c 	beq	1a1a0 <fpurge+0x88>
	FREEUB (ptr, fp);
   1a16c:	e2843040 	add	r3, r4, #64	@ 0x40
   1a170:	e1510003 	cmp	r1, r3
   1a174:	0a000001 	beq	1a180 <fpurge+0x68>
   1a178:	e1a00005 	mov	r0, r5
   1a17c:	eb0014f2 	bl	1f54c <_free_r>
   1a180:	e3a03000 	mov	r3, #0
  return 0;
   1a184:	e3a00000 	mov	r0, #0
	FREEUB (ptr, fp);
   1a188:	e5843030 	str	r3, [r4, #48]	@ 0x30
}
   1a18c:	e8bd8070 	pop	{r4, r5, r6, pc}
    fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
   1a190:	e3130003 	tst	r3, #3
   1a194:	05943014 	ldreq	r3, [r4, #20]
   1a198:	13a03000 	movne	r3, #0
   1a19c:	e5843008 	str	r3, [r4, #8]
  return 0;
   1a1a0:	e3a00000 	mov	r0, #0
}
   1a1a4:	e8bd8070 	pop	{r4, r5, r6, pc}
  CHECK_INIT (ptr, fp);
   1a1a8:	e1a00005 	mov	r0, r5
   1a1ac:	ebfff8cb 	bl	184e0 <__sinit>
   1a1b0:	eaffffe2 	b	1a140 <fpurge+0x28>
      _REENT_ERRNO(ptr) = EBADF;
   1a1b4:	e3a03009 	mov	r3, #9
      return EOF;
   1a1b8:	e3e00000 	mvn	r0, #0
      _REENT_ERRNO(ptr) = EBADF;
   1a1bc:	e5853000 	str	r3, [r5]
      return EOF;
   1a1c0:	e8bd8070 	pop	{r4, r5, r6, pc}

0001a1c4 <__fpurge>:
#ifndef __rtems__

void
__fpurge (register FILE * fp)
{
  _fpurge_r (_REENT, fp);
   1a1c4:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
{
   1a1c8:	e92d4070 	push	{r4, r5, r6, lr}
  _fpurge_r (_REENT, fp);
   1a1cc:	e3403002 	movt	r3, #2
{
   1a1d0:	e1a04000 	mov	r4, r0
  _fpurge_r (_REENT, fp);
   1a1d4:	e5935000 	ldr	r5, [r3]
  CHECK_INIT (ptr, fp);
   1a1d8:	e3550000 	cmp	r5, #0
   1a1dc:	0a000002 	beq	1a1ec <__fpurge+0x28>
   1a1e0:	e5953034 	ldr	r3, [r5, #52]	@ 0x34
   1a1e4:	e3530000 	cmp	r3, #0
   1a1e8:	0a000017 	beq	1a24c <__fpurge+0x88>
  t = fp->_flags;
   1a1ec:	e1d430fc 	ldrsh	r3, [r4, #12]
  if (!t)
   1a1f0:	e3530000 	cmp	r3, #0
   1a1f4:	0a000017 	beq	1a258 <__fpurge+0x94>
  fp->_p = fp->_bf._base;
   1a1f8:	e5942010 	ldr	r2, [r4, #16]
  if ((t & __SWR) == 0)
   1a1fc:	e2130008 	ands	r0, r3, #8
  fp->_p = fp->_bf._base;
   1a200:	e5842000 	str	r2, [r4]
  if ((t & __SWR) == 0)
   1a204:	1a00000b 	bne	1a238 <__fpurge+0x74>
      if (HASUB (fp))
   1a208:	e5941030 	ldr	r1, [r4, #48]	@ 0x30
      fp->_r = 0;
   1a20c:	e5840004 	str	r0, [r4, #4]
      if (HASUB (fp))
   1a210:	e3510000 	cmp	r1, #0
   1a214:	08bd8070 	popeq	{r4, r5, r6, pc}
	FREEUB (ptr, fp);
   1a218:	e2843040 	add	r3, r4, #64	@ 0x40
   1a21c:	e1510003 	cmp	r1, r3
   1a220:	0a000001 	beq	1a22c <__fpurge+0x68>
   1a224:	e1a00005 	mov	r0, r5
   1a228:	eb0014c7 	bl	1f54c <_free_r>
   1a22c:	e3a03000 	mov	r3, #0
   1a230:	e5843030 	str	r3, [r4, #48]	@ 0x30
   1a234:	e8bd8070 	pop	{r4, r5, r6, pc}
    fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
   1a238:	e3130003 	tst	r3, #3
   1a23c:	05943014 	ldreq	r3, [r4, #20]
   1a240:	13a03000 	movne	r3, #0
   1a244:	e5843008 	str	r3, [r4, #8]
}
   1a248:	e8bd8070 	pop	{r4, r5, r6, pc}
  CHECK_INIT (ptr, fp);
   1a24c:	e1a00005 	mov	r0, r5
   1a250:	ebfff8a2 	bl	184e0 <__sinit>
   1a254:	eaffffe4 	b	1a1ec <__fpurge+0x28>
      _REENT_ERRNO(ptr) = EBADF;
   1a258:	e3a03009 	mov	r3, #9
   1a25c:	e5853000 	str	r3, [r5]
      return EOF;
   1a260:	e8bd8070 	pop	{r4, r5, r6, pc}

0001a264 <_fputc_unlocked_r>:

int
_fputc_unlocked_r (struct _reent *ptr,
       int ch,
       FILE * file)
{
   1a264:	e92d4010 	push	{r4, lr}
  CHECK_INIT(ptr, file);
   1a268:	e2504000 	subs	r4, r0, #0
{
   1a26c:	e24dd008 	sub	sp, sp, #8
  CHECK_INIT(ptr, file);
   1a270:	0a000002 	beq	1a280 <_fputc_unlocked_r+0x1c>
   1a274:	e5943034 	ldr	r3, [r4, #52]	@ 0x34
   1a278:	e3530000 	cmp	r3, #0
   1a27c:	0a000003 	beq	1a290 <_fputc_unlocked_r+0x2c>
  return _putc_unlocked_r (ptr, ch, file);
   1a280:	e1a00004 	mov	r0, r4
}
   1a284:	e28dd008 	add	sp, sp, #8
   1a288:	e8bd4010 	pop	{r4, lr}
  return _putc_unlocked_r (ptr, ch, file);
   1a28c:	eafffb8c 	b	190c4 <_putc_unlocked_r>
   1a290:	e88d0006 	stm	sp, {r1, r2}
  CHECK_INIT(ptr, file);
   1a294:	ebfff891 	bl	184e0 <__sinit>
   1a298:	e89d0006 	ldm	sp, {r1, r2}
  return _putc_unlocked_r (ptr, ch, file);
   1a29c:	e1a00004 	mov	r0, r4
}
   1a2a0:	e28dd008 	add	sp, sp, #8
   1a2a4:	e8bd4010 	pop	{r4, lr}
  return _putc_unlocked_r (ptr, ch, file);
   1a2a8:	eafffb85 	b	190c4 <_putc_unlocked_r>

0001a2ac <fputc_unlocked>:
int
fputc_unlocked (int ch,
       FILE * file)
{
#if !defined(__OPTIMIZE_SIZE__) && !defined(PREFER_SIZE_OVER_SPEED)
  struct _reent *reent = _REENT;
   1a2ac:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
{
   1a2b0:	e92d4010 	push	{r4, lr}
  struct _reent *reent = _REENT;
   1a2b4:	e3403002 	movt	r3, #2
{
   1a2b8:	e1a04000 	mov	r4, r0
   1a2bc:	e24dd008 	sub	sp, sp, #8
   1a2c0:	e1a02001 	mov	r2, r1
  struct _reent *reent = _REENT;
   1a2c4:	e5930000 	ldr	r0, [r3]

  CHECK_INIT(reent, file);
   1a2c8:	e3500000 	cmp	r0, #0
   1a2cc:	0a000002 	beq	1a2dc <fputc_unlocked+0x30>
   1a2d0:	e5903034 	ldr	r3, [r0, #52]	@ 0x34
   1a2d4:	e3530000 	cmp	r3, #0
   1a2d8:	0a000003 	beq	1a2ec <fputc_unlocked+0x40>
  return _putc_unlocked_r (reent, ch, file);
   1a2dc:	e1a01004 	mov	r1, r4
#else
  return _fputc_unlocked_r (_REENT, ch, file);
#endif
}
   1a2e0:	e28dd008 	add	sp, sp, #8
   1a2e4:	e8bd4010 	pop	{r4, lr}
  return _putc_unlocked_r (reent, ch, file);
   1a2e8:	eafffb75 	b	190c4 <_putc_unlocked_r>
  CHECK_INIT(reent, file);
   1a2ec:	e88d0005 	stm	sp, {r0, r2}
   1a2f0:	ebfff87a 	bl	184e0 <__sinit>
   1a2f4:	e89d0005 	ldm	sp, {r0, r2}
  return _putc_unlocked_r (reent, ch, file);
   1a2f8:	e1a01004 	mov	r1, r4
}
   1a2fc:	e28dd008 	add	sp, sp, #8
   1a300:	e8bd4010 	pop	{r4, lr}
  return _putc_unlocked_r (reent, ch, file);
   1a304:	eafffb6e 	b	190c4 <_putc_unlocked_r>

0001a308 <_fwrite_unlocked_r>:
{
   1a308:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  uio.uio_resid = iov.iov_len = n = count * size;
   1a30c:	e0080392 	mul	r8, r2, r3
{
   1a310:	e24dd018 	sub	sp, sp, #24
   1a314:	e1a04003 	mov	r4, r3
  CHECK_INIT(ptr, fp);
   1a318:	e2506000 	subs	r6, r0, #0
  uio.uio_iov = &iov;
   1a31c:	e28d3004 	add	r3, sp, #4
{
   1a320:	e59d5030 	ldr	r5, [sp, #48]	@ 0x30
  uio.uio_iov = &iov;
   1a324:	e58d300c 	str	r3, [sp, #12]
  uio.uio_iovcnt = 1;
   1a328:	e3a03001 	mov	r3, #1
{
   1a32c:	e1a07002 	mov	r7, r2
  iov.iov_base = buf;
   1a330:	e58d1004 	str	r1, [sp, #4]
  uio.uio_resid = iov.iov_len = n = count * size;
   1a334:	e58d8008 	str	r8, [sp, #8]
   1a338:	e58d8014 	str	r8, [sp, #20]
  uio.uio_iovcnt = 1;
   1a33c:	e58d3010 	str	r3, [sp, #16]
  CHECK_INIT(ptr, fp);
   1a340:	0a000002 	beq	1a350 <_fwrite_unlocked_r+0x48>
   1a344:	e5963034 	ldr	r3, [r6, #52]	@ 0x34
   1a348:	e3530000 	cmp	r3, #0
   1a34c:	0a000018 	beq	1a3b4 <_fwrite_unlocked_r+0xac>
  if (ORIENT (fp, -1) != -1)
   1a350:	e1d5c0fc 	ldrsh	ip, [r5, #12]
   1a354:	e5953064 	ldr	r3, [r5, #100]	@ 0x64
   1a358:	e31c0a02 	tst	ip, #8192	@ 0x2000
   1a35c:	038cca02 	orreq	ip, ip, #8192	@ 0x2000
   1a360:	03c33a02 	biceq	r3, r3, #8192	@ 0x2000
   1a364:	01c5c0bc 	strheq	ip, [r5, #12]
   1a368:	05853064 	streq	r3, [r5, #100]	@ 0x64
   1a36c:	e3130a02 	tst	r3, #8192	@ 0x2000
      return 0;
   1a370:	13a00000 	movne	r0, #0
  if (ORIENT (fp, -1) != -1)
   1a374:	0a000001 	beq	1a380 <_fwrite_unlocked_r+0x78>
}
   1a378:	e28dd018 	add	sp, sp, #24
   1a37c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  if (__sfvwrite_r (ptr, fp, &uio) == 0)
   1a380:	e1a01005 	mov	r1, r5
   1a384:	e1a00006 	mov	r0, r6
   1a388:	e28d200c 	add	r2, sp, #12
   1a38c:	ebfff927 	bl	18830 <__sfvwrite_r>
   1a390:	e3500000 	cmp	r0, #0
      return count;
   1a394:	01a00004 	moveq	r0, r4
  if (__sfvwrite_r (ptr, fp, &uio) == 0)
   1a398:	0afffff6 	beq	1a378 <_fwrite_unlocked_r+0x70>
  return (n - uio.uio_resid) / size;
   1a39c:	e59d0014 	ldr	r0, [sp, #20]
   1a3a0:	e1a01007 	mov	r1, r7
   1a3a4:	e0480000 	sub	r0, r8, r0
   1a3a8:	ebffef6c 	bl	16160 <__udivsi3>
}
   1a3ac:	e28dd018 	add	sp, sp, #24
   1a3b0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  CHECK_INIT(ptr, fp);
   1a3b4:	ebfff849 	bl	184e0 <__sinit>
   1a3b8:	eaffffe4 	b	1a350 <_fwrite_unlocked_r+0x48>

0001a3bc <fwrite_unlocked>:
  return _fwrite_r (_REENT, buf, size, count, fp);
   1a3bc:	e30bc1e8 	movw	ip, #45544	@ 0xb1e8
{
   1a3c0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  return _fwrite_r (_REENT, buf, size, count, fp);
   1a3c4:	e340c002 	movt	ip, #2
  uio.uio_resid = iov.iov_len = n = count * size;
   1a3c8:	e0070192 	mul	r7, r2, r1
{
   1a3cc:	e24dd018 	sub	sp, sp, #24
   1a3d0:	e1a05003 	mov	r5, r3
  return _fwrite_r (_REENT, buf, size, count, fp);
   1a3d4:	e59c8000 	ldr	r8, [ip]
  uio.uio_iov = &iov;
   1a3d8:	e28d3004 	add	r3, sp, #4
   1a3dc:	e58d300c 	str	r3, [sp, #12]
  uio.uio_iovcnt = 1;
   1a3e0:	e3a03001 	mov	r3, #1
{
   1a3e4:	e1a06001 	mov	r6, r1
   1a3e8:	e1a04002 	mov	r4, r2
  CHECK_INIT(ptr, fp);
   1a3ec:	e3580000 	cmp	r8, #0
  iov.iov_base = buf;
   1a3f0:	e58d0004 	str	r0, [sp, #4]
  uio.uio_resid = iov.iov_len = n = count * size;
   1a3f4:	e58d7008 	str	r7, [sp, #8]
   1a3f8:	e58d7014 	str	r7, [sp, #20]
  uio.uio_iovcnt = 1;
   1a3fc:	e58d3010 	str	r3, [sp, #16]
  CHECK_INIT(ptr, fp);
   1a400:	0a000002 	beq	1a410 <fwrite_unlocked+0x54>
   1a404:	e5983034 	ldr	r3, [r8, #52]	@ 0x34
   1a408:	e3530000 	cmp	r3, #0
   1a40c:	0a000018 	beq	1a474 <fwrite_unlocked+0xb8>
  if (ORIENT (fp, -1) != -1)
   1a410:	e1d520fc 	ldrsh	r2, [r5, #12]
   1a414:	e5953064 	ldr	r3, [r5, #100]	@ 0x64
   1a418:	e3120a02 	tst	r2, #8192	@ 0x2000
   1a41c:	03822a02 	orreq	r2, r2, #8192	@ 0x2000
   1a420:	03c33a02 	biceq	r3, r3, #8192	@ 0x2000
   1a424:	01c520bc 	strheq	r2, [r5, #12]
   1a428:	05853064 	streq	r3, [r5, #100]	@ 0x64
   1a42c:	e3130a02 	tst	r3, #8192	@ 0x2000
      return 0;
   1a430:	13a00000 	movne	r0, #0
  if (ORIENT (fp, -1) != -1)
   1a434:	0a000001 	beq	1a440 <fwrite_unlocked+0x84>
}
   1a438:	e28dd018 	add	sp, sp, #24
   1a43c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  if (__sfvwrite_r (ptr, fp, &uio) == 0)
   1a440:	e1a01005 	mov	r1, r5
   1a444:	e1a00008 	mov	r0, r8
   1a448:	e28d200c 	add	r2, sp, #12
   1a44c:	ebfff8f7 	bl	18830 <__sfvwrite_r>
   1a450:	e3500000 	cmp	r0, #0
      return count;
   1a454:	01a00004 	moveq	r0, r4
  if (__sfvwrite_r (ptr, fp, &uio) == 0)
   1a458:	0afffff6 	beq	1a438 <fwrite_unlocked+0x7c>
  return (n - uio.uio_resid) / size;
   1a45c:	e59d0014 	ldr	r0, [sp, #20]
   1a460:	e1a01006 	mov	r1, r6
   1a464:	e0470000 	sub	r0, r7, r0
   1a468:	ebffef3c 	bl	16160 <__udivsi3>
}
   1a46c:	e28dd018 	add	sp, sp, #24
   1a470:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  CHECK_INIT(ptr, fp);
   1a474:	e1a00008 	mov	r0, r8
   1a478:	ebfff818 	bl	184e0 <__sinit>
   1a47c:	eaffffe3 	b	1a410 <fwrite_unlocked+0x54>

0001a480 <memcmp>:
  unsigned long *a2;

  /* If the size is too small, or either pointer is unaligned,
     then we punt to the byte compare loop.  Hopefully this will
     not turn up in inner loops.  */
  if (!TOO_SMALL(n) && !UNALIGNED(s1,s2))
   1a480:	e3520003 	cmp	r2, #3
   1a484:	8a00000f 	bhi	1a4c8 <memcmp+0x48>

      s1 = (unsigned char*)a1;
      s2 = (unsigned char*)a2;
    }

  while (n--)
   1a488:	e3520000 	cmp	r2, #0
   1a48c:	e242c001 	sub	ip, r2, #1
   1a490:	12403001 	subne	r3, r0, #1
   1a494:	12411001 	subne	r1, r1, #1
   1a498:	1080200c 	addne	r2, r0, ip
   1a49c:	1a000003 	bne	1a4b0 <memcmp+0x30>
	return *s1 - *s2;
      s1++;
      s2++;
    }

  return 0;
   1a4a0:	e3a00000 	mov	r0, #0
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   1a4a4:	e12fff1e 	bx	lr
  while (n--)
   1a4a8:	e1520003 	cmp	r2, r3
   1a4ac:	0afffffb 	beq	1a4a0 <memcmp+0x20>
      if (*s1 != *s2)
   1a4b0:	e5f30001 	ldrb	r0, [r3, #1]!
   1a4b4:	e5f1c001 	ldrb	ip, [r1, #1]!
   1a4b8:	e150000c 	cmp	r0, ip
   1a4bc:	0afffff9 	beq	1a4a8 <memcmp+0x28>
	return *s1 - *s2;
   1a4c0:	e040000c 	sub	r0, r0, ip
   1a4c4:	e12fff1e 	bx	lr
{
   1a4c8:	e92d4010 	push	{r4, lr}
  if (!TOO_SMALL(n) && !UNALIGNED(s1,s2))
   1a4cc:	e181e000 	orr	lr, r1, r0
   1a4d0:	e31e0003 	tst	lr, #3
   1a4d4:	e1a0c000 	mov	ip, r0
   1a4d8:	e1a03001 	mov	r3, r1
   1a4dc:	0a00000f 	beq	1a520 <memcmp+0xa0>
  while (n--)
   1a4e0:	e242c001 	sub	ip, r2, #1
   1a4e4:	e2403001 	sub	r3, r0, #1
   1a4e8:	e2411001 	sub	r1, r1, #1
   1a4ec:	e080200c 	add	r2, r0, ip
   1a4f0:	ea000001 	b	1a4fc <memcmp+0x7c>
   1a4f4:	e1520003 	cmp	r2, r3
   1a4f8:	0a000014 	beq	1a550 <memcmp+0xd0>
      if (*s1 != *s2)
   1a4fc:	e5f30001 	ldrb	r0, [r3, #1]!
   1a500:	e5f1c001 	ldrb	ip, [r1, #1]!
   1a504:	e150000c 	cmp	r0, ip
   1a508:	0afffff9 	beq	1a4f4 <memcmp+0x74>
	return *s1 - *s2;
   1a50c:	e040000c 	sub	r0, r0, ip
   1a510:	e8bd8010 	pop	{r4, pc}
          n -= LBLOCKSIZE;
   1a514:	e2422004 	sub	r2, r2, #4
      while (n >= LBLOCKSIZE)
   1a518:	e3520003 	cmp	r2, #3
   1a51c:	9a000006 	bls	1a53c <memcmp+0xbc>
          a1++;
   1a520:	e1a01003 	mov	r1, r3
   1a524:	e1a0000c 	mov	r0, ip
          if (*a1 != *a2) 
   1a528:	e493e004 	ldr	lr, [r3], #4
   1a52c:	e49c4004 	ldr	r4, [ip], #4
   1a530:	e154000e 	cmp	r4, lr
   1a534:	0afffff6 	beq	1a514 <memcmp+0x94>
   1a538:	eaffffe8 	b	1a4e0 <memcmp+0x60>
  while (n--)
   1a53c:	e3520000 	cmp	r2, #0
          a1++;
   1a540:	e1a0000c 	mov	r0, ip
          a2++;
   1a544:	e1a01003 	mov	r1, r3
  while (n--)
   1a548:	e242c001 	sub	ip, r2, #1
   1a54c:	1affffe4 	bne	1a4e4 <memcmp+0x64>
  return 0;
   1a550:	e3a00000 	mov	r0, #0
}
   1a554:	e8bd8010 	pop	{r4, pc}

0001a558 <memmove>:
  char *dst = dst_void;
  const char *src = src_void;
  long *aligned_dst;
  const long *aligned_src;

  if (src < dst && dst < src + length)
   1a558:	e1500001 	cmp	r0, r1
   1a55c:	9a00000a 	bls	1a58c <memmove+0x34>
   1a560:	e0813002 	add	r3, r1, r2
   1a564:	e1530000 	cmp	r3, r0
   1a568:	9a000007 	bls	1a58c <memmove+0x34>
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
      dst += length;
      while (length--)
   1a56c:	e3520000 	cmp	r2, #0
      dst += length;
   1a570:	e0802002 	add	r2, r0, r2
      while (length--)
   1a574:	012fff1e 	bxeq	lr
	{
	  *--dst = *--src;
   1a578:	e573c001 	ldrb	ip, [r3, #-1]!
      while (length--)
   1a57c:	e1510003 	cmp	r1, r3
	  *--dst = *--src;
   1a580:	e562c001 	strb	ip, [r2, #-1]!
      while (length--)
   1a584:	1afffffb 	bne	1a578 <memmove+0x20>
   1a588:	e12fff1e 	bx	lr
  else
    {
      /* Use optimizing algorithm for a non-destructive copy to closely 
         match memcpy. If the size is small or either SRC or DST is unaligned,
         then punt into the byte copy loop.  This should be rare.  */
      if (!TOO_SMALL(length) && !UNALIGNED (src, dst))
   1a58c:	e352000f 	cmp	r2, #15
   1a590:	8a00000b 	bhi	1a5c4 <memmove+0x6c>
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   1a594:	e3520000 	cmp	r2, #0
  char *dst = dst_void;
   1a598:	e1a03000 	mov	r3, r0
      while (length--)
   1a59c:	e2422001 	sub	r2, r2, #1
   1a5a0:	012fff1e 	bxeq	lr
   1a5a4:	e2822001 	add	r2, r2, #1
   1a5a8:	e2433001 	sub	r3, r3, #1
   1a5ac:	e0812002 	add	r2, r1, r2
        {
          *dst++ = *src++;
   1a5b0:	e4d1c001 	ldrb	ip, [r1], #1
      while (length--)
   1a5b4:	e1510002 	cmp	r1, r2
          *dst++ = *src++;
   1a5b8:	e5e3c001 	strb	ip, [r3, #1]!
      while (length--)
   1a5bc:	1afffffb 	bne	1a5b0 <memmove+0x58>
   1a5c0:	e12fff1e 	bx	lr
      if (!TOO_SMALL(length) && !UNALIGNED (src, dst))
   1a5c4:	e1803001 	orr	r3, r0, r1
   1a5c8:	e3130003 	tst	r3, #3
      while (length--)
   1a5cc:	12422001 	subne	r2, r2, #1
  char *dst = dst_void;
   1a5d0:	11a03000 	movne	r3, r0
      if (!TOO_SMALL(length) && !UNALIGNED (src, dst))
   1a5d4:	1afffff2 	bne	1a5a4 <memmove+0x4c>
   1a5d8:	e2423010 	sub	r3, r2, #16
{
   1a5dc:	e92d4070 	push	{r4, r5, r6, lr}
   1a5e0:	e281c020 	add	ip, r1, #32
   1a5e4:	e3c3e00f 	bic	lr, r3, #15
   1a5e8:	e08cc00e 	add	ip, ip, lr
   1a5ec:	e1a0e223 	lsr	lr, r3, #4
   1a5f0:	e2814010 	add	r4, r1, #16
   1a5f4:	e2805010 	add	r5, r0, #16
              *aligned_dst++ = *aligned_src++;
   1a5f8:	e5143010 	ldr	r3, [r4, #-16]
          while (length >= BIGBLOCKSIZE)
   1a5fc:	e2844010 	add	r4, r4, #16
   1a600:	e2855010 	add	r5, r5, #16
              *aligned_dst++ = *aligned_src++;
   1a604:	e5053020 	str	r3, [r5, #-32]	@ 0xffffffe0
              *aligned_dst++ = *aligned_src++;
   1a608:	e514301c 	ldr	r3, [r4, #-28]	@ 0xffffffe4
   1a60c:	e505301c 	str	r3, [r5, #-28]	@ 0xffffffe4
              *aligned_dst++ = *aligned_src++;
   1a610:	e5143018 	ldr	r3, [r4, #-24]	@ 0xffffffe8
   1a614:	e5053018 	str	r3, [r5, #-24]	@ 0xffffffe8
              *aligned_dst++ = *aligned_src++;
   1a618:	e5143014 	ldr	r3, [r4, #-20]	@ 0xffffffec
          while (length >= BIGBLOCKSIZE)
   1a61c:	e154000c 	cmp	r4, ip
              *aligned_dst++ = *aligned_src++;
   1a620:	e5053014 	str	r3, [r5, #-20]	@ 0xffffffec
          while (length >= BIGBLOCKSIZE)
   1a624:	1afffff3 	bne	1a5f8 <memmove+0xa0>
   1a628:	e28e3001 	add	r3, lr, #1
          while (length >= LITTLEBLOCKSIZE)
   1a62c:	e312000c 	tst	r2, #12
   1a630:	e1a03203 	lsl	r3, r3, #4
   1a634:	e202e00f 	and	lr, r2, #15
   1a638:	01a0200e 	moveq	r2, lr
   1a63c:	e0811003 	add	r1, r1, r3
   1a640:	e0803003 	add	r3, r0, r3
   1a644:	0a00000e 	beq	1a684 <memmove+0x12c>
   1a648:	e24ee004 	sub	lr, lr, #4
   1a64c:	e243c004 	sub	ip, r3, #4
   1a650:	e3ce6003 	bic	r6, lr, #3
   1a654:	e1a0e12e 	lsr	lr, lr, #2
   1a658:	e0836006 	add	r6, r3, r6
   1a65c:	e1a04001 	mov	r4, r1
              *aligned_dst++ = *aligned_src++;
   1a660:	e4945004 	ldr	r5, [r4], #4
   1a664:	e5ac5004 	str	r5, [ip, #4]!
          while (length >= LITTLEBLOCKSIZE)
   1a668:	e15c0006 	cmp	ip, r6
   1a66c:	1afffffb 	bne	1a660 <memmove+0x108>
   1a670:	e28ec001 	add	ip, lr, #1
   1a674:	e2022003 	and	r2, r2, #3
   1a678:	e1a0c10c 	lsl	ip, ip, #2
          dst = (char*)aligned_dst;
   1a67c:	e083300c 	add	r3, r3, ip
          src = (char*)aligned_src;
   1a680:	e081100c 	add	r1, r1, ip
      while (length--)
   1a684:	e3520000 	cmp	r2, #0
   1a688:	e2422001 	sub	r2, r2, #1
   1a68c:	08bd8070 	popeq	{r4, r5, r6, pc}
   1a690:	e2822001 	add	r2, r2, #1
   1a694:	e2433001 	sub	r3, r3, #1
   1a698:	e0812002 	add	r2, r1, r2
          *dst++ = *src++;
   1a69c:	e4d1c001 	ldrb	ip, [r1], #1
      while (length--)
   1a6a0:	e1510002 	cmp	r1, r2
          *dst++ = *src++;
   1a6a4:	e5e3c001 	strb	ip, [r3, #1]!
      while (length--)
   1a6a8:	1afffffb 	bne	1a69c <memmove+0x144>
   1a6ac:	e8bd8070 	pop	{r4, r5, r6, pc}

0001a6b0 <memset>:
  unsigned long buffer;
  unsigned long *aligned_addr;
  unsigned int d = c & 0xff;	/* To avoid sign extension, copy C to an
				   unsigned variable.  */

  while (UNALIGNED (s))
   1a6b0:	e3100003 	tst	r0, #3
{
   1a6b4:	e92d4030 	push	{r4, r5, lr}
  while (UNALIGNED (s))
   1a6b8:	0a000037 	beq	1a79c <memset+0xec>
    {
      if (n--)
   1a6bc:	e3520000 	cmp	r2, #0
   1a6c0:	e2423001 	sub	r3, r2, #1
   1a6c4:	08bd8030 	popeq	{r4, r5, pc}
        *s++ = (char) c;
   1a6c8:	e6ef2071 	uxtb	r2, r1
  char *s = (char *) m;
   1a6cc:	e1a0e000 	mov	lr, r0
   1a6d0:	ea000002 	b	1a6e0 <memset+0x30>
      if (n--)
   1a6d4:	e2433001 	sub	r3, r3, #1
   1a6d8:	e3730001 	cmn	r3, #1
   1a6dc:	08bd8030 	popeq	{r4, r5, pc}
        *s++ = (char) c;
   1a6e0:	e4ce2001 	strb	r2, [lr], #1
  while (UNALIGNED (s))
   1a6e4:	e31e0003 	tst	lr, #3
   1a6e8:	1afffff9 	bne	1a6d4 <memset+0x24>
      else
        return m;
    }

  if (!TOO_SMALL (n))
   1a6ec:	e3530003 	cmp	r3, #3
   1a6f0:	9a000021 	bls	1a77c <memset+0xcc>
  unsigned int d = c & 0xff;	/* To avoid sign extension, copy C to an
   1a6f4:	e6efc071 	uxtb	ip, r1
      buffer |= (buffer << 16);
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        buffer = (buffer << i) | buffer;

      /* Unroll the loop.  */
      while (n >= LBLOCKSIZE*4)
   1a6f8:	e353000f 	cmp	r3, #15
   1a6fc:	e08cc40c 	add	ip, ip, ip, lsl #8
   1a700:	e08cc80c 	add	ip, ip, ip, lsl #16
   1a704:	9a000011 	bls	1a750 <memset+0xa0>
   1a708:	e2432010 	sub	r2, r3, #16
   1a70c:	e3c2500f 	bic	r5, r2, #15
   1a710:	e28e4010 	add	r4, lr, #16
   1a714:	e0844005 	add	r4, r4, r5
   1a718:	e1a05222 	lsr	r5, r2, #4
   1a71c:	e1a0200e 	mov	r2, lr
        {
          *aligned_addr++ = buffer;
   1a720:	e582c000 	str	ip, [r2]
      while (n >= LBLOCKSIZE*4)
   1a724:	e2822010 	add	r2, r2, #16
          *aligned_addr++ = buffer;
   1a728:	e502c00c 	str	ip, [r2, #-12]
   1a72c:	e502c008 	str	ip, [r2, #-8]
   1a730:	e502c004 	str	ip, [r2, #-4]
      while (n >= LBLOCKSIZE*4)
   1a734:	e1520004 	cmp	r2, r4
   1a738:	1afffff8 	bne	1a720 <memset+0x70>
          *aligned_addr++ = buffer;
          *aligned_addr++ = buffer;
          n -= 4*LBLOCKSIZE;
        }

      while (n >= LBLOCKSIZE)
   1a73c:	e313000c 	tst	r3, #12
   1a740:	e2852001 	add	r2, r5, #1
   1a744:	e08ee202 	add	lr, lr, r2, lsl #4
   1a748:	e203300f 	and	r3, r3, #15
   1a74c:	0a00000a 	beq	1a77c <memset+0xcc>
      while (n >= LBLOCKSIZE*4)
   1a750:	e1a0200e 	mov	r2, lr
   1a754:	e08e5003 	add	r5, lr, r3
        {
          *aligned_addr++ = buffer;
   1a758:	e482c004 	str	ip, [r2], #4
      while (n >= LBLOCKSIZE)
   1a75c:	e0454002 	sub	r4, r5, r2
   1a760:	e3540003 	cmp	r4, #3
   1a764:	8afffffb 	bhi	1a758 <memset+0xa8>
   1a768:	e2432004 	sub	r2, r3, #4
   1a76c:	e2033003 	and	r3, r3, #3
   1a770:	e3c22003 	bic	r2, r2, #3
   1a774:	e2822004 	add	r2, r2, #4
   1a778:	e08ee002 	add	lr, lr, r2
      s = (char*)aligned_addr;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (n--)
   1a77c:	e3530000 	cmp	r3, #0
   1a780:	08bd8030 	popeq	{r4, r5, pc}
        *s++ = (char) c;
   1a784:	e6ef1071 	uxtb	r1, r1
   1a788:	e08e3003 	add	r3, lr, r3
    *s++ = (char) c;
   1a78c:	e4ce1001 	strb	r1, [lr], #1
  while (n--)
   1a790:	e15e0003 	cmp	lr, r3
   1a794:	1afffffc 	bne	1a78c <memset+0xdc>
   1a798:	e8bd8030 	pop	{r4, r5, pc}
  char *s = (char *) m;
   1a79c:	e1a0e000 	mov	lr, r0
  while (UNALIGNED (s))
   1a7a0:	e1a03002 	mov	r3, r2
   1a7a4:	eaffffd0 	b	1a6ec <memset+0x3c>

0001a7a8 <strchr>:
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long mask,j;
  unsigned long *aligned_addr;

  /* Special case for finding 0.  */
  if (!c)
   1a7a8:	e21110ff 	ands	r1, r1, #255	@ 0xff
        s++;
      return (char *) s;
    }

  /* All other bytes.  Align the pointer, then search a long at a time.  */
  while (UNALIGNED (s))
   1a7ac:	e1a03000 	mov	r3, r0
   1a7b0:	e2002003 	and	r2, r0, #3
  if (!c)
   1a7b4:	0a000029 	beq	1a860 <strchr+0xb8>
  while (UNALIGNED (s))
   1a7b8:	e3520000 	cmp	r2, #0
   1a7bc:	1a000020 	bne	1a844 <strchr+0x9c>
{
   1a7c0:	e92d4030 	push	{r4, r5, lr}
   1a7c4:	e0814401 	add	r4, r1, r1, lsl #8
  mask = c;
  for (j = 8; j < LBLOCKSIZE * 8; j <<= 1)
    mask = (mask << j) | mask;

  aligned_addr = (unsigned long *) s;
  while (!DETECTNULL (*aligned_addr) && !DETECTCHAR (*aligned_addr, mask))
   1a7c8:	e5902000 	ldr	r2, [r0]
   1a7cc:	e30feeff 	movw	lr, #65279	@ 0xfeff
   1a7d0:	e0844804 	add	r4, r4, r4, lsl #16
   1a7d4:	e3085080 	movw	r5, #32896	@ 0x8080
   1a7d8:	e34feefe 	movt	lr, #65278	@ 0xfefe
   1a7dc:	e024c002 	eor	ip, r4, r2
   1a7e0:	e3485080 	movt	r5, #32896	@ 0x8080
   1a7e4:	ea000001 	b	1a7f0 <strchr+0x48>
   1a7e8:	e5b02004 	ldr	r2, [r0, #4]!
   1a7ec:	e022c004 	eor	ip, r2, r4
   1a7f0:	e082300e 	add	r3, r2, lr
   1a7f4:	e1c33002 	bic	r3, r3, r2
   1a7f8:	e08c200e 	add	r2, ip, lr
   1a7fc:	e1c2200c 	bic	r2, r2, ip
   1a800:	e1833002 	orr	r3, r3, r2
   1a804:	e1130005 	tst	r3, r5
   1a808:	0afffff6 	beq	1a7e8 <strchr+0x40>

  s = (unsigned char *) aligned_addr;

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (*s && *s != c)
   1a80c:	e5d03000 	ldrb	r3, [r0]
   1a810:	e3530000 	cmp	r3, #0
   1a814:	0a000004 	beq	1a82c <strchr+0x84>
   1a818:	e1510003 	cmp	r1, r3
   1a81c:	08bd8030 	popeq	{r4, r5, pc}
   1a820:	e5f03001 	ldrb	r3, [r0, #1]!
   1a824:	e3530000 	cmp	r3, #0
   1a828:	1afffffa 	bne	1a818 <strchr+0x70>
        return NULL;
   1a82c:	e1a00003 	mov	r0, r3
    s++;
  if (*s == c)
    return (char *)s;
  return NULL;
}
   1a830:	e8bd8030 	pop	{r4, r5, pc}
      if (*s == c)
   1a834:	e1520001 	cmp	r2, r1
   1a838:	012fff1e 	bxeq	lr
  while (UNALIGNED (s))
   1a83c:	e3130003 	tst	r3, #3
   1a840:	0a000024 	beq	1a8d8 <strchr+0x130>
      if (!*s)
   1a844:	e5d32000 	ldrb	r2, [r3]
   1a848:	e1a00003 	mov	r0, r3
   1a84c:	e2833001 	add	r3, r3, #1
   1a850:	e3520000 	cmp	r2, #0
   1a854:	1afffff6 	bne	1a834 <strchr+0x8c>
        return NULL;
   1a858:	e1a00002 	mov	r0, r2
}
   1a85c:	e12fff1e 	bx	lr
      while (UNALIGNED (s))
   1a860:	e3520000 	cmp	r2, #0
   1a864:	0a000006 	beq	1a884 <strchr+0xdc>
          s++;
   1a868:	e1a00003 	mov	r0, r3
          if (!*s)
   1a86c:	e4d32001 	ldrb	r2, [r3], #1
   1a870:	e3520000 	cmp	r2, #0
   1a874:	012fff1e 	bxeq	lr
      while (UNALIGNED (s))
   1a878:	e3130003 	tst	r3, #3
   1a87c:	1afffff9 	bne	1a868 <strchr+0xc0>
          s++;
   1a880:	e1a00003 	mov	r0, r3
      while (!DETECTNULL (*aligned_addr))
   1a884:	e5902000 	ldr	r2, [r0]
   1a888:	e30fceff 	movw	ip, #65279	@ 0xfeff
   1a88c:	e34fcefe 	movt	ip, #65278	@ 0xfefe
   1a890:	e3081080 	movw	r1, #32896	@ 0x8080
   1a894:	e3481080 	movt	r1, #32896	@ 0x8080
   1a898:	e082300c 	add	r3, r2, ip
   1a89c:	e1c33002 	bic	r3, r3, r2
   1a8a0:	e1130001 	tst	r3, r1
   1a8a4:	1a000004 	bne	1a8bc <strchr+0x114>
   1a8a8:	e5b02004 	ldr	r2, [r0, #4]!
   1a8ac:	e082300c 	add	r3, r2, ip
   1a8b0:	e1c33002 	bic	r3, r3, r2
   1a8b4:	e1130001 	tst	r3, r1
   1a8b8:	0afffffa 	beq	1a8a8 <strchr+0x100>
      while (*s)
   1a8bc:	e5d03000 	ldrb	r3, [r0]
   1a8c0:	e3530000 	cmp	r3, #0
   1a8c4:	012fff1e 	bxeq	lr
   1a8c8:	e5f03001 	ldrb	r3, [r0, #1]!
   1a8cc:	e3530000 	cmp	r3, #0
   1a8d0:	1afffffc 	bne	1a8c8 <strchr+0x120>
   1a8d4:	e12fff1e 	bx	lr
      s++;
   1a8d8:	e1a00003 	mov	r0, r3
   1a8dc:	eaffffb7 	b	1a7c0 <strchr+0x18>

0001a8e0 <strerror_r>:
char *
strerror_r (int errnum,
	char *buffer,
	size_t n)
{
  char *error = _strerror_r (_REENT, errnum, 1, NULL);
   1a8e0:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
{
   1a8e4:	e92d4070 	push	{r4, r5, r6, lr}
  char *error = _strerror_r (_REENT, errnum, 1, NULL);
   1a8e8:	e3403002 	movt	r3, #2
{
   1a8ec:	e1a0e000 	mov	lr, r0
   1a8f0:	e1a04002 	mov	r4, r2
   1a8f4:	e1a06001 	mov	r6, r1
  char *error = _strerror_r (_REENT, errnum, 1, NULL);
   1a8f8:	e5930000 	ldr	r0, [r3]
   1a8fc:	e1a0100e 	mov	r1, lr
   1a900:	e3a03000 	mov	r3, #0
   1a904:	e3a02001 	mov	r2, #1
   1a908:	eb002b2b 	bl	255bc <_strerror_r>
   1a90c:	e1a05000 	mov	r5, r0

  if (strlen (error) >= n)
   1a910:	fa0016da 	blx	20480 <strlen>
   1a914:	e1500004 	cmp	r0, r4
   1a918:	3a000001 	bcc	1a924 <strerror_r+0x44>
    return error;
  return strcpy (buffer, error);
}
   1a91c:	e1a00005 	mov	r0, r5
   1a920:	e8bd8070 	pop	{r4, r5, r6, pc}
  return strcpy (buffer, error);
   1a924:	e1a01005 	mov	r1, r5
   1a928:	e1a00006 	mov	r0, r6
}
   1a92c:	e8bd4070 	pop	{r4, r5, r6, lr}
  return strcpy (buffer, error);
   1a930:	ea0014e2 	b	1fcc0 <strcpy>

0001a934 <strncmp>:
  return (*(unsigned char *) s1) - (*(unsigned char *) s2);
#else
  unsigned long *a1;
  unsigned long *a2;

  if (n == 0)
   1a934:	e3520000 	cmp	r2, #0
   1a938:	0a00002e 	beq	1a9f8 <strncmp+0xc4>
    return 0;

  /* If s1 or s2 are unaligned, then compare bytes. */
  if (!UNALIGNED (s1, s2))
   1a93c:	e180c001 	orr	ip, r0, r1
{
   1a940:	e92d40f0 	push	{r4, r5, r6, r7, lr}
  if (!UNALIGNED (s1, s2))
   1a944:	e31c0003 	tst	ip, #3
   1a948:	e1a04000 	mov	r4, r0
   1a94c:	e1a03001 	mov	r3, r1
   1a950:	1a000015 	bne	1a9ac <strncmp+0x78>
    {
      /* If s1 and s2 are word-aligned, compare them a word at a time. */
      a1 = (unsigned long*)s1;
      a2 = (unsigned long*)s2;
      while (n >= sizeof (long) && *a1 == *a2)
   1a954:	e3520003 	cmp	r2, #3
   1a958:	9a000013 	bls	1a9ac <strncmp+0x78>
        {
          n -= sizeof (long);

          /* If we've run out of bytes or hit a null, return zero
	     since we already know *a1 == *a2.  */
          if (n == 0 || DETECTNULL (*a1))
   1a95c:	e30f6eff 	movw	r6, #65279	@ 0xfeff
   1a960:	e3087080 	movw	r7, #32896	@ 0x8080
   1a964:	e34f6efe 	movt	r6, #65278	@ 0xfefe
   1a968:	e3487080 	movt	r7, #32896	@ 0x8080
   1a96c:	ea000005 	b	1a988 <strncmp+0x54>
   1a970:	e2522004 	subs	r2, r2, #4
   1a974:	0a00001d 	beq	1a9f0 <strncmp+0xbc>
   1a978:	e11e0007 	tst	lr, r7
   1a97c:	1a00001b 	bne	1a9f0 <strncmp+0xbc>
      while (n >= sizeof (long) && *a1 == *a2)
   1a980:	e3520003 	cmp	r2, #3
   1a984:	9a00001f 	bls	1aa08 <strncmp+0xd4>
   1a988:	e594c000 	ldr	ip, [r4]
   1a98c:	e1a01003 	mov	r1, r3
   1a990:	e4935004 	ldr	r5, [r3], #4
   1a994:	e1a00004 	mov	r0, r4
   1a998:	e2844004 	add	r4, r4, #4
          if (n == 0 || DETECTNULL (*a1))
   1a99c:	e08ce006 	add	lr, ip, r6
      while (n >= sizeof (long) && *a1 == *a2)
   1a9a0:	e15c0005 	cmp	ip, r5
          if (n == 0 || DETECTNULL (*a1))
   1a9a4:	e1cee00c 	bic	lr, lr, ip
      while (n >= sizeof (long) && *a1 == *a2)
   1a9a8:	0afffff0 	beq	1a970 <strncmp+0x3c>
      /* A difference was detected in last few bytes of s1, so search bytewise */
      s1 = (char*)a1;
      s2 = (char*)a2;
    }

  while (n-- > 0 && *s1 == *s2)
   1a9ac:	e5d0c000 	ldrb	ip, [r0]
   1a9b0:	e5d14000 	ldrb	r4, [r1]
   1a9b4:	e15c0004 	cmp	ip, r4
   1a9b8:	1a000010 	bne	1aa00 <strncmp+0xcc>
    {
      /* If we've run out of bytes or hit a null, return zero
	 since we already know *s1 == *s2.  */
      if (n == 0 || *s1 == '\0')
   1a9bc:	e3520001 	cmp	r2, #1
   1a9c0:	135c0000 	cmpne	ip, #0
   1a9c4:	0a000009 	beq	1a9f0 <strncmp+0xbc>
   1a9c8:	e1a0e000 	mov	lr, r0
  while (n-- > 0 && *s1 == *s2)
   1a9cc:	e5fec001 	ldrb	ip, [lr, #1]!
   1a9d0:	e5f14001 	ldrb	r4, [r1, #1]!
   1a9d4:	e042300e 	sub	r3, r2, lr
   1a9d8:	e15c0004 	cmp	ip, r4
      if (n == 0 || *s1 == '\0')
   1a9dc:	e2633001 	rsb	r3, r3, #1
  while (n-- > 0 && *s1 == *s2)
   1a9e0:	1a000006 	bne	1aa00 <strncmp+0xcc>
      if (n == 0 || *s1 == '\0')
   1a9e4:	e1500003 	cmp	r0, r3
   1a9e8:	135c0000 	cmpne	ip, #0
   1a9ec:	1afffff6 	bne	1a9cc <strncmp+0x98>
    return 0;
   1a9f0:	e3a00000 	mov	r0, #0
      s1++;
      s2++;
    }
  return (*(unsigned char *) s1) - (*(unsigned char *) s2);
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   1a9f4:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    return 0;
   1a9f8:	e1a00002 	mov	r0, r2
}
   1a9fc:	e12fff1e 	bx	lr
  return (*(unsigned char *) s1) - (*(unsigned char *) s2);
   1aa00:	e04c0004 	sub	r0, ip, r4
   1aa04:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
          a1++;
   1aa08:	e1a00004 	mov	r0, r4
          a2++;
   1aa0c:	e1a01003 	mov	r1, r3
   1aa10:	eaffffe5 	b	1a9ac <strncmp+0x78>

0001aa14 <strncpy>:
  const char *src = src0;
  long *aligned_dst;
  const long *aligned_src;

  /* If SRC and DEST is aligned and count large enough, then copy words.  */
  if (!UNALIGNED (src, dst) && !TOO_SMALL (count))
   1aa14:	e1803001 	orr	r3, r0, r1
   1aa18:	e3520003 	cmp	r2, #3
   1aa1c:	e7e13053 	ubfx	r3, r3, #0, #2
   1aa20:	93a0c000 	movls	ip, #0
   1aa24:	83a0c001 	movhi	ip, #1
   1aa28:	e3530000 	cmp	r3, #0
   1aa2c:	13a0c000 	movne	ip, #0
{
   1aa30:	e92d4070 	push	{r4, r5, r6, lr}
  if (!UNALIGNED (src, dst) && !TOO_SMALL (count))
   1aa34:	e35c0000 	cmp	ip, #0
  char *dst = dst0;
   1aa38:	01a0e000 	moveq	lr, r0
  if (!UNALIGNED (src, dst) && !TOO_SMALL (count))
   1aa3c:	1a000012 	bne	1aa8c <strncpy+0x78>
   1aa40:	e2411001 	sub	r1, r1, #1
   1aa44:	ea000001 	b	1aa50 <strncpy+0x3c>
    }

  while (count > 0)
    {
      --count;
      if ((*dst++ = *src++) == '\0')
   1aa48:	e1a0e003 	mov	lr, r3
      --count;
   1aa4c:	e1a02004 	mov	r2, r4
  while (count > 0)
   1aa50:	e3520000 	cmp	r2, #0
      if ((*dst++ = *src++) == '\0')
   1aa54:	e1a0300e 	mov	r3, lr
      --count;
   1aa58:	e2424001 	sub	r4, r2, #1
  while (count > 0)
   1aa5c:	08bd8070 	popeq	{r4, r5, r6, pc}
      if ((*dst++ = *src++) == '\0')
   1aa60:	e5f1c001 	ldrb	ip, [r1, #1]!
   1aa64:	e35c0000 	cmp	ip, #0
   1aa68:	e4c3c001 	strb	ip, [r3], #1
   1aa6c:	1afffff5 	bne	1aa48 <strncpy+0x34>
	break;
    }

  while (count-- > 0)
   1aa70:	e3540000 	cmp	r4, #0
   1aa74:	08bd8070 	popeq	{r4, r5, r6, pc}
   1aa78:	e08ee002 	add	lr, lr, r2
    *dst++ = '\0';
   1aa7c:	e4c3c001 	strb	ip, [r3], #1
  while (count-- > 0)
   1aa80:	e153000e 	cmp	r3, lr
   1aa84:	1afffffc 	bne	1aa7c <strncpy+0x68>
   1aa88:	e8bd8070 	pop	{r4, r5, r6, pc}
      while (count >= sizeof (long int) && !DETECTNULL(*aligned_src))
   1aa8c:	e30f6eff 	movw	r6, #65279	@ 0xfeff
   1aa90:	e3085080 	movw	r5, #32896	@ 0x8080
   1aa94:	e1a04001 	mov	r4, r1
      aligned_dst = (long*)dst;
   1aa98:	e1a0e000 	mov	lr, r0
      while (count >= sizeof (long int) && !DETECTNULL(*aligned_src))
   1aa9c:	e34f6efe 	movt	r6, #65278	@ 0xfefe
   1aaa0:	e3485080 	movt	r5, #32896	@ 0x8080
   1aaa4:	e594c000 	ldr	ip, [r4]
   1aaa8:	e1a01004 	mov	r1, r4
   1aaac:	e2844004 	add	r4, r4, #4
   1aab0:	e08c3006 	add	r3, ip, r6
   1aab4:	e1c3300c 	bic	r3, r3, ip
   1aab8:	e1130005 	tst	r3, r5
   1aabc:	1affffdf 	bne	1aa40 <strncpy+0x2c>
	  count -= sizeof (long int);
   1aac0:	e2422004 	sub	r2, r2, #4
	  *aligned_dst++ = *aligned_src++;
   1aac4:	e48ec004 	str	ip, [lr], #4
      while (count >= sizeof (long int) && !DETECTNULL(*aligned_src))
   1aac8:	e3520003 	cmp	r2, #3
   1aacc:	8afffff4 	bhi	1aaa4 <strncpy+0x90>
	  *aligned_dst++ = *aligned_src++;
   1aad0:	e1a01004 	mov	r1, r4
   1aad4:	eaffffd9 	b	1aa40 <strncpy+0x2c>

0001aad8 <strnlen>:
strnlen (const char *str,
	size_t n)
{
  const char *start = str;

  while (n-- > 0 && *str)
   1aad8:	e3510000 	cmp	r1, #0
   1aadc:	11a03000 	movne	r3, r0
   1aae0:	10801001 	addne	r1, r0, r1
   1aae4:	1a000002 	bne	1aaf4 <strnlen+0x1c>
   1aae8:	ea00000a 	b	1ab18 <strnlen+0x40>
   1aaec:	e1530001 	cmp	r3, r1
   1aaf0:	0a000006 	beq	1ab10 <strnlen+0x38>
    str++;
   1aaf4:	e1a02003 	mov	r2, r3
   1aaf8:	e2833001 	add	r3, r3, #1
  while (n-- > 0 && *str)
   1aafc:	e5d2c000 	ldrb	ip, [r2]
   1ab00:	e35c0000 	cmp	ip, #0
   1ab04:	1afffff8 	bne	1aaec <strnlen+0x14>

  return str - start;
   1ab08:	e0420000 	sub	r0, r2, r0
}
   1ab0c:	e12fff1e 	bx	lr
  return str - start;
   1ab10:	e0430000 	sub	r0, r3, r0
   1ab14:	e12fff1e 	bx	lr
  while (n-- > 0 && *str)
   1ab18:	e1a00001 	mov	r0, r1
   1ab1c:	e12fff1e 	bx	lr

0001ab20 <strrchr>:
#include <string.h>

char *
strrchr (const char *s,
	int i)
{
   1ab20:	e92d4070 	push	{r4, r5, r6, lr}
  const char *last = NULL;
  char c = i;

  if (c)
   1ab24:	e21140ff 	ands	r4, r1, #255	@ 0xff
   1ab28:	11a03000 	movne	r3, r0
  const char *last = NULL;
   1ab2c:	13a05000 	movne	r5, #0
  if (c)
   1ab30:	1a000001 	bne	1ab3c <strrchr+0x1c>
   1ab34:	ea000008 	b	1ab5c <strrchr+0x3c>
    {
      while ((s=strchr(s, c)))
	{
	  last = s;
   1ab38:	e1a05000 	mov	r5, r0
      while ((s=strchr(s, c)))
   1ab3c:	e1a00003 	mov	r0, r3
   1ab40:	e1a01004 	mov	r1, r4
   1ab44:	ebffff17 	bl	1a7a8 <strchr>
   1ab48:	e3500000 	cmp	r0, #0
	  s++;
   1ab4c:	e2803001 	add	r3, r0, #1
      while ((s=strchr(s, c)))
   1ab50:	1afffff8 	bne	1ab38 <strrchr+0x18>
    {
      last = strchr(s, c);
    }

  return (char *) last;
}
   1ab54:	e1a00005 	mov	r0, r5
   1ab58:	e8bd8070 	pop	{r4, r5, r6, pc}
      last = strchr(s, c);
   1ab5c:	e1a01004 	mov	r1, r4
}
   1ab60:	e8bd4070 	pop	{r4, r5, r6, lr}
      last = strchr(s, c);
   1ab64:	eaffff0f 	b	1a7a8 <strchr>

0001ab68 <wcslen>:
#include <_ansi.h>
#include <wchar.h>

size_t
wcslen (const wchar_t * s)
{
   1ab68:	e1a01000 	mov	r1, r0
  const wchar_t *p;

  p = s;
  while (*p)
   1ab6c:	e5900000 	ldr	r0, [r0]
   1ab70:	e3500000 	cmp	r0, #0
   1ab74:	012fff1e 	bxeq	lr
  p = s;
   1ab78:	e1a03001 	mov	r3, r1
  while (*p)
   1ab7c:	e5b32004 	ldr	r2, [r3, #4]!
   1ab80:	e3520000 	cmp	r2, #0
   1ab84:	1afffffc 	bne	1ab7c <wcslen+0x14>
    p++;

  return p - s;
   1ab88:	e0430001 	sub	r0, r3, r1
   1ab8c:	e1a00140 	asr	r0, r0, #2
}
   1ab90:	e12fff1e 	bx	lr

0001ab94 <rawmemchr>:
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
   1ab94:	e3100003 	tst	r0, #3
  unsigned char d = c;
   1ab98:	e6ef1071 	uxtb	r1, r1
  while (UNALIGNED (src))
   1ab9c:	0a000007 	beq	1abc0 <rawmemchr+0x2c>
   1aba0:	e1a03000 	mov	r3, r0
    {
      if (*src == d)
        return (void *) src;
      src++;
   1aba4:	e1a00003 	mov	r0, r3
      if (*src == d)
   1aba8:	e4d32001 	ldrb	r2, [r3], #1
   1abac:	e1520001 	cmp	r2, r1
   1abb0:	012fff1e 	bxeq	lr
  while (UNALIGNED (src))
   1abb4:	e3130003 	tst	r3, #3
   1abb8:	1afffff9 	bne	1aba4 <rawmemchr+0x10>
      src++;
   1abbc:	e1a00003 	mov	r0, r3
     the word-sized segment with a word-sized block of the search
     character and then detecting for the presence of NUL in the
     result.  */
  asrc = (unsigned long *) src;
  mask = d << 8 | d;
  mask = mask << 16 | mask;
   1abc0:	e081c401 	add	ip, r1, r1, lsl #8
  for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
    mask = (mask << i) | mask;

  while (1)
    {
      if (DETECTCHAR (*asrc, mask))
   1abc4:	e5903000 	ldr	r3, [r0]
{
   1abc8:	e92d4010 	push	{r4, lr}
   1abcc:	e08cc80c 	add	ip, ip, ip, lsl #16
      if (DETECTCHAR (*asrc, mask))
   1abd0:	e30f4eff 	movw	r4, #65279	@ 0xfeff
   1abd4:	e34f4efe 	movt	r4, #65278	@ 0xfefe
   1abd8:	e023300c 	eor	r3, r3, ip
   1abdc:	e308e080 	movw	lr, #32896	@ 0x8080
   1abe0:	e0832004 	add	r2, r3, r4
   1abe4:	e348e080 	movt	lr, #32896	@ 0x8080
   1abe8:	e1c23003 	bic	r3, r2, r3
   1abec:	e113000e 	tst	r3, lr
   1abf0:	1a000005 	bne	1ac0c <rawmemchr+0x78>
   1abf4:	e5b03004 	ldr	r3, [r0, #4]!
   1abf8:	e023300c 	eor	r3, r3, ip
   1abfc:	e0832004 	add	r2, r3, r4
   1ac00:	e1c23003 	bic	r3, r2, r3
   1ac04:	e113000e 	tst	r3, lr
   1ac08:	0afffff9 	beq	1abf4 <rawmemchr+0x60>

#endif /* !PREFER_SIZE_OVER_SPEED && !__OPTIMIZE_SIZE__ */

  while (1)
    {
      if (*src == d)
   1ac0c:	e5d03000 	ldrb	r3, [r0]
   1ac10:	e1530001 	cmp	r3, r1
   1ac14:	08bd8010 	popeq	{r4, pc}
   1ac18:	e5f03001 	ldrb	r3, [r0, #1]!
   1ac1c:	e1530001 	cmp	r3, r1
   1ac20:	1afffffc 	bne	1ac18 <rawmemchr+0x84>
   1ac24:	e8bd8010 	pop	{r4, pc}

0001ac28 <_init_signal_r>:
_Thread_local void (**_tls_sig_func)(int);
#endif

int
_init_signal_r (struct _reent *ptr)
{
   1ac28:	e92d4070 	push	{r4, r5, r6, lr}
  int i;

  if (_REENT_SIG_FUNC(ptr) == NULL)
   1ac2c:	e5904118 	ldr	r4, [r0, #280]	@ 0x118
   1ac30:	e3540000 	cmp	r4, #0
   1ac34:	0a000001 	beq	1ac40 <_init_signal_r+0x18>

      for (i = 0; i < NSIG; i++)
	_REENT_SIG_FUNC(ptr)[i] = SIG_DFL;
    }

  return 0;
   1ac38:	e3a00000 	mov	r0, #0
   1ac3c:	e8bd8070 	pop	{r4, r5, r6, pc}
      _REENT_SIG_FUNC(ptr) = (_sig_func_ptr *)_malloc_r (ptr, sizeof (_sig_func_ptr) * NSIG);
   1ac40:	e3a01080 	mov	r1, #128	@ 0x80
   1ac44:	e1a05000 	mov	r5, r0
   1ac48:	eb00123d 	bl	1f544 <_malloc_r>
      if (_REENT_SIG_FUNC(ptr) == NULL)
   1ac4c:	e3500000 	cmp	r0, #0
      _REENT_SIG_FUNC(ptr) = (_sig_func_ptr *)_malloc_r (ptr, sizeof (_sig_func_ptr) * NSIG);
   1ac50:	e5850118 	str	r0, [r5, #280]	@ 0x118
      if (_REENT_SIG_FUNC(ptr) == NULL)
   1ac54:	0a000006 	beq	1ac74 <_init_signal_r+0x4c>
   1ac58:	e2403004 	sub	r3, r0, #4
   1ac5c:	e280207c 	add	r2, r0, #124	@ 0x7c
	_REENT_SIG_FUNC(ptr)[i] = SIG_DFL;
   1ac60:	e5a34004 	str	r4, [r3, #4]!
      for (i = 0; i < NSIG; i++)
   1ac64:	e1530002 	cmp	r3, r2
   1ac68:	1afffffc 	bne	1ac60 <_init_signal_r+0x38>
  return 0;
   1ac6c:	e3a00000 	mov	r0, #0
   1ac70:	e8bd8070 	pop	{r4, r5, r6, pc}
	return -1;
   1ac74:	e3e00000 	mvn	r0, #0
}
   1ac78:	e8bd8070 	pop	{r4, r5, r6, pc}

0001ac7c <_signal_r>:
	int sig,
	_sig_func_ptr func)
{
  _sig_func_ptr old_func;

  if (sig < 0 || sig >= NSIG)
   1ac7c:	e351001f 	cmp	r1, #31
{
   1ac80:	e92d4030 	push	{r4, r5, lr}
    {
      _REENT_ERRNO(ptr) = EINVAL;
   1ac84:	83a03016 	movhi	r3, #22
{
   1ac88:	e24dd00c 	sub	sp, sp, #12
   1ac8c:	e1a05000 	mov	r5, r0
      _REENT_ERRNO(ptr) = EINVAL;
   1ac90:	85803000 	strhi	r3, [r0]
  if (sig < 0 || sig >= NSIG)
   1ac94:	8a000016 	bhi	1acf4 <_signal_r+0x78>
      return SIG_ERR;
    }

  if (_REENT_SIG_FUNC(ptr) == NULL && _init_signal_r (ptr) != 0)
   1ac98:	e5903118 	ldr	r3, [r0, #280]	@ 0x118
   1ac9c:	e1a04001 	mov	r4, r1
   1aca0:	e3530000 	cmp	r3, #0
   1aca4:	0a000003 	beq	1acb8 <_signal_r+0x3c>
    return SIG_ERR;
  
  old_func = _REENT_SIG_FUNC(ptr)[sig];
   1aca8:	e7930104 	ldr	r0, [r3, r4, lsl #2]
  _REENT_SIG_FUNC(ptr)[sig] = func;
   1acac:	e7832104 	str	r2, [r3, r4, lsl #2]

  return old_func;
}
   1acb0:	e28dd00c 	add	sp, sp, #12
   1acb4:	e8bd8030 	pop	{r4, r5, pc}
      _REENT_SIG_FUNC(ptr) = (_sig_func_ptr *)_malloc_r (ptr, sizeof (_sig_func_ptr) * NSIG);
   1acb8:	e3a01080 	mov	r1, #128	@ 0x80
   1acbc:	e58d2004 	str	r2, [sp, #4]
   1acc0:	eb00121f 	bl	1f544 <_malloc_r>
      if (_REENT_SIG_FUNC(ptr) == NULL)
   1acc4:	e3500000 	cmp	r0, #0
      _REENT_SIG_FUNC(ptr) = (_sig_func_ptr *)_malloc_r (ptr, sizeof (_sig_func_ptr) * NSIG);
   1acc8:	e1a03000 	mov	r3, r0
   1accc:	12401004 	subne	r1, r0, #4
   1acd0:	1280c07c 	addne	ip, r0, #124	@ 0x7c
   1acd4:	e5850118 	str	r0, [r5, #280]	@ 0x118
	_REENT_SIG_FUNC(ptr)[i] = SIG_DFL;
   1acd8:	13a00000 	movne	r0, #0
      if (_REENT_SIG_FUNC(ptr) == NULL)
   1acdc:	e59d2004 	ldr	r2, [sp, #4]
   1ace0:	0a000003 	beq	1acf4 <_signal_r+0x78>
	_REENT_SIG_FUNC(ptr)[i] = SIG_DFL;
   1ace4:	e5a10004 	str	r0, [r1, #4]!
      for (i = 0; i < NSIG; i++)
   1ace8:	e151000c 	cmp	r1, ip
   1acec:	1afffffc 	bne	1ace4 <_signal_r+0x68>
   1acf0:	eaffffec 	b	1aca8 <_signal_r+0x2c>
      return SIG_ERR;
   1acf4:	e3e00000 	mvn	r0, #0
   1acf8:	eaffffec 	b	1acb0 <_signal_r+0x34>

0001acfc <_raise_r>:
_raise_r (struct _reent *ptr,
     int sig)
{
  _sig_func_ptr func;

  if (sig < 0 || sig >= NSIG)
   1acfc:	e351001f 	cmp	r1, #31
{
   1ad00:	e92d4070 	push	{r4, r5, r6, lr}
   1ad04:	e1a05000 	mov	r5, r0
  if (sig < 0 || sig >= NSIG)
   1ad08:	8a00001b 	bhi	1ad7c <_raise_r+0x80>
    {
      _REENT_ERRNO(ptr) = EINVAL;
      return -1;
    }

  if (_REENT_SIG_FUNC(ptr) == NULL)
   1ad0c:	e5902118 	ldr	r2, [r0, #280]	@ 0x118
   1ad10:	e1a04001 	mov	r4, r1
   1ad14:	e3520000 	cmp	r2, #0
   1ad18:	0a00000c 	beq	1ad50 <_raise_r+0x54>
    func = SIG_DFL;
  else
    func = _REENT_SIG_FUNC(ptr)[sig];
   1ad1c:	e7923101 	ldr	r3, [r2, r1, lsl #2]

  if (func == SIG_DFL)
   1ad20:	e3530000 	cmp	r3, #0
   1ad24:	0a000009 	beq	1ad50 <_raise_r+0x54>
    return _kill_r (ptr, _getpid_r (ptr), sig);
  else if (func == SIG_IGN)
   1ad28:	e3530001 	cmp	r3, #1
   1ad2c:	0a000005 	beq	1ad48 <_raise_r+0x4c>
    return 0;
  else if (func == SIG_ERR)
   1ad30:	e3730001 	cmn	r3, #1
   1ad34:	0a00000c 	beq	1ad6c <_raise_r+0x70>
      _REENT_ERRNO(ptr) = EINVAL;
      return 1;
    }
  else
    {
      _REENT_SIG_FUNC(ptr)[sig] = SIG_DFL;
   1ad38:	e3a01000 	mov	r1, #0
      func (sig);
   1ad3c:	e1a00004 	mov	r0, r4
      _REENT_SIG_FUNC(ptr)[sig] = SIG_DFL;
   1ad40:	e7821104 	str	r1, [r2, r4, lsl #2]
      func (sig);
   1ad44:	e12fff33 	blx	r3
    return 0;
   1ad48:	e3a00000 	mov	r0, #0
      return 0;
    }
}
   1ad4c:	e8bd8070 	pop	{r4, r5, r6, pc}
    return _kill_r (ptr, _getpid_r (ptr), sig);
   1ad50:	e1a00005 	mov	r0, r5
   1ad54:	eb00029c 	bl	1b7cc <_getpid_r>
   1ad58:	e1a02004 	mov	r2, r4
   1ad5c:	e1a01000 	mov	r1, r0
   1ad60:	e1a00005 	mov	r0, r5
}
   1ad64:	e8bd4070 	pop	{r4, r5, r6, lr}
    return _kill_r (ptr, _getpid_r (ptr), sig);
   1ad68:	ea000287 	b	1b78c <_kill_r>
      _REENT_ERRNO(ptr) = EINVAL;
   1ad6c:	e3a03016 	mov	r3, #22
      return 1;
   1ad70:	e3a00001 	mov	r0, #1
      _REENT_ERRNO(ptr) = EINVAL;
   1ad74:	e5853000 	str	r3, [r5]
      return 1;
   1ad78:	e8bd8070 	pop	{r4, r5, r6, pc}
      _REENT_ERRNO(ptr) = EINVAL;
   1ad7c:	e3a03016 	mov	r3, #22
      return -1;
   1ad80:	e3e00000 	mvn	r0, #0
      _REENT_ERRNO(ptr) = EINVAL;
   1ad84:	e5853000 	str	r3, [r5]
      return -1;
   1ad88:	e8bd8070 	pop	{r4, r5, r6, pc}

0001ad8c <__sigtramp_r>:
__sigtramp_r (struct _reent *ptr,
     int sig)
{
  _sig_func_ptr func;

  if (sig < 0 || sig >= NSIG)
   1ad8c:	e351001f 	cmp	r1, #31
   1ad90:	8a000028 	bhi	1ae38 <__sigtramp_r+0xac>
    {
      return -1;
    }

  if (_REENT_SIG_FUNC(ptr) == NULL && _init_signal_r (ptr) != 0)
   1ad94:	e5903118 	ldr	r3, [r0, #280]	@ 0x118
{
   1ad98:	e92d4070 	push	{r4, r5, r6, lr}
   1ad9c:	e1a04001 	mov	r4, r1
   1ada0:	e1a05000 	mov	r5, r0
  if (_REENT_SIG_FUNC(ptr) == NULL && _init_signal_r (ptr) != 0)
   1ada4:	e3530000 	cmp	r3, #0
   1ada8:	0a000013 	beq	1adfc <__sigtramp_r+0x70>
    return -1;

  func = _REENT_SIG_FUNC(ptr)[sig];
   1adac:	e7932104 	ldr	r2, [r3, r4, lsl #2]
   1adb0:	e0833104 	add	r3, r3, r4, lsl #2
  if (func == SIG_DFL)
   1adb4:	e3520000 	cmp	r2, #0
   1adb8:	0a000009 	beq	1ade4 <__sigtramp_r+0x58>
    return 1;
  else if (func == SIG_ERR)
   1adbc:	e3720001 	cmn	r2, #1
   1adc0:	0a00000b 	beq	1adf4 <__sigtramp_r+0x68>
    return 2;
  else if (func == SIG_IGN)
   1adc4:	e3520001 	cmp	r2, #1
   1adc8:	0a000007 	beq	1adec <__sigtramp_r+0x60>
    return 3;
  else
    {
      _REENT_SIG_FUNC(ptr)[sig] = SIG_DFL;
   1adcc:	e3a05000 	mov	r5, #0
      func (sig);
   1add0:	e1a00004 	mov	r0, r4
      _REENT_SIG_FUNC(ptr)[sig] = SIG_DFL;
   1add4:	e5835000 	str	r5, [r3]
      func (sig);
   1add8:	e12fff32 	blx	r2
      return 0;
   1addc:	e1a00005 	mov	r0, r5
   1ade0:	e8bd8070 	pop	{r4, r5, r6, pc}
    return 1;
   1ade4:	e3a00001 	mov	r0, #1
   1ade8:	e8bd8070 	pop	{r4, r5, r6, pc}
    return 3;
   1adec:	e3a00003 	mov	r0, #3
    }
}
   1adf0:	e8bd8070 	pop	{r4, r5, r6, pc}
    return 2;
   1adf4:	e3a00002 	mov	r0, #2
   1adf8:	e8bd8070 	pop	{r4, r5, r6, pc}
      _REENT_SIG_FUNC(ptr) = (_sig_func_ptr *)_malloc_r (ptr, sizeof (_sig_func_ptr) * NSIG);
   1adfc:	e3a01080 	mov	r1, #128	@ 0x80
   1ae00:	eb0011cf 	bl	1f544 <_malloc_r>
      if (_REENT_SIG_FUNC(ptr) == NULL)
   1ae04:	e3500000 	cmp	r0, #0
      _REENT_SIG_FUNC(ptr) = (_sig_func_ptr *)_malloc_r (ptr, sizeof (_sig_func_ptr) * NSIG);
   1ae08:	e1a03000 	mov	r3, r0
   1ae0c:	e5850118 	str	r0, [r5, #280]	@ 0x118
      if (_REENT_SIG_FUNC(ptr) == NULL)
   1ae10:	0a000006 	beq	1ae30 <__sigtramp_r+0xa4>
   1ae14:	e2402004 	sub	r2, r0, #4
	_REENT_SIG_FUNC(ptr)[i] = SIG_DFL;
   1ae18:	e3a01000 	mov	r1, #0
   1ae1c:	e280007c 	add	r0, r0, #124	@ 0x7c
   1ae20:	e5a21004 	str	r1, [r2, #4]!
      for (i = 0; i < NSIG; i++)
   1ae24:	e1520000 	cmp	r2, r0
   1ae28:	1afffffc 	bne	1ae20 <__sigtramp_r+0x94>
   1ae2c:	eaffffde 	b	1adac <__sigtramp_r+0x20>
      return -1;
   1ae30:	e3e00000 	mvn	r0, #0
   1ae34:	e8bd8070 	pop	{r4, r5, r6, pc}
   1ae38:	e3e00000 	mvn	r0, #0
}
   1ae3c:	e12fff1e 	bx	lr

0001ae40 <raise>:
#ifndef _REENT_ONLY

int 
raise (int sig)
{
  return _raise_r (_REENT, sig);
   1ae40:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
  if (sig < 0 || sig >= NSIG)
   1ae44:	e350001f 	cmp	r0, #31
  return _raise_r (_REENT, sig);
   1ae48:	e3403002 	movt	r3, #2
{
   1ae4c:	e92d4070 	push	{r4, r5, r6, lr}
  return _raise_r (_REENT, sig);
   1ae50:	e5935000 	ldr	r5, [r3]
  if (sig < 0 || sig >= NSIG)
   1ae54:	8a00001a 	bhi	1aec4 <raise+0x84>
   1ae58:	e1a04000 	mov	r4, r0
  if (_REENT_SIG_FUNC(ptr) == NULL)
   1ae5c:	e5952118 	ldr	r2, [r5, #280]	@ 0x118
   1ae60:	e3520000 	cmp	r2, #0
   1ae64:	0a00000b 	beq	1ae98 <raise+0x58>
    func = _REENT_SIG_FUNC(ptr)[sig];
   1ae68:	e7923100 	ldr	r3, [r2, r0, lsl #2]
  if (func == SIG_DFL)
   1ae6c:	e3530000 	cmp	r3, #0
   1ae70:	0a000008 	beq	1ae98 <raise+0x58>
  else if (func == SIG_IGN)
   1ae74:	e3530001 	cmp	r3, #1
   1ae78:	0a000004 	beq	1ae90 <raise+0x50>
  else if (func == SIG_ERR)
   1ae7c:	e3730001 	cmn	r3, #1
   1ae80:	0a00000b 	beq	1aeb4 <raise+0x74>
      _REENT_SIG_FUNC(ptr)[sig] = SIG_DFL;
   1ae84:	e3a01000 	mov	r1, #0
   1ae88:	e7821100 	str	r1, [r2, r0, lsl #2]
      func (sig);
   1ae8c:	e12fff33 	blx	r3
    return 0;
   1ae90:	e3a00000 	mov	r0, #0
}
   1ae94:	e8bd8070 	pop	{r4, r5, r6, pc}
    return _kill_r (ptr, _getpid_r (ptr), sig);
   1ae98:	e1a00005 	mov	r0, r5
   1ae9c:	eb00024a 	bl	1b7cc <_getpid_r>
   1aea0:	e1a02004 	mov	r2, r4
   1aea4:	e1a01000 	mov	r1, r0
   1aea8:	e1a00005 	mov	r0, r5
}
   1aeac:	e8bd4070 	pop	{r4, r5, r6, lr}
    return _kill_r (ptr, _getpid_r (ptr), sig);
   1aeb0:	ea000235 	b	1b78c <_kill_r>
      _REENT_ERRNO(ptr) = EINVAL;
   1aeb4:	e3a03016 	mov	r3, #22
      return 1;
   1aeb8:	e3a00001 	mov	r0, #1
      _REENT_ERRNO(ptr) = EINVAL;
   1aebc:	e5853000 	str	r3, [r5]
      return 1;
   1aec0:	e8bd8070 	pop	{r4, r5, r6, pc}
      _REENT_ERRNO(ptr) = EINVAL;
   1aec4:	e3a03016 	mov	r3, #22
      return -1;
   1aec8:	e3e00000 	mvn	r0, #0
      _REENT_ERRNO(ptr) = EINVAL;
   1aecc:	e5853000 	str	r3, [r5]
      return -1;
   1aed0:	e8bd8070 	pop	{r4, r5, r6, pc}

0001aed4 <signal>:

_sig_func_ptr
signal (int sig,
	_sig_func_ptr func)
{
  return _signal_r (_REENT, sig, func);
   1aed4:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
{
   1aed8:	e92d4070 	push	{r4, r5, r6, lr}
  return _signal_r (_REENT, sig, func);
   1aedc:	e3403002 	movt	r3, #2
  if (sig < 0 || sig >= NSIG)
   1aee0:	e350001f 	cmp	r0, #31
  return _signal_r (_REENT, sig, func);
   1aee4:	e5936000 	ldr	r6, [r3]
      _REENT_ERRNO(ptr) = EINVAL;
   1aee8:	83a03016 	movhi	r3, #22
   1aeec:	85863000 	strhi	r3, [r6]
  if (sig < 0 || sig >= NSIG)
   1aef0:	8a000015 	bhi	1af4c <signal+0x78>
  if (_REENT_SIG_FUNC(ptr) == NULL && _init_signal_r (ptr) != 0)
   1aef4:	e5963118 	ldr	r3, [r6, #280]	@ 0x118
   1aef8:	e1a04000 	mov	r4, r0
   1aefc:	e1a05001 	mov	r5, r1
   1af00:	e3530000 	cmp	r3, #0
   1af04:	0a000002 	beq	1af14 <signal+0x40>
  old_func = _REENT_SIG_FUNC(ptr)[sig];
   1af08:	e7930104 	ldr	r0, [r3, r4, lsl #2]
  _REENT_SIG_FUNC(ptr)[sig] = func;
   1af0c:	e7835104 	str	r5, [r3, r4, lsl #2]
}
   1af10:	e8bd8070 	pop	{r4, r5, r6, pc}
      _REENT_SIG_FUNC(ptr) = (_sig_func_ptr *)_malloc_r (ptr, sizeof (_sig_func_ptr) * NSIG);
   1af14:	e3a01080 	mov	r1, #128	@ 0x80
   1af18:	e1a00006 	mov	r0, r6
   1af1c:	eb001188 	bl	1f544 <_malloc_r>
      if (_REENT_SIG_FUNC(ptr) == NULL)
   1af20:	e3500000 	cmp	r0, #0
      _REENT_SIG_FUNC(ptr) = (_sig_func_ptr *)_malloc_r (ptr, sizeof (_sig_func_ptr) * NSIG);
   1af24:	e1a03000 	mov	r3, r0
   1af28:	12402004 	subne	r2, r0, #4
   1af2c:	e5860118 	str	r0, [r6, #280]	@ 0x118
	_REENT_SIG_FUNC(ptr)[i] = SIG_DFL;
   1af30:	13a01000 	movne	r1, #0
   1af34:	1280007c 	addne	r0, r0, #124	@ 0x7c
      if (_REENT_SIG_FUNC(ptr) == NULL)
   1af38:	0a000003 	beq	1af4c <signal+0x78>
	_REENT_SIG_FUNC(ptr)[i] = SIG_DFL;
   1af3c:	e5a21004 	str	r1, [r2, #4]!
      for (i = 0; i < NSIG; i++)
   1af40:	e1520000 	cmp	r2, r0
   1af44:	1afffffc 	bne	1af3c <signal+0x68>
   1af48:	eaffffee 	b	1af08 <signal+0x34>
      return SIG_ERR;
   1af4c:	e3e00000 	mvn	r0, #0
   1af50:	e8bd8070 	pop	{r4, r5, r6, pc}

0001af54 <_init_signal>:

int 
_init_signal (void)
{
  return _init_signal_r (_REENT);
   1af54:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
{
   1af58:	e92d4070 	push	{r4, r5, r6, lr}
  return _init_signal_r (_REENT);
   1af5c:	e3403002 	movt	r3, #2
   1af60:	e5935000 	ldr	r5, [r3]
  if (_REENT_SIG_FUNC(ptr) == NULL)
   1af64:	e5954118 	ldr	r4, [r5, #280]	@ 0x118
   1af68:	e3540000 	cmp	r4, #0
   1af6c:	0a000001 	beq	1af78 <_init_signal+0x24>
  return 0;
   1af70:	e3a00000 	mov	r0, #0
   1af74:	e8bd8070 	pop	{r4, r5, r6, pc}
      _REENT_SIG_FUNC(ptr) = (_sig_func_ptr *)_malloc_r (ptr, sizeof (_sig_func_ptr) * NSIG);
   1af78:	e3a01080 	mov	r1, #128	@ 0x80
   1af7c:	e1a00005 	mov	r0, r5
   1af80:	eb00116f 	bl	1f544 <_malloc_r>
      if (_REENT_SIG_FUNC(ptr) == NULL)
   1af84:	e3500000 	cmp	r0, #0
      _REENT_SIG_FUNC(ptr) = (_sig_func_ptr *)_malloc_r (ptr, sizeof (_sig_func_ptr) * NSIG);
   1af88:	e5850118 	str	r0, [r5, #280]	@ 0x118
      if (_REENT_SIG_FUNC(ptr) == NULL)
   1af8c:	0a000006 	beq	1afac <_init_signal+0x58>
   1af90:	e2403004 	sub	r3, r0, #4
   1af94:	e280207c 	add	r2, r0, #124	@ 0x7c
	_REENT_SIG_FUNC(ptr)[i] = SIG_DFL;
   1af98:	e5a34004 	str	r4, [r3, #4]!
      for (i = 0; i < NSIG; i++)
   1af9c:	e1530002 	cmp	r3, r2
   1afa0:	1afffffc 	bne	1af98 <_init_signal+0x44>
  return 0;
   1afa4:	e3a00000 	mov	r0, #0
   1afa8:	e8bd8070 	pop	{r4, r5, r6, pc}
	return -1;
   1afac:	e3e00000 	mvn	r0, #0
}
   1afb0:	e8bd8070 	pop	{r4, r5, r6, pc}

0001afb4 <__sigtramp>:

int
__sigtramp (int sig)
{
  return __sigtramp_r (_REENT, sig);
   1afb4:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
  if (sig < 0 || sig >= NSIG)
   1afb8:	e350001f 	cmp	r0, #31
  return __sigtramp_r (_REENT, sig);
   1afbc:	e3403002 	movt	r3, #2
{
   1afc0:	e92d4070 	push	{r4, r5, r6, lr}
  return __sigtramp_r (_REENT, sig);
   1afc4:	e5935000 	ldr	r5, [r3]
  if (sig < 0 || sig >= NSIG)
   1afc8:	8a000024 	bhi	1b060 <__sigtramp+0xac>
   1afcc:	e1a04000 	mov	r4, r0
  if (_REENT_SIG_FUNC(ptr) == NULL && _init_signal_r (ptr) != 0)
   1afd0:	e5950118 	ldr	r0, [r5, #280]	@ 0x118
   1afd4:	e3500000 	cmp	r0, #0
   1afd8:	0a000013 	beq	1b02c <__sigtramp+0x78>
  func = _REENT_SIG_FUNC(ptr)[sig];
   1afdc:	e7902104 	ldr	r2, [r0, r4, lsl #2]
   1afe0:	e0803104 	add	r3, r0, r4, lsl #2
  if (func == SIG_DFL)
   1afe4:	e3520000 	cmp	r2, #0
   1afe8:	0a000009 	beq	1b014 <__sigtramp+0x60>
  else if (func == SIG_ERR)
   1afec:	e3720001 	cmn	r2, #1
   1aff0:	0a00000b 	beq	1b024 <__sigtramp+0x70>
  else if (func == SIG_IGN)
   1aff4:	e3520001 	cmp	r2, #1
   1aff8:	0a000007 	beq	1b01c <__sigtramp+0x68>
      _REENT_SIG_FUNC(ptr)[sig] = SIG_DFL;
   1affc:	e3a05000 	mov	r5, #0
      func (sig);
   1b000:	e1a00004 	mov	r0, r4
      _REENT_SIG_FUNC(ptr)[sig] = SIG_DFL;
   1b004:	e5835000 	str	r5, [r3]
      func (sig);
   1b008:	e12fff32 	blx	r2
      return 0;
   1b00c:	e1a00005 	mov	r0, r5
   1b010:	e8bd8070 	pop	{r4, r5, r6, pc}
    return 1;
   1b014:	e3a00001 	mov	r0, #1
   1b018:	e8bd8070 	pop	{r4, r5, r6, pc}
    return 3;
   1b01c:	e3a00003 	mov	r0, #3
}
   1b020:	e8bd8070 	pop	{r4, r5, r6, pc}
    return 2;
   1b024:	e3a00002 	mov	r0, #2
   1b028:	e8bd8070 	pop	{r4, r5, r6, pc}
      _REENT_SIG_FUNC(ptr) = (_sig_func_ptr *)_malloc_r (ptr, sizeof (_sig_func_ptr) * NSIG);
   1b02c:	e3a01080 	mov	r1, #128	@ 0x80
   1b030:	e1a00005 	mov	r0, r5
   1b034:	eb001142 	bl	1f544 <_malloc_r>
      if (_REENT_SIG_FUNC(ptr) == NULL)
   1b038:	e3500000 	cmp	r0, #0
      _REENT_SIG_FUNC(ptr) = (_sig_func_ptr *)_malloc_r (ptr, sizeof (_sig_func_ptr) * NSIG);
   1b03c:	e5850118 	str	r0, [r5, #280]	@ 0x118
      if (_REENT_SIG_FUNC(ptr) == NULL)
   1b040:	0a000006 	beq	1b060 <__sigtramp+0xac>
   1b044:	e2403004 	sub	r3, r0, #4
   1b048:	e280107c 	add	r1, r0, #124	@ 0x7c
	_REENT_SIG_FUNC(ptr)[i] = SIG_DFL;
   1b04c:	e3a02000 	mov	r2, #0
   1b050:	e5a32004 	str	r2, [r3, #4]!
      for (i = 0; i < NSIG; i++)
   1b054:	e1530001 	cmp	r3, r1
   1b058:	1afffffc 	bne	1b050 <__sigtramp+0x9c>
   1b05c:	eaffffde 	b	1afdc <__sigtramp+0x28>
      return -1;
   1b060:	e3e00000 	mvn	r0, #0
   1b064:	e8bd8070 	pop	{r4, r5, r6, pc}

0001b068 <_setlocale_r>:

char *
_setlocale_r (struct _reent *p,
       int category,
       const char *locale)
{
   1b068:	e92d4010 	push	{r4, lr}
#ifndef _MB_CAPABLE
  if (locale)
   1b06c:	e2524000 	subs	r4, r2, #0
   1b070:	0a000005 	beq	1b08c <_setlocale_r+0x24>
    { 
      if (strcmp (locale, "POSIX") && strcmp (locale, "C")
   1b074:	e3091138 	movw	r1, #37176	@ 0x9138
   1b078:	e1a00004 	mov	r0, r4
   1b07c:	e3401002 	movt	r1, #2
   1b080:	fa001256 	blx	1f9e0 <strcmp>
   1b084:	e3500000 	cmp	r0, #0
   1b088:	1a000002 	bne	1b098 <_setlocale_r+0x30>
	  && strcmp (locale, ""))
        return NULL;
    }
  return "C";
   1b08c:	e3090134 	movw	r0, #37172	@ 0x9134
   1b090:	e3400002 	movt	r0, #2
   1b094:	e8bd8010 	pop	{r4, pc}
      if (strcmp (locale, "POSIX") && strcmp (locale, "C")
   1b098:	e3091134 	movw	r1, #37172	@ 0x9134
   1b09c:	e1a00004 	mov	r0, r4
   1b0a0:	e3401002 	movt	r1, #2
   1b0a4:	fa00124d 	blx	1f9e0 <strcmp>
   1b0a8:	e3500000 	cmp	r0, #0
   1b0ac:	0afffff6 	beq	1b08c <_setlocale_r+0x24>
	  && strcmp (locale, ""))
   1b0b0:	e3081d5c 	movw	r1, #36188	@ 0x8d5c
   1b0b4:	e1a00004 	mov	r0, r4
   1b0b8:	e3401002 	movt	r1, #2
   1b0bc:	fa001247 	blx	1f9e0 <strcmp>
   1b0c0:	e3500000 	cmp	r0, #0
   1b0c4:	0afffff0 	beq	1b08c <_setlocale_r+0x24>
        return NULL;
   1b0c8:	e3a00000 	mov	r0, #0
	  return NULL;
	}
    }
  return currentlocale ();
#endif /* _MB_CAPABLE */
}
   1b0cc:	e8bd8010 	pop	{r4, pc}

0001b0d0 <__locale_mb_cur_max>:
__locale_mb_cur_max (void)
{
#ifdef __HAVE_LOCALE_INFO__
  return __get_current_ctype_locale ()->mb_cur_max[0];
#else
  return __get_current_locale ()->mb_cur_max[0];
   1b0d0:	e30b3078 	movw	r3, #45176	@ 0xb078
   1b0d4:	e3403002 	movt	r3, #2
#endif
}
   1b0d8:	e5d30128 	ldrb	r0, [r3, #296]	@ 0x128
   1b0dc:	e12fff1e 	bx	lr

0001b0e0 <setlocale>:
#ifndef _REENT_ONLY

char *
setlocale (int category,
	const char *locale)
{
   1b0e0:	e92d4010 	push	{r4, lr}
  if (locale)
   1b0e4:	e2514000 	subs	r4, r1, #0
   1b0e8:	0a000005 	beq	1b104 <setlocale+0x24>
      if (strcmp (locale, "POSIX") && strcmp (locale, "C")
   1b0ec:	e3091138 	movw	r1, #37176	@ 0x9138
   1b0f0:	e1a00004 	mov	r0, r4
   1b0f4:	e3401002 	movt	r1, #2
   1b0f8:	fa001238 	blx	1f9e0 <strcmp>
   1b0fc:	e3500000 	cmp	r0, #0
   1b100:	1a000002 	bne	1b110 <setlocale+0x30>
  return "C";
   1b104:	e3090134 	movw	r0, #37172	@ 0x9134
   1b108:	e3400002 	movt	r0, #2
   1b10c:	e8bd8010 	pop	{r4, pc}
      if (strcmp (locale, "POSIX") && strcmp (locale, "C")
   1b110:	e3091134 	movw	r1, #37172	@ 0x9134
   1b114:	e1a00004 	mov	r0, r4
   1b118:	e3401002 	movt	r1, #2
   1b11c:	fa00122f 	blx	1f9e0 <strcmp>
   1b120:	e3500000 	cmp	r0, #0
   1b124:	0afffff6 	beq	1b104 <setlocale+0x24>
	  && strcmp (locale, ""))
   1b128:	e3081d5c 	movw	r1, #36188	@ 0x8d5c
   1b12c:	e1a00004 	mov	r0, r4
   1b130:	e3401002 	movt	r1, #2
   1b134:	fa001229 	blx	1f9e0 <strcmp>
   1b138:	e3500000 	cmp	r0, #0
   1b13c:	0afffff0 	beq	1b104 <setlocale+0x24>
        return NULL;
   1b140:	e3a00000 	mov	r0, #0
  return _setlocale_r (_REENT, category, locale);
}
   1b144:	e8bd8010 	pop	{r4, pc}

0001b148 <__localeconv_l>:
  lconv->int_n_sign_posn = m->n_sign_posn[0];
  lconv->int_p_sign_posn = m->p_sign_posn[0];
#endif /* !__HAVE_LOCALE_INFO_EXTENDED__ */
#endif /* __HAVE_LOCALE_INFO__ */
  return lconv;
}
   1b148:	e28000f0 	add	r0, r0, #240	@ 0xf0
   1b14c:	e12fff1e 	bx	lr

0001b150 <_localeconv_r>:
{
  /* Note that we always fall back to the global locale, even in case
     of specifying a reent.  Otherwise a call to _localeconv_r would just
     crash if the reent locale pointer is NULL. */
  return __localeconv_l (__get_current_locale ());
}
   1b150:	e59f0000 	ldr	r0, [pc]	@ 1b158 <_localeconv_r+0x8>
   1b154:	e12fff1e 	bx	lr
   1b158:	0002b168 	.word	0x0002b168

0001b15c <localeconv>:
#ifndef _REENT_ONLY
struct lconv *
localeconv (void)
{
  return __localeconv_l (__get_current_locale ());
}
   1b15c:	e59f0000 	ldr	r0, [pc]	@ 1b164 <localeconv+0x8>
   1b160:	e12fff1e 	bx	lr
   1b164:	0002b168 	.word	0x0002b168

0001b168 <nl_langinfo_l>:
   char *s;
#endif
   static char *csym = NULL;
   char *nptr;

   switch (item) {
   1b168:	e3500054 	cmp	r0, #84	@ 0x54
   1b16c:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
   1b170:	ea000054 	b	1b2c8 <nl_langinfo_l+0x160>
   1b174:	0001b498 	.word	0x0001b498
   1b178:	0001b3e8 	.word	0x0001b3e8
   1b17c:	0001b3d8 	.word	0x0001b3d8
   1b180:	0001b3c8 	.word	0x0001b3c8
   1b184:	0001b3b8 	.word	0x0001b3b8
   1b188:	0001b3a8 	.word	0x0001b3a8
   1b18c:	0001b338 	.word	0x0001b338
   1b190:	0001b324 	.word	0x0001b324
   1b194:	0001b324 	.word	0x0001b324
   1b198:	0001b324 	.word	0x0001b324
   1b19c:	0001b324 	.word	0x0001b324
   1b1a0:	0001b324 	.word	0x0001b324
   1b1a4:	0001b324 	.word	0x0001b324
   1b1a8:	0001b324 	.word	0x0001b324
   1b1ac:	0001b310 	.word	0x0001b310
   1b1b0:	0001b310 	.word	0x0001b310
   1b1b4:	0001b310 	.word	0x0001b310
   1b1b8:	0001b310 	.word	0x0001b310
   1b1bc:	0001b310 	.word	0x0001b310
   1b1c0:	0001b310 	.word	0x0001b310
   1b1c4:	0001b310 	.word	0x0001b310
   1b1c8:	0001b2fc 	.word	0x0001b2fc
   1b1cc:	0001b2fc 	.word	0x0001b2fc
   1b1d0:	0001b2fc 	.word	0x0001b2fc
   1b1d4:	0001b2fc 	.word	0x0001b2fc
   1b1d8:	0001b2fc 	.word	0x0001b2fc
   1b1dc:	0001b2fc 	.word	0x0001b2fc
   1b1e0:	0001b2fc 	.word	0x0001b2fc
   1b1e4:	0001b2fc 	.word	0x0001b2fc
   1b1e8:	0001b2fc 	.word	0x0001b2fc
   1b1ec:	0001b2fc 	.word	0x0001b2fc
   1b1f0:	0001b2fc 	.word	0x0001b2fc
   1b1f4:	0001b2fc 	.word	0x0001b2fc
   1b1f8:	0001b2e8 	.word	0x0001b2e8
   1b1fc:	0001b2e8 	.word	0x0001b2e8
   1b200:	0001b2e8 	.word	0x0001b2e8
   1b204:	0001b2e8 	.word	0x0001b2e8
   1b208:	0001b2e8 	.word	0x0001b2e8
   1b20c:	0001b2e8 	.word	0x0001b2e8
   1b210:	0001b2e8 	.word	0x0001b2e8
   1b214:	0001b2e8 	.word	0x0001b2e8
   1b218:	0001b2e8 	.word	0x0001b2e8
   1b21c:	0001b2e8 	.word	0x0001b2e8
   1b220:	0001b2e8 	.word	0x0001b2e8
   1b224:	0001b2e8 	.word	0x0001b2e8
   1b228:	0001b398 	.word	0x0001b398
   1b22c:	0001b378 	.word	0x0001b378
   1b230:	0001b368 	.word	0x0001b368
   1b234:	0001b358 	.word	0x0001b358
   1b238:	0001b348 	.word	0x0001b348
   1b23c:	0001b478 	.word	0x0001b478
   1b240:	0001b468 	.word	0x0001b468
   1b244:	0001b458 	.word	0x0001b458
   1b248:	0001b448 	.word	0x0001b448
   1b24c:	0001b488 	.word	0x0001b488
   1b250:	0001b438 	.word	0x0001b438
   1b254:	0001b408 	.word	0x0001b408
   1b258:	0001b3f8 	.word	0x0001b3f8
   1b25c:	0001b2c8 	.word	0x0001b2c8
   1b260:	0001b2c8 	.word	0x0001b2c8
   1b264:	0001b2c8 	.word	0x0001b2c8
   1b268:	0001b2c8 	.word	0x0001b2c8
   1b26c:	0001b2c8 	.word	0x0001b2c8
   1b270:	0001b2c8 	.word	0x0001b2c8
   1b274:	0001b2c8 	.word	0x0001b2c8
   1b278:	0001b2c8 	.word	0x0001b2c8
   1b27c:	0001b2c8 	.word	0x0001b2c8
   1b280:	0001b2c8 	.word	0x0001b2c8
   1b284:	0001b2c8 	.word	0x0001b2c8
   1b288:	0001b2c8 	.word	0x0001b2c8
   1b28c:	0001b2c8 	.word	0x0001b2c8
   1b290:	0001b2c8 	.word	0x0001b2c8
   1b294:	0001b2c8 	.word	0x0001b2c8
   1b298:	0001b2c8 	.word	0x0001b2c8
   1b29c:	0001b2c8 	.word	0x0001b2c8
   1b2a0:	0001b2c8 	.word	0x0001b2c8
   1b2a4:	0001b2c8 	.word	0x0001b2c8
   1b2a8:	0001b2c8 	.word	0x0001b2c8
   1b2ac:	0001b2c8 	.word	0x0001b2c8
   1b2b0:	0001b2c8 	.word	0x0001b2c8
   1b2b4:	0001b2c8 	.word	0x0001b2c8
   1b2b8:	0001b2c8 	.word	0x0001b2c8
   1b2bc:	0001b2c8 	.word	0x0001b2c8
   1b2c0:	0001b2c8 	.word	0x0001b2c8
   1b2c4:	0001b388 	.word	0x0001b388
#endif
	default:
		/* Relies on the fact that LC_ALL is 0, and all other
		   LC_ constants are in ascending order. */
		if (item > NL_LOCALE_NAME(LC_ALL)
		    && item < NL_LOCALE_NAME(_LC_LAST)) {
   1b2c8:	e307395f 	movw	r3, #31071	@ 0x795f
   1b2cc:	e34f3ffe 	movt	r3, #65534	@ 0xfffe
   1b2d0:	e0803003 	add	r3, r0, r3
		if (item > NL_LOCALE_NAME(LC_ALL)
   1b2d4:	e3530005 	cmp	r3, #5
   1b2d8:	9a000071 	bls	1b4a4 <nl_langinfo_l+0x33c>
		ret = "";
   1b2dc:	e3080d5c 	movw	r0, #36188	@ 0x8d5c
   1b2e0:	e3400002 	movt	r0, #2
		}
#endif
		ret = "";
   }
   return (ret);
}
   1b2e4:	e12fff1e 	bx	lr
		ret = (char*) __get_time_locale (locale)->mon[_REL(ABMON_1)];
   1b2e8:	e3093f74 	movw	r3, #40820	@ 0x9f74
   1b2ec:	e2400021 	sub	r0, r0, #33	@ 0x21
   1b2f0:	e3403002 	movt	r3, #2
   1b2f4:	e7930100 	ldr	r0, [r3, r0, lsl #2]
		break;
   1b2f8:	e12fff1e 	bx	lr
		ret = (char*) __get_time_locale (locale)->month[_REL(MON_1)];
   1b2fc:	e3093f74 	movw	r3, #40820	@ 0x9f74
   1b300:	e2400009 	sub	r0, r0, #9
   1b304:	e3403002 	movt	r3, #2
   1b308:	e7930100 	ldr	r0, [r3, r0, lsl #2]
		break;
   1b30c:	e12fff1e 	bx	lr
		ret = (char*) __get_time_locale (locale)->wday[_REL(ABDAY_1)];
   1b310:	e3093f74 	movw	r3, #40820	@ 0x9f74
   1b314:	e280000a 	add	r0, r0, #10
   1b318:	e3403002 	movt	r3, #2
   1b31c:	e7930100 	ldr	r0, [r3, r0, lsl #2]
		break;
   1b320:	e12fff1e 	bx	lr
		ret = (char*) __get_time_locale (locale)->weekday[_REL(DAY_1)];
   1b324:	e3093f74 	movw	r3, #40820	@ 0x9f74
   1b328:	e3403002 	movt	r3, #2
   1b32c:	e0833100 	add	r3, r3, r0, lsl #2
   1b330:	e5930060 	ldr	r0, [r3, #96]	@ 0x60
		break;
   1b334:	e12fff1e 	bx	lr
		ret = (char *) __get_time_locale (locale)->am_pm[1];
   1b338:	e3093f74 	movw	r3, #40820	@ 0x9f74
   1b33c:	e3403002 	movt	r3, #2
   1b340:	e59300a8 	ldr	r0, [r3, #168]	@ 0xa8
		break;
   1b344:	e12fff1e 	bx	lr
		ret = (char*) __get_time_locale (locale)->alt_digits;
   1b348:	e3093f74 	movw	r3, #40820	@ 0x9f74
   1b34c:	e3403002 	movt	r3, #2
   1b350:	e59300f8 	ldr	r0, [r3, #248]	@ 0xf8
		break;
   1b354:	e12fff1e 	bx	lr
		ret = (char*) __get_time_locale (locale)->era_t_fmt;
   1b358:	e3093f74 	movw	r3, #40820	@ 0x9f74
   1b35c:	e3403002 	movt	r3, #2
   1b360:	e59300f4 	ldr	r0, [r3, #244]	@ 0xf4
		break;
   1b364:	e12fff1e 	bx	lr
		ret = (char*) __get_time_locale (locale)->era_d_t_fmt;
   1b368:	e3093f74 	movw	r3, #40820	@ 0x9f74
   1b36c:	e3403002 	movt	r3, #2
   1b370:	e59300f0 	ldr	r0, [r3, #240]	@ 0xf0
		break;
   1b374:	e12fff1e 	bx	lr
		ret = (char*) __get_time_locale (locale)->era_d_fmt;
   1b378:	e3093f74 	movw	r3, #40820	@ 0x9f74
   1b37c:	e3403002 	movt	r3, #2
   1b380:	e59300ec 	ldr	r0, [r3, #236]	@ 0xec
		break;
   1b384:	e12fff1e 	bx	lr
		ret = (char*) __get_time_locale (locale)->date_fmt;
   1b388:	e3093f74 	movw	r3, #40820	@ 0x9f74
   1b38c:	e3403002 	movt	r3, #2
   1b390:	e59300ac 	ldr	r0, [r3, #172]	@ 0xac
		break;
   1b394:	e12fff1e 	bx	lr
		ret = (char*) __get_time_locale (locale)->era;
   1b398:	e3093f74 	movw	r3, #40820	@ 0x9f74
   1b39c:	e3403002 	movt	r3, #2
   1b3a0:	e59300e8 	ldr	r0, [r3, #232]	@ 0xe8
		break;
   1b3a4:	e12fff1e 	bx	lr
		ret = (char *) __get_time_locale (locale)->am_pm[0];
   1b3a8:	e3093f74 	movw	r3, #40820	@ 0x9f74
   1b3ac:	e3403002 	movt	r3, #2
   1b3b0:	e59300a4 	ldr	r0, [r3, #164]	@ 0xa4
		break;
   1b3b4:	e12fff1e 	bx	lr
		ret = (char *) __get_time_locale (locale)->ampm_fmt;
   1b3b8:	e3093f74 	movw	r3, #40820	@ 0x9f74
   1b3bc:	e3403002 	movt	r3, #2
   1b3c0:	e59300e4 	ldr	r0, [r3, #228]	@ 0xe4
		break;
   1b3c4:	e12fff1e 	bx	lr
		ret = (char *) __get_time_locale (locale)->X_fmt;
   1b3c8:	e3093f74 	movw	r3, #40820	@ 0x9f74
   1b3cc:	e3403002 	movt	r3, #2
   1b3d0:	e5930098 	ldr	r0, [r3, #152]	@ 0x98
		break;
   1b3d4:	e12fff1e 	bx	lr
		ret = (char *) __get_time_locale (locale)->x_fmt;
   1b3d8:	e3093f74 	movw	r3, #40820	@ 0x9f74
   1b3dc:	e3403002 	movt	r3, #2
   1b3e0:	e593009c 	ldr	r0, [r3, #156]	@ 0x9c
		break;
   1b3e4:	e12fff1e 	bx	lr
		ret = (char *) __get_time_locale (locale)->c_fmt;
   1b3e8:	e3093f74 	movw	r3, #40820	@ 0x9f74
   1b3ec:	e3403002 	movt	r3, #2
   1b3f0:	e59300a0 	ldr	r0, [r3, #160]	@ 0xa0
		break;
   1b3f4:	e12fff1e 	bx	lr
		ret = (char *) __get_time_locale (locale)->md_order;
   1b3f8:	e3093f74 	movw	r3, #40820	@ 0x9f74
   1b3fc:	e3403002 	movt	r3, #2
   1b400:	e59300e0 	ldr	r0, [r3, #224]	@ 0xe0
		break;
   1b404:	e12fff1e 	bx	lr
{
   1b408:	e92d40f0 	push	{r4, r5, r6, r7, lr}
		cs = (char*) __get_monetary_locale (locale)->currency_symbol;
   1b40c:	e30a40cc 	movw	r4, #41164	@ 0xa0cc
   1b410:	e3404002 	movt	r4, #2
{
   1b414:	e24dd00c 	sub	sp, sp, #12
		cs = (char*) __get_monetary_locale (locale)->currency_symbol;
   1b418:	e5945004 	ldr	r5, [r4, #4]
		if (*cs != '\0') {
   1b41c:	e5d53000 	ldrb	r3, [r5]
   1b420:	e3530000 	cmp	r3, #0
   1b424:	1a000022 	bne	1b4b4 <nl_langinfo_l+0x34c>
		ret = "";
   1b428:	e3080d5c 	movw	r0, #36188	@ 0x8d5c
   1b42c:	e3400002 	movt	r0, #2
}
   1b430:	e28dd00c 	add	sp, sp, #12
   1b434:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
		ret = (char*) __get_messages_locale (locale)->nostr;
   1b438:	e30a30b0 	movw	r3, #41136	@ 0xa0b0
   1b43c:	e3403002 	movt	r3, #2
   1b440:	e593000c 	ldr	r0, [r3, #12]
		break;
   1b444:	e12fff1e 	bx	lr
		ret = (char*) __get_messages_locale (locale)->noexpr;
   1b448:	e30a30b0 	movw	r3, #41136	@ 0xa0b0
   1b44c:	e3403002 	movt	r3, #2
   1b450:	e5930004 	ldr	r0, [r3, #4]
		break;
   1b454:	e12fff1e 	bx	lr
		ret = (char*) __get_messages_locale (locale)->yesexpr;
   1b458:	e30a30b0 	movw	r3, #41136	@ 0xa0b0
   1b45c:	e3403002 	movt	r3, #2
   1b460:	e5930000 	ldr	r0, [r3]
		break;
   1b464:	e12fff1e 	bx	lr
		ret = (char*) __get_numeric_locale (locale)->thousands_sep;
   1b468:	e30a30c0 	movw	r3, #41152	@ 0xa0c0
   1b46c:	e3403002 	movt	r3, #2
   1b470:	e5930004 	ldr	r0, [r3, #4]
		break;
   1b474:	e12fff1e 	bx	lr
		ret = (char*) __get_numeric_locale (locale)->decimal_point;
   1b478:	e30a30c0 	movw	r3, #41152	@ 0xa0c0
   1b47c:	e3403002 	movt	r3, #2
   1b480:	e5930000 	ldr	r0, [r3]
		break;
   1b484:	e12fff1e 	bx	lr
		ret = (char*) __get_messages_locale (locale)->yesstr;
   1b488:	e30a30b0 	movw	r3, #41136	@ 0xa0b0
   1b48c:	e3403002 	movt	r3, #2
   1b490:	e5930008 	ldr	r0, [r3, #8]
		break;
   1b494:	e12fff1e 	bx	lr
   switch (item) {
   1b498:	e30901d8 	movw	r0, #37336	@ 0x91d8
   1b49c:	e3400002 	movt	r0, #2
   1b4a0:	e12fff1e 	bx	lr
						  - NL_LOCALE_NAME(LC_ALL)];
   1b4a4:	e2403b61 	sub	r3, r0, #99328	@ 0x18400
   1b4a8:	e2433e2a 	sub	r3, r3, #672	@ 0x2a0
			return locale->categories[item
   1b4ac:	e0810283 	add	r0, r1, r3, lsl #5
   1b4b0:	e12fff1e 	bx	lr
			char pos = __localeconv_l (locale)->p_cs_precedes;
   1b4b4:	e1a00001 	mov	r0, r1
   1b4b8:	e58d1004 	str	r1, [sp, #4]
   1b4bc:	ebffff21 	bl	1b148 <__localeconv_l>
			if (pos == __localeconv_l (locale)->n_cs_precedes) {
   1b4c0:	e59d1004 	ldr	r1, [sp, #4]
			char pos = __localeconv_l (locale)->p_cs_precedes;
   1b4c4:	e1a03000 	mov	r3, r0
   1b4c8:	e5d3602a 	ldrb	r6, [r3, #42]	@ 0x2a
			if (pos == __localeconv_l (locale)->n_cs_precedes) {
   1b4cc:	e1a00001 	mov	r0, r1
   1b4d0:	ebffff1c 	bl	1b148 <__localeconv_l>
   1b4d4:	e5d0302c 	ldrb	r3, [r0, #44]	@ 0x2c
   1b4d8:	e1530006 	cmp	r3, r6
   1b4dc:	1affffd1 	bne	1b428 <nl_langinfo_l+0x2c0>
				if (pos == CHAR_MAX) {
   1b4e0:	e35300ff 	cmp	r3, #255	@ 0xff
   1b4e4:	0a000018 	beq	1b54c <nl_langinfo_l+0x3e4>
					psn = pos ? '-' : '+';
   1b4e8:	e3530000 	cmp	r3, #0
   1b4ec:	03a0702b 	moveq	r7, #43	@ 0x2b
   1b4f0:	13a0702d 	movne	r7, #45	@ 0x2d
                                        nptr = realloc(csym, clen + 2);
   1b4f4:	e30b4664 	movw	r4, #46692	@ 0xb664
					int clen = strlen(cs);
   1b4f8:	e1a00005 	mov	r0, r5
                                        nptr = realloc(csym, clen + 2);
   1b4fc:	e3404002 	movt	r4, #2
					int clen = strlen(cs);
   1b500:	fa0013de 	blx	20480 <strlen>
                                        nptr = realloc(csym, clen + 2);
   1b504:	e2801002 	add	r1, r0, #2
   1b508:	e5940000 	ldr	r0, [r4]
   1b50c:	eb000e37 	bl	1edf0 <realloc>
                                        if (!nptr && csym)
   1b510:	e2506000 	subs	r6, r0, #0
   1b514:	0a000006 	beq	1b534 <nl_langinfo_l+0x3cc>
						*csym = psn;
   1b518:	e1a00006 	mov	r0, r6
						strcpy(csym + 1, cs);
   1b51c:	e1a01005 	mov	r1, r5
						*csym = psn;
   1b520:	e4c07001 	strb	r7, [r0], #1
                                        csym = nptr;
   1b524:	e5846000 	str	r6, [r4]
						strcpy(csym + 1, cs);
   1b528:	eb0011e4 	bl	1fcc0 <strcpy>
						ret = csym;
   1b52c:	e5940000 	ldr	r0, [r4]
   1b530:	eaffffbe 	b	1b430 <nl_langinfo_l+0x2c8>
                                        if (!nptr && csym)
   1b534:	e5940000 	ldr	r0, [r4]
   1b538:	e3500000 	cmp	r0, #0
   1b53c:	0affffb9 	beq	1b428 <nl_langinfo_l+0x2c0>
                                          free (csym);
   1b540:	eb000c37 	bl	1e624 <free>
                                        csym = nptr;
   1b544:	e5846000 	str	r6, [r4]
					if (csym != NULL) {
   1b548:	eaffffb6 	b	1b428 <nl_langinfo_l+0x2c0>
					if (strcmp(cs, __get_monetary_locale (locale)->mon_decimal_point) == 0)
   1b54c:	e5941008 	ldr	r1, [r4, #8]
   1b550:	e1a00005 	mov	r0, r5
   1b554:	fa001121 	blx	1f9e0 <strcmp>
   1b558:	e3500000 	cmp	r0, #0
   1b55c:	1affffb1 	bne	1b428 <nl_langinfo_l+0x2c0>
						psn = '.';
   1b560:	e3a0702e 	mov	r7, #46	@ 0x2e
   1b564:	eaffffe2 	b	1b4f4 <nl_langinfo_l+0x38c>

0001b568 <nl_langinfo>:

char *nl_langinfo (nl_item item)
{
  return nl_langinfo_l (item, __get_current_locale ());
   1b568:	e30b1078 	movw	r1, #45176	@ 0xb078
   1b56c:	e3401002 	movt	r1, #2
   1b570:	eafffefc 	b	1b168 <nl_langinfo_l>

0001b574 <__time_load_locale>:
#else
  /* TODO */
#endif
#endif /* __HAVE_LOCALE_INFO__ */
  return (ret);
}
   1b574:	e3a00000 	mov	r0, #0
   1b578:	e12fff1e 	bx	lr

0001b57c <_close_r>:

int
_close_r (ptr, fd)
     struct _reent *ptr;
     int fd;
{
   1b57c:	e92d4070 	push	{r4, r5, r6, lr}
  int ret;

  errno = 0;
   1b580:	e30b4668 	movw	r4, #46696	@ 0xb668
   1b584:	e3a02000 	mov	r2, #0
{
   1b588:	e1a05000 	mov	r5, r0
  errno = 0;
   1b58c:	e3404002 	movt	r4, #2
  if ((ret = _close (fd)) == -1 && errno != 0)
   1b590:	e1a00001 	mov	r0, r1
  errno = 0;
   1b594:	e5842000 	str	r2, [r4]
  if ((ret = _close (fd)) == -1 && errno != 0)
   1b598:	eb001050 	bl	1f6e0 <_close>
   1b59c:	e3700001 	cmn	r0, #1
   1b5a0:	18bd8070 	popne	{r4, r5, r6, pc}
   1b5a4:	e5943000 	ldr	r3, [r4]
   1b5a8:	e3530000 	cmp	r3, #0
    _REENT_ERRNO(ptr) = errno;
   1b5ac:	15853000 	strne	r3, [r5]
  return ret;
}
   1b5b0:	e8bd8070 	pop	{r4, r5, r6, pc}

0001b5b4 <_reclaim_reent>:

void
_reclaim_reent (struct _reent *ptr)
{
#ifndef _REENT_THREAD_LOCAL
  if (ptr != _impure_ptr)
   1b5b4:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
   1b5b8:	e3403002 	movt	r3, #2
   1b5bc:	e5933000 	ldr	r3, [r3]
   1b5c0:	e1530000 	cmp	r3, r0
   1b5c4:	012fff1e 	bxeq	lr
      /* used by mprec routines. */
#ifdef _REENT_SMALL
      if (ptr->_mp)	/* don't bother allocating it! */
      {
#endif
      if (_REENT_MP_FREELIST(ptr))
   1b5c8:	e5901044 	ldr	r1, [r0, #68]	@ 0x44
{
   1b5cc:	e92d4070 	push	{r4, r5, r6, lr}
   1b5d0:	e1a05000 	mov	r5, r0
      if (_REENT_MP_FREELIST(ptr))
   1b5d4:	e3510000 	cmp	r1, #0
   1b5d8:	0a00000f 	beq	1b61c <_reclaim_reent+0x68>
   1b5dc:	e3a06000 	mov	r6, #0
	  int i;
	  for (i = 0; i < _Kmax; i++) 
	    {
	      struct _Bigint *thisone, *nextone;
	
	      nextone = _REENT_MP_FREELIST(ptr)[i];
   1b5e0:	e7914006 	ldr	r4, [r1, r6]
	      while (nextone)
   1b5e4:	e3540000 	cmp	r4, #0
   1b5e8:	0a000006 	beq	1b608 <_reclaim_reent+0x54>
		{
		  thisone = nextone;
		  nextone = nextone->_next;
   1b5ec:	e1a01004 	mov	r1, r4
   1b5f0:	e5944000 	ldr	r4, [r4]
		  _free_r (ptr, thisone);
   1b5f4:	e1a00005 	mov	r0, r5
   1b5f8:	eb000fd3 	bl	1f54c <_free_r>
	      while (nextone)
   1b5fc:	e3540000 	cmp	r4, #0
   1b600:	1afffff9 	bne	1b5ec <_reclaim_reent+0x38>
		}
	    }    

	  _free_r (ptr, _REENT_MP_FREELIST(ptr));
   1b604:	e5951044 	ldr	r1, [r5, #68]	@ 0x44
	  for (i = 0; i < _Kmax; i++) 
   1b608:	e2866004 	add	r6, r6, #4
   1b60c:	e3560080 	cmp	r6, #128	@ 0x80
   1b610:	1afffff2 	bne	1b5e0 <_reclaim_reent+0x2c>
	  _free_r (ptr, _REENT_MP_FREELIST(ptr));
   1b614:	e1a00005 	mov	r0, r5
   1b618:	eb000fcb 	bl	1f54c <_free_r>
	}
      if (_REENT_MP_RESULT(ptr))
   1b61c:	e5951038 	ldr	r1, [r5, #56]	@ 0x38
   1b620:	e3510000 	cmp	r1, #0
   1b624:	0a000001 	beq	1b630 <_reclaim_reent+0x7c>
	_free_r (ptr, _REENT_MP_RESULT(ptr));
   1b628:	e1a00005 	mov	r0, r5
   1b62c:	eb000fc6 	bl	1f54c <_free_r>
      if (_REENT_MP_P5S(ptr))
   1b630:	e5954040 	ldr	r4, [r5, #64]	@ 0x40
   1b634:	e3540000 	cmp	r4, #0
   1b638:	0a000005 	beq	1b654 <_reclaim_reent+0xa0>
          struct _Bigint *thisone, *nextone;
          nextone = _REENT_MP_P5S(ptr);
          while (nextone)
           {
             thisone = nextone;
             nextone = nextone->_next;
   1b63c:	e1a01004 	mov	r1, r4
   1b640:	e5944000 	ldr	r4, [r4]
             _free_r (ptr, thisone);
   1b644:	e1a00005 	mov	r0, r5
   1b648:	eb000fbf 	bl	1f54c <_free_r>
          while (nextone)
   1b64c:	e3540000 	cmp	r4, #0
   1b650:	1afffff9 	bne	1b63c <_reclaim_reent+0x88>
	_free_r (ptr, ptr->_signal_buf);
	  if (ptr->_misc)
	_free_r (ptr, ptr->_misc);
#endif

      if (_REENT_CVTBUF(ptr))
   1b654:	e595104c 	ldr	r1, [r5, #76]	@ 0x4c
   1b658:	e3510000 	cmp	r1, #0
   1b65c:	0a000001 	beq	1b668 <_reclaim_reent+0xb4>
	_free_r (ptr, _REENT_CVTBUF(ptr));
   1b660:	e1a00005 	mov	r0, r5
   1b664:	eb000fb8 	bl	1f54c <_free_r>
	   do it safely considering that a signal may be delivered immediately
	   after the free?
	  if (_REENT_SIG_FUNC(ptr))
	_free_r (ptr, _REENT_SIG_FUNC(ptr));*/

      if (_REENT_CLEANUP(ptr))
   1b668:	e5953034 	ldr	r3, [r5, #52]	@ 0x34
   1b66c:	e3530000 	cmp	r3, #0
   1b670:	08bd8070 	popeq	{r4, r5, r6, pc}
	{
	  /* cleanup won't reclaim memory 'coz usually it's run
	     before the program exits, and who wants to wait for that? */
	  _REENT_CLEANUP(ptr) (ptr);
   1b674:	e1a00005 	mov	r0, r5
	}

      /* Malloc memory not reclaimed; no good way to return memory anyway. */

    }
}
   1b678:	e8bd4070 	pop	{r4, r5, r6, lr}
	  _REENT_CLEANUP(ptr) (ptr);
   1b67c:	e12fff13 	bx	r3

0001b680 <_fstat_r>:
int
_fstat_r (ptr, fd, pstat)
     struct _reent *ptr;
     int fd;
     struct stat *pstat;
{
   1b680:	e92d4070 	push	{r4, r5, r6, lr}
   1b684:	e1a0e001 	mov	lr, r1
  int ret;

  errno = 0;
   1b688:	e30b4668 	movw	r4, #46696	@ 0xb668
   1b68c:	e3a0c000 	mov	ip, #0
{
   1b690:	e1a05000 	mov	r5, r0
  errno = 0;
   1b694:	e3404002 	movt	r4, #2
  if ((ret = _fstat (fd, pstat)) == -1 && errno != 0)
   1b698:	e1a01002 	mov	r1, r2
   1b69c:	e1a0000e 	mov	r0, lr
  errno = 0;
   1b6a0:	e584c000 	str	ip, [r4]
  if ((ret = _fstat (fd, pstat)) == -1 && errno != 0)
   1b6a4:	eb000fc8 	bl	1f5cc <_fstat>
   1b6a8:	e3700001 	cmn	r0, #1
   1b6ac:	18bd8070 	popne	{r4, r5, r6, pc}
   1b6b0:	e5943000 	ldr	r3, [r4]
   1b6b4:	e3530000 	cmp	r3, #0
    _REENT_ERRNO(ptr) = errno;
   1b6b8:	15853000 	strne	r3, [r5]
  return ret;
}
   1b6bc:	e8bd8070 	pop	{r4, r5, r6, pc}

0001b6c0 <_lseek_r>:
_off_t
_lseek_r (struct _reent *ptr,
     int fd,
     _off_t pos,
     int whence)
{
   1b6c0:	e92d4070 	push	{r4, r5, r6, lr}
   1b6c4:	e1a0e001 	mov	lr, r1
  _off_t ret;

  errno = 0;
   1b6c8:	e30b4668 	movw	r4, #46696	@ 0xb668
{
   1b6cc:	e1a01002 	mov	r1, r2
   1b6d0:	e1a05000 	mov	r5, r0
  if ((ret = _lseek (fd, pos, whence)) == (_off_t) -1 && errno != 0)
   1b6d4:	e1a02003 	mov	r2, r3
  errno = 0;
   1b6d8:	e3404002 	movt	r4, #2
   1b6dc:	e3a03000 	mov	r3, #0
  if ((ret = _lseek (fd, pos, whence)) == (_off_t) -1 && errno != 0)
   1b6e0:	e1a0000e 	mov	r0, lr
  errno = 0;
   1b6e4:	e5843000 	str	r3, [r4]
  if ((ret = _lseek (fd, pos, whence)) == (_off_t) -1 && errno != 0)
   1b6e8:	eb00103e 	bl	1f7e8 <_lseek>
   1b6ec:	e3700001 	cmn	r0, #1
   1b6f0:	18bd8070 	popne	{r4, r5, r6, pc}
   1b6f4:	e5943000 	ldr	r3, [r4]
   1b6f8:	e3530000 	cmp	r3, #0
    _REENT_ERRNO(ptr) = errno;
   1b6fc:	15853000 	strne	r3, [r5]
  return ret;
}
   1b700:	e8bd8070 	pop	{r4, r5, r6, pc}

0001b704 <_open_r>:
int
_open_r (struct _reent *ptr,
     const char *file,
     int flags,
     int mode)
{
   1b704:	e92d4070 	push	{r4, r5, r6, lr}
   1b708:	e1a0e001 	mov	lr, r1
  int ret;

  errno = 0;
   1b70c:	e30b4668 	movw	r4, #46696	@ 0xb668
{
   1b710:	e1a01002 	mov	r1, r2
   1b714:	e1a05000 	mov	r5, r0
  if ((ret = _open (file, flags, mode)) == -1 && errno != 0)
   1b718:	e1a02003 	mov	r2, r3
  errno = 0;
   1b71c:	e3404002 	movt	r4, #2
   1b720:	e3a03000 	mov	r3, #0
  if ((ret = _open (file, flags, mode)) == -1 && errno != 0)
   1b724:	e1a0000e 	mov	r0, lr
  errno = 0;
   1b728:	e5843000 	str	r3, [r4]
  if ((ret = _open (file, flags, mode)) == -1 && errno != 0)
   1b72c:	eb00008a 	bl	1b95c <_open>
   1b730:	e3700001 	cmn	r0, #1
   1b734:	18bd8070 	popne	{r4, r5, r6, pc}
   1b738:	e5943000 	ldr	r3, [r4]
   1b73c:	e3530000 	cmp	r3, #0
    _REENT_ERRNO(ptr) = errno;
   1b740:	15853000 	strne	r3, [r5]
  return ret;
}
   1b744:	e8bd8070 	pop	{r4, r5, r6, pc}

0001b748 <_read_r>:
_ssize_t
_read_r (struct _reent *ptr,
     int fd,
     void *buf,
     size_t cnt)
{
   1b748:	e92d4070 	push	{r4, r5, r6, lr}
   1b74c:	e1a0e001 	mov	lr, r1
  _ssize_t ret;

  errno = 0;
   1b750:	e30b4668 	movw	r4, #46696	@ 0xb668
{
   1b754:	e1a01002 	mov	r1, r2
   1b758:	e1a05000 	mov	r5, r0
  if ((ret = (_ssize_t)_read (fd, buf, cnt)) == -1 && errno != 0)
   1b75c:	e1a02003 	mov	r2, r3
  errno = 0;
   1b760:	e3404002 	movt	r4, #2
   1b764:	e3a03000 	mov	r3, #0
  if ((ret = (_ssize_t)_read (fd, buf, cnt)) == -1 && errno != 0)
   1b768:	e1a0000e 	mov	r0, lr
  errno = 0;
   1b76c:	e5843000 	str	r3, [r4]
  if ((ret = (_ssize_t)_read (fd, buf, cnt)) == -1 && errno != 0)
   1b770:	eb001038 	bl	1f858 <_read>
   1b774:	e3700001 	cmn	r0, #1
   1b778:	18bd8070 	popne	{r4, r5, r6, pc}
   1b77c:	e5943000 	ldr	r3, [r4]
   1b780:	e3530000 	cmp	r3, #0
    _REENT_ERRNO(ptr) = errno;
   1b784:	15853000 	strne	r3, [r5]
  return ret;
}
   1b788:	e8bd8070 	pop	{r4, r5, r6, pc}

0001b78c <_kill_r>:

int
_kill_r (struct _reent *ptr,
     int pid,
     int sig)
{
   1b78c:	e92d4070 	push	{r4, r5, r6, lr}
   1b790:	e1a0e001 	mov	lr, r1
  int ret;

  errno = 0;
   1b794:	e30b4668 	movw	r4, #46696	@ 0xb668
   1b798:	e3a0c000 	mov	ip, #0
{
   1b79c:	e1a05000 	mov	r5, r0
  errno = 0;
   1b7a0:	e3404002 	movt	r4, #2
  if ((ret = _kill (pid, sig)) == -1 && errno != 0)
   1b7a4:	e1a01002 	mov	r1, r2
   1b7a8:	e1a0000e 	mov	r0, lr
  errno = 0;
   1b7ac:	e584c000 	str	ip, [r4]
  if ((ret = _kill (pid, sig)) == -1 && errno != 0)
   1b7b0:	eb000099 	bl	1ba1c <_kill>
   1b7b4:	e3700001 	cmn	r0, #1
   1b7b8:	18bd8070 	popne	{r4, r5, r6, pc}
   1b7bc:	e5943000 	ldr	r3, [r4]
   1b7c0:	e3530000 	cmp	r3, #0
    _REENT_ERRNO(ptr) = errno;
   1b7c4:	15853000 	strne	r3, [r5]
  return ret;
}
   1b7c8:	e8bd8070 	pop	{r4, r5, r6, pc}

0001b7cc <_getpid_r>:

int
_getpid_r (struct _reent *ptr)
{
  int ret;
  ret = _getpid ();
   1b7cc:	ea000fe3 	b	1f760 <_getpid>

0001b7d0 <_write_r>:
_ssize_t
_write_r (struct _reent *ptr,
     int fd,
     const void *buf,
     size_t cnt)
{
   1b7d0:	e92d4070 	push	{r4, r5, r6, lr}
   1b7d4:	e1a0e001 	mov	lr, r1
  _ssize_t ret;

  errno = 0;
   1b7d8:	e30b4668 	movw	r4, #46696	@ 0xb668
{
   1b7dc:	e1a01002 	mov	r1, r2
   1b7e0:	e1a05000 	mov	r5, r0
  if ((ret = (_ssize_t)_write (fd, buf, cnt)) == -1 && errno != 0)
   1b7e4:	e1a02003 	mov	r2, r3
  errno = 0;
   1b7e8:	e3404002 	movt	r4, #2
   1b7ec:	e3a03000 	mov	r3, #0
  if ((ret = (_ssize_t)_write (fd, buf, cnt)) == -1 && errno != 0)
   1b7f0:	e1a0000e 	mov	r0, lr
  errno = 0;
   1b7f4:	e5843000 	str	r3, [r4]
  if ((ret = (_ssize_t)_write (fd, buf, cnt)) == -1 && errno != 0)
   1b7f8:	eb00105b 	bl	1f96c <_write>
   1b7fc:	e3700001 	cmn	r0, #1
   1b800:	18bd8070 	popne	{r4, r5, r6, pc}
   1b804:	e5943000 	ldr	r3, [r4]
   1b808:	e3530000 	cmp	r3, #0
    _REENT_ERRNO(ptr) = errno;
   1b80c:	15853000 	strne	r3, [r5]
  return ret;
}
   1b810:	e8bd8070 	pop	{r4, r5, r6, pc}

0001b814 <__errno>:
#ifndef _REENT_ONLY

int *
__errno ()
{
  return &_REENT_ERRNO(_REENT);
   1b814:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
   1b818:	e3403002 	movt	r3, #2
}
   1b81c:	e5930000 	ldr	r0, [r3]
   1b820:	e12fff1e 	bx	lr

0001b824 <__libc_init_array>:
#endif

/* Iterate over all the init routines.  */
void
__libc_init_array (void)
{
   1b824:	e92d4070 	push	{r4, r5, r6, lr}
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
   1b828:	e30b6000 	movw	r6, #45056	@ 0xb000
   1b82c:	e30b5000 	movw	r5, #45056	@ 0xb000
   1b830:	e3406002 	movt	r6, #2
   1b834:	e3405002 	movt	r5, #2
  for (i = 0; i < count; i++)
   1b838:	e1560005 	cmp	r6, r5
  count = __preinit_array_end - __preinit_array_start;
   1b83c:	e0466005 	sub	r6, r6, r5
  for (i = 0; i < count; i++)
   1b840:	0a000006 	beq	1b860 <__libc_init_array+0x3c>
   1b844:	e1a06146 	asr	r6, r6, #2
   1b848:	e3a04000 	mov	r4, #0
    __preinit_array_start[i] ();
   1b84c:	e4953004 	ldr	r3, [r5], #4
  for (i = 0; i < count; i++)
   1b850:	e2844001 	add	r4, r4, #1
    __preinit_array_start[i] ();
   1b854:	e12fff33 	blx	r3
  for (i = 0; i < count; i++)
   1b858:	e1560004 	cmp	r6, r4
   1b85c:	8afffffa 	bhi	1b84c <__libc_init_array+0x28>

#ifdef _HAVE_INIT_FINI
  _init ();
#endif

  count = __init_array_end - __init_array_start;
   1b860:	e30b6004 	movw	r6, #45060	@ 0xb004
   1b864:	e30b5000 	movw	r5, #45056	@ 0xb000
   1b868:	e3406002 	movt	r6, #2
   1b86c:	e3405002 	movt	r5, #2
  _init ();
   1b870:	ebffb1e2 	bl	8000 <_init>
  for (i = 0; i < count; i++)
   1b874:	e1560005 	cmp	r6, r5
  count = __init_array_end - __init_array_start;
   1b878:	e0466005 	sub	r6, r6, r5
   1b87c:	e1a06146 	asr	r6, r6, #2
  for (i = 0; i < count; i++)
   1b880:	08bd8070 	popeq	{r4, r5, r6, pc}
   1b884:	e3a04000 	mov	r4, #0
    __init_array_start[i] ();
   1b888:	e4953004 	ldr	r3, [r5], #4
  for (i = 0; i < count; i++)
   1b88c:	e2844001 	add	r4, r4, #1
    __init_array_start[i] ();
   1b890:	e12fff33 	blx	r3
  for (i = 0; i < count; i++)
   1b894:	e1560004 	cmp	r6, r4
   1b898:	8afffffa 	bhi	1b888 <__libc_init_array+0x64>
   1b89c:	e8bd8070 	pop	{r4, r5, r6, pc}

0001b8a0 <__memcpy_chk>:

void *
__memcpy_chk(void * __restrict dst, const void * __restrict src, size_t len,
    size_t slen)
{
	if (len > slen)
   1b8a0:	e1520003 	cmp	r2, r3
   1b8a4:	8a00000a 	bhi	1b8d4 <__memcpy_chk+0x34>
		__chk_fail();

	if (__ssp_overlap((const char *)src, (const char *)dst, len))
   1b8a8:	e1510000 	cmp	r1, r0
   1b8ac:	8a000004 	bhi	1b8c4 <__memcpy_chk+0x24>
   1b8b0:	e0813002 	add	r3, r1, r2
   1b8b4:	e1500003 	cmp	r0, r3
   1b8b8:	3a000005 	bcc	1b8d4 <__memcpy_chk+0x34>
   1b8bc:	e1510000 	cmp	r1, r0
   1b8c0:	1a000002 	bne	1b8d0 <__memcpy_chk+0x30>
   1b8c4:	e0803002 	add	r3, r0, r2
   1b8c8:	e1510003 	cmp	r1, r3
   1b8cc:	3a000000 	bcc	1b8d4 <__memcpy_chk+0x34>
		__chk_fail();

	return memcpy(dst, src, len);
   1b8d0:	ea00116a 	b	1fe80 <memcpy>
{
   1b8d4:	e92d4010 	push	{r4, lr}
		__chk_fail();
   1b8d8:	eb002924 	bl	25d70 <__chk_fail>

0001b8dc <fcntl>:
#include <stdarg.h>
#include <sys/syscall.h>

int
fcntl(int fildes, int cmd, ...)
{
   1b8dc:	e92d000e 	push	{r1, r2, r3}
   1b8e0:	e92d4030 	push	{r4, r5, lr}
   1b8e4:	e24dd008 	sub	sp, sp, #8
  long arg;
  va_list ap;

  va_start(ap, cmd);
   1b8e8:	e28d3018 	add	r3, sp, #24
{
   1b8ec:	e59d1014 	ldr	r1, [sp, #20]
  va_start(ap, cmd);
   1b8f0:	e58d3004 	str	r3, [sp, #4]

  // Fetch the third argument for operations that require it
  switch (cmd) {
   1b8f4:	e3510009 	cmp	r1, #9
   1b8f8:	83a02000 	movhi	r2, #0
   1b8fc:	8a000006 	bhi	1b91c <fcntl+0x40>
   1b900:	e3a02001 	mov	r2, #1
   1b904:	e1a02112 	lsl	r2, r2, r1
   1b908:	e3120055 	tst	r2, #85	@ 0x55
   1b90c:	1a000001 	bne	1b918 <fcntl+0x3c>
   1b910:	e2122d0e 	ands	r2, r2, #896	@ 0x380
   1b914:	0a000000 	beq	1b91c <fcntl+0x40>
    arg = va_arg(ap, int);
    break;
  case F_GETLK:
  case F_SETLK:
  case F_SETLKW:
    arg = va_arg(ap, uintptr_t);
   1b918:	e59d2018 	ldr	r2, [sp, #24]
            uint32_t a5, uint32_t a6)
{
  register int32_t r0 asm("r0") = a1;
  register int32_t r1 asm("r1") = a2;
  register int32_t r2 asm("r2") = a3;
  register int32_t r3 asm("r3") = a4;
   1b91c:	e3a03000 	mov	r3, #0
  register int32_t r4 asm("r4") = a5;
   1b920:	e1a04003 	mov	r4, r3
  register int32_t r5 asm("r5") = a6;
   1b924:	e1a05003 	mov	r5, r3

  asm volatile("svc %1\n"
   1b928:	ef00000c 	svc	0x0000000c
__syscall(uint8_t num, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4,
          uint32_t a5, uint32_t a6)
{
  int r = __syscall_r(num, a1, a2, a3, a4, a5, a6);

  if (r < 0) {
   1b92c:	e2504000 	subs	r4, r0, #0
   1b930:	ba000004 	blt	1b948 <fcntl+0x6c>
  }

  va_end(ap);

  return __syscall3(__SYS_FCNTL, fildes, cmd, arg);
}
   1b934:	e1a00004 	mov	r0, r4
   1b938:	e28dd008 	add	sp, sp, #8
   1b93c:	e8bd4030 	pop	{r4, r5, lr}
   1b940:	e28dd00c 	add	sp, sp, #12
   1b944:	e12fff1e 	bx	lr
    errno = -r;
   1b948:	ebffffb1 	bl	1b814 <__errno>
   1b94c:	e2643000 	rsb	r3, r4, #0
    return -1;
   1b950:	e3e04000 	mvn	r4, #0
    errno = -r;
   1b954:	e5803000 	str	r3, [r0]
  return __syscall3(__SYS_FCNTL, fildes, cmd, arg);
   1b958:	eafffff5 	b	1b934 <fcntl+0x58>

0001b95c <_open>:
#include <stdarg.h>
#include <sys/syscall.h>

int
_open(const char *path, int flags, ...)
{
   1b95c:	e92d000e 	push	{r1, r2, r3}
   1b960:	e92d4030 	push	{r4, r5, lr}
   1b964:	e24dd008 	sub	sp, sp, #8
   1b968:	e59d1014 	ldr	r1, [sp, #20]
  int mode = 0;

  if (flags & O_CREAT) {
   1b96c:	e2112c02 	ands	r2, r1, #512	@ 0x200
    va_list ap;

    va_start(ap, flags);
   1b970:	128d3018 	addne	r3, sp, #24
    mode = va_arg(ap, int);
   1b974:	159d2018 	ldrne	r2, [sp, #24]
    va_start(ap, flags);
   1b978:	158d3004 	strne	r3, [sp, #4]
  register int32_t r3 asm("r3") = a4;
   1b97c:	e3a03000 	mov	r3, #0
  register int32_t r4 asm("r4") = a5;
   1b980:	e1a04003 	mov	r4, r3
  register int32_t r5 asm("r5") = a6;
   1b984:	e1a05003 	mov	r5, r3
  asm volatile("svc %1\n"
   1b988:	ef00000b 	svc	0x0000000b
  if (r < 0) {
   1b98c:	e2504000 	subs	r4, r0, #0
   1b990:	ba000004 	blt	1b9a8 <_open+0x4c>

    // TODO: umask
  }

  return __syscall3(__SYS_OPEN, path, flags, mode);
}
   1b994:	e1a00004 	mov	r0, r4
   1b998:	e28dd008 	add	sp, sp, #8
   1b99c:	e8bd4030 	pop	{r4, r5, lr}
   1b9a0:	e28dd00c 	add	sp, sp, #12
   1b9a4:	e12fff1e 	bx	lr
    errno = -r;
   1b9a8:	ebffff99 	bl	1b814 <__errno>
   1b9ac:	e2643000 	rsb	r3, r4, #0
    return -1;
   1b9b0:	e3e04000 	mvn	r4, #0
    errno = -r;
   1b9b4:	e5803000 	str	r3, [r0]
  return __syscall3(__SYS_OPEN, path, flags, mode);
   1b9b8:	eafffff5 	b	1b994 <_open+0x38>

0001b9bc <open>:

int
open(const char *path, int flags, ...)
{
   1b9bc:	e92d000e 	push	{r1, r2, r3}
   1b9c0:	e92d4030 	push	{r4, r5, lr}
   1b9c4:	e24dd008 	sub	sp, sp, #8
   1b9c8:	e59d1014 	ldr	r1, [sp, #20]
  int mode = 0;

  if (flags & O_CREAT) {
   1b9cc:	e2112c02 	ands	r2, r1, #512	@ 0x200
    va_list ap;

    va_start(ap, flags);
   1b9d0:	128d3018 	addne	r3, sp, #24
    mode = va_arg(ap, int);
   1b9d4:	159d2018 	ldrne	r2, [sp, #24]
    va_start(ap, flags);
   1b9d8:	158d3004 	strne	r3, [sp, #4]
  register int32_t r3 asm("r3") = a4;
   1b9dc:	e3a03000 	mov	r3, #0
  register int32_t r4 asm("r4") = a5;
   1b9e0:	e1a04003 	mov	r4, r3
  register int32_t r5 asm("r5") = a6;
   1b9e4:	e1a05003 	mov	r5, r3
  asm volatile("svc %1\n"
   1b9e8:	ef00000b 	svc	0x0000000b
  if (r < 0) {
   1b9ec:	e2504000 	subs	r4, r0, #0
   1b9f0:	ba000004 	blt	1ba08 <open+0x4c>

    // TODO: umask
  }

  return __syscall3(__SYS_OPEN, path, flags, mode);
}
   1b9f4:	e1a00004 	mov	r0, r4
   1b9f8:	e28dd008 	add	sp, sp, #8
   1b9fc:	e8bd4030 	pop	{r4, r5, lr}
   1ba00:	e28dd00c 	add	sp, sp, #12
   1ba04:	e12fff1e 	bx	lr
    errno = -r;
   1ba08:	ebffff81 	bl	1b814 <__errno>
   1ba0c:	e2643000 	rsb	r3, r4, #0
    return -1;
   1ba10:	e3e04000 	mvn	r4, #0
    errno = -r;
   1ba14:	e5803000 	str	r3, [r0]
  return __syscall3(__SYS_OPEN, path, flags, mode);
   1ba18:	eafffff5 	b	1b9f4 <open+0x38>

0001ba1c <_kill>:
  register int32_t r2 asm("r2") = a3;
   1ba1c:	e3a02000 	mov	r2, #0
#include <signal.h>
#include <sys/syscall.h>

int
_kill(pid_t pid, int sig)
{
   1ba20:	e92d4070 	push	{r4, r5, r6, lr}
  register int32_t r3 asm("r3") = a4;
   1ba24:	e1a03002 	mov	r3, r2
  register int32_t r4 asm("r4") = a5;
   1ba28:	e1a04002 	mov	r4, r2
  register int32_t r5 asm("r5") = a6;
   1ba2c:	e1a05002 	mov	r5, r2
  asm volatile("svc %1\n"
   1ba30:	ef000022 	svc	0x00000022
  if (r < 0) {
   1ba34:	e2504000 	subs	r4, r0, #0
   1ba38:	ba000001 	blt	1ba44 <_kill+0x28>
  return __syscall2(__SYS_KILL, pid, sig);
}
   1ba3c:	e1a00004 	mov	r0, r4
   1ba40:	e8bd8070 	pop	{r4, r5, r6, pc}
    errno = -r;
   1ba44:	ebffff72 	bl	1b814 <__errno>
   1ba48:	e2643000 	rsb	r3, r4, #0
    return -1;
   1ba4c:	e3e04000 	mvn	r4, #0
    errno = -r;
   1ba50:	e5803000 	str	r3, [r0]
  return __syscall2(__SYS_KILL, pid, sig);
   1ba54:	eafffff8 	b	1ba3c <_kill+0x20>

0001ba58 <kill>:
  register int32_t r2 asm("r2") = a3;
   1ba58:	e3a02000 	mov	r2, #0

int
kill(pid_t pid, int sig)
{
   1ba5c:	e92d4070 	push	{r4, r5, r6, lr}
  register int32_t r3 asm("r3") = a4;
   1ba60:	e1a03002 	mov	r3, r2
  register int32_t r4 asm("r4") = a5;
   1ba64:	e1a04002 	mov	r4, r2
  register int32_t r5 asm("r5") = a6;
   1ba68:	e1a05002 	mov	r5, r2
  asm volatile("svc %1\n"
   1ba6c:	ef000022 	svc	0x00000022
  if (r < 0) {
   1ba70:	e2504000 	subs	r4, r0, #0
   1ba74:	ba000001 	blt	1ba80 <kill+0x28>
  return _kill(pid, sig);
}
   1ba78:	e1a00004 	mov	r0, r4
   1ba7c:	e8bd8070 	pop	{r4, r5, r6, pc}
    errno = -r;
   1ba80:	ebffff63 	bl	1b814 <__errno>
   1ba84:	e2643000 	rsb	r3, r4, #0
    return -1;
   1ba88:	e3e04000 	mvn	r4, #0
    errno = -r;
   1ba8c:	e5803000 	str	r3, [r0]
  return _kill(pid, sig);
   1ba90:	eafffff8 	b	1ba78 <kill+0x20>

0001ba94 <init_mparams.part.0>:
    size_t magic;
    size_t psize;
    size_t gsize;

#ifndef WIN32
    psize = malloc_getpagesize;
   1ba94:	e3a00008 	mov	r0, #8
static int init_mparams(void) {
   1ba98:	e92d4010 	push	{r4, lr}
    psize = malloc_getpagesize;
   1ba9c:	eb000f89 	bl	1f8c8 <sysconf>
   1baa0:	e1a03000 	mov	r3, r0
        (sizeof(int) < 4)  ||
        (MALLOC_ALIGNMENT < (size_t)8U) ||
        ((MALLOC_ALIGNMENT & (MALLOC_ALIGNMENT-SIZE_T_ONE)) != 0) ||
        ((MCHUNK_SIZE      & (MCHUNK_SIZE-SIZE_T_ONE))      != 0) ||
        ((gsize            & (gsize-SIZE_T_ONE))            != 0) ||
        ((psize            & (psize-SIZE_T_ONE))            != 0))
   1baa4:	e2400001 	sub	r0, r0, #1
        ((gsize            & (gsize-SIZE_T_ONE))            != 0) ||
   1baa8:	e0100003 	ands	r0, r0, r3
   1baac:	1a000013 	bne	1bb00 <init_mparams.part.0+0x6c>
      ABORT;
    mparams.granularity = gsize;
   1bab0:	e30b466c 	movw	r4, #46700	@ 0xb66c
   1bab4:	e3a01801 	mov	r1, #65536	@ 0x10000
   1bab8:	e3404002 	movt	r4, #2
    mparams.mmap_threshold = DEFAULT_MMAP_THRESHOLD;
    mparams.trim_threshold = DEFAULT_TRIM_THRESHOLD;
#if MORECORE_CONTIGUOUS
    mparams.default_mflags = USE_LOCK_BIT|USE_MMAP_BIT;
#else  /* MORECORE_CONTIGUOUS */
    mparams.default_mflags = USE_LOCK_BIT|USE_MMAP_BIT|USE_NONCONTIGUOUS_BIT;
   1babc:	e3a02005 	mov	r2, #5
    mparams.granularity = gsize;
   1bac0:	e5841008 	str	r1, [r4, #8]
    mparams.mmap_threshold = DEFAULT_MMAP_THRESHOLD;
   1bac4:	e3a01701 	mov	r1, #262144	@ 0x40000
    mparams.page_size = psize;
   1bac8:	e5843004 	str	r3, [r4, #4]
    mparams.trim_threshold = DEFAULT_TRIM_THRESHOLD;
   1bacc:	e3a03602 	mov	r3, #2097152	@ 0x200000
   1bad0:	e5843010 	str	r3, [r4, #16]
    mparams.mmap_threshold = DEFAULT_MMAP_THRESHOLD;
   1bad4:	e584100c 	str	r1, [r4, #12]
    mparams.default_mflags = USE_LOCK_BIT|USE_MMAP_BIT|USE_NONCONTIGUOUS_BIT;
   1bad8:	e5842014 	str	r2, [r4, #20]
#endif /* MORECORE_CONTIGUOUS */

#if !ONLY_MSPACES
    /* Set up lock for main malloc area */
    gm->mflags = mparams.default_mflags;
   1badc:	e58421d4 	str	r2, [r4, #468]	@ 0x1d4
#ifdef WIN32
      magic = (size_t)(GetTickCount() ^ (size_t)0x55555555U);
#elif defined(LACKS_TIME_H)
      magic = (size_t)&magic ^ (size_t)0x55555555U;
#else
      magic = (size_t)(time(0) ^ (size_t)0x55555555U);
   1bae0:	eb002854 	bl	25c38 <time>
   1bae4:	e3053555 	movw	r3, #21845	@ 0x5555
   1bae8:	e3453555 	movt	r3, #21845	@ 0x5555
   1baec:	e0233000 	eor	r3, r3, r0
#endif
      magic |= (size_t)8U;    /* ensure nonzero */
      magic &= ~(size_t)7U;   /* improve chances of fault for bad values */
   1baf0:	e3c33007 	bic	r3, r3, #7
   1baf4:	e3833008 	orr	r3, r3, #8
      /* Until memory modes commonly available, use volatile-write */
      (*(volatile size_t *)(&(mparams.magic))) = magic;
   1baf8:	e5843000 	str	r3, [r4]
    }
  }

  RELEASE_MALLOC_GLOBAL_LOCK();
  return 1;
}
   1bafc:	e8bd8010 	pop	{r4, pc}
      ABORT;
   1bb00:	ebffeb01 	bl	1670c <abort>

0001bb04 <dispose_chunk.constprop.0>:
/* Consolidate and bin a chunk. Differs from exported versions
   of free mainly in that the chunk need not be marked as inuse.
*/
static void dispose_chunk(mstate m, mchunkptr p, size_t psize) {
  mchunkptr next = chunk_plus_offset(p, psize);
  if (!pinuse(p)) {
   1bb04:	e5903004 	ldr	r3, [r0, #4]
static void dispose_chunk(mstate m, mchunkptr p, size_t psize) {
   1bb08:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  mchunkptr next = chunk_plus_offset(p, psize);
   1bb0c:	e080e001 	add	lr, r0, r1
  if (!pinuse(p)) {
   1bb10:	e3130001 	tst	r3, #1
   1bb14:	1a00003f 	bne	1bc18 <dispose_chunk.constprop.0+0x114>
    mchunkptr prev;
    size_t prevsize = p->prev_foot;
   1bb18:	e5902000 	ldr	r2, [r0]
    if (is_mmapped(p)) {
   1bb1c:	e3130003 	tst	r3, #3
      psize += prevsize + MMAP_FOOT_PAD;
      if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
   1bb20:	e0400002 	sub	r0, r0, r2
    if (is_mmapped(p)) {
   1bb24:	0a0000eb 	beq	1bed8 <dispose_chunk.constprop.0+0x3d4>
      return;
    }
    prev = chunk_minus_offset(p, prevsize);
    psize += prevsize;
    p = prev;
    if (RTCHECK(ok_address(m, prev))) { /* consolidate backward */
   1bb28:	e30b366c 	movw	r3, #46700	@ 0xb66c
    psize += prevsize;
   1bb2c:	e0811002 	add	r1, r1, r2
    if (RTCHECK(ok_address(m, prev))) { /* consolidate backward */
   1bb30:	e3403002 	movt	r3, #2
   1bb34:	e593c028 	ldr	ip, [r3, #40]	@ 0x28
   1bb38:	e15c0000 	cmp	ip, r0
   1bb3c:	8a0000cb 	bhi	1be70 <dispose_chunk.constprop.0+0x36c>
      if (p != m->dv) {
   1bb40:	e593402c 	ldr	r4, [r3, #44]	@ 0x2c
   1bb44:	e1540000 	cmp	r4, r0
   1bb48:	0a00010b 	beq	1bf7c <dispose_chunk.constprop.0+0x478>
        unlink_chunk(m, p, prevsize);
   1bb4c:	e35200ff 	cmp	r2, #255	@ 0xff
   1bb50:	e590400c 	ldr	r4, [r0, #12]
   1bb54:	e1a021a2 	lsr	r2, r2, #3
   1bb58:	9a0000bb 	bls	1be4c <dispose_chunk.constprop.0+0x348>
   1bb5c:	e1540000 	cmp	r4, r0
   1bb60:	e5907018 	ldr	r7, [r0, #24]
   1bb64:	0a000130 	beq	1c02c <dispose_chunk.constprop.0+0x528>
   1bb68:	e5902008 	ldr	r2, [r0, #8]
   1bb6c:	e15c0002 	cmp	ip, r2
   1bb70:	8a0000be 	bhi	1be70 <dispose_chunk.constprop.0+0x36c>
   1bb74:	e592500c 	ldr	r5, [r2, #12]
   1bb78:	e1500005 	cmp	r0, r5
   1bb7c:	1a0000bb 	bne	1be70 <dispose_chunk.constprop.0+0x36c>
   1bb80:	e5945008 	ldr	r5, [r4, #8]
   1bb84:	e1500005 	cmp	r0, r5
   1bb88:	1a0000b8 	bne	1be70 <dispose_chunk.constprop.0+0x36c>
   1bb8c:	e3570000 	cmp	r7, #0
   1bb90:	e582400c 	str	r4, [r2, #12]
   1bb94:	e5842008 	str	r2, [r4, #8]
   1bb98:	0a000021 	beq	1bc24 <dispose_chunk.constprop.0+0x120>
   1bb9c:	e590201c 	ldr	r2, [r0, #28]
   1bba0:	e282204c 	add	r2, r2, #76	@ 0x4c
   1bba4:	e0832102 	add	r2, r3, r2, lsl #2
   1bba8:	e5925018 	ldr	r5, [r2, #24]
   1bbac:	e1500005 	cmp	r0, r5
   1bbb0:	05824018 	streq	r4, [r2, #24]
   1bbb4:	0a000005 	beq	1bbd0 <dispose_chunk.constprop.0+0xcc>
   1bbb8:	e15c0007 	cmp	ip, r7
   1bbbc:	8a0000ab 	bhi	1be70 <dispose_chunk.constprop.0+0x36c>
   1bbc0:	e5972010 	ldr	r2, [r7, #16]
   1bbc4:	e1500002 	cmp	r0, r2
   1bbc8:	05874010 	streq	r4, [r7, #16]
   1bbcc:	15874014 	strne	r4, [r7, #20]
   1bbd0:	e15c0004 	cmp	ip, r4
   1bbd4:	8a0000a5 	bhi	1be70 <dispose_chunk.constprop.0+0x36c>
   1bbd8:	e5902010 	ldr	r2, [r0, #16]
   1bbdc:	e5847018 	str	r7, [r4, #24]
   1bbe0:	e3520000 	cmp	r2, #0
   1bbe4:	0a000003 	beq	1bbf8 <dispose_chunk.constprop.0+0xf4>
   1bbe8:	e15c0002 	cmp	ip, r2
   1bbec:	8a00009f 	bhi	1be70 <dispose_chunk.constprop.0+0x36c>
   1bbf0:	e5842010 	str	r2, [r4, #16]
   1bbf4:	e5824018 	str	r4, [r2, #24]
   1bbf8:	e5902014 	ldr	r2, [r0, #20]
   1bbfc:	e3520000 	cmp	r2, #0
   1bc00:	0a000007 	beq	1bc24 <dispose_chunk.constprop.0+0x120>
   1bc04:	e15c0002 	cmp	ip, r2
   1bc08:	8a000098 	bhi	1be70 <dispose_chunk.constprop.0+0x36c>
   1bc0c:	e5842014 	str	r2, [r4, #20]
   1bc10:	e5824018 	str	r4, [r2, #24]
   1bc14:	ea000002 	b	1bc24 <dispose_chunk.constprop.0+0x120>
    if (RTCHECK(ok_address(m, prev))) { /* consolidate backward */
   1bc18:	e30b366c 	movw	r3, #46700	@ 0xb66c
   1bc1c:	e3403002 	movt	r3, #2
   1bc20:	e593c028 	ldr	ip, [r3, #40]	@ 0x28
    else {
      CORRUPTION_ERROR_ACTION(m);
      return;
    }
  }
  if (RTCHECK(ok_address(m, next))) {
   1bc24:	e15e000c 	cmp	lr, ip
   1bc28:	3a000090 	bcc	1be70 <dispose_chunk.constprop.0+0x36c>
    if (!cinuse(next)) {  /* consolidate forward */
   1bc2c:	e59e2004 	ldr	r2, [lr, #4]
   1bc30:	e2124002 	ands	r4, r2, #2
   1bc34:	1a000040 	bne	1bd3c <dispose_chunk.constprop.0+0x238>
      if (next == m->top) {
   1bc38:	e5935030 	ldr	r5, [r3, #48]	@ 0x30
      if (p != m->dv) {
   1bc3c:	e593702c 	ldr	r7, [r3, #44]	@ 0x2c
      if (next == m->top) {
   1bc40:	e15e0005 	cmp	lr, r5
   1bc44:	0a0000d7 	beq	1bfa8 <dispose_chunk.constprop.0+0x4a4>
          m->dv = 0;
          m->dvsize = 0;
        }
        return;
      }
      else if (next == m->dv) {
   1bc48:	e15e0007 	cmp	lr, r7
   1bc4c:	0a0000e8 	beq	1bff4 <dispose_chunk.constprop.0+0x4f0>
        m->dv = p;
        set_size_and_pinuse_of_free_chunk(p, dsize);
        return;
      }
      else {
        size_t nsize = chunksize(next);
   1bc50:	e3c22007 	bic	r2, r2, #7
        psize += nsize;
        unlink_chunk(m, next, nsize);
   1bc54:	e59e400c 	ldr	r4, [lr, #12]
   1bc58:	e35200f8 	cmp	r2, #248	@ 0xf8
        psize += nsize;
   1bc5c:	e0811002 	add	r1, r1, r2
        unlink_chunk(m, next, nsize);
   1bc60:	e1a021a2 	lsr	r2, r2, #3
   1bc64:	9a00008b 	bls	1be98 <dispose_chunk.constprop.0+0x394>
   1bc68:	e15e0004 	cmp	lr, r4
   1bc6c:	e59e8018 	ldr	r8, [lr, #24]
   1bc70:	0a000106 	beq	1c090 <dispose_chunk.constprop.0+0x58c>
   1bc74:	e59e2008 	ldr	r2, [lr, #8]
   1bc78:	e15c0002 	cmp	ip, r2
   1bc7c:	8a00007b 	bhi	1be70 <dispose_chunk.constprop.0+0x36c>
   1bc80:	e592500c 	ldr	r5, [r2, #12]
   1bc84:	e15e0005 	cmp	lr, r5
   1bc88:	1a000078 	bne	1be70 <dispose_chunk.constprop.0+0x36c>
   1bc8c:	e5945008 	ldr	r5, [r4, #8]
   1bc90:	e15e0005 	cmp	lr, r5
   1bc94:	1a000075 	bne	1be70 <dispose_chunk.constprop.0+0x36c>
   1bc98:	e3580000 	cmp	r8, #0
   1bc9c:	e582400c 	str	r4, [r2, #12]
   1bca0:	e5842008 	str	r2, [r4, #8]
   1bca4:	0a00001d 	beq	1bd20 <dispose_chunk.constprop.0+0x21c>
   1bca8:	e59e201c 	ldr	r2, [lr, #28]
   1bcac:	e282204c 	add	r2, r2, #76	@ 0x4c
   1bcb0:	e0832102 	add	r2, r3, r2, lsl #2
   1bcb4:	e5925018 	ldr	r5, [r2, #24]
   1bcb8:	e15e0005 	cmp	lr, r5
   1bcbc:	05824018 	streq	r4, [r2, #24]
   1bcc0:	0a000005 	beq	1bcdc <dispose_chunk.constprop.0+0x1d8>
   1bcc4:	e15c0008 	cmp	ip, r8
   1bcc8:	8a000068 	bhi	1be70 <dispose_chunk.constprop.0+0x36c>
   1bccc:	e5982010 	ldr	r2, [r8, #16]
   1bcd0:	e15e0002 	cmp	lr, r2
   1bcd4:	05884010 	streq	r4, [r8, #16]
   1bcd8:	15884014 	strne	r4, [r8, #20]
   1bcdc:	e15c0004 	cmp	ip, r4
   1bce0:	8a000062 	bhi	1be70 <dispose_chunk.constprop.0+0x36c>
   1bce4:	e59e2010 	ldr	r2, [lr, #16]
   1bce8:	e5848018 	str	r8, [r4, #24]
   1bcec:	e3520000 	cmp	r2, #0
   1bcf0:	0a000003 	beq	1bd04 <dispose_chunk.constprop.0+0x200>
   1bcf4:	e15c0002 	cmp	ip, r2
   1bcf8:	8a00005c 	bhi	1be70 <dispose_chunk.constprop.0+0x36c>
   1bcfc:	e5842010 	str	r2, [r4, #16]
   1bd00:	e5824018 	str	r4, [r2, #24]
   1bd04:	e59e2014 	ldr	r2, [lr, #20]
   1bd08:	e3520000 	cmp	r2, #0
   1bd0c:	0a000003 	beq	1bd20 <dispose_chunk.constprop.0+0x21c>
   1bd10:	e15c0002 	cmp	ip, r2
   1bd14:	8a000055 	bhi	1be70 <dispose_chunk.constprop.0+0x36c>
   1bd18:	e5842014 	str	r2, [r4, #20]
   1bd1c:	e5824018 	str	r4, [r2, #24]
        set_size_and_pinuse_of_free_chunk(p, psize);
        if (p == m->dv) {
   1bd20:	e1570000 	cmp	r7, r0
        set_size_and_pinuse_of_free_chunk(p, psize);
   1bd24:	e3812001 	orr	r2, r1, #1
   1bd28:	e5802004 	str	r2, [r0, #4]
   1bd2c:	e7801001 	str	r1, [r0, r1]
        if (p == m->dv) {
   1bd30:	1a000006 	bne	1bd50 <dispose_chunk.constprop.0+0x24c>
          m->dvsize = psize;
   1bd34:	e5831020 	str	r1, [r3, #32]
          return;
   1bd38:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        }
      }
    }
    else {
      set_free_with_pinuse(p, psize, next);
   1bd3c:	e3c22001 	bic	r2, r2, #1
   1bd40:	e58e2004 	str	r2, [lr, #4]
   1bd44:	e3812001 	orr	r2, r1, #1
   1bd48:	e5802004 	str	r2, [r0, #4]
   1bd4c:	e7801001 	str	r1, [r0, r1]
    }
    insert_chunk(m, p, psize);
   1bd50:	e35100ff 	cmp	r1, #255	@ 0xff
   1bd54:	e1a0e1a1 	lsr	lr, r1, #3
   1bd58:	8a00000f 	bhi	1bd9c <dispose_chunk.constprop.0+0x298>
   1bd5c:	e59f24c8 	ldr	r2, [pc, #1224]	@ 1c22c <dispose_chunk.constprop.0+0x728>
   1bd60:	e3a01001 	mov	r1, #1
   1bd64:	e5934018 	ldr	r4, [r3, #24]
   1bd68:	e1a01e11 	lsl	r1, r1, lr
   1bd6c:	e082218e 	add	r2, r2, lr, lsl #3
   1bd70:	e1140001 	tst	r4, r1
   1bd74:	e2822028 	add	r2, r2, #40	@ 0x28
   1bd78:	0a000042 	beq	1be88 <dispose_chunk.constprop.0+0x384>
   1bd7c:	e5921008 	ldr	r1, [r2, #8]
   1bd80:	e15c0001 	cmp	ip, r1
   1bd84:	8a000039 	bhi	1be70 <dispose_chunk.constprop.0+0x36c>
   1bd88:	e5820008 	str	r0, [r2, #8]
   1bd8c:	e581000c 	str	r0, [r1, #12]
   1bd90:	e5801008 	str	r1, [r0, #8]
   1bd94:	e580200c 	str	r2, [r0, #12]
   1bd98:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
   1bd9c:	e3510401 	cmp	r1, #16777216	@ 0x1000000
   1bda0:	e1a02421 	lsr	r2, r1, #8
   1bda4:	2a000032 	bcs	1be74 <dispose_chunk.constprop.0+0x370>
   1bda8:	e242ec01 	sub	lr, r2, #256	@ 0x100
   1bdac:	e3a04001 	mov	r4, #1
   1bdb0:	e1a0e82e 	lsr	lr, lr, #16
   1bdb4:	e20ee008 	and	lr, lr, #8
   1bdb8:	e1a02e12 	lsl	r2, r2, lr
   1bdbc:	e2425a01 	sub	r5, r2, #4096	@ 0x1000
   1bdc0:	e1a05825 	lsr	r5, r5, #16
   1bdc4:	e2055004 	and	r5, r5, #4
   1bdc8:	e1a02512 	lsl	r2, r2, r5
   1bdcc:	e18ee005 	orr	lr, lr, r5
   1bdd0:	e2425901 	sub	r5, r2, #16384	@ 0x4000
   1bdd4:	e1a05825 	lsr	r5, r5, #16
   1bdd8:	e2055002 	and	r5, r5, #2
   1bddc:	e1a02512 	lsl	r2, r2, r5
   1bde0:	e08ee005 	add	lr, lr, r5
   1bde4:	e06ee7a2 	rsb	lr, lr, r2, lsr #15
   1bde8:	e28e2015 	add	r2, lr, #21
   1bdec:	e28ee00e 	add	lr, lr, #14
   1bdf0:	e1a02231 	lsr	r2, r1, r2
   1bdf4:	e0022004 	and	r2, r2, r4
   1bdf8:	e082241e 	add	r2, r2, lr, lsl r4
   1bdfc:	e282e04c 	add	lr, r2, #76	@ 0x4c
   1be00:	e1a04214 	lsl	r4, r4, r2
   1be04:	e1a0710e 	lsl	r7, lr, #2
   1be08:	e593601c 	ldr	r6, [r3, #28]
   1be0c:	e3a05000 	mov	r5, #0
   1be10:	e580201c 	str	r2, [r0, #28]
   1be14:	e5805010 	str	r5, [r0, #16]
   1be18:	e1140006 	tst	r4, r6
   1be1c:	e5805014 	str	r5, [r0, #20]
   1be20:	1a000037 	bne	1bf04 <dispose_chunk.constprop.0+0x400>
   1be24:	e1844006 	orr	r4, r4, r6
   1be28:	e083e10e 	add	lr, r3, lr, lsl #2
   1be2c:	e583401c 	str	r4, [r3, #28]
   1be30:	e59f33f4 	ldr	r3, [pc, #1012]	@ 1c22c <dispose_chunk.constprop.0+0x728>
   1be34:	e58e0018 	str	r0, [lr, #24]
   1be38:	e5800008 	str	r0, [r0, #8]
   1be3c:	e0833007 	add	r3, r3, r7
   1be40:	e580000c 	str	r0, [r0, #12]
   1be44:	e5803018 	str	r3, [r0, #24]
   1be48:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        unlink_chunk(m, p, prevsize);
   1be4c:	e5905008 	ldr	r5, [r0, #8]
   1be50:	e0836182 	add	r6, r3, r2, lsl #3
   1be54:	e2866040 	add	r6, r6, #64	@ 0x40
   1be58:	e1550006 	cmp	r5, r6
   1be5c:	1a0000a4 	bne	1c0f4 <dispose_chunk.constprop.0+0x5f0>
   1be60:	e1550004 	cmp	r5, r4
   1be64:	0a000084 	beq	1c07c <dispose_chunk.constprop.0+0x578>
   1be68:	e15c0004 	cmp	ip, r4
   1be6c:	9a000068 	bls	1c014 <dispose_chunk.constprop.0+0x510>
   1be70:	ebffea25 	bl	1670c <abort>
   1be74:	e3a04102 	mov	r4, #-2147483648	@ 0x80000000
   1be78:	e3a07f6b 	mov	r7, #428	@ 0x1ac
    insert_chunk(m, p, psize);
   1be7c:	e3a0201f 	mov	r2, #31
   1be80:	e3a0e06b 	mov	lr, #107	@ 0x6b
   1be84:	eaffffdf 	b	1be08 <dispose_chunk.constprop.0+0x304>
   1be88:	e1844001 	orr	r4, r4, r1
   1be8c:	e1a01002 	mov	r1, r2
   1be90:	e5834018 	str	r4, [r3, #24]
   1be94:	eaffffbb 	b	1bd88 <dispose_chunk.constprop.0+0x284>
        unlink_chunk(m, next, nsize);
   1be98:	e59f538c 	ldr	r5, [pc, #908]	@ 1c22c <dispose_chunk.constprop.0+0x728>
   1be9c:	e59e6008 	ldr	r6, [lr, #8]
   1bea0:	e0855182 	add	r5, r5, r2, lsl #3
   1bea4:	e2855028 	add	r5, r5, #40	@ 0x28
   1bea8:	e1560005 	cmp	r6, r5
   1beac:	1a00009a 	bne	1c11c <dispose_chunk.constprop.0+0x618>
   1beb0:	e1540006 	cmp	r4, r6
   1beb4:	0a000089 	beq	1c0e0 <dispose_chunk.constprop.0+0x5dc>
   1beb8:	e154000c 	cmp	r4, ip
   1bebc:	3affffeb 	bcc	1be70 <dispose_chunk.constprop.0+0x36c>
   1bec0:	e5942008 	ldr	r2, [r4, #8]
   1bec4:	e15e0002 	cmp	lr, r2
   1bec8:	1affffe8 	bne	1be70 <dispose_chunk.constprop.0+0x36c>
   1becc:	e586400c 	str	r4, [r6, #12]
   1bed0:	e5846008 	str	r6, [r4, #8]
   1bed4:	eaffff91 	b	1bd20 <dispose_chunk.constprop.0+0x21c>
      psize += prevsize + MMAP_FOOT_PAD;
   1bed8:	e2811010 	add	r1, r1, #16
   1bedc:	e0824001 	add	r4, r2, r1
      if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
   1bee0:	e1a01004 	mov	r1, r4
   1bee4:	eb000da9 	bl	1f590 <munmap>
   1bee8:	e3500000 	cmp	r0, #0
        m->footprint -= psize;
   1beec:	030b366c 	movweq	r3, #46700	@ 0xb66c
   1bef0:	03403002 	movteq	r3, #2
   1bef4:	059321c8 	ldreq	r2, [r3, #456]	@ 0x1c8
   1bef8:	00422004 	subeq	r2, r2, r4
   1befc:	058321c8 	streq	r2, [r3, #456]	@ 0x1c8
   1bf00:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    insert_chunk(m, p, psize);
   1bf04:	e083310e 	add	r3, r3, lr, lsl #2
   1bf08:	e352001f 	cmp	r2, #31
   1bf0c:	e593e018 	ldr	lr, [r3, #24]
   1bf10:	11a030a2 	lsrne	r3, r2, #1
   1bf14:	01a03001 	moveq	r3, r1
   1bf18:	12633019 	rsbne	r3, r3, #25
   1bf1c:	11a03311 	lslne	r3, r1, r3
   1bf20:	ea000006 	b	1bf40 <dispose_chunk.constprop.0+0x43c>
   1bf24:	e1a04fa3 	lsr	r4, r3, #31
   1bf28:	e1a03083 	lsl	r3, r3, #1
   1bf2c:	e08e5104 	add	r5, lr, r4, lsl #2
   1bf30:	e5952010 	ldr	r2, [r5, #16]
   1bf34:	e3520000 	cmp	r2, #0
   1bf38:	0a000024 	beq	1bfd0 <dispose_chunk.constprop.0+0x4cc>
   1bf3c:	e1a0e002 	mov	lr, r2
   1bf40:	e59e2004 	ldr	r2, [lr, #4]
   1bf44:	e3c22007 	bic	r2, r2, #7
   1bf48:	e1510002 	cmp	r1, r2
   1bf4c:	1afffff4 	bne	1bf24 <dispose_chunk.constprop.0+0x420>
   1bf50:	e59e3008 	ldr	r3, [lr, #8]
   1bf54:	e15c0003 	cmp	ip, r3
   1bf58:	915c000e 	cmpls	ip, lr
   1bf5c:	8affffc3 	bhi	1be70 <dispose_chunk.constprop.0+0x36c>
   1bf60:	e3a02000 	mov	r2, #0
   1bf64:	e583000c 	str	r0, [r3, #12]
   1bf68:	e58e0008 	str	r0, [lr, #8]
   1bf6c:	e5803008 	str	r3, [r0, #8]
   1bf70:	e580e00c 	str	lr, [r0, #12]
   1bf74:	e5802018 	str	r2, [r0, #24]
  }
  else {
    CORRUPTION_ERROR_ACTION(m);
  }
}
   1bf78:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
      else if ((next->head & INUSE_BITS) == INUSE_BITS) {
   1bf7c:	e59e2004 	ldr	r2, [lr, #4]
   1bf80:	e2025003 	and	r5, r2, #3
   1bf84:	e3550003 	cmp	r5, #3
   1bf88:	1affff25 	bne	1bc24 <dispose_chunk.constprop.0+0x120>
        m->dvsize = psize;
   1bf8c:	e5831020 	str	r1, [r3, #32]
        set_free_with_pinuse(p, psize, next);
   1bf90:	e3c22001 	bic	r2, r2, #1
   1bf94:	e3813001 	orr	r3, r1, #1
   1bf98:	e58e2004 	str	r2, [lr, #4]
   1bf9c:	e5843004 	str	r3, [r4, #4]
   1bfa0:	e58e1000 	str	r1, [lr]
        return;
   1bfa4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        size_t tsize = m->topsize += psize;
   1bfa8:	e5932024 	ldr	r2, [r3, #36]	@ 0x24
        if (p == m->dv) {
   1bfac:	e1570000 	cmp	r7, r0
        m->top = p;
   1bfb0:	e5830030 	str	r0, [r3, #48]	@ 0x30
        size_t tsize = m->topsize += psize;
   1bfb4:	e0812002 	add	r2, r1, r2
        p->head = tsize | PINUSE_BIT;
   1bfb8:	e3821001 	orr	r1, r2, #1
        size_t tsize = m->topsize += psize;
   1bfbc:	e5832024 	str	r2, [r3, #36]	@ 0x24
        p->head = tsize | PINUSE_BIT;
   1bfc0:	e5801004 	str	r1, [r0, #4]
          m->dv = 0;
   1bfc4:	0583402c 	streq	r4, [r3, #44]	@ 0x2c
          m->dvsize = 0;
   1bfc8:	05834020 	streq	r4, [r3, #32]
   1bfcc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    insert_chunk(m, p, psize);
   1bfd0:	e2844004 	add	r4, r4, #4
   1bfd4:	e08e4104 	add	r4, lr, r4, lsl #2
   1bfd8:	e15c0004 	cmp	ip, r4
   1bfdc:	8affffa3 	bhi	1be70 <dispose_chunk.constprop.0+0x36c>
   1bfe0:	e5850010 	str	r0, [r5, #16]
   1bfe4:	e580e018 	str	lr, [r0, #24]
   1bfe8:	e5800008 	str	r0, [r0, #8]
   1bfec:	e580000c 	str	r0, [r0, #12]
   1bff0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        size_t dsize = m->dvsize += psize;
   1bff4:	e5932020 	ldr	r2, [r3, #32]
        m->dv = p;
   1bff8:	e583002c 	str	r0, [r3, #44]	@ 0x2c
        size_t dsize = m->dvsize += psize;
   1bffc:	e0812002 	add	r2, r1, r2
        set_size_and_pinuse_of_free_chunk(p, dsize);
   1c000:	e3821001 	orr	r1, r2, #1
        size_t dsize = m->dvsize += psize;
   1c004:	e5832020 	str	r2, [r3, #32]
        set_size_and_pinuse_of_free_chunk(p, dsize);
   1c008:	e5801004 	str	r1, [r0, #4]
   1c00c:	e7802002 	str	r2, [r0, r2]
        return;
   1c010:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        unlink_chunk(m, p, prevsize);
   1c014:	e5942008 	ldr	r2, [r4, #8]
   1c018:	e1520000 	cmp	r2, r0
   1c01c:	1affff93 	bne	1be70 <dispose_chunk.constprop.0+0x36c>
   1c020:	e585400c 	str	r4, [r5, #12]
   1c024:	e5845008 	str	r5, [r4, #8]
   1c028:	eafffefd 	b	1bc24 <dispose_chunk.constprop.0+0x120>
   1c02c:	e5902014 	ldr	r2, [r0, #20]
   1c030:	e3520000 	cmp	r2, #0
   1c034:	12805014 	addne	r5, r0, #20
   1c038:	0a000041 	beq	1c144 <dispose_chunk.constprop.0+0x640>
   1c03c:	e1a06005 	mov	r6, r5
   1c040:	e1a04002 	mov	r4, r2
   1c044:	e2825014 	add	r5, r2, #20
   1c048:	e5922014 	ldr	r2, [r2, #20]
   1c04c:	e3520000 	cmp	r2, #0
   1c050:	1afffff9 	bne	1c03c <dispose_chunk.constprop.0+0x538>
   1c054:	e5942010 	ldr	r2, [r4, #16]
   1c058:	e2845010 	add	r5, r4, #16
   1c05c:	e3520000 	cmp	r2, #0
   1c060:	1afffff5 	bne	1c03c <dispose_chunk.constprop.0+0x538>
   1c064:	e15c0006 	cmp	ip, r6
   1c068:	8affff80 	bhi	1be70 <dispose_chunk.constprop.0+0x36c>
   1c06c:	e3570000 	cmp	r7, #0
   1c070:	e5862000 	str	r2, [r6]
   1c074:	1afffec8 	bne	1bb9c <dispose_chunk.constprop.0+0x98>
   1c078:	eafffee9 	b	1bc24 <dispose_chunk.constprop.0+0x120>
   1c07c:	e5934018 	ldr	r4, [r3, #24]
   1c080:	e3a05001 	mov	r5, #1
   1c084:	e1c42215 	bic	r2, r4, r5, lsl r2
   1c088:	e5832018 	str	r2, [r3, #24]
   1c08c:	eafffee4 	b	1bc24 <dispose_chunk.constprop.0+0x120>
        unlink_chunk(m, next, nsize);
   1c090:	e59e2014 	ldr	r2, [lr, #20]
   1c094:	e3520000 	cmp	r2, #0
   1c098:	128e5014 	addne	r5, lr, #20
   1c09c:	0a00002d 	beq	1c158 <dispose_chunk.constprop.0+0x654>
   1c0a0:	e1a06005 	mov	r6, r5
   1c0a4:	e1a04002 	mov	r4, r2
   1c0a8:	e2825014 	add	r5, r2, #20
   1c0ac:	e5922014 	ldr	r2, [r2, #20]
   1c0b0:	e3520000 	cmp	r2, #0
   1c0b4:	1afffff9 	bne	1c0a0 <dispose_chunk.constprop.0+0x59c>
   1c0b8:	e5942010 	ldr	r2, [r4, #16]
   1c0bc:	e2845010 	add	r5, r4, #16
   1c0c0:	e3520000 	cmp	r2, #0
   1c0c4:	1afffff5 	bne	1c0a0 <dispose_chunk.constprop.0+0x59c>
   1c0c8:	e15c0006 	cmp	ip, r6
   1c0cc:	8affff67 	bhi	1be70 <dispose_chunk.constprop.0+0x36c>
   1c0d0:	e3580000 	cmp	r8, #0
   1c0d4:	e5862000 	str	r2, [r6]
   1c0d8:	1afffef2 	bne	1bca8 <dispose_chunk.constprop.0+0x1a4>
   1c0dc:	eaffff0f 	b	1bd20 <dispose_chunk.constprop.0+0x21c>
   1c0e0:	e593e018 	ldr	lr, [r3, #24]
   1c0e4:	e3a04001 	mov	r4, #1
   1c0e8:	e1ce2214 	bic	r2, lr, r4, lsl r2
   1c0ec:	e5832018 	str	r2, [r3, #24]
   1c0f0:	eaffff0a 	b	1bd20 <dispose_chunk.constprop.0+0x21c>
        unlink_chunk(m, p, prevsize);
   1c0f4:	e15c0005 	cmp	ip, r5
   1c0f8:	8affff5c 	bhi	1be70 <dispose_chunk.constprop.0+0x36c>
   1c0fc:	e595700c 	ldr	r7, [r5, #12]
   1c100:	e1570000 	cmp	r7, r0
   1c104:	1affff59 	bne	1be70 <dispose_chunk.constprop.0+0x36c>
   1c108:	e1550004 	cmp	r5, r4
   1c10c:	0affffda 	beq	1c07c <dispose_chunk.constprop.0+0x578>
   1c110:	e1560004 	cmp	r6, r4
   1c114:	0affffc1 	beq	1c020 <dispose_chunk.constprop.0+0x51c>
   1c118:	eaffff52 	b	1be68 <dispose_chunk.constprop.0+0x364>
        unlink_chunk(m, next, nsize);
   1c11c:	e15c0006 	cmp	ip, r6
   1c120:	8affff52 	bhi	1be70 <dispose_chunk.constprop.0+0x36c>
   1c124:	e596800c 	ldr	r8, [r6, #12]
   1c128:	e15e0008 	cmp	lr, r8
   1c12c:	1affff4f 	bne	1be70 <dispose_chunk.constprop.0+0x36c>
   1c130:	e1540006 	cmp	r4, r6
   1c134:	0affffe9 	beq	1c0e0 <dispose_chunk.constprop.0+0x5dc>
   1c138:	e1540005 	cmp	r4, r5
   1c13c:	0affff62 	beq	1becc <dispose_chunk.constprop.0+0x3c8>
   1c140:	eaffff5c 	b	1beb8 <dispose_chunk.constprop.0+0x3b4>
        unlink_chunk(m, p, prevsize);
   1c144:	e5902010 	ldr	r2, [r0, #16]
   1c148:	e3520000 	cmp	r2, #0
   1c14c:	0a000006 	beq	1c16c <dispose_chunk.constprop.0+0x668>
   1c150:	e2805010 	add	r5, r0, #16
   1c154:	eaffffb8 	b	1c03c <dispose_chunk.constprop.0+0x538>
        unlink_chunk(m, next, nsize);
   1c158:	e59e2010 	ldr	r2, [lr, #16]
   1c15c:	e3520000 	cmp	r2, #0
   1c160:	0a000019 	beq	1c1cc <dispose_chunk.constprop.0+0x6c8>
   1c164:	e28e5010 	add	r5, lr, #16
   1c168:	eaffffcc 	b	1c0a0 <dispose_chunk.constprop.0+0x59c>
        unlink_chunk(m, p, prevsize);
   1c16c:	e3570000 	cmp	r7, #0
   1c170:	0afffeab 	beq	1bc24 <dispose_chunk.constprop.0+0x120>
   1c174:	e590601c 	ldr	r6, [r0, #28]
   1c178:	e286404c 	add	r4, r6, #76	@ 0x4c
   1c17c:	e0832104 	add	r2, r3, r4, lsl #2
   1c180:	e5922018 	ldr	r2, [r2, #24]
   1c184:	e1500002 	cmp	r0, r2
   1c188:	0a000007 	beq	1c1ac <dispose_chunk.constprop.0+0x6a8>
   1c18c:	e15c0007 	cmp	ip, r7
   1c190:	8affff36 	bhi	1be70 <dispose_chunk.constprop.0+0x36c>
   1c194:	e5972010 	ldr	r2, [r7, #16]
   1c198:	e1500002 	cmp	r0, r2
   1c19c:	e3a02000 	mov	r2, #0
   1c1a0:	05872010 	streq	r2, [r7, #16]
   1c1a4:	15872014 	strne	r2, [r7, #20]
   1c1a8:	eafffe9d 	b	1bc24 <dispose_chunk.constprop.0+0x120>
   1c1ac:	e593201c 	ldr	r2, [r3, #28]
   1c1b0:	e3a05001 	mov	r5, #1
   1c1b4:	e0834104 	add	r4, r3, r4, lsl #2
   1c1b8:	e1c22615 	bic	r2, r2, r5, lsl r6
   1c1bc:	e583201c 	str	r2, [r3, #28]
   1c1c0:	e3a02000 	mov	r2, #0
   1c1c4:	e5842018 	str	r2, [r4, #24]
   1c1c8:	eafffe95 	b	1bc24 <dispose_chunk.constprop.0+0x120>
        unlink_chunk(m, next, nsize);
   1c1cc:	e3580000 	cmp	r8, #0
   1c1d0:	0afffed2 	beq	1bd20 <dispose_chunk.constprop.0+0x21c>
   1c1d4:	e59e501c 	ldr	r5, [lr, #28]
   1c1d8:	e285204c 	add	r2, r5, #76	@ 0x4c
   1c1dc:	e0834102 	add	r4, r3, r2, lsl #2
   1c1e0:	e5944018 	ldr	r4, [r4, #24]
   1c1e4:	e15e0004 	cmp	lr, r4
   1c1e8:	0a000007 	beq	1c20c <dispose_chunk.constprop.0+0x708>
   1c1ec:	e15c0008 	cmp	ip, r8
   1c1f0:	8affff1e 	bhi	1be70 <dispose_chunk.constprop.0+0x36c>
   1c1f4:	e5982010 	ldr	r2, [r8, #16]
   1c1f8:	e15e0002 	cmp	lr, r2
   1c1fc:	e3a02000 	mov	r2, #0
   1c200:	05882010 	streq	r2, [r8, #16]
   1c204:	15882014 	strne	r2, [r8, #20]
   1c208:	eafffec4 	b	1bd20 <dispose_chunk.constprop.0+0x21c>
   1c20c:	e083e102 	add	lr, r3, r2, lsl #2
   1c210:	e593201c 	ldr	r2, [r3, #28]
   1c214:	e3a04001 	mov	r4, #1
   1c218:	e1c22514 	bic	r2, r2, r4, lsl r5
   1c21c:	e583201c 	str	r2, [r3, #28]
   1c220:	e3a02000 	mov	r2, #0
   1c224:	e58e2018 	str	r2, [lr, #24]
   1c228:	eafffebc 	b	1bd20 <dispose_chunk.constprop.0+0x21c>
   1c22c:	0002b684 	.word	0x0002b684

0001c230 <release_unused_segments.constprop.0>:
static size_t release_unused_segments(mstate m) {
   1c230:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  msegmentptr sp = pred->next;
   1c234:	e30bb66c 	movw	fp, #46700	@ 0xb66c
   1c238:	e340b002 	movt	fp, #2
static size_t release_unused_segments(mstate m) {
   1c23c:	e24dd00c 	sub	sp, sp, #12
  msegmentptr sp = pred->next;
   1c240:	e59b41e0 	ldr	r4, [fp, #480]	@ 0x1e0
  while (sp != 0) {
   1c244:	e3540000 	cmp	r4, #0
   1c248:	0a000108 	beq	1c670 <release_unused_segments.constprop.0+0x440>
  size_t released = 0;
   1c24c:	e3a07000 	mov	r7, #0
  msegmentptr pred = &m->seg;
   1c250:	e28baf76 	add	sl, fp, #472	@ 0x1d8
  size_t released = 0;
   1c254:	e58d7004 	str	r7, [sp, #4]
   1c258:	ea000002 	b	1c268 <release_unused_segments.constprop.0+0x38>
  while (sp != 0) {
   1c25c:	e3540000 	cmp	r4, #0
          insert_large_chunk(m, tp, psize);
   1c260:	e1a0a006 	mov	sl, r6
  while (sp != 0) {
   1c264:	0a00005f 	beq	1c3e8 <release_unused_segments.constprop.0+0x1b8>
    if (is_mmapped_segment(sp) && !is_extern_segment(sp)) {
   1c268:	e594300c 	ldr	r3, [r4, #12]
   1c26c:	e1a06004 	mov	r6, r4
    char* base = sp->base;
   1c270:	e5940000 	ldr	r0, [r4]
    ++nsegs;
   1c274:	e2877001 	add	r7, r7, #1
    size_t size = sp->size;
   1c278:	e5941004 	ldr	r1, [r4, #4]
    if (is_mmapped_segment(sp) && !is_extern_segment(sp)) {
   1c27c:	e2033009 	and	r3, r3, #9
    msegmentptr next = sp->next;
   1c280:	e5944008 	ldr	r4, [r4, #8]
    if (is_mmapped_segment(sp) && !is_extern_segment(sp)) {
   1c284:	e3530001 	cmp	r3, #1
   1c288:	1afffff3 	bne	1c25c <release_unused_segments.constprop.0+0x2c>
      mchunkptr p = align_as_chunk(base);
   1c28c:	e3100007 	tst	r0, #7
   1c290:	e2805008 	add	r5, r0, #8
   1c294:	12655000 	rsbne	r5, r5, #0
   1c298:	01a05000 	moveq	r5, r0
   1c29c:	12055007 	andne	r5, r5, #7
   1c2a0:	10805005 	addne	r5, r0, r5
      size_t psize = chunksize(p);
   1c2a4:	e5958004 	ldr	r8, [r5, #4]
      if (!is_inuse(p) && (char*)p + psize >= base + size - TOP_FOOT_SIZE) {
   1c2a8:	e2089003 	and	r9, r8, #3
   1c2ac:	e3590001 	cmp	r9, #1
   1c2b0:	1affffe9 	bne	1c25c <release_unused_segments.constprop.0+0x2c>
      size_t psize = chunksize(p);
   1c2b4:	e3c88007 	bic	r8, r8, #7
      if (!is_inuse(p) && (char*)p + psize >= base + size - TOP_FOOT_SIZE) {
   1c2b8:	e2413028 	sub	r3, r1, #40	@ 0x28
   1c2bc:	e0803003 	add	r3, r0, r3
   1c2c0:	e0852008 	add	r2, r5, r8
   1c2c4:	e1520003 	cmp	r2, r3
   1c2c8:	3affffe3 	bcc	1c25c <release_unused_segments.constprop.0+0x2c>
        if (p == m->dv) {
   1c2cc:	e59b302c 	ldr	r3, [fp, #44]	@ 0x2c
   1c2d0:	e1530005 	cmp	r3, r5
          m->dv = 0;
   1c2d4:	03a03000 	moveq	r3, #0
   1c2d8:	058b302c 	streq	r3, [fp, #44]	@ 0x2c
          m->dvsize = 0;
   1c2dc:	058b3020 	streq	r3, [fp, #32]
        if (p == m->dv) {
   1c2e0:	0a000033 	beq	1c3b4 <release_unused_segments.constprop.0+0x184>
          unlink_large_chunk(m, tp);
   1c2e4:	e595200c 	ldr	r2, [r5, #12]
   1c2e8:	e5953018 	ldr	r3, [r5, #24]
   1c2ec:	e1520005 	cmp	r2, r5
   1c2f0:	e58d3000 	str	r3, [sp]
   1c2f4:	0a00005f 	beq	1c478 <release_unused_segments.constprop.0+0x248>
   1c2f8:	e5953008 	ldr	r3, [r5, #8]
   1c2fc:	e59bc028 	ldr	ip, [fp, #40]	@ 0x28
   1c300:	e153000c 	cmp	r3, ip
   1c304:	3a00005a 	bcc	1c474 <release_unused_segments.constprop.0+0x244>
   1c308:	e593e00c 	ldr	lr, [r3, #12]
   1c30c:	e15e0005 	cmp	lr, r5
   1c310:	1a000057 	bne	1c474 <release_unused_segments.constprop.0+0x244>
   1c314:	e592e008 	ldr	lr, [r2, #8]
   1c318:	e15e0005 	cmp	lr, r5
   1c31c:	1a000054 	bne	1c474 <release_unused_segments.constprop.0+0x244>
   1c320:	e59de000 	ldr	lr, [sp]
   1c324:	e583200c 	str	r2, [r3, #12]
   1c328:	e5823008 	str	r3, [r2, #8]
   1c32c:	e35e0000 	cmp	lr, #0
   1c330:	0a00001f 	beq	1c3b4 <release_unused_segments.constprop.0+0x184>
   1c334:	e595301c 	ldr	r3, [r5, #28]
   1c338:	e283304c 	add	r3, r3, #76	@ 0x4c
   1c33c:	e08b3103 	add	r3, fp, r3, lsl #2
   1c340:	e593e018 	ldr	lr, [r3, #24]
   1c344:	e15e0005 	cmp	lr, r5
   1c348:	0a00007d 	beq	1c544 <release_unused_segments.constprop.0+0x314>
   1c34c:	e59d3000 	ldr	r3, [sp]
   1c350:	e153000c 	cmp	r3, ip
   1c354:	3a000046 	bcc	1c474 <release_unused_segments.constprop.0+0x244>
   1c358:	e5933010 	ldr	r3, [r3, #16]
   1c35c:	e1550003 	cmp	r5, r3
   1c360:	e59d3000 	ldr	r3, [sp]
   1c364:	05832010 	streq	r2, [r3, #16]
   1c368:	15832014 	strne	r2, [r3, #20]
   1c36c:	e15c0002 	cmp	ip, r2
   1c370:	8a00003f 	bhi	1c474 <release_unused_segments.constprop.0+0x244>
   1c374:	e59d3000 	ldr	r3, [sp]
   1c378:	e5823018 	str	r3, [r2, #24]
   1c37c:	e5953010 	ldr	r3, [r5, #16]
   1c380:	e3530000 	cmp	r3, #0
   1c384:	0a000003 	beq	1c398 <release_unused_segments.constprop.0+0x168>
   1c388:	e15c0003 	cmp	ip, r3
   1c38c:	8a000038 	bhi	1c474 <release_unused_segments.constprop.0+0x244>
   1c390:	e5823010 	str	r3, [r2, #16]
   1c394:	e5832018 	str	r2, [r3, #24]
   1c398:	e5953014 	ldr	r3, [r5, #20]
   1c39c:	e3530000 	cmp	r3, #0
   1c3a0:	0a000003 	beq	1c3b4 <release_unused_segments.constprop.0+0x184>
   1c3a4:	e15c0003 	cmp	ip, r3
   1c3a8:	8a000031 	bhi	1c474 <release_unused_segments.constprop.0+0x244>
   1c3ac:	e5823014 	str	r3, [r2, #20]
   1c3b0:	e5832018 	str	r2, [r3, #24]
        if (CALL_MUNMAP(base, size) == 0) {
   1c3b4:	e58d1000 	str	r1, [sp]
   1c3b8:	eb000c74 	bl	1f590 <munmap>
   1c3bc:	e3500000 	cmp	r0, #0
   1c3c0:	1a00000f 	bne	1c404 <release_unused_segments.constprop.0+0x1d4>
          released += size;
   1c3c4:	e89d000a 	ldm	sp, {r1, r3}
  while (sp != 0) {
   1c3c8:	e3540000 	cmp	r4, #0
          released += size;
   1c3cc:	e0833001 	add	r3, r3, r1
   1c3d0:	e58d3004 	str	r3, [sp, #4]
          m->footprint -= size;
   1c3d4:	e59b31c8 	ldr	r3, [fp, #456]	@ 0x1c8
   1c3d8:	e0433001 	sub	r3, r3, r1
   1c3dc:	e58b31c8 	str	r3, [fp, #456]	@ 0x1c8
          sp->next = next;
   1c3e0:	e58a4008 	str	r4, [sl, #8]
  while (sp != 0) {
   1c3e4:	1affff9f 	bne	1c268 <release_unused_segments.constprop.0+0x38>
                       (size_t) nsegs : (size_t) MAX_RELEASE_CHECK_RATE);
   1c3e8:	e3003fff 	movw	r3, #4095	@ 0xfff
   1c3ec:	e1570003 	cmp	r7, r3
   1c3f0:	31a07003 	movcc	r7, r3
}
   1c3f4:	e59d0004 	ldr	r0, [sp, #4]
  m->release_checks = (((size_t) nsegs > (size_t) MAX_RELEASE_CHECK_RATE)?
   1c3f8:	e58b7038 	str	r7, [fp, #56]	@ 0x38
}
   1c3fc:	e28dd00c 	add	sp, sp, #12
   1c400:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
          insert_large_chunk(m, tp, psize);
   1c404:	e1b03428 	lsrs	r3, r8, #8
   1c408:	03a0ce13 	moveq	ip, #304	@ 0x130
   1c40c:	03a0104c 	moveq	r1, #76	@ 0x4c
   1c410:	1a000010 	bne	1c458 <release_unused_segments.constprop.0+0x228>
   1c414:	e59b201c 	ldr	r2, [fp, #28]
   1c418:	e3a00000 	mov	r0, #0
   1c41c:	e585301c 	str	r3, [r5, #28]
   1c420:	e5850010 	str	r0, [r5, #16]
   1c424:	e1120009 	tst	r2, r9
   1c428:	e5850014 	str	r0, [r5, #20]
   1c42c:	1a000046 	bne	1c54c <release_unused_segments.constprop.0+0x31c>
   1c430:	e59f3244 	ldr	r3, [pc, #580]	@ 1c67c <release_unused_segments.constprop.0+0x44c>
   1c434:	e08b1101 	add	r1, fp, r1, lsl #2
   1c438:	e1822009 	orr	r2, r2, r9
   1c43c:	e5815018 	str	r5, [r1, #24]
   1c440:	e083300c 	add	r3, r3, ip
   1c444:	e58b201c 	str	r2, [fp, #28]
   1c448:	e5855008 	str	r5, [r5, #8]
   1c44c:	e585500c 	str	r5, [r5, #12]
   1c450:	e5853018 	str	r3, [r5, #24]
   1c454:	eaffff80 	b	1c25c <release_unused_segments.constprop.0+0x2c>
   1c458:	e3530801 	cmp	r3, #65536	@ 0x10000
   1c45c:	3a000059 	bcc	1c5c8 <release_unused_segments.constprop.0+0x398>
   1c460:	e3a09102 	mov	r9, #-2147483648	@ 0x80000000
   1c464:	e3a0cf6b 	mov	ip, #428	@ 0x1ac
   1c468:	e3a0301f 	mov	r3, #31
   1c46c:	e3a0106b 	mov	r1, #107	@ 0x6b
   1c470:	eaffffe7 	b	1c414 <release_unused_segments.constprop.0+0x1e4>
          unlink_large_chunk(m, tp);
   1c474:	ebffe8a4 	bl	1670c <abort>
   1c478:	e5953014 	ldr	r3, [r5, #20]
   1c47c:	e3530000 	cmp	r3, #0
   1c480:	1285c014 	addne	ip, r5, #20
   1c484:	1a00001a 	bne	1c4f4 <release_unused_segments.constprop.0+0x2c4>
   1c488:	e5953010 	ldr	r3, [r5, #16]
   1c48c:	e3530000 	cmp	r3, #0
   1c490:	1a00006a 	bne	1c640 <release_unused_segments.constprop.0+0x410>
   1c494:	e59d2000 	ldr	r2, [sp]
   1c498:	e3520000 	cmp	r2, #0
   1c49c:	0affffc4 	beq	1c3b4 <release_unused_segments.constprop.0+0x184>
   1c4a0:	e595e01c 	ldr	lr, [r5, #28]
   1c4a4:	e28e204c 	add	r2, lr, #76	@ 0x4c
   1c4a8:	e08b2102 	add	r2, fp, r2, lsl #2
   1c4ac:	e592c018 	ldr	ip, [r2, #24]
   1c4b0:	e155000c 	cmp	r5, ip
   1c4b4:	0a00005c 	beq	1c62c <release_unused_segments.constprop.0+0x3fc>
   1c4b8:	e59b3028 	ldr	r3, [fp, #40]	@ 0x28
   1c4bc:	e59d2000 	ldr	r2, [sp]
   1c4c0:	e1520003 	cmp	r2, r3
   1c4c4:	3affffea 	bcc	1c474 <release_unused_segments.constprop.0+0x244>
   1c4c8:	e5923010 	ldr	r3, [r2, #16]
   1c4cc:	e1530005 	cmp	r3, r5
   1c4d0:	e3a03000 	mov	r3, #0
   1c4d4:	159d2000 	ldrne	r2, [sp]
   1c4d8:	05823010 	streq	r3, [r2, #16]
   1c4dc:	15823014 	strne	r3, [r2, #20]
   1c4e0:	eaffffb3 	b	1c3b4 <release_unused_segments.constprop.0+0x184>
   1c4e4:	e5923010 	ldr	r3, [r2, #16]
   1c4e8:	e282c010 	add	ip, r2, #16
   1c4ec:	e3530000 	cmp	r3, #0
   1c4f0:	0a000006 	beq	1c510 <release_unused_segments.constprop.0+0x2e0>
   1c4f4:	e1a0e00c 	mov	lr, ip
   1c4f8:	e1a02003 	mov	r2, r3
   1c4fc:	e283c014 	add	ip, r3, #20
   1c500:	e5933014 	ldr	r3, [r3, #20]
   1c504:	e3530000 	cmp	r3, #0
   1c508:	1afffff9 	bne	1c4f4 <release_unused_segments.constprop.0+0x2c4>
   1c50c:	eafffff4 	b	1c4e4 <release_unused_segments.constprop.0+0x2b4>
   1c510:	e59bc028 	ldr	ip, [fp, #40]	@ 0x28
   1c514:	e15c000e 	cmp	ip, lr
   1c518:	8affffd5 	bhi	1c474 <release_unused_segments.constprop.0+0x244>
   1c51c:	e58e3000 	str	r3, [lr]
   1c520:	e59d3000 	ldr	r3, [sp]
   1c524:	e3530000 	cmp	r3, #0
   1c528:	0affffa1 	beq	1c3b4 <release_unused_segments.constprop.0+0x184>
   1c52c:	e595301c 	ldr	r3, [r5, #28]
   1c530:	e283304c 	add	r3, r3, #76	@ 0x4c
   1c534:	e08b3103 	add	r3, fp, r3, lsl #2
   1c538:	e593e018 	ldr	lr, [r3, #24]
   1c53c:	e155000e 	cmp	r5, lr
   1c540:	1affff81 	bne	1c34c <release_unused_segments.constprop.0+0x11c>
   1c544:	e5832018 	str	r2, [r3, #24]
   1c548:	eaffff87 	b	1c36c <release_unused_segments.constprop.0+0x13c>
          insert_large_chunk(m, tp, psize);
   1c54c:	e353001f 	cmp	r3, #31
   1c550:	e08b1101 	add	r1, fp, r1, lsl #2
   1c554:	11a030a3 	lsrne	r3, r3, #1
   1c558:	01a03008 	moveq	r3, r8
   1c55c:	e5911018 	ldr	r1, [r1, #24]
   1c560:	12633019 	rsbne	r3, r3, #25
   1c564:	11a03318 	lslne	r3, r8, r3
   1c568:	ea000006 	b	1c588 <release_unused_segments.constprop.0+0x358>
   1c56c:	e1a00fa3 	lsr	r0, r3, #31
   1c570:	e1a03083 	lsl	r3, r3, #1
   1c574:	e081c100 	add	ip, r1, r0, lsl #2
   1c578:	e59c2010 	ldr	r2, [ip, #16]
   1c57c:	e3520000 	cmp	r2, #0
   1c580:	0a000030 	beq	1c648 <release_unused_segments.constprop.0+0x418>
   1c584:	e1a01002 	mov	r1, r2
   1c588:	e5912004 	ldr	r2, [r1, #4]
   1c58c:	e3c22007 	bic	r2, r2, #7
   1c590:	e1580002 	cmp	r8, r2
   1c594:	1afffff4 	bne	1c56c <release_unused_segments.constprop.0+0x33c>
   1c598:	e5913008 	ldr	r3, [r1, #8]
   1c59c:	e59b2028 	ldr	r2, [fp, #40]	@ 0x28
   1c5a0:	e1530002 	cmp	r3, r2
   1c5a4:	21510002 	cmpcs	r1, r2
   1c5a8:	3affffb1 	bcc	1c474 <release_unused_segments.constprop.0+0x244>
   1c5ac:	e583500c 	str	r5, [r3, #12]
   1c5b0:	e5815008 	str	r5, [r1, #8]
   1c5b4:	e5853008 	str	r3, [r5, #8]
   1c5b8:	e3a03000 	mov	r3, #0
   1c5bc:	e585100c 	str	r1, [r5, #12]
   1c5c0:	e5853018 	str	r3, [r5, #24]
   1c5c4:	eaffff24 	b	1c25c <release_unused_segments.constprop.0+0x2c>
   1c5c8:	e2432c01 	sub	r2, r3, #256	@ 0x100
   1c5cc:	e3a09001 	mov	r9, #1
   1c5d0:	e1a02822 	lsr	r2, r2, #16
   1c5d4:	e2022008 	and	r2, r2, #8
   1c5d8:	e1a03213 	lsl	r3, r3, r2
   1c5dc:	e2430a01 	sub	r0, r3, #4096	@ 0x1000
   1c5e0:	e1a00820 	lsr	r0, r0, #16
   1c5e4:	e2000004 	and	r0, r0, #4
   1c5e8:	e1a01013 	lsl	r1, r3, r0
   1c5ec:	e1823000 	orr	r3, r2, r0
   1c5f0:	e2412901 	sub	r2, r1, #16384	@ 0x4000
   1c5f4:	e1a02822 	lsr	r2, r2, #16
   1c5f8:	e2022002 	and	r2, r2, #2
   1c5fc:	e1a01211 	lsl	r1, r1, r2
   1c600:	e0833002 	add	r3, r3, r2
   1c604:	e06337a1 	rsb	r3, r3, r1, lsr #15
   1c608:	e2832015 	add	r2, r3, #21
   1c60c:	e283300e 	add	r3, r3, #14
   1c610:	e1a02238 	lsr	r2, r8, r2
   1c614:	e0022009 	and	r2, r2, r9
   1c618:	e0823913 	add	r3, r2, r3, lsl r9
   1c61c:	e283104c 	add	r1, r3, #76	@ 0x4c
   1c620:	e1a09319 	lsl	r9, r9, r3
   1c624:	e1a0c101 	lsl	ip, r1, #2
   1c628:	eaffff79 	b	1c414 <release_unused_segments.constprop.0+0x1e4>
          unlink_large_chunk(m, tp);
   1c62c:	e5823018 	str	r3, [r2, #24]
   1c630:	e59b301c 	ldr	r3, [fp, #28]
   1c634:	e1c33e19 	bic	r3, r3, r9, lsl lr
   1c638:	e58b301c 	str	r3, [fp, #28]
   1c63c:	eaffff5c 	b	1c3b4 <release_unused_segments.constprop.0+0x184>
   1c640:	e285c010 	add	ip, r5, #16
   1c644:	eaffffaa 	b	1c4f4 <release_unused_segments.constprop.0+0x2c4>
          insert_large_chunk(m, tp, psize);
   1c648:	e59b2028 	ldr	r2, [fp, #40]	@ 0x28
   1c64c:	e2803004 	add	r3, r0, #4
   1c650:	e0813103 	add	r3, r1, r3, lsl #2
   1c654:	e1520003 	cmp	r2, r3
   1c658:	8affff85 	bhi	1c474 <release_unused_segments.constprop.0+0x244>
   1c65c:	e58c5010 	str	r5, [ip, #16]
   1c660:	e5851018 	str	r1, [r5, #24]
   1c664:	e5855008 	str	r5, [r5, #8]
   1c668:	e585500c 	str	r5, [r5, #12]
   1c66c:	eafffefa 	b	1c25c <release_unused_segments.constprop.0+0x2c>
  while (sp != 0) {
   1c670:	e3007fff 	movw	r7, #4095	@ 0xfff
  size_t released = 0;
   1c674:	e58d4004 	str	r4, [sp, #4]
   1c678:	eaffff5d 	b	1c3f4 <release_unused_segments.constprop.0+0x1c4>
   1c67c:	0002b684 	.word	0x0002b684

0001c680 <sys_trim.constprop.0>:
static int sys_trim(mstate m, size_t pad) {
   1c680:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
  ensure_initialization();
   1c684:	e30b666c 	movw	r6, #46700	@ 0xb66c
   1c688:	e3406002 	movt	r6, #2
static int sys_trim(mstate m, size_t pad) {
   1c68c:	e1a04000 	mov	r4, r0
  ensure_initialization();
   1c690:	e5963000 	ldr	r3, [r6]
   1c694:	e3530000 	cmp	r3, #0
   1c698:	0a000025 	beq	1c734 <sys_trim.constprop.0+0xb4>
  if (pad < MAX_REQUEST && is_initialized(m)) {
   1c69c:	e3740041 	cmn	r4, #65	@ 0x41
   1c6a0:	9a000001 	bls	1c6ac <sys_trim.constprop.0+0x2c>
  msegmentptr sp = &m->seg;
   1c6a4:	e3a00000 	mov	r0, #0
   1c6a8:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
  if (pad < MAX_REQUEST && is_initialized(m)) {
   1c6ac:	e5963030 	ldr	r3, [r6, #48]	@ 0x30
   1c6b0:	e3530000 	cmp	r3, #0
   1c6b4:	0afffffa 	beq	1c6a4 <sys_trim.constprop.0+0x24>
    if (m->topsize > pad) {
   1c6b8:	e5962024 	ldr	r2, [r6, #36]	@ 0x24
    pad += TOP_FOOT_SIZE; /* ensure enough room for segment overhead */
   1c6bc:	e2840028 	add	r0, r4, #40	@ 0x28
    if (m->topsize > pad) {
   1c6c0:	e1500002 	cmp	r0, r2
   1c6c4:	2a00000f 	bcs	1c708 <sys_trim.constprop.0+0x88>
      size_t unit = mparams.granularity;
   1c6c8:	e5969008 	ldr	r9, [r6, #8]
  msegmentptr sp = &m->seg;
   1c6cc:	e59f4150 	ldr	r4, [pc, #336]	@ 1c824 <sys_trim.constprop.0+0x1a4>
   1c6d0:	ea000002 	b	1c6e0 <sys_trim.constprop.0+0x60>
    if ((sp = sp->next) == 0)
   1c6d4:	e5944008 	ldr	r4, [r4, #8]
   1c6d8:	e3540000 	cmp	r4, #0
   1c6dc:	0a00004e 	beq	1c81c <sys_trim.constprop.0+0x19c>
    if (addr >= sp->base && addr < sp->base + sp->size)
   1c6e0:	e5945000 	ldr	r5, [r4]
   1c6e4:	e1530005 	cmp	r3, r5
   1c6e8:	3afffff9 	bcc	1c6d4 <sys_trim.constprop.0+0x54>
   1c6ec:	e5948004 	ldr	r8, [r4, #4]
   1c6f0:	e0857008 	add	r7, r5, r8
   1c6f4:	e1530007 	cmp	r3, r7
   1c6f8:	2afffff5 	bcs	1c6d4 <sys_trim.constprop.0+0x54>
      if (!is_extern_segment(sp)) {
   1c6fc:	e594300c 	ldr	r3, [r4, #12]
   1c700:	e3130008 	tst	r3, #8
   1c704:	0a00000e 	beq	1c744 <sys_trim.constprop.0+0xc4>
  msegmentptr sp = &m->seg;
   1c708:	e3a09000 	mov	r9, #0
      released += release_unused_segments(m);
   1c70c:	ebfffec7 	bl	1c230 <release_unused_segments.constprop.0>
    if (released == 0 && m->topsize > m->trim_check)
   1c710:	e1700009 	cmn	r0, r9
   1c714:	1a000008 	bne	1c73c <sys_trim.constprop.0+0xbc>
   1c718:	e5963034 	ldr	r3, [r6, #52]	@ 0x34
  msegmentptr sp = &m->seg;
   1c71c:	e3a00000 	mov	r0, #0
    if (released == 0 && m->topsize > m->trim_check)
   1c720:	e5962024 	ldr	r2, [r6, #36]	@ 0x24
   1c724:	e1520003 	cmp	r2, r3
      m->trim_check = MAX_SIZE_T;
   1c728:	83e03000 	mvnhi	r3, #0
   1c72c:	85863034 	strhi	r3, [r6, #52]	@ 0x34
   1c730:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
  if (mparams.magic == 0) {
   1c734:	ebfffcd6 	bl	1ba94 <init_mparams.part.0>
  return 1;
   1c738:	eaffffd7 	b	1c69c <sys_trim.constprop.0+0x1c>
   1c73c:	e3a00001 	mov	r0, #1
}
   1c740:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        if (is_mmapped_segment(sp)) {
   1c744:	e3130001 	tst	r3, #1
   1c748:	0affffee 	beq	1c708 <sys_trim.constprop.0+0x88>
      size_t extra = ((m->topsize - pad + (unit - SIZE_T_ONE)) / unit -
   1c74c:	e0822009 	add	r2, r2, r9
   1c750:	e1a01009 	mov	r1, r9
   1c754:	e2422001 	sub	r2, r2, #1
   1c758:	e0420000 	sub	r0, r2, r0
   1c75c:	ebffe67f 	bl	16160 <__udivsi3>
   1c760:	e2400001 	sub	r0, r0, #1
   1c764:	e0090099 	mul	r9, r9, r0
          if (HAVE_MMAP &&
   1c768:	e1590008 	cmp	r9, r8
   1c76c:	8affffe5 	bhi	1c708 <sys_trim.constprop.0+0x88>
  msegmentptr sp = &m->seg;
   1c770:	e59f30ac 	ldr	r3, [pc, #172]	@ 1c824 <sys_trim.constprop.0+0x1a4>
    if ((char*)sp >= ss->base && (char*)sp < ss->base + ss->size)
   1c774:	e1550003 	cmp	r5, r3
   1c778:	8a000001 	bhi	1c784 <sys_trim.constprop.0+0x104>
   1c77c:	e1570003 	cmp	r7, r3
   1c780:	8affffe0 	bhi	1c708 <sys_trim.constprop.0+0x88>
    if ((sp = sp->next) == 0)
   1c784:	e5933008 	ldr	r3, [r3, #8]
   1c788:	e3530000 	cmp	r3, #0
   1c78c:	1afffff8 	bne	1c774 <sys_trim.constprop.0+0xf4>
            size_t newsize = sp->size - extra;
   1c790:	e0480009 	sub	r0, r8, r9
                (CALL_MUNMAP(sp->base + newsize, extra) == 0)) {
   1c794:	e1a01009 	mov	r1, r9
   1c798:	e0850000 	add	r0, r5, r0
   1c79c:	eb000b7b 	bl	1f590 <munmap>
      if (released != 0) {
   1c7a0:	e2593000 	subs	r3, r9, #0
   1c7a4:	13a03001 	movne	r3, #1
   1c7a8:	e3500000 	cmp	r0, #0
   1c7ac:	13a03000 	movne	r3, #0
   1c7b0:	e3530000 	cmp	r3, #0
   1c7b4:	0affffd3 	beq	1c708 <sys_trim.constprop.0+0x88>
        sp->size -= released;
   1c7b8:	e5942004 	ldr	r2, [r4, #4]
        init_top(m, m->top, m->topsize - released);
   1c7bc:	e5963030 	ldr	r3, [r6, #48]	@ 0x30
   1c7c0:	e5960024 	ldr	r0, [r6, #36]	@ 0x24
        sp->size -= released;
   1c7c4:	e0422009 	sub	r2, r2, r9
  m->trim_check = mparams.trim_threshold; /* reset on each update */
   1c7c8:	e596c010 	ldr	ip, [r6, #16]
        sp->size -= released;
   1c7cc:	e5842004 	str	r2, [r4, #4]
  size_t offset = align_offset(chunk2mem(p));
   1c7d0:	e2831008 	add	r1, r3, #8
        m->footprint -= released;
   1c7d4:	e59621c8 	ldr	r2, [r6, #456]	@ 0x1c8
        init_top(m, m->top, m->topsize - released);
   1c7d8:	e0400009 	sub	r0, r0, r9
        m->footprint -= released;
   1c7dc:	e0422009 	sub	r2, r2, r9
   1c7e0:	e58621c8 	str	r2, [r6, #456]	@ 0x1c8
  size_t offset = align_offset(chunk2mem(p));
   1c7e4:	e2132007 	ands	r2, r3, #7
   1c7e8:	12612000 	rsbne	r2, r1, #0
   1c7ec:	12022007 	andne	r2, r2, #7
  psize -= offset;
   1c7f0:	e0401002 	sub	r1, r0, r2
  p = (mchunkptr)((char*)p + offset);
   1c7f4:	e0832002 	add	r2, r3, r2
  m->topsize = psize;
   1c7f8:	e5861024 	str	r1, [r6, #36]	@ 0x24
  p->head = psize | PINUSE_BIT;
   1c7fc:	e3811001 	orr	r1, r1, #1
  m->top = p;
   1c800:	e5862030 	str	r2, [r6, #48]	@ 0x30
  chunk_plus_offset(p, psize)->head = TOP_FOOT_SIZE;
   1c804:	e0833000 	add	r3, r3, r0
  p->head = psize | PINUSE_BIT;
   1c808:	e5821004 	str	r1, [r2, #4]
  chunk_plus_offset(p, psize)->head = TOP_FOOT_SIZE;
   1c80c:	e3a02028 	mov	r2, #40	@ 0x28
   1c810:	e5832004 	str	r2, [r3, #4]
  m->trim_check = mparams.trim_threshold; /* reset on each update */
   1c814:	e586c034 	str	ip, [r6, #52]	@ 0x34
}
   1c818:	eaffffbb 	b	1c70c <sys_trim.constprop.0+0x8c>
      if (!is_extern_segment(sp)) {
   1c81c:	e594300c 	ldr	r3, [r4, #12]
   1c820:	e7f000f0 	udf	#0
   1c824:	0002b844 	.word	0x0002b844

0001c828 <try_realloc_chunk.constprop.0.isra.0>:
static mchunkptr try_realloc_chunk(mstate m, mchunkptr p, size_t nb,
                                   int can_move) {
  mchunkptr newp = 0;
  size_t oldsize = chunksize(p);
  mchunkptr next = chunk_plus_offset(p, oldsize);
  if (RTCHECK(ok_address(m, p) && ok_inuse(p) &&
   1c828:	e30b366c 	movw	r3, #46700	@ 0xb66c
static mchunkptr try_realloc_chunk(mstate m, mchunkptr p, size_t nb,
   1c82c:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
  if (RTCHECK(ok_address(m, p) && ok_inuse(p) &&
   1c830:	e3403002 	movt	r3, #2
static mchunkptr try_realloc_chunk(mstate m, mchunkptr p, size_t nb,
   1c834:	e1a04000 	mov	r4, r0
  if (RTCHECK(ok_address(m, p) && ok_inuse(p) &&
   1c838:	e593e028 	ldr	lr, [r3, #40]	@ 0x28
  size_t oldsize = chunksize(p);
   1c83c:	e5900004 	ldr	r0, [r0, #4]
  if (RTCHECK(ok_address(m, p) && ok_inuse(p) &&
   1c840:	e154000e 	cmp	r4, lr
  size_t oldsize = chunksize(p);
   1c844:	e3c02007 	bic	r2, r0, #7
  mchunkptr next = chunk_plus_offset(p, oldsize);
   1c848:	e0845002 	add	r5, r4, r2
  if (RTCHECK(ok_address(m, p) && ok_inuse(p) &&
   1c84c:	3a000042 	bcc	1c95c <try_realloc_chunk.constprop.0.isra.0+0x134>
   1c850:	e200c003 	and	ip, r0, #3
   1c854:	e35c0001 	cmp	ip, #1
   1c858:	11540005 	cmpne	r4, r5
   1c85c:	2a00003e 	bcs	1c95c <try_realloc_chunk.constprop.0.isra.0+0x134>
   1c860:	e5956004 	ldr	r6, [r5, #4]
   1c864:	e3160001 	tst	r6, #1
   1c868:	0a00003b 	beq	1c95c <try_realloc_chunk.constprop.0.isra.0+0x134>
              ok_next(p, next) && ok_pinuse(next))) {
    if (is_mmapped(p)) {
   1c86c:	e35c0000 	cmp	ip, #0
   1c870:	1a00000a 	bne	1c8a0 <try_realloc_chunk.constprop.0.isra.0+0x78>
  if (is_small(nb)) /* Can't shrink mmap regions below small size */
   1c874:	e35100ff 	cmp	r1, #255	@ 0xff
   1c878:	9a000035 	bls	1c954 <try_realloc_chunk.constprop.0.isra.0+0x12c>
  if (oldsize >= nb + SIZE_T_SIZE &&
   1c87c:	e2810004 	add	r0, r1, #4
   1c880:	e1520000 	cmp	r2, r0
   1c884:	3a000032 	bcc	1c954 <try_realloc_chunk.constprop.0.isra.0+0x12c>
      (oldsize - nb) <= (mparams.granularity << 1))
   1c888:	e5933008 	ldr	r3, [r3, #8]
   1c88c:	e0422001 	sub	r2, r2, r1
  if (oldsize >= nb + SIZE_T_SIZE &&
   1c890:	e1520083 	cmp	r2, r3, lsl #1
   1c894:	8a00002e 	bhi	1c954 <try_realloc_chunk.constprop.0.isra.0+0x12c>
    return oldp;
   1c898:	e1a00004 	mov	r0, r4
   1c89c:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
      newp = mmap_resize(m, p, nb, can_move);
    }
    else if (oldsize >= nb) {             /* already big enough */
   1c8a0:	e1520001 	cmp	r2, r1
   1c8a4:	2a00002d 	bcs	1c960 <try_realloc_chunk.constprop.0.isra.0+0x138>
        set_inuse(m, r, rsize);
        dispose_chunk(m, r, rsize);
      }
      newp = p;
    }
    else if (next == m->top) {  /* extend into top */
   1c8a8:	e593c030 	ldr	ip, [r3, #48]	@ 0x30
   1c8ac:	e155000c 	cmp	r5, ip
   1c8b0:	0a00003a 	beq	1c9a0 <try_realloc_chunk.constprop.0.isra.0+0x178>
        m->top = newtop;
        m->topsize = newtopsize;
        newp = p;
      }
    }
    else if (next == m->dv) { /* extend into dv */
   1c8b4:	e593c02c 	ldr	ip, [r3, #44]	@ 0x2c
   1c8b8:	e155000c 	cmp	r5, ip
   1c8bc:	0a000046 	beq	1c9dc <try_realloc_chunk.constprop.0.isra.0+0x1b4>
          m->dv = 0;
        }
        newp = p;
      }
    }
    else if (!cinuse(next)) { /* extend into next free chunk */
   1c8c0:	e216c002 	ands	ip, r6, #2
   1c8c4:	1a000022 	bne	1c954 <try_realloc_chunk.constprop.0.isra.0+0x12c>
      size_t nextsize = chunksize(next);
   1c8c8:	e3c66007 	bic	r6, r6, #7
      if (oldsize + nextsize >= nb) {
   1c8cc:	e0828006 	add	r8, r2, r6
   1c8d0:	e1510008 	cmp	r1, r8
   1c8d4:	8a00001e 	bhi	1c954 <try_realloc_chunk.constprop.0.isra.0+0x12c>
        size_t rsize = oldsize + nextsize - nb;
        unlink_chunk(m, next, nextsize);
   1c8d8:	e35600f8 	cmp	r6, #248	@ 0xf8
   1c8dc:	e595700c 	ldr	r7, [r5, #12]
   1c8e0:	e1a061a6 	lsr	r6, r6, #3
        size_t rsize = oldsize + nextsize - nb;
   1c8e4:	e0482001 	sub	r2, r8, r1
        unlink_chunk(m, next, nextsize);
   1c8e8:	8a000051 	bhi	1ca34 <try_realloc_chunk.constprop.0.isra.0+0x20c>
   1c8ec:	e59fc344 	ldr	ip, [pc, #836]	@ 1cc38 <try_realloc_chunk.constprop.0.isra.0+0x410>
   1c8f0:	e5959008 	ldr	r9, [r5, #8]
   1c8f4:	e08cc186 	add	ip, ip, r6, lsl #3
   1c8f8:	e28cc028 	add	ip, ip, #40	@ 0x28
   1c8fc:	e159000c 	cmp	r9, ip
   1c900:	1a0000a9 	bne	1cbac <try_realloc_chunk.constprop.0.isra.0+0x384>
   1c904:	e1590007 	cmp	r9, r7
   1c908:	0a0000a2 	beq	1cb98 <try_realloc_chunk.constprop.0.isra.0+0x370>
   1c90c:	e15e0007 	cmp	lr, r7
   1c910:	8a000011 	bhi	1c95c <try_realloc_chunk.constprop.0.isra.0+0x134>
   1c914:	e5973008 	ldr	r3, [r7, #8]
   1c918:	e1550003 	cmp	r5, r3
   1c91c:	1a00000e 	bne	1c95c <try_realloc_chunk.constprop.0.isra.0+0x134>
   1c920:	e589700c 	str	r7, [r9, #12]
   1c924:	e5879008 	str	r9, [r7, #8]
        if (rsize < MIN_CHUNK_SIZE) {
   1c928:	e352000f 	cmp	r2, #15
        set_inuse(m, p, nb);
   1c92c:	e2000001 	and	r0, r0, #1
          size_t newsize = oldsize + nextsize;
          set_inuse(m, p, newsize);
   1c930:	e084c008 	add	ip, r4, r8
        if (rsize < MIN_CHUNK_SIZE) {
   1c934:	8a000077 	bhi	1cb18 <try_realloc_chunk.constprop.0.isra.0+0x2f0>
          set_inuse(m, p, newsize);
   1c938:	e1800008 	orr	r0, r0, r8
   1c93c:	e3800002 	orr	r0, r0, #2
   1c940:	e5840004 	str	r0, [r4, #4]
   1c944:	e59c3004 	ldr	r3, [ip, #4]
   1c948:	e3833001 	orr	r3, r3, #1
   1c94c:	e58c3004 	str	r3, [ip, #4]
   1c950:	eaffffd0 	b	1c898 <try_realloc_chunk.constprop.0.isra.0+0x70>
    return 0;
   1c954:	e3a00000 	mov	r0, #0
   1c958:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        unlink_chunk(m, next, nextsize);
   1c95c:	ebffe76a 	bl	1670c <abort>
      size_t rsize = oldsize - nb;
   1c960:	e0422001 	sub	r2, r2, r1
      if (rsize >= MIN_CHUNK_SIZE) {      /* split off remainder */
   1c964:	e352000f 	cmp	r2, #15
   1c968:	9affffca 	bls	1c898 <try_realloc_chunk.constprop.0.isra.0+0x70>
        set_inuse(m, p, nb);
   1c96c:	e2003001 	and	r3, r0, #1
        mchunkptr r = chunk_plus_offset(p, nb);
   1c970:	e0840001 	add	r0, r4, r1
        set_inuse(m, p, nb);
   1c974:	e1833001 	orr	r3, r3, r1
        dispose_chunk(m, r, rsize);
   1c978:	e1a01002 	mov	r1, r2
        set_inuse(m, p, nb);
   1c97c:	e3833002 	orr	r3, r3, #2
   1c980:	e5843004 	str	r3, [r4, #4]
        set_inuse(m, r, rsize);
   1c984:	e3823003 	orr	r3, r2, #3
   1c988:	e5803004 	str	r3, [r0, #4]
   1c98c:	e5953004 	ldr	r3, [r5, #4]
   1c990:	e3833001 	orr	r3, r3, #1
   1c994:	e5853004 	str	r3, [r5, #4]
        dispose_chunk(m, r, rsize);
   1c998:	ebfffc59 	bl	1bb04 <dispose_chunk.constprop.0>
   1c99c:	eaffffbd 	b	1c898 <try_realloc_chunk.constprop.0.isra.0+0x70>
      if (oldsize + m->topsize > nb) {
   1c9a0:	e593c024 	ldr	ip, [r3, #36]	@ 0x24
   1c9a4:	e082200c 	add	r2, r2, ip
   1c9a8:	e1510002 	cmp	r1, r2
   1c9ac:	2affffe8 	bcs	1c954 <try_realloc_chunk.constprop.0.isra.0+0x12c>
        set_inuse(m, p, nb);
   1c9b0:	e2000001 	and	r0, r0, #1
        size_t newtopsize = newsize - nb;
   1c9b4:	e0422001 	sub	r2, r2, r1
        set_inuse(m, p, nb);
   1c9b8:	e1800001 	orr	r0, r0, r1
        mchunkptr newtop = chunk_plus_offset(p, nb);
   1c9bc:	e0841001 	add	r1, r4, r1
        set_inuse(m, p, nb);
   1c9c0:	e3800002 	orr	r0, r0, #2
   1c9c4:	e5840004 	str	r0, [r4, #4]
        newtop->head = newtopsize |PINUSE_BIT;
   1c9c8:	e3820001 	orr	r0, r2, #1
   1c9cc:	e5810004 	str	r0, [r1, #4]
        m->top = newtop;
   1c9d0:	e5831030 	str	r1, [r3, #48]	@ 0x30
        m->topsize = newtopsize;
   1c9d4:	e5832024 	str	r2, [r3, #36]	@ 0x24
        newp = p;
   1c9d8:	eaffffae 	b	1c898 <try_realloc_chunk.constprop.0.isra.0+0x70>
      if (oldsize + dvs >= nb) {
   1c9dc:	e593c020 	ldr	ip, [r3, #32]
   1c9e0:	e082200c 	add	r2, r2, ip
   1c9e4:	e1510002 	cmp	r1, r2
   1c9e8:	8affffd9 	bhi	1c954 <try_realloc_chunk.constprop.0.isra.0+0x12c>
        size_t dsize = oldsize + dvs - nb;
   1c9ec:	e042c001 	sub	ip, r2, r1
        set_inuse(m, p, nb);
   1c9f0:	e2000001 	and	r0, r0, #1
        if (dsize >= MIN_CHUNK_SIZE) {
   1c9f4:	e35c000f 	cmp	ip, #15
          mchunkptr n = chunk_plus_offset(r, dsize);
   1c9f8:	e084e002 	add	lr, r4, r2
        if (dsize >= MIN_CHUNK_SIZE) {
   1c9fc:	9a00003b 	bls	1caf0 <try_realloc_chunk.constprop.0.isra.0+0x2c8>
          set_inuse(m, p, nb);
   1ca00:	e1800001 	orr	r0, r0, r1
          mchunkptr r = chunk_plus_offset(p, nb);
   1ca04:	e0841001 	add	r1, r4, r1
          set_inuse(m, p, nb);
   1ca08:	e3800002 	orr	r0, r0, #2
   1ca0c:	e5840004 	str	r0, [r4, #4]
          set_size_and_pinuse_of_free_chunk(r, dsize);
   1ca10:	e38c0001 	orr	r0, ip, #1
   1ca14:	e5810004 	str	r0, [r1, #4]
   1ca18:	e784c002 	str	ip, [r4, r2]
          clear_pinuse(n);
   1ca1c:	e59e2004 	ldr	r2, [lr, #4]
   1ca20:	e3c22001 	bic	r2, r2, #1
   1ca24:	e58e2004 	str	r2, [lr, #4]
          m->dvsize = dsize;
   1ca28:	e583c020 	str	ip, [r3, #32]
          m->dv = r;
   1ca2c:	e583102c 	str	r1, [r3, #44]	@ 0x2c
   1ca30:	eaffff98 	b	1c898 <try_realloc_chunk.constprop.0.isra.0+0x70>
        unlink_chunk(m, next, nextsize);
   1ca34:	e1550007 	cmp	r5, r7
   1ca38:	e595a018 	ldr	sl, [r5, #24]
   1ca3c:	0a000041 	beq	1cb48 <try_realloc_chunk.constprop.0.isra.0+0x320>
   1ca40:	e595c008 	ldr	ip, [r5, #8]
   1ca44:	e15e000c 	cmp	lr, ip
   1ca48:	8affffc3 	bhi	1c95c <try_realloc_chunk.constprop.0.isra.0+0x134>
   1ca4c:	e59c600c 	ldr	r6, [ip, #12]
   1ca50:	e1550006 	cmp	r5, r6
   1ca54:	1affffc0 	bne	1c95c <try_realloc_chunk.constprop.0.isra.0+0x134>
   1ca58:	e5976008 	ldr	r6, [r7, #8]
   1ca5c:	e1550006 	cmp	r5, r6
   1ca60:	1affffbd 	bne	1c95c <try_realloc_chunk.constprop.0.isra.0+0x134>
   1ca64:	e35a0000 	cmp	sl, #0
   1ca68:	e58c700c 	str	r7, [ip, #12]
   1ca6c:	e587c008 	str	ip, [r7, #8]
   1ca70:	0affffac 	beq	1c928 <try_realloc_chunk.constprop.0.isra.0+0x100>
   1ca74:	e595c01c 	ldr	ip, [r5, #28]
   1ca78:	e28cc04c 	add	ip, ip, #76	@ 0x4c
   1ca7c:	e083310c 	add	r3, r3, ip, lsl #2
   1ca80:	e593c018 	ldr	ip, [r3, #24]
   1ca84:	e155000c 	cmp	r5, ip
   1ca88:	05837018 	streq	r7, [r3, #24]
   1ca8c:	0a000005 	beq	1caa8 <try_realloc_chunk.constprop.0.isra.0+0x280>
   1ca90:	e15e000a 	cmp	lr, sl
   1ca94:	8affffb0 	bhi	1c95c <try_realloc_chunk.constprop.0.isra.0+0x134>
   1ca98:	e59a3010 	ldr	r3, [sl, #16]
   1ca9c:	e1550003 	cmp	r5, r3
   1caa0:	058a7010 	streq	r7, [sl, #16]
   1caa4:	158a7014 	strne	r7, [sl, #20]
   1caa8:	e15e0007 	cmp	lr, r7
   1caac:	8affffaa 	bhi	1c95c <try_realloc_chunk.constprop.0.isra.0+0x134>
   1cab0:	e5953010 	ldr	r3, [r5, #16]
   1cab4:	e587a018 	str	sl, [r7, #24]
   1cab8:	e3530000 	cmp	r3, #0
   1cabc:	0a000003 	beq	1cad0 <try_realloc_chunk.constprop.0.isra.0+0x2a8>
   1cac0:	e15e0003 	cmp	lr, r3
   1cac4:	8affffa4 	bhi	1c95c <try_realloc_chunk.constprop.0.isra.0+0x134>
   1cac8:	e5873010 	str	r3, [r7, #16]
   1cacc:	e5837018 	str	r7, [r3, #24]
   1cad0:	e5953014 	ldr	r3, [r5, #20]
   1cad4:	e3530000 	cmp	r3, #0
   1cad8:	0affff92 	beq	1c928 <try_realloc_chunk.constprop.0.isra.0+0x100>
   1cadc:	e15e0003 	cmp	lr, r3
   1cae0:	8affff9d 	bhi	1c95c <try_realloc_chunk.constprop.0.isra.0+0x134>
   1cae4:	e5873014 	str	r3, [r7, #20]
   1cae8:	e5837018 	str	r7, [r3, #24]
   1caec:	eaffff8d 	b	1c928 <try_realloc_chunk.constprop.0.isra.0+0x100>
          set_inuse(m, p, newsize);
   1caf0:	e1800002 	orr	r0, r0, r2
          m->dvsize = 0;
   1caf4:	e3a01000 	mov	r1, #0
          set_inuse(m, p, newsize);
   1caf8:	e3802002 	orr	r2, r0, #2
   1cafc:	e5842004 	str	r2, [r4, #4]
   1cb00:	e59e2004 	ldr	r2, [lr, #4]
   1cb04:	e3822001 	orr	r2, r2, #1
   1cb08:	e58e2004 	str	r2, [lr, #4]
          m->dvsize = 0;
   1cb0c:	e5831020 	str	r1, [r3, #32]
          m->dv = 0;
   1cb10:	e583102c 	str	r1, [r3, #44]	@ 0x2c
   1cb14:	eaffff5f 	b	1c898 <try_realloc_chunk.constprop.0.isra.0+0x70>
        }
        else {
          mchunkptr r = chunk_plus_offset(p, nb);
          set_inuse(m, p, nb);
   1cb18:	e1803001 	orr	r3, r0, r1
          mchunkptr r = chunk_plus_offset(p, nb);
   1cb1c:	e0840001 	add	r0, r4, r1
          set_inuse(m, p, nb);
   1cb20:	e3833002 	orr	r3, r3, #2
          set_inuse(m, r, rsize);
          dispose_chunk(m, r, rsize);
   1cb24:	e1a01002 	mov	r1, r2
          set_inuse(m, p, nb);
   1cb28:	e5843004 	str	r3, [r4, #4]
          set_inuse(m, r, rsize);
   1cb2c:	e3823003 	orr	r3, r2, #3
   1cb30:	e5803004 	str	r3, [r0, #4]
   1cb34:	e59c3004 	ldr	r3, [ip, #4]
   1cb38:	e3833001 	orr	r3, r3, #1
   1cb3c:	e58c3004 	str	r3, [ip, #4]
          dispose_chunk(m, r, rsize);
   1cb40:	ebfffbef 	bl	1bb04 <dispose_chunk.constprop.0>
   1cb44:	eaffff53 	b	1c898 <try_realloc_chunk.constprop.0.isra.0+0x70>
        unlink_chunk(m, next, nextsize);
   1cb48:	e595c014 	ldr	ip, [r5, #20]
   1cb4c:	e35c0000 	cmp	ip, #0
   1cb50:	12856014 	addne	r6, r5, #20
   1cb54:	0a00001e 	beq	1cbd4 <try_realloc_chunk.constprop.0.isra.0+0x3ac>
   1cb58:	e1a09006 	mov	r9, r6
   1cb5c:	e1a0700c 	mov	r7, ip
   1cb60:	e28c6014 	add	r6, ip, #20
   1cb64:	e59cc014 	ldr	ip, [ip, #20]
   1cb68:	e35c0000 	cmp	ip, #0
   1cb6c:	1afffff9 	bne	1cb58 <try_realloc_chunk.constprop.0.isra.0+0x330>
   1cb70:	e597c010 	ldr	ip, [r7, #16]
   1cb74:	e2876010 	add	r6, r7, #16
   1cb78:	e35c0000 	cmp	ip, #0
   1cb7c:	1afffff5 	bne	1cb58 <try_realloc_chunk.constprop.0.isra.0+0x330>
   1cb80:	e15e0009 	cmp	lr, r9
   1cb84:	8affff74 	bhi	1c95c <try_realloc_chunk.constprop.0.isra.0+0x134>
   1cb88:	e35a0000 	cmp	sl, #0
   1cb8c:	e589c000 	str	ip, [r9]
   1cb90:	1affffb7 	bne	1ca74 <try_realloc_chunk.constprop.0.isra.0+0x24c>
   1cb94:	eaffff63 	b	1c928 <try_realloc_chunk.constprop.0.isra.0+0x100>
   1cb98:	e593c018 	ldr	ip, [r3, #24]
   1cb9c:	e3a0e001 	mov	lr, #1
   1cba0:	e1ccc61e 	bic	ip, ip, lr, lsl r6
   1cba4:	e583c018 	str	ip, [r3, #24]
   1cba8:	eaffff5e 	b	1c928 <try_realloc_chunk.constprop.0.isra.0+0x100>
   1cbac:	e15e0009 	cmp	lr, r9
   1cbb0:	8affff69 	bhi	1c95c <try_realloc_chunk.constprop.0.isra.0+0x134>
   1cbb4:	e599a00c 	ldr	sl, [r9, #12]
   1cbb8:	e155000a 	cmp	r5, sl
   1cbbc:	1affff66 	bne	1c95c <try_realloc_chunk.constprop.0.isra.0+0x134>
   1cbc0:	e1590007 	cmp	r9, r7
   1cbc4:	0afffff3 	beq	1cb98 <try_realloc_chunk.constprop.0.isra.0+0x370>
   1cbc8:	e15c0007 	cmp	ip, r7
   1cbcc:	0affff53 	beq	1c920 <try_realloc_chunk.constprop.0.isra.0+0xf8>
   1cbd0:	eaffff4d 	b	1c90c <try_realloc_chunk.constprop.0.isra.0+0xe4>
   1cbd4:	e595c010 	ldr	ip, [r5, #16]
   1cbd8:	e35c0000 	cmp	ip, #0
   1cbdc:	12856010 	addne	r6, r5, #16
   1cbe0:	1affffdc 	bne	1cb58 <try_realloc_chunk.constprop.0.isra.0+0x330>
   1cbe4:	e35a0000 	cmp	sl, #0
   1cbe8:	0affff4e 	beq	1c928 <try_realloc_chunk.constprop.0.isra.0+0x100>
   1cbec:	e595701c 	ldr	r7, [r5, #28]
   1cbf0:	e287604c 	add	r6, r7, #76	@ 0x4c
   1cbf4:	e0836106 	add	r6, r3, r6, lsl #2
   1cbf8:	e5969018 	ldr	r9, [r6, #24]
   1cbfc:	e1550009 	cmp	r5, r9
   1cc00:	0a000006 	beq	1cc20 <try_realloc_chunk.constprop.0.isra.0+0x3f8>
   1cc04:	e15e000a 	cmp	lr, sl
   1cc08:	8affff53 	bhi	1c95c <try_realloc_chunk.constprop.0.isra.0+0x134>
   1cc0c:	e59a3010 	ldr	r3, [sl, #16]
   1cc10:	e1550003 	cmp	r5, r3
   1cc14:	058ac010 	streq	ip, [sl, #16]
   1cc18:	158ac014 	strne	ip, [sl, #20]
   1cc1c:	eaffff41 	b	1c928 <try_realloc_chunk.constprop.0.isra.0+0x100>
   1cc20:	e586c018 	str	ip, [r6, #24]
   1cc24:	e3a0e001 	mov	lr, #1
   1cc28:	e593c01c 	ldr	ip, [r3, #28]
   1cc2c:	e1ccc71e 	bic	ip, ip, lr, lsl r7
   1cc30:	e583c01c 	str	ip, [r3, #28]
   1cc34:	eaffff3b 	b	1c928 <try_realloc_chunk.constprop.0.isra.0+0x100>
   1cc38:	0002b684 	.word	0x0002b684

0001cc3c <malloc>:
    if (bytes <= MAX_SMALL_REQUEST) {
   1cc3c:	e35000f4 	cmp	r0, #244	@ 0xf4
void* dlmalloc(size_t bytes) {
   1cc40:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1cc44:	e24dd00c 	sub	sp, sp, #12
    if (bytes <= MAX_SMALL_REQUEST) {
   1cc48:	8a00007d 	bhi	1ce44 <malloc+0x208>
      smallbits = gm->smallmap >> idx;
   1cc4c:	e30b566c 	movw	r5, #46700	@ 0xb66c
      nb = (bytes < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(bytes);
   1cc50:	e350000a 	cmp	r0, #10
      smallbits = gm->smallmap >> idx;
   1cc54:	e3405002 	movt	r5, #2
      nb = (bytes < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(bytes);
   1cc58:	8280400b 	addhi	r4, r0, #11
      smallbits = gm->smallmap >> idx;
   1cc5c:	e5952018 	ldr	r2, [r5, #24]
      idx = small_index(nb);
   1cc60:	81a0c1a4 	lsrhi	ip, r4, #3
   1cc64:	93a0c002 	movls	ip, #2
      nb = (bytes < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(bytes);
   1cc68:	83c44007 	bichi	r4, r4, #7
   1cc6c:	93a04010 	movls	r4, #16
      smallbits = gm->smallmap >> idx;
   1cc70:	e1a03c32 	lsr	r3, r2, ip
      if ((smallbits & 0x3U) != 0) { /* Remainderless fit to a smallbin. */
   1cc74:	e3130003 	tst	r3, #3
   1cc78:	0a00001d 	beq	1ccf4 <malloc+0xb8>
        idx += ~smallbits & 1;       /* Uses next bin if idx empty */
   1cc7c:	e1e03003 	mvn	r3, r3
   1cc80:	e2033001 	and	r3, r3, #1
   1cc84:	e083300c 	add	r3, r3, ip
        b = smallbin_at(gm, idx);
   1cc88:	e0851183 	add	r1, r5, r3, lsl #3
        p = b->fd;
   1cc8c:	e591c048 	ldr	ip, [r1, #72]	@ 0x48
        b = smallbin_at(gm, idx);
   1cc90:	e2811040 	add	r1, r1, #64	@ 0x40
        unlink_first_small_chunk(gm, b, p, idx);
   1cc94:	e59c0008 	ldr	r0, [ip, #8]
   1cc98:	e1510000 	cmp	r1, r0
   1cc9c:	03a01001 	moveq	r1, #1
   1cca0:	01c22311 	biceq	r2, r2, r1, lsl r3
   1cca4:	05852018 	streq	r2, [r5, #24]
   1cca8:	0a000007 	beq	1cccc <malloc+0x90>
   1ccac:	e5952028 	ldr	r2, [r5, #40]	@ 0x28
   1ccb0:	e1520000 	cmp	r2, r0
   1ccb4:	8a00015d 	bhi	1d230 <malloc+0x5f4>
   1ccb8:	e590200c 	ldr	r2, [r0, #12]
   1ccbc:	e152000c 	cmp	r2, ip
   1ccc0:	1a00015a 	bne	1d230 <malloc+0x5f4>
   1ccc4:	e580100c 	str	r1, [r0, #12]
   1ccc8:	e5810008 	str	r0, [r1, #8]
        set_inuse_and_pinuse(gm, p, small_index2size(idx));
   1cccc:	e1a03183 	lsl	r3, r3, #3
        mem = chunk2mem(p);
   1ccd0:	e28c0008 	add	r0, ip, #8
        set_inuse_and_pinuse(gm, p, small_index2size(idx));
   1ccd4:	e08c2003 	add	r2, ip, r3
   1ccd8:	e3833003 	orr	r3, r3, #3
   1ccdc:	e58c3004 	str	r3, [ip, #4]
   1cce0:	e5923004 	ldr	r3, [r2, #4]
   1cce4:	e3833001 	orr	r3, r3, #1
   1cce8:	e5823004 	str	r3, [r2, #4]
}
   1ccec:	e28dd00c 	add	sp, sp, #12
   1ccf0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
      else if (nb > gm->dvsize) {
   1ccf4:	e5951020 	ldr	r1, [r5, #32]
   1ccf8:	e1510004 	cmp	r1, r4
   1ccfc:	2a00014c 	bcs	1d234 <malloc+0x5f8>
        if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
   1cd00:	e3530000 	cmp	r3, #0
   1cd04:	0a0000c6 	beq	1d024 <malloc+0x3e8>
          binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
   1cd08:	e3a06001 	mov	r6, #1
          b = smallbin_at(gm, i);
   1cd0c:	e285e018 	add	lr, r5, #24
          binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
   1cd10:	e1a07c16 	lsl	r7, r6, ip
   1cd14:	e1a07617 	lsl	r7, r7, r6
   1cd18:	e2670000 	rsb	r0, r7, #0
   1cd1c:	e1800007 	orr	r0, r0, r7
   1cd20:	e0000c13 	and	r0, r0, r3, lsl ip
          binmap_t leastbit = least_bit(leftbits);
   1cd24:	e2603000 	rsb	r3, r0, #0
   1cd28:	e0033000 	and	r3, r3, r0
          compute_bit2idx(leastbit, i);
   1cd2c:	e2433001 	sub	r3, r3, #1
   1cd30:	e1a00623 	lsr	r0, r3, #12
   1cd34:	e2000010 	and	r0, r0, #16
   1cd38:	e1a03033 	lsr	r3, r3, r0
   1cd3c:	e1a0c2a3 	lsr	ip, r3, #5
   1cd40:	e20cc008 	and	ip, ip, #8
   1cd44:	e1a03c33 	lsr	r3, r3, ip
   1cd48:	e180000c 	orr	r0, r0, ip
   1cd4c:	e1a0c123 	lsr	ip, r3, #2
   1cd50:	e20cc004 	and	ip, ip, #4
   1cd54:	e1a03c33 	lsr	r3, r3, ip
   1cd58:	e080000c 	add	r0, r0, ip
   1cd5c:	e1a0c633 	lsr	ip, r3, r6
   1cd60:	e20cc002 	and	ip, ip, #2
   1cd64:	e1a03c33 	lsr	r3, r3, ip
   1cd68:	e080000c 	add	r0, r0, ip
   1cd6c:	e7e0c0d3 	ubfx	ip, r3, #1, #1
   1cd70:	e080000c 	add	r0, r0, ip
   1cd74:	e0803c33 	add	r3, r0, r3, lsr ip
          b = smallbin_at(gm, i);
   1cd78:	e08e7183 	add	r7, lr, r3, lsl #3
          p = b->fd;
   1cd7c:	e597c030 	ldr	ip, [r7, #48]	@ 0x30
          b = smallbin_at(gm, i);
   1cd80:	e2877028 	add	r7, r7, #40	@ 0x28
          unlink_first_small_chunk(gm, b, p, i);
   1cd84:	e59c0008 	ldr	r0, [ip, #8]
   1cd88:	e1570000 	cmp	r7, r0
   1cd8c:	01c26316 	biceq	r6, r2, r6, lsl r3
   1cd90:	05856018 	streq	r6, [r5, #24]
   1cd94:	0a000007 	beq	1cdb8 <malloc+0x17c>
   1cd98:	e5952028 	ldr	r2, [r5, #40]	@ 0x28
   1cd9c:	e1520000 	cmp	r2, r0
   1cda0:	8a000122 	bhi	1d230 <malloc+0x5f4>
   1cda4:	e590200c 	ldr	r2, [r0, #12]
   1cda8:	e152000c 	cmp	r2, ip
   1cdac:	1a00011f 	bne	1d230 <malloc+0x5f4>
   1cdb0:	e580700c 	str	r7, [r0, #12]
   1cdb4:	e5870008 	str	r0, [r7, #8]
          rsize = small_index2size(i) - nb;
   1cdb8:	e0642183 	rsb	r2, r4, r3, lsl #3
            set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
   1cdbc:	e3840003 	orr	r0, r4, #3
            replace_dv(gm, r, rsize);
   1cdc0:	e3510000 	cmp	r1, #0
            set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
   1cdc4:	e58c0004 	str	r0, [ip, #4]
            r = chunk_plus_offset(p, nb);
   1cdc8:	e08c4004 	add	r4, ip, r4
            set_size_and_pinuse_of_free_chunk(r, rsize);
   1cdcc:	e3820001 	orr	r0, r2, #1
   1cdd0:	e5840004 	str	r0, [r4, #4]
   1cdd4:	e78c2183 	str	r2, [ip, r3, lsl #3]
            replace_dv(gm, r, rsize);
   1cdd8:	0a000014 	beq	1ce30 <malloc+0x1f4>
   1cddc:	e1a031a1 	lsr	r3, r1, #3
   1cde0:	e3c11007 	bic	r1, r1, #7
   1cde4:	e2811028 	add	r1, r1, #40	@ 0x28
   1cde8:	e5950018 	ldr	r0, [r5, #24]
   1cdec:	e08ee001 	add	lr, lr, r1
   1cdf0:	e3a01001 	mov	r1, #1
   1cdf4:	e1a01311 	lsl	r1, r1, r3
   1cdf8:	e595302c 	ldr	r3, [r5, #44]	@ 0x2c
   1cdfc:	e1100001 	tst	r0, r1
   1ce00:	01800001 	orreq	r0, r0, r1
   1ce04:	01a0100e 	moveq	r1, lr
   1ce08:	05850018 	streq	r0, [r5, #24]
   1ce0c:	0a000003 	beq	1ce20 <malloc+0x1e4>
   1ce10:	e59e1008 	ldr	r1, [lr, #8]
   1ce14:	e5950028 	ldr	r0, [r5, #40]	@ 0x28
   1ce18:	e1510000 	cmp	r1, r0
   1ce1c:	3a000103 	bcc	1d230 <malloc+0x5f4>
   1ce20:	e58e3008 	str	r3, [lr, #8]
   1ce24:	e581300c 	str	r3, [r1, #12]
   1ce28:	e5831008 	str	r1, [r3, #8]
   1ce2c:	e583e00c 	str	lr, [r3, #12]
          mem = chunk2mem(p);
   1ce30:	e28c0008 	add	r0, ip, #8
            replace_dv(gm, r, rsize);
   1ce34:	e5852020 	str	r2, [r5, #32]
   1ce38:	e585402c 	str	r4, [r5, #44]	@ 0x2c
}
   1ce3c:	e28dd00c 	add	sp, sp, #12
   1ce40:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
      else if (nb > gm->dvsize) {
   1ce44:	e30b566c 	movw	r5, #46700	@ 0xb66c
    else if (bytes >= MAX_REQUEST)
   1ce48:	e3700041 	cmn	r0, #65	@ 0x41
      else if (nb > gm->dvsize) {
   1ce4c:	e3405002 	movt	r5, #2
   1ce50:	e5951020 	ldr	r1, [r5, #32]
    else if (bytes >= MAX_REQUEST)
   1ce54:	9a00005c 	bls	1cfcc <malloc+0x390>
    if (nb <= gm->dvsize) {
   1ce58:	e3710001 	cmn	r1, #1
      nb = MAX_SIZE_T; /* Too big to allocate. Force failure (in sys alloc) */
   1ce5c:	13e04000 	mvnne	r4, #0
    if (nb <= gm->dvsize) {
   1ce60:	0a00019d 	beq	1d4dc <malloc+0x8a0>
  ensure_initialization();
   1ce64:	e5953000 	ldr	r3, [r5]
   1ce68:	e3530000 	cmp	r3, #0
   1ce6c:	0a00028c 	beq	1d8a4 <malloc+0xc68>
  if (use_mmap(m) && nb >= mparams.mmap_threshold && m->topsize != 0) {
   1ce70:	e59531d4 	ldr	r3, [r5, #468]	@ 0x1d4
   1ce74:	e3130001 	tst	r3, #1
   1ce78:	0a000002 	beq	1ce88 <malloc+0x24c>
   1ce7c:	e595300c 	ldr	r3, [r5, #12]
   1ce80:	e1540003 	cmp	r4, r3
   1ce84:	2a00023f 	bcs	1d788 <malloc+0xb4c>
  asize = granularity_align(nb + SYS_ALLOC_PADDING);
   1ce88:	e5953008 	ldr	r3, [r5, #8]
   1ce8c:	e283802f 	add	r8, r3, #47	@ 0x2f
   1ce90:	e2633000 	rsb	r3, r3, #0
   1ce94:	e0888004 	add	r8, r8, r4
   1ce98:	e0088003 	and	r8, r8, r3
  if (asize <= nb)
   1ce9c:	e1540008 	cmp	r4, r8
   1cea0:	2a000047 	bcs	1cfc4 <malloc+0x388>
  if (m->footprint_limit != 0) {
   1cea4:	e59531d0 	ldr	r3, [r5, #464]	@ 0x1d0
   1cea8:	e3530000 	cmp	r3, #0
   1ceac:	0a000004 	beq	1cec4 <malloc+0x288>
    size_t fp = m->footprint + asize;
   1ceb0:	e59521c8 	ldr	r2, [r5, #456]	@ 0x1c8
   1ceb4:	e0881002 	add	r1, r8, r2
    if (fp <= m->footprint || fp > m->footprint_limit)
   1ceb8:	e1530001 	cmp	r3, r1
   1cebc:	21510002 	cmpcs	r1, r2
   1cec0:	9a00003f 	bls	1cfc4 <malloc+0x388>
    char* mp = (char*)(CALL_MMAP(asize));
   1cec4:	e3a00000 	mov	r0, #0
   1cec8:	e3e03000 	mvn	r3, #0
   1cecc:	e58d3000 	str	r3, [sp]
   1ced0:	e3a02003 	mov	r2, #3
   1ced4:	e3a0300a 	mov	r3, #10
   1ced8:	e1a01008 	mov	r1, r8
   1cedc:	e58d0004 	str	r0, [sp, #4]
   1cee0:	eb00099e 	bl	1f560 <mmap>
    if (mp != CMFAIL) {
   1cee4:	e3700001 	cmn	r0, #1
    char* mp = (char*)(CALL_MMAP(asize));
   1cee8:	e1a0c000 	mov	ip, r0
    if (mp != CMFAIL) {
   1ceec:	0a000031 	beq	1cfb8 <malloc+0x37c>
    if ((m->footprint += tsize) > m->max_footprint)
   1cef0:	e59531c8 	ldr	r3, [r5, #456]	@ 0x1c8
   1cef4:	e59521cc 	ldr	r2, [r5, #460]	@ 0x1cc
    if (!is_initialized(m)) { /* first-time initialization */
   1cef8:	e5956030 	ldr	r6, [r5, #48]	@ 0x30
    if ((m->footprint += tsize) > m->max_footprint)
   1cefc:	e0883003 	add	r3, r8, r3
   1cf00:	e1530002 	cmp	r3, r2
   1cf04:	e58531c8 	str	r3, [r5, #456]	@ 0x1c8
      m->max_footprint = m->footprint;
   1cf08:	858531cc 	strhi	r3, [r5, #460]	@ 0x1cc
    if (!is_initialized(m)) { /* first-time initialization */
   1cf0c:	e3560000 	cmp	r6, #0
      msegmentptr sp = &m->seg;
   1cf10:	159f2f88 	ldrne	r2, [pc, #3976]	@ 1dea0 <malloc+0x1264>
   1cf14:	11a03002 	movne	r3, r2
    if (!is_initialized(m)) { /* first-time initialization */
   1cf18:	1a000003 	bne	1cf2c <malloc+0x2f0>
   1cf1c:	ea000262 	b	1d8ac <malloc+0xc70>
        sp = (NO_SEGMENT_TRAVERSAL) ? 0 : sp->next;
   1cf20:	e5933008 	ldr	r3, [r3, #8]
      while (sp != 0 && tbase != sp->base + sp->size)
   1cf24:	e3530000 	cmp	r3, #0
   1cf28:	0a0000d0 	beq	1d270 <malloc+0x634>
   1cf2c:	e5931000 	ldr	r1, [r3]
   1cf30:	e5930004 	ldr	r0, [r3, #4]
   1cf34:	e081e000 	add	lr, r1, r0
   1cf38:	e15c000e 	cmp	ip, lr
   1cf3c:	1afffff7 	bne	1cf20 <malloc+0x2e4>
          !is_extern_segment(sp) &&
   1cf40:	e593e00c 	ldr	lr, [r3, #12]
      if (sp != 0 &&
   1cf44:	e31e0008 	tst	lr, #8
   1cf48:	1a0000c8 	bne	1d270 <malloc+0x634>
          !is_extern_segment(sp) &&
   1cf4c:	e31e0001 	tst	lr, #1
   1cf50:	0a0000c6 	beq	1d270 <malloc+0x634>
          (sp->sflags & USE_MMAP_BIT) == mmap_flag &&
   1cf54:	e1560001 	cmp	r6, r1
   1cf58:	3a0000c4 	bcc	1d270 <malloc+0x634>
          segment_holds(sp, m->top)) { /* append */
   1cf5c:	e156000c 	cmp	r6, ip
   1cf60:	2a0000c2 	bcs	1d270 <malloc+0x634>
        init_top(m, m->top, m->topsize + tsize);
   1cf64:	e5952024 	ldr	r2, [r5, #36]	@ 0x24
        sp->size += tsize;
   1cf68:	e0880000 	add	r0, r8, r0
   1cf6c:	e5830004 	str	r0, [r3, #4]
  size_t offset = align_offset(chunk2mem(p));
   1cf70:	e2161007 	ands	r1, r6, #7
   1cf74:	e2863008 	add	r3, r6, #8
  m->trim_check = mparams.trim_threshold; /* reset on each update */
   1cf78:	e5950010 	ldr	r0, [r5, #16]
  size_t offset = align_offset(chunk2mem(p));
   1cf7c:	12633000 	rsbne	r3, r3, #0
        init_top(m, m->top, m->topsize + tsize);
   1cf80:	e0882002 	add	r2, r8, r2
  size_t offset = align_offset(chunk2mem(p));
   1cf84:	12031007 	andne	r1, r3, #7
  psize -= offset;
   1cf88:	e0423001 	sub	r3, r2, r1
  p = (mchunkptr)((char*)p + offset);
   1cf8c:	e0861001 	add	r1, r6, r1
  p->head = psize | PINUSE_BIT;
   1cf90:	e383c001 	orr	ip, r3, #1
  m->top = p;
   1cf94:	e5851030 	str	r1, [r5, #48]	@ 0x30
  m->topsize = psize;
   1cf98:	e5853024 	str	r3, [r5, #36]	@ 0x24
  chunk_plus_offset(p, psize)->head = TOP_FOOT_SIZE;
   1cf9c:	e0862002 	add	r2, r6, r2
  p->head = psize | PINUSE_BIT;
   1cfa0:	e581c004 	str	ip, [r1, #4]
  chunk_plus_offset(p, psize)->head = TOP_FOOT_SIZE;
   1cfa4:	e3a01028 	mov	r1, #40	@ 0x28
   1cfa8:	e5821004 	str	r1, [r2, #4]
  m->trim_check = mparams.trim_threshold; /* reset on each update */
   1cfac:	e5850034 	str	r0, [r5, #52]	@ 0x34
    if (nb < m->topsize) { /* Allocate from new or extended top space */
   1cfb0:	e1540003 	cmp	r4, r3
   1cfb4:	3a00000e 	bcc	1cff4 <malloc+0x3b8>
  MALLOC_FAILURE_ACTION;
   1cfb8:	ebfffa15 	bl	1b814 <__errno>
   1cfbc:	e3a0300c 	mov	r3, #12
   1cfc0:	e5803000 	str	r3, [r0]
    return 0; /* wraparound */
   1cfc4:	e3a00000 	mov	r0, #0
   1cfc8:	eaffff47 	b	1ccec <malloc+0xb0>
      if (gm->treemap != 0 && (mem = tmalloc_large(gm, nb)) != 0) {
   1cfcc:	e595e01c 	ldr	lr, [r5, #28]
      nb = pad_request(bytes);
   1cfd0:	e280400b 	add	r4, r0, #11
   1cfd4:	e3c44007 	bic	r4, r4, #7
      if (gm->treemap != 0 && (mem = tmalloc_large(gm, nb)) != 0) {
   1cfd8:	e35e0000 	cmp	lr, #0
   1cfdc:	1a000149 	bne	1d508 <malloc+0x8cc>
    if (nb <= gm->dvsize) {
   1cfe0:	e1540001 	cmp	r4, r1
   1cfe4:	9a000092 	bls	1d234 <malloc+0x5f8>
    else if (nb < gm->topsize) { /* Split top */
   1cfe8:	e5953024 	ldr	r3, [r5, #36]	@ 0x24
   1cfec:	e1530004 	cmp	r3, r4
   1cff0:	9affff9b 	bls	1ce64 <malloc+0x228>
      mchunkptr p = m->top;
   1cff4:	e5952030 	ldr	r2, [r5, #48]	@ 0x30
      size_t rsize = m->topsize -= nb;
   1cff8:	e0433004 	sub	r3, r3, r4
   1cffc:	e5853024 	str	r3, [r5, #36]	@ 0x24
      r->head = rsize | PINUSE_BIT;
   1d000:	e3833001 	orr	r3, r3, #1
      mchunkptr r = m->top = chunk_plus_offset(p, nb);
   1d004:	e0821004 	add	r1, r2, r4
      set_size_and_pinuse_of_inuse_chunk(m, p, nb);
   1d008:	e3844003 	orr	r4, r4, #3
      mchunkptr r = m->top = chunk_plus_offset(p, nb);
   1d00c:	e5851030 	str	r1, [r5, #48]	@ 0x30
      return chunk2mem(p);
   1d010:	e2820008 	add	r0, r2, #8
      r->head = rsize | PINUSE_BIT;
   1d014:	e5813004 	str	r3, [r1, #4]
      set_size_and_pinuse_of_inuse_chunk(m, p, nb);
   1d018:	e5824004 	str	r4, [r2, #4]
}
   1d01c:	e28dd00c 	add	sp, sp, #12
   1d020:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        else if (gm->treemap != 0 && (mem = tmalloc_small(gm, nb)) != 0) {
   1d024:	e595001c 	ldr	r0, [r5, #28]
   1d028:	e3500000 	cmp	r0, #0
   1d02c:	0affffed 	beq	1cfe8 <malloc+0x3ac>
  binmap_t leastbit = least_bit(m->treemap);
   1d030:	e2603000 	rsb	r3, r0, #0
   1d034:	e0033000 	and	r3, r3, r0
  compute_bit2idx(leastbit, i);
   1d038:	e2433001 	sub	r3, r3, #1
   1d03c:	e1a0c623 	lsr	ip, r3, #12
   1d040:	e20cc010 	and	ip, ip, #16
   1d044:	e1a03c33 	lsr	r3, r3, ip
   1d048:	e1a0e2a3 	lsr	lr, r3, #5
   1d04c:	e20ee008 	and	lr, lr, #8
   1d050:	e1a03e33 	lsr	r3, r3, lr
   1d054:	e18cc00e 	orr	ip, ip, lr
   1d058:	e1a0e123 	lsr	lr, r3, #2
   1d05c:	e20ee004 	and	lr, lr, #4
   1d060:	e1a03e33 	lsr	r3, r3, lr
   1d064:	e08cc00e 	add	ip, ip, lr
   1d068:	e1a0e0a3 	lsr	lr, r3, #1
   1d06c:	e20ee002 	and	lr, lr, #2
   1d070:	e1a03e33 	lsr	r3, r3, lr
   1d074:	e08cc00e 	add	ip, ip, lr
   1d078:	e7e0e0d3 	ubfx	lr, r3, #1, #1
  v = t = *treebin_at(m, i);
   1d07c:	e08cc00e 	add	ip, ip, lr
   1d080:	e08c3e33 	add	r3, ip, r3, lsr lr
   1d084:	e0853103 	add	r3, r5, r3, lsl #2
   1d088:	e5933148 	ldr	r3, [r3, #328]	@ 0x148
  rsize = chunksize(t) - nb;
   1d08c:	e593c004 	ldr	ip, [r3, #4]
  v = t = *treebin_at(m, i);
   1d090:	e1a0e003 	mov	lr, r3
  rsize = chunksize(t) - nb;
   1d094:	e3ccc007 	bic	ip, ip, #7
   1d098:	e04cc004 	sub	ip, ip, r4
  while ((t = leftmost_child(t)) != 0) {
   1d09c:	ea000006 	b	1d0bc <malloc+0x480>
    size_t trem = chunksize(t) - nb;
   1d0a0:	e5963004 	ldr	r3, [r6, #4]
   1d0a4:	e3c33007 	bic	r3, r3, #7
   1d0a8:	e0433004 	sub	r3, r3, r4
      v = t;
   1d0ac:	e153000c 	cmp	r3, ip
   1d0b0:	31a0c003 	movcc	ip, r3
   1d0b4:	31a0e006 	movcc	lr, r6
   1d0b8:	e1a03006 	mov	r3, r6
  while ((t = leftmost_child(t)) != 0) {
   1d0bc:	e5936010 	ldr	r6, [r3, #16]
   1d0c0:	e3560000 	cmp	r6, #0
   1d0c4:	1afffff5 	bne	1d0a0 <malloc+0x464>
   1d0c8:	e5936014 	ldr	r6, [r3, #20]
   1d0cc:	e3560000 	cmp	r6, #0
   1d0d0:	1afffff2 	bne	1d0a0 <malloc+0x464>
  if (RTCHECK(ok_address(m, v))) {
   1d0d4:	e5959028 	ldr	r9, [r5, #40]	@ 0x28
   1d0d8:	e159000e 	cmp	r9, lr
   1d0dc:	8a000053 	bhi	1d230 <malloc+0x5f4>
    mchunkptr r = chunk_plus_offset(v, nb);
   1d0e0:	e08e7004 	add	r7, lr, r4
    if (RTCHECK(ok_next(v, r))) {
   1d0e4:	e157000e 	cmp	r7, lr
   1d0e8:	9a000050 	bls	1d230 <malloc+0x5f4>
      unlink_large_chunk(m, v);
   1d0ec:	e59e800c 	ldr	r8, [lr, #12]
   1d0f0:	e59ea018 	ldr	sl, [lr, #24]
   1d0f4:	e158000e 	cmp	r8, lr
   1d0f8:	0a0002f1 	beq	1dcc4 <malloc+0x1088>
   1d0fc:	e59e3008 	ldr	r3, [lr, #8]
   1d100:	e1590003 	cmp	r9, r3
   1d104:	8a000049 	bhi	1d230 <malloc+0x5f4>
   1d108:	e593000c 	ldr	r0, [r3, #12]
   1d10c:	e150000e 	cmp	r0, lr
   1d110:	1a000046 	bne	1d230 <malloc+0x5f4>
   1d114:	e5980008 	ldr	r0, [r8, #8]
   1d118:	e150000e 	cmp	r0, lr
   1d11c:	1a000043 	bne	1d230 <malloc+0x5f4>
   1d120:	e35a0000 	cmp	sl, #0
   1d124:	e583800c 	str	r8, [r3, #12]
   1d128:	e5883008 	str	r3, [r8, #8]
   1d12c:	0a00001c 	beq	1d1a4 <malloc+0x568>
   1d130:	e59e301c 	ldr	r3, [lr, #28]
   1d134:	e283304c 	add	r3, r3, #76	@ 0x4c
   1d138:	e0850103 	add	r0, r5, r3, lsl #2
   1d13c:	e5900018 	ldr	r0, [r0, #24]
   1d140:	e150000e 	cmp	r0, lr
   1d144:	0a000321 	beq	1ddd0 <malloc+0x1194>
   1d148:	e159000a 	cmp	r9, sl
   1d14c:	8a000037 	bhi	1d230 <malloc+0x5f4>
   1d150:	e59a3010 	ldr	r3, [sl, #16]
   1d154:	e153000e 	cmp	r3, lr
   1d158:	058a8010 	streq	r8, [sl, #16]
   1d15c:	158a8014 	strne	r8, [sl, #20]
   1d160:	e1590008 	cmp	r9, r8
   1d164:	8a000031 	bhi	1d230 <malloc+0x5f4>
   1d168:	e59e3010 	ldr	r3, [lr, #16]
   1d16c:	e588a018 	str	sl, [r8, #24]
   1d170:	e3530000 	cmp	r3, #0
   1d174:	0a000003 	beq	1d188 <malloc+0x54c>
   1d178:	e1590003 	cmp	r9, r3
   1d17c:	8a00002b 	bhi	1d230 <malloc+0x5f4>
   1d180:	e5883010 	str	r3, [r8, #16]
   1d184:	e5838018 	str	r8, [r3, #24]
   1d188:	e59e3014 	ldr	r3, [lr, #20]
   1d18c:	e3530000 	cmp	r3, #0
   1d190:	0a000003 	beq	1d1a4 <malloc+0x568>
   1d194:	e1590003 	cmp	r9, r3
   1d198:	8a000024 	bhi	1d230 <malloc+0x5f4>
   1d19c:	e5883014 	str	r3, [r8, #20]
   1d1a0:	e5838018 	str	r8, [r3, #24]
      if (rsize < MIN_CHUNK_SIZE)
   1d1a4:	e35c000f 	cmp	ip, #15
   1d1a8:	9a0002eb 	bls	1dd5c <malloc+0x1120>
        replace_dv(m, r, rsize);
   1d1ac:	e3510000 	cmp	r1, #0
        set_size_and_pinuse_of_inuse_chunk(m, v, nb);
   1d1b0:	e3844003 	orr	r4, r4, #3
        set_size_and_pinuse_of_free_chunk(r, rsize);
   1d1b4:	e38c3001 	orr	r3, ip, #1
        set_size_and_pinuse_of_inuse_chunk(m, v, nb);
   1d1b8:	e58e4004 	str	r4, [lr, #4]
        set_size_and_pinuse_of_free_chunk(r, rsize);
   1d1bc:	e5873004 	str	r3, [r7, #4]
   1d1c0:	e787c00c 	str	ip, [r7, ip]
        replace_dv(m, r, rsize);
   1d1c4:	0a000011 	beq	1d210 <malloc+0x5d4>
   1d1c8:	e1a041a1 	lsr	r4, r1, #3
   1d1cc:	e3a00001 	mov	r0, #1
   1d1d0:	e3c13007 	bic	r3, r1, #7
   1d1d4:	e59f1cc8 	ldr	r1, [pc, #3272]	@ 1dea4 <malloc+0x1268>
   1d1d8:	e1a00410 	lsl	r0, r0, r4
   1d1dc:	e1120000 	tst	r2, r0
   1d1e0:	e0833001 	add	r3, r3, r1
   1d1e4:	01822000 	orreq	r2, r2, r0
   1d1e8:	e595102c 	ldr	r1, [r5, #44]	@ 0x2c
   1d1ec:	05852018 	streq	r2, [r5, #24]
   1d1f0:	01a02003 	moveq	r2, r3
   1d1f4:	0a000002 	beq	1d204 <malloc+0x5c8>
   1d1f8:	e5932008 	ldr	r2, [r3, #8]
   1d1fc:	e1590002 	cmp	r9, r2
   1d200:	8a00000a 	bhi	1d230 <malloc+0x5f4>
   1d204:	e5831008 	str	r1, [r3, #8]
   1d208:	e582100c 	str	r1, [r2, #12]
   1d20c:	e1c120f8 	strd	r2, [r1, #8]
      return chunk2mem(v);
   1d210:	e28e0008 	add	r0, lr, #8
        replace_dv(m, r, rsize);
   1d214:	e585c020 	str	ip, [r5, #32]
   1d218:	e585702c 	str	r7, [r5, #44]	@ 0x2c
      return chunk2mem(v);
   1d21c:	eafffeb2 	b	1ccec <malloc+0xb0>
    insert_chunk(m, q, psize);
   1d220:	e5923008 	ldr	r3, [r2, #8]
   1d224:	e5951028 	ldr	r1, [r5, #40]	@ 0x28
   1d228:	e1530001 	cmp	r3, r1
   1d22c:	2a0000a4 	bcs	1d4c4 <malloc+0x888>
        unlink_first_small_chunk(gm, b, p, idx);
   1d230:	ebffe535 	bl	1670c <abort>
      size_t rsize = gm->dvsize - nb;
   1d234:	e0413004 	sub	r3, r1, r4
      mchunkptr p = gm->dv;
   1d238:	e595c02c 	ldr	ip, [r5, #44]	@ 0x2c
      if (rsize >= MIN_CHUNK_SIZE) { /* split dv */
   1d23c:	e353000f 	cmp	r3, #15
   1d240:	9a0001e0 	bls	1d9c8 <malloc+0xd8c>
        mchunkptr r = gm->dv = chunk_plus_offset(p, nb);
   1d244:	e08c2004 	add	r2, ip, r4
        set_size_and_pinuse_of_free_chunk(r, rsize);
   1d248:	e3830001 	orr	r0, r3, #1
        set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
   1d24c:	e3844003 	orr	r4, r4, #3
        gm->dvsize = rsize;
   1d250:	e5853020 	str	r3, [r5, #32]
        mchunkptr r = gm->dv = chunk_plus_offset(p, nb);
   1d254:	e585202c 	str	r2, [r5, #44]	@ 0x2c
        set_size_and_pinuse_of_free_chunk(r, rsize);
   1d258:	e5820004 	str	r0, [r2, #4]
   1d25c:	e78c3001 	str	r3, [ip, r1]
        set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
   1d260:	e58c4004 	str	r4, [ip, #4]
  return chunk2mem(p);
   1d264:	e28c0008 	add	r0, ip, #8
}
   1d268:	e28dd00c 	add	sp, sp, #12
   1d26c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (tbase < m->least_addr)
   1d270:	e5953028 	ldr	r3, [r5, #40]	@ 0x28
        while (sp != 0 && sp->base != tbase + tsize)
   1d274:	e08c0008 	add	r0, ip, r8
        if (tbase < m->least_addr)
   1d278:	e15c0003 	cmp	ip, r3
        sp = &m->seg;
   1d27c:	e59f3c1c 	ldr	r3, [pc, #3100]	@ 1dea0 <malloc+0x1264>
          m->least_addr = tbase;
   1d280:	3585c028 	strcc	ip, [r5, #40]	@ 0x28
        while (sp != 0 && sp->base != tbase + tsize)
   1d284:	ea000002 	b	1d294 <malloc+0x658>
          sp = (NO_SEGMENT_TRAVERSAL) ? 0 : sp->next;
   1d288:	e5933008 	ldr	r3, [r3, #8]
        while (sp != 0 && sp->base != tbase + tsize)
   1d28c:	e3530000 	cmp	r3, #0
   1d290:	0a00003c 	beq	1d388 <malloc+0x74c>
   1d294:	e5931000 	ldr	r1, [r3]
   1d298:	e1510000 	cmp	r1, r0
   1d29c:	1afffff9 	bne	1d288 <malloc+0x64c>
            !is_extern_segment(sp) &&
   1d2a0:	e593100c 	ldr	r1, [r3, #12]
        if (sp != 0 &&
   1d2a4:	e211e008 	ands	lr, r1, #8
   1d2a8:	1a000036 	bne	1d388 <malloc+0x74c>
            !is_extern_segment(sp) &&
   1d2ac:	e3110001 	tst	r1, #1
   1d2b0:	0a000034 	beq	1d388 <malloc+0x74c>
          sp->size += tsize;
   1d2b4:	e5932004 	ldr	r2, [r3, #4]
  mchunkptr p = align_as_chunk(newbase);
   1d2b8:	e31c0007 	tst	ip, #7
          sp->base = tbase;
   1d2bc:	e583c000 	str	ip, [r3]
          char* oldbase = sp->base;
   1d2c0:	e1a07000 	mov	r7, r0
          sp->size += tsize;
   1d2c4:	e0822008 	add	r2, r2, r8
   1d2c8:	e5832004 	str	r2, [r3, #4]
  mchunkptr p = align_as_chunk(newbase);
   1d2cc:	e28c3008 	add	r3, ip, #8
   1d2d0:	12633000 	rsbne	r3, r3, #0
   1d2d4:	12033007 	andne	r3, r3, #7
   1d2d8:	108cc003 	addne	ip, ip, r3
  mchunkptr oldfirst = align_as_chunk(oldbase);
   1d2dc:	e3100007 	tst	r0, #7
   1d2e0:	e2803008 	add	r3, r0, #8
   1d2e4:	12633000 	rsbne	r3, r3, #0
   1d2e8:	12033007 	andne	r3, r3, #7
   1d2ec:	10807003 	addne	r7, r0, r3
  set_size_and_pinuse_of_inuse_chunk(m, p, nb);
   1d2f0:	e3843003 	orr	r3, r4, #3
  if (oldfirst == m->top) {
   1d2f4:	e1560007 	cmp	r6, r7
  size_t psize = (char*)oldfirst - (char*)p;
   1d2f8:	e047200c 	sub	r2, r7, ip
  size_t qsize = psize - nb;
   1d2fc:	e0422004 	sub	r2, r2, r4
  set_size_and_pinuse_of_inuse_chunk(m, p, nb);
   1d300:	e58c3004 	str	r3, [ip, #4]
  mchunkptr q = chunk_plus_offset(p, nb);
   1d304:	e08c4004 	add	r4, ip, r4
  if (oldfirst == m->top) {
   1d308:	0a0002c8 	beq	1de30 <malloc+0x11f4>
  else if (oldfirst == m->dv) {
   1d30c:	e595302c 	ldr	r3, [r5, #44]	@ 0x2c
   1d310:	e1530007 	cmp	r3, r7
   1d314:	0a000310 	beq	1df5c <malloc+0x1320>
    if (!is_inuse(oldfirst)) {
   1d318:	e5970004 	ldr	r0, [r7, #4]
   1d31c:	e2003003 	and	r3, r0, #3
   1d320:	e3530001 	cmp	r3, #1
   1d324:	0a000314 	beq	1df7c <malloc+0x1340>
    set_free_with_pinuse(q, qsize, oldfirst);
   1d328:	e5973004 	ldr	r3, [r7, #4]
    insert_chunk(m, q, qsize);
   1d32c:	e35200ff 	cmp	r2, #255	@ 0xff
   1d330:	e1a001a2 	lsr	r0, r2, #3
    set_free_with_pinuse(q, qsize, oldfirst);
   1d334:	e3c33001 	bic	r3, r3, #1
   1d338:	e5873004 	str	r3, [r7, #4]
   1d33c:	e3823001 	orr	r3, r2, #1
   1d340:	e5843004 	str	r3, [r4, #4]
   1d344:	e7842002 	str	r2, [r4, r2]
    insert_chunk(m, q, qsize);
   1d348:	8a0002d7 	bhi	1deac <malloc+0x1270>
   1d34c:	e5952018 	ldr	r2, [r5, #24]
   1d350:	e3a01001 	mov	r1, #1
   1d354:	e59f3b4c 	ldr	r3, [pc, #2892]	@ 1dea8 <malloc+0x126c>
   1d358:	e012e011 	ands	lr, r2, r1, lsl r0
   1d35c:	e1a01011 	lsl	r1, r1, r0
   1d360:	e0833180 	add	r3, r3, r0, lsl #3
   1d364:	e2833028 	add	r3, r3, #40	@ 0x28
   1d368:	1a00032c 	bne	1e020 <malloc+0x13e4>
   1d36c:	e1822001 	orr	r2, r2, r1
   1d370:	e5852018 	str	r2, [r5, #24]
   1d374:	e1a02003 	mov	r2, r3
   1d378:	e5834008 	str	r4, [r3, #8]
   1d37c:	e582400c 	str	r4, [r2, #12]
   1d380:	e1c420f8 	strd	r2, [r4, #8]
   1d384:	eaffffb6 	b	1d264 <malloc+0x628>
   1d388:	e59f3b10 	ldr	r3, [pc, #2832]	@ 1dea0 <malloc+0x1264>
   1d38c:	ea000002 	b	1d39c <malloc+0x760>
    if ((sp = sp->next) == 0)
   1d390:	e5933008 	ldr	r3, [r3, #8]
   1d394:	e3530000 	cmp	r3, #0
   1d398:	0a0003b5 	beq	1e274 <malloc+0x1638>
    if (addr >= sp->base && addr < sp->base + sp->size)
   1d39c:	e5931000 	ldr	r1, [r3]
   1d3a0:	e1560001 	cmp	r6, r1
   1d3a4:	3afffff9 	bcc	1d390 <malloc+0x754>
   1d3a8:	e5930004 	ldr	r0, [r3, #4]
   1d3ac:	e0811000 	add	r1, r1, r0
   1d3b0:	e1560001 	cmp	r6, r1
   1d3b4:	2afffff5 	bcs	1d390 <malloc+0x754>
  size_t offset = align_offset(chunk2mem(rawsp));
   1d3b8:	e2413027 	sub	r3, r1, #39	@ 0x27
   1d3bc:	e1a0e001 	mov	lr, r1
   1d3c0:	e3130007 	tst	r3, #7
    p->head = FENCEPOST_HEAD;
   1d3c4:	e3a0a007 	mov	sl, #7
  size_t offset = align_offset(chunk2mem(rawsp));
   1d3c8:	12639000 	rsbne	r9, r3, #0
   1d3cc:	03e0902e 	mvneq	r9, #46	@ 0x2e
   1d3d0:	12099007 	andne	r9, r9, #7
  char* csp = (asp < (old_top + MIN_CHUNK_SIZE))? old_top : asp;
   1d3d4:	e2863010 	add	r3, r6, #16
   1d3d8:	1249902f 	subne	r9, r9, #47	@ 0x2f
  char* asp = rawsp + offset;
   1d3dc:	e0819009 	add	r9, r1, r9
  init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);
   1d3e0:	e2481028 	sub	r1, r8, #40	@ 0x28
  char* csp = (asp < (old_top + MIN_CHUNK_SIZE))? old_top : asp;
   1d3e4:	e1590003 	cmp	r9, r3
  size_t offset = align_offset(chunk2mem(p));
   1d3e8:	e28c3008 	add	r3, ip, #8
  char* csp = (asp < (old_top + MIN_CHUNK_SIZE))? old_top : asp;
   1d3ec:	31a09006 	movcc	r9, r6
  size_t offset = align_offset(chunk2mem(p));
   1d3f0:	e31c0007 	tst	ip, #7
   1d3f4:	12633000 	rsbne	r3, r3, #0
   1d3f8:	01a03001 	moveq	r3, r1
   1d3fc:	12033007 	andne	r3, r3, #7
   1d400:	01a0000c 	moveq	r0, ip
  p = (mchunkptr)((char*)p + offset);
   1d404:	108c0003 	addne	r0, ip, r3
  psize -= offset;
   1d408:	10413003 	subne	r3, r1, r3
  m->topsize = psize;
   1d40c:	e5853024 	str	r3, [r5, #36]	@ 0x24
  p->head = psize | PINUSE_BIT;
   1d410:	e3833001 	orr	r3, r3, #1
  m->top = p;
   1d414:	e5850030 	str	r0, [r5, #48]	@ 0x30
  chunk_plus_offset(p, psize)->head = TOP_FOOT_SIZE;
   1d418:	e08c1001 	add	r1, ip, r1
  p->head = psize | PINUSE_BIT;
   1d41c:	e5803004 	str	r3, [r0, #4]
  chunk_plus_offset(p, psize)->head = TOP_FOOT_SIZE;
   1d420:	e3a00028 	mov	r0, #40	@ 0x28
  m->trim_check = mparams.trim_threshold; /* reset on each update */
   1d424:	e5953010 	ldr	r3, [r5, #16]
  msegmentptr ss = (msegmentptr)(chunk2mem(sp));
   1d428:	e289b008 	add	fp, r9, #8
  chunk_plus_offset(p, psize)->head = TOP_FOOT_SIZE;
   1d42c:	e5810004 	str	r0, [r1, #4]
  m->trim_check = mparams.trim_threshold; /* reset on each update */
   1d430:	e289701c 	add	r7, r9, #28
   1d434:	e5853034 	str	r3, [r5, #52]	@ 0x34
  set_size_and_pinuse_of_inuse_chunk(m, sp, ssize);
   1d438:	e3a0301b 	mov	r3, #27
   1d43c:	e5893004 	str	r3, [r9, #4]
  *ss = m->seg; /* Push current record */
   1d440:	e892000f 	ldm	r2, {r0, r1, r2, r3}
   1d444:	e88b000f 	stm	fp, {r0, r1, r2, r3}
  m->seg.sflags = mmapped;
   1d448:	e3a03001 	mov	r3, #1
  m->seg.base = tbase;
   1d44c:	e585c1d8 	str	ip, [r5, #472]	@ 0x1d8
  m->seg.size = tsize;
   1d450:	e58581dc 	str	r8, [r5, #476]	@ 0x1dc
  m->seg.sflags = mmapped;
   1d454:	e58531e4 	str	r3, [r5, #484]	@ 0x1e4
  m->seg.next = ss;
   1d458:	e585b1e0 	str	fp, [r5, #480]	@ 0x1e0
    p->head = FENCEPOST_HEAD;
   1d45c:	e487a004 	str	sl, [r7], #4
    if ((char*)(&(nextp->head)) < old_end)
   1d460:	e15e0007 	cmp	lr, r7
   1d464:	8afffffc 	bhi	1d45c <malloc+0x820>
  if (csp != old_top) {
   1d468:	e1560009 	cmp	r6, r9
   1d46c:	0a000184 	beq	1da84 <malloc+0xe48>
    set_free_with_pinuse(q, psize, tn);
   1d470:	e5993004 	ldr	r3, [r9, #4]
    size_t psize = csp - old_top;
   1d474:	e0491006 	sub	r1, r9, r6
    insert_chunk(m, q, psize);
   1d478:	e35100ff 	cmp	r1, #255	@ 0xff
   1d47c:	e1a001a1 	lsr	r0, r1, #3
    set_free_with_pinuse(q, psize, tn);
   1d480:	e3c33001 	bic	r3, r3, #1
   1d484:	e5893004 	str	r3, [r9, #4]
   1d488:	e3813001 	orr	r3, r1, #1
   1d48c:	e5863004 	str	r3, [r6, #4]
   1d490:	e5891000 	str	r1, [r9]
    insert_chunk(m, q, psize);
   1d494:	8a00014d 	bhi	1d9d0 <malloc+0xd94>
   1d498:	e59f2a08 	ldr	r2, [pc, #2568]	@ 1dea8 <malloc+0x126c>
   1d49c:	e3a03001 	mov	r3, #1
   1d4a0:	e5951018 	ldr	r1, [r5, #24]
   1d4a4:	e1a03013 	lsl	r3, r3, r0
   1d4a8:	e0822180 	add	r2, r2, r0, lsl #3
   1d4ac:	e1110003 	tst	r1, r3
   1d4b0:	e2822028 	add	r2, r2, #40	@ 0x28
   1d4b4:	1affff59 	bne	1d220 <malloc+0x5e4>
   1d4b8:	e1811003 	orr	r1, r1, r3
   1d4bc:	e1a03002 	mov	r3, r2
   1d4c0:	e5851018 	str	r1, [r5, #24]
   1d4c4:	e5826008 	str	r6, [r2, #8]
   1d4c8:	e583600c 	str	r6, [r3, #12]
   1d4cc:	e5863008 	str	r3, [r6, #8]
    if (nb < m->topsize) { /* Allocate from new or extended top space */
   1d4d0:	e5953024 	ldr	r3, [r5, #36]	@ 0x24
    insert_chunk(m, q, psize);
   1d4d4:	e586200c 	str	r2, [r6, #12]
   1d4d8:	eafffeb4 	b	1cfb0 <malloc+0x374>
      mchunkptr p = gm->dv;
   1d4dc:	e595c02c 	ldr	ip, [r5, #44]	@ 0x2c
   1d4e0:	e1a02001 	mov	r2, r1
        gm->dvsize = 0;
   1d4e4:	e3a03000 	mov	r3, #0
        set_inuse_and_pinuse(gm, p, dvs);
   1d4e8:	e08c1001 	add	r1, ip, r1
        gm->dvsize = 0;
   1d4ec:	e5853020 	str	r3, [r5, #32]
        gm->dv = 0;
   1d4f0:	e585302c 	str	r3, [r5, #44]	@ 0x2c
        set_inuse_and_pinuse(gm, p, dvs);
   1d4f4:	e58c2004 	str	r2, [ip, #4]
   1d4f8:	e5913004 	ldr	r3, [r1, #4]
   1d4fc:	e3833001 	orr	r3, r3, #1
   1d500:	e5813004 	str	r3, [r1, #4]
      mem = chunk2mem(p);
   1d504:	eaffff56 	b	1d264 <malloc+0x628>
  compute_tree_index(nb, idx);
   1d508:	e3540401 	cmp	r4, #16777216	@ 0x1000000
   1d50c:	e1a02424 	lsr	r2, r4, #8
  size_t rsize = -nb; /* Unsigned negation */
   1d510:	e2646000 	rsb	r6, r4, #0
  compute_tree_index(nb, idx);
   1d514:	2a0000dc 	bcs	1d88c <malloc+0xc50>
   1d518:	e2423c01 	sub	r3, r2, #256	@ 0x100
   1d51c:	e1a03823 	lsr	r3, r3, #16
   1d520:	e2033008 	and	r3, r3, #8
   1d524:	e1a02312 	lsl	r2, r2, r3
   1d528:	e2420a01 	sub	r0, r2, #4096	@ 0x1000
   1d52c:	e1a00820 	lsr	r0, r0, #16
   1d530:	e2000004 	and	r0, r0, #4
   1d534:	e1a02012 	lsl	r2, r2, r0
   1d538:	e1833000 	orr	r3, r3, r0
   1d53c:	e2420901 	sub	r0, r2, #16384	@ 0x4000
   1d540:	e1a00820 	lsr	r0, r0, #16
   1d544:	e2000002 	and	r0, r0, #2
   1d548:	e1a02012 	lsl	r2, r2, r0
   1d54c:	e0833000 	add	r3, r3, r0
   1d550:	e06337a2 	rsb	r3, r3, r2, lsr #15
   1d554:	e2838015 	add	r8, r3, #21
   1d558:	e283300e 	add	r3, r3, #14
   1d55c:	e1a08834 	lsr	r8, r4, r8
   1d560:	e2088001 	and	r8, r8, #1
   1d564:	e0888083 	add	r8, r8, r3, lsl #1
  if ((t = *treebin_at(m, idx)) != 0) {
   1d568:	e0853108 	add	r3, r5, r8, lsl #2
   1d56c:	e5932148 	ldr	r2, [r3, #328]	@ 0x148
   1d570:	e3520000 	cmp	r2, #0
   1d574:	0a0000f5 	beq	1d950 <malloc+0xd14>
    size_t sizebits = nb << leftshift_for_tree_index(idx);
   1d578:	e358001f 	cmp	r8, #31
   1d57c:	11a070a8 	lsrne	r7, r8, #1
   1d580:	01a07004 	moveq	r7, r4
   1d584:	12677019 	rsbne	r7, r7, #25
   1d588:	11a07714 	lslne	r7, r4, r7
    tchunkptr rst = 0;  /* The deepest untaken right subtree */
   1d58c:	e3a00000 	mov	r0, #0
  tchunkptr v = 0;
   1d590:	e1a0c000 	mov	ip, r0
   1d594:	ea000000 	b	1d59c <malloc+0x960>
      sizebits <<= 1;
   1d598:	e1a07087 	lsl	r7, r7, #1
      size_t trem = chunksize(t) - nb;
   1d59c:	e5923004 	ldr	r3, [r2, #4]
   1d5a0:	e3c33007 	bic	r3, r3, #7
   1d5a4:	e0433004 	sub	r3, r3, r4
      if (trem < rsize) {
   1d5a8:	e1530006 	cmp	r3, r6
   1d5ac:	2a000003 	bcs	1d5c0 <malloc+0x984>
        if ((rsize = trem) == 0)
   1d5b0:	e3530000 	cmp	r3, #0
   1d5b4:	0a000134 	beq	1da8c <malloc+0xe50>
   1d5b8:	e1a06003 	mov	r6, r3
        v = t;
   1d5bc:	e1a0c002 	mov	ip, r2
      t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];
   1d5c0:	e1a09fa7 	lsr	r9, r7, #31
      rt = t->child[1];
   1d5c4:	e5923014 	ldr	r3, [r2, #20]
      t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];
   1d5c8:	e2899004 	add	r9, r9, #4
   1d5cc:	e7922109 	ldr	r2, [r2, r9, lsl #2]
        rst = rt;
   1d5d0:	e3530000 	cmp	r3, #0
   1d5d4:	11530002 	cmpne	r3, r2
   1d5d8:	11a00003 	movne	r0, r3
      if (t == 0) {
   1d5dc:	e3520000 	cmp	r2, #0
   1d5e0:	1affffec 	bne	1d598 <malloc+0x95c>
  if (t == 0 && v == 0) { /* set t to root of next non-empty treebin */
   1d5e4:	e19c3000 	orrs	r3, ip, r0
   1d5e8:	0a0000d8 	beq	1d950 <malloc+0xd14>
  while (t != 0) { /* find smallest of tree or subtree */
   1d5ec:	e3500000 	cmp	r0, #0
   1d5f0:	1a000001 	bne	1d5fc <malloc+0x9c0>
   1d5f4:	ea00000c 	b	1d62c <malloc+0x9f0>
   1d5f8:	e1a00003 	mov	r0, r3
    size_t trem = chunksize(t) - nb;
   1d5fc:	e5903004 	ldr	r3, [r0, #4]
   1d600:	e3c33007 	bic	r3, r3, #7
   1d604:	e0433004 	sub	r3, r3, r4
      v = t;
   1d608:	e1560003 	cmp	r6, r3
   1d60c:	81a06003 	movhi	r6, r3
    t = leftmost_child(t);
   1d610:	e5903010 	ldr	r3, [r0, #16]
      v = t;
   1d614:	81a0c000 	movhi	ip, r0
    t = leftmost_child(t);
   1d618:	e3530000 	cmp	r3, #0
   1d61c:	1afffff5 	bne	1d5f8 <malloc+0x9bc>
   1d620:	e5903014 	ldr	r3, [r0, #20]
  while (t != 0) { /* find smallest of tree or subtree */
   1d624:	e3530000 	cmp	r3, #0
   1d628:	1afffff2 	bne	1d5f8 <malloc+0x9bc>
  if (v != 0 && rsize < (size_t)(m->dvsize - nb)) {
   1d62c:	e35c0000 	cmp	ip, #0
   1d630:	0afffe6a 	beq	1cfe0 <malloc+0x3a4>
   1d634:	e0413004 	sub	r3, r1, r4
   1d638:	e1560003 	cmp	r6, r3
   1d63c:	2afffe67 	bcs	1cfe0 <malloc+0x3a4>
    if (RTCHECK(ok_address(m, v))) { /* split */
   1d640:	e5958028 	ldr	r8, [r5, #40]	@ 0x28
   1d644:	e158000c 	cmp	r8, ip
   1d648:	8afffef8 	bhi	1d230 <malloc+0x5f4>
      mchunkptr r = chunk_plus_offset(v, nb);
   1d64c:	e08c7004 	add	r7, ip, r4
      if (RTCHECK(ok_next(v, r))) {
   1d650:	e15c0007 	cmp	ip, r7
   1d654:	2afffef5 	bcs	1d230 <malloc+0x5f4>
        unlink_large_chunk(m, v);
   1d658:	e59c900c 	ldr	r9, [ip, #12]
   1d65c:	e59ca018 	ldr	sl, [ip, #24]
   1d660:	e15c0009 	cmp	ip, r9
   1d664:	0a000131 	beq	1db30 <malloc+0xef4>
   1d668:	e59c3008 	ldr	r3, [ip, #8]
   1d66c:	e1580003 	cmp	r8, r3
   1d670:	8afffeee 	bhi	1d230 <malloc+0x5f4>
   1d674:	e593200c 	ldr	r2, [r3, #12]
   1d678:	e15c0002 	cmp	ip, r2
   1d67c:	1afffeeb 	bne	1d230 <malloc+0x5f4>
   1d680:	e5992008 	ldr	r2, [r9, #8]
   1d684:	e15c0002 	cmp	ip, r2
   1d688:	1afffee8 	bne	1d230 <malloc+0x5f4>
   1d68c:	e35a0000 	cmp	sl, #0
   1d690:	e583900c 	str	r9, [r3, #12]
   1d694:	e5893008 	str	r3, [r9, #8]
   1d698:	0a00001e 	beq	1d718 <malloc+0xadc>
   1d69c:	e59c301c 	ldr	r3, [ip, #28]
   1d6a0:	e283304c 	add	r3, r3, #76	@ 0x4c
   1d6a4:	e0852103 	add	r2, r5, r3, lsl #2
   1d6a8:	e5922018 	ldr	r2, [r2, #24]
   1d6ac:	e152000c 	cmp	r2, ip
   1d6b0:	00853103 	addeq	r3, r5, r3, lsl #2
   1d6b4:	05839018 	streq	r9, [r3, #24]
   1d6b8:	0a000005 	beq	1d6d4 <malloc+0xa98>
   1d6bc:	e158000a 	cmp	r8, sl
   1d6c0:	8afffeda 	bhi	1d230 <malloc+0x5f4>
   1d6c4:	e59a3010 	ldr	r3, [sl, #16]
   1d6c8:	e15c0003 	cmp	ip, r3
   1d6cc:	058a9010 	streq	r9, [sl, #16]
   1d6d0:	158a9014 	strne	r9, [sl, #20]
   1d6d4:	e1580009 	cmp	r8, r9
   1d6d8:	8afffed4 	bhi	1d230 <malloc+0x5f4>
   1d6dc:	e59c3010 	ldr	r3, [ip, #16]
   1d6e0:	e589a018 	str	sl, [r9, #24]
   1d6e4:	e3530000 	cmp	r3, #0
   1d6e8:	0a000003 	beq	1d6fc <malloc+0xac0>
   1d6ec:	e1580003 	cmp	r8, r3
   1d6f0:	8afffece 	bhi	1d230 <malloc+0x5f4>
   1d6f4:	e5893010 	str	r3, [r9, #16]
   1d6f8:	e5839018 	str	r9, [r3, #24]
   1d6fc:	e59c3014 	ldr	r3, [ip, #20]
   1d700:	e3530000 	cmp	r3, #0
   1d704:	0a000003 	beq	1d718 <malloc+0xadc>
   1d708:	e1580003 	cmp	r8, r3
   1d70c:	8afffec7 	bhi	1d230 <malloc+0x5f4>
   1d710:	e5893014 	str	r3, [r9, #20]
   1d714:	e5839018 	str	r9, [r3, #24]
        if (rsize < MIN_CHUNK_SIZE)
   1d718:	e356000f 	cmp	r6, #15
   1d71c:	9a000120 	bls	1dba4 <malloc+0xf68>
          insert_chunk(m, r, rsize);
   1d720:	e35600ff 	cmp	r6, #255	@ 0xff
          set_size_and_pinuse_of_inuse_chunk(m, v, nb);
   1d724:	e3844003 	orr	r4, r4, #3
          set_size_and_pinuse_of_free_chunk(r, rsize);
   1d728:	e3863001 	orr	r3, r6, #1
          set_size_and_pinuse_of_inuse_chunk(m, v, nb);
   1d72c:	e58c4004 	str	r4, [ip, #4]
          insert_chunk(m, r, rsize);
   1d730:	e1a011a6 	lsr	r1, r6, #3
          set_size_and_pinuse_of_free_chunk(r, rsize);
   1d734:	e5873004 	str	r3, [r7, #4]
   1d738:	e7876006 	str	r6, [r7, r6]
          insert_chunk(m, r, rsize);
   1d73c:	8a000120 	bhi	1dbc4 <malloc+0xf88>
   1d740:	e59f3760 	ldr	r3, [pc, #1888]	@ 1dea8 <malloc+0x126c>
   1d744:	e3a02001 	mov	r2, #1
   1d748:	e5950018 	ldr	r0, [r5, #24]
   1d74c:	e1a02112 	lsl	r2, r2, r1
   1d750:	e0833181 	add	r3, r3, r1, lsl #3
   1d754:	e1100002 	tst	r0, r2
   1d758:	01800002 	orreq	r0, r0, r2
   1d75c:	e2833028 	add	r3, r3, #40	@ 0x28
   1d760:	05850018 	streq	r0, [r5, #24]
   1d764:	01a02003 	moveq	r2, r3
   1d768:	0a000002 	beq	1d778 <malloc+0xb3c>
   1d76c:	e5932008 	ldr	r2, [r3, #8]
   1d770:	e1580002 	cmp	r8, r2
   1d774:	8afffead 	bhi	1d230 <malloc+0x5f4>
   1d778:	e5837008 	str	r7, [r3, #8]
   1d77c:	e582700c 	str	r7, [r2, #12]
   1d780:	e1c720f8 	strd	r2, [r7, #8]
   1d784:	eafffeb6 	b	1d264 <malloc+0x628>
  if (use_mmap(m) && nb >= mparams.mmap_threshold && m->topsize != 0) {
   1d788:	e5953024 	ldr	r3, [r5, #36]	@ 0x24
   1d78c:	e3530000 	cmp	r3, #0
   1d790:	0afffdbc 	beq	1ce88 <malloc+0x24c>
  size_t mmsize = mmap_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
   1d794:	e5953004 	ldr	r3, [r5, #4]
   1d798:	e283601e 	add	r6, r3, #30
   1d79c:	e2633000 	rsb	r3, r3, #0
   1d7a0:	e0866004 	add	r6, r6, r4
   1d7a4:	e0066003 	and	r6, r6, r3
  if (m->footprint_limit != 0) {
   1d7a8:	e59531d0 	ldr	r3, [r5, #464]	@ 0x1d0
   1d7ac:	e3530000 	cmp	r3, #0
   1d7b0:	0a000008 	beq	1d7d8 <malloc+0xb9c>
    size_t fp = m->footprint + mmsize;
   1d7b4:	e59521c8 	ldr	r2, [r5, #456]	@ 0x1c8
   1d7b8:	e0860002 	add	r0, r6, r2
    if (fp <= m->footprint || fp > m->footprint_limit)
   1d7bc:	e1530000 	cmp	r3, r0
   1d7c0:	23a01000 	movcs	r1, #0
   1d7c4:	33a01001 	movcc	r1, #1
   1d7c8:	e1520000 	cmp	r2, r0
   1d7cc:	23811001 	orrcs	r1, r1, #1
   1d7d0:	e3510000 	cmp	r1, #0
   1d7d4:	1a00017f 	bne	1ddd8 <malloc+0x119c>
  if (mmsize > nb) {     /* Check for wrap around 0 */
   1d7d8:	e1540006 	cmp	r4, r6
   1d7dc:	2afffda9 	bcs	1ce88 <malloc+0x24c>
    char* mm = (char*)(CALL_DIRECT_MMAP(mmsize));
   1d7e0:	e3a00000 	mov	r0, #0
   1d7e4:	e3e03000 	mvn	r3, #0
   1d7e8:	e58d3000 	str	r3, [sp]
   1d7ec:	e3a02003 	mov	r2, #3
   1d7f0:	e3a0300a 	mov	r3, #10
   1d7f4:	e1a01006 	mov	r1, r6
   1d7f8:	e58d0004 	str	r0, [sp, #4]
   1d7fc:	eb000757 	bl	1f560 <mmap>
    if (mm != CMFAIL) {
   1d800:	e3700001 	cmn	r0, #1
    char* mm = (char*)(CALL_DIRECT_MMAP(mmsize));
   1d804:	e1a03000 	mov	r3, r0
    if (mm != CMFAIL) {
   1d808:	0afffd9e 	beq	1ce88 <malloc+0x24c>
      size_t offset = align_offset(chunk2mem(mm));
   1d80c:	e210c007 	ands	ip, r0, #7
   1d810:	e2800008 	add	r0, r0, #8
   1d814:	1260c000 	rsbne	ip, r0, #0
   1d818:	01a01006 	moveq	r1, r6
   1d81c:	120cc007 	andne	ip, ip, #7
      size_t psize = mmsize - offset - MMAP_FOOT_PAD;
   1d820:	01a02003 	moveq	r2, r3
   1d824:	1046100c 	subne	r1, r6, ip
      mchunkptr p = (mchunkptr)(mm + offset);
   1d828:	1083200c 	addne	r2, r3, ip
      size_t psize = mmsize - offset - MMAP_FOOT_PAD;
   1d82c:	e2411010 	sub	r1, r1, #16
      p->prev_foot = offset;
   1d830:	e582c000 	str	ip, [r2]
      p->head = psize;
   1d834:	e5821004 	str	r1, [r2, #4]
      return chunk2mem(p);
   1d838:	12820008 	addne	r0, r2, #8
      chunk_plus_offset(p, psize)->head = FENCEPOST_HEAD;
   1d83c:	e0822001 	add	r2, r2, r1
      if (m->least_addr == 0 || mm < m->least_addr)
   1d840:	e5951028 	ldr	r1, [r5, #40]	@ 0x28
      chunk_plus_offset(p, psize)->head = FENCEPOST_HEAD;
   1d844:	e3a0c007 	mov	ip, #7
   1d848:	e582c004 	str	ip, [r2, #4]
   1d84c:	e3a0c000 	mov	ip, #0
      if (m->least_addr == 0 || mm < m->least_addr)
   1d850:	e1530001 	cmp	r3, r1
      chunk_plus_offset(p, psize)->head = FENCEPOST_HEAD;
   1d854:	e582c008 	str	ip, [r2, #8]
      if (m->least_addr == 0 || mm < m->least_addr)
   1d858:	23a02000 	movcs	r2, #0
   1d85c:	33a02001 	movcc	r2, #1
   1d860:	e151000c 	cmp	r1, ip
   1d864:	03822001 	orreq	r2, r2, #1
   1d868:	e152000c 	cmp	r2, ip
      if ((m->footprint += mmsize) > m->max_footprint)
   1d86c:	e59521c8 	ldr	r2, [r5, #456]	@ 0x1c8
        m->least_addr = mm;
   1d870:	15853028 	strne	r3, [r5, #40]	@ 0x28
      if ((m->footprint += mmsize) > m->max_footprint)
   1d874:	e59531cc 	ldr	r3, [r5, #460]	@ 0x1cc
   1d878:	e0866002 	add	r6, r6, r2
   1d87c:	e58561c8 	str	r6, [r5, #456]	@ 0x1c8
   1d880:	e1560003 	cmp	r6, r3
        m->max_footprint = m->footprint;
   1d884:	858561cc 	strhi	r6, [r5, #460]	@ 0x1cc
   1d888:	eafffd17 	b	1ccec <malloc+0xb0>
  if ((t = *treebin_at(m, idx)) != 0) {
   1d88c:	e59521c4 	ldr	r2, [r5, #452]	@ 0x1c4
   1d890:	e3520000 	cmp	r2, #0
   1d894:	11a07004 	movne	r7, r4
  compute_tree_index(nb, idx);
   1d898:	13a0801f 	movne	r8, #31
  if ((t = *treebin_at(m, idx)) != 0) {
   1d89c:	1affff3a 	bne	1d58c <malloc+0x950>
   1d8a0:	eafffdce 	b	1cfe0 <malloc+0x3a4>
  if (mparams.magic == 0) {
   1d8a4:	ebfff87a 	bl	1ba94 <init_mparams.part.0>
  return 1;
   1d8a8:	eafffd70 	b	1ce70 <malloc+0x234>
      if (m->least_addr == 0 || tbase < m->least_addr)
   1d8ac:	e5952028 	ldr	r2, [r5, #40]	@ 0x28
      m->seg.base = tbase;
   1d8b0:	e58501d8 	str	r0, [r5, #472]	@ 0x1d8
      m->seg.size = tsize;
   1d8b4:	e58581dc 	str	r8, [r5, #476]	@ 0x1dc
      if (m->least_addr == 0 || tbase < m->least_addr)
   1d8b8:	e16f3f12 	clz	r3, r2
   1d8bc:	e1a032a3 	lsr	r3, r3, #5
   1d8c0:	e1500002 	cmp	r0, r2
   1d8c4:	33833001 	orrcc	r3, r3, #1
   1d8c8:	e3530000 	cmp	r3, #0
      m->seg.sflags = mmap_flag;
   1d8cc:	e3a03001 	mov	r3, #1
   1d8d0:	e58531e4 	str	r3, [r5, #484]	@ 0x1e4
      m->magic = mparams.magic;
   1d8d4:	e5953000 	ldr	r3, [r5]
        m->least_addr = tbase;
   1d8d8:	15850028 	strne	r0, [r5, #40]	@ 0x28
      m->magic = mparams.magic;
   1d8dc:	e585303c 	str	r3, [r5, #60]	@ 0x3c
      m->release_checks = MAX_RELEASE_CHECK_RATE;
   1d8e0:	e3003fff 	movw	r3, #4095	@ 0xfff
   1d8e4:	e5853038 	str	r3, [r5, #56]	@ 0x38
  for (i = 0; i < NSMALLBINS; ++i) {
   1d8e8:	e59f35b4 	ldr	r3, [pc, #1460]	@ 1dea4 <malloc+0x1268>
   1d8ec:	e2831c01 	add	r1, r3, #256	@ 0x100
    sbinptr bin = smallbin_at(m,i);
   1d8f0:	e1a02003 	mov	r2, r3
    bin->fd = bin->bk = bin;
   1d8f4:	e5a32008 	str	r2, [r3, #8]!
  for (i = 0; i < NSMALLBINS; ++i) {
   1d8f8:	e1510003 	cmp	r1, r3
    bin->fd = bin->bk = bin;
   1d8fc:	e5832004 	str	r2, [r3, #4]
  for (i = 0; i < NSMALLBINS; ++i) {
   1d900:	1afffffa 	bne	1d8f0 <malloc+0xcb4>
  size_t offset = align_offset(chunk2mem(p));
   1d904:	e28c3008 	add	r3, ip, #8
   1d908:	e31c0007 	tst	ip, #7
   1d90c:	12633000 	rsbne	r3, r3, #0
        init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);
   1d910:	e2488028 	sub	r8, r8, #40	@ 0x28
  size_t offset = align_offset(chunk2mem(p));
   1d914:	12033007 	andne	r3, r3, #7
   1d918:	01a03008 	moveq	r3, r8
  p = (mchunkptr)((char*)p + offset);
   1d91c:	108c2003 	addne	r2, ip, r3
  m->trim_check = mparams.trim_threshold; /* reset on each update */
   1d920:	e5951010 	ldr	r1, [r5, #16]
  psize -= offset;
   1d924:	10483003 	subne	r3, r8, r3
   1d928:	01a0200c 	moveq	r2, ip
  p->head = psize | PINUSE_BIT;
   1d92c:	e3830001 	orr	r0, r3, #1
  m->top = p;
   1d930:	e5852030 	str	r2, [r5, #48]	@ 0x30
  m->topsize = psize;
   1d934:	e5853024 	str	r3, [r5, #36]	@ 0x24
  chunk_plus_offset(p, psize)->head = TOP_FOOT_SIZE;
   1d938:	e08c8008 	add	r8, ip, r8
  p->head = psize | PINUSE_BIT;
   1d93c:	e5820004 	str	r0, [r2, #4]
  chunk_plus_offset(p, psize)->head = TOP_FOOT_SIZE;
   1d940:	e3a02028 	mov	r2, #40	@ 0x28
   1d944:	e5882004 	str	r2, [r8, #4]
  m->trim_check = mparams.trim_threshold; /* reset on each update */
   1d948:	e5851034 	str	r1, [r5, #52]	@ 0x34
}
   1d94c:	eafffd97 	b	1cfb0 <malloc+0x374>
    binmap_t leftbits = left_bits(idx2bit(idx)) & m->treemap;
   1d950:	e3e03001 	mvn	r3, #1
    if (leftbits != 0) {
   1d954:	e01e2813 	ands	r2, lr, r3, lsl r8
   1d958:	0afffda0 	beq	1cfe0 <malloc+0x3a4>
      binmap_t leastbit = least_bit(leftbits);
   1d95c:	e2623000 	rsb	r3, r2, #0
   1d960:	e0033002 	and	r3, r3, r2
      compute_bit2idx(leastbit, i);
   1d964:	e2433001 	sub	r3, r3, #1
   1d968:	e1a02623 	lsr	r2, r3, #12
   1d96c:	e2022010 	and	r2, r2, #16
   1d970:	e1a03233 	lsr	r3, r3, r2
   1d974:	e1a002a3 	lsr	r0, r3, #5
   1d978:	e2000008 	and	r0, r0, #8
   1d97c:	e1a03033 	lsr	r3, r3, r0
   1d980:	e1822000 	orr	r2, r2, r0
   1d984:	e1a00123 	lsr	r0, r3, #2
   1d988:	e2000004 	and	r0, r0, #4
   1d98c:	e1a03033 	lsr	r3, r3, r0
   1d990:	e0822000 	add	r2, r2, r0
   1d994:	e1a000a3 	lsr	r0, r3, #1
   1d998:	e2000002 	and	r0, r0, #2
   1d99c:	e1a03033 	lsr	r3, r3, r0
   1d9a0:	e0822000 	add	r2, r2, r0
   1d9a4:	e7e000d3 	ubfx	r0, r3, #1, #1
      t = *treebin_at(m, i);
   1d9a8:	e0822000 	add	r2, r2, r0
   1d9ac:	e0823033 	add	r3, r2, r3, lsr r0
   1d9b0:	e0853103 	add	r3, r5, r3, lsl #2
   1d9b4:	e5930148 	ldr	r0, [r3, #328]	@ 0x148
  while (t != 0) { /* find smallest of tree or subtree */
   1d9b8:	e3500000 	cmp	r0, #0
   1d9bc:	13a0c000 	movne	ip, #0
   1d9c0:	1affff0d 	bne	1d5fc <malloc+0x9c0>
   1d9c4:	eafffd85 	b	1cfe0 <malloc+0x3a4>
        set_inuse_and_pinuse(gm, p, dvs);
   1d9c8:	e3812003 	orr	r2, r1, #3
   1d9cc:	eafffec4 	b	1d4e4 <malloc+0x8a8>
    insert_chunk(m, q, psize);
   1d9d0:	e3510401 	cmp	r1, #16777216	@ 0x1000000
   1d9d4:	e1a02421 	lsr	r2, r1, #8
   1d9d8:	2a00004f 	bcs	1db1c <malloc+0xee0>
   1d9dc:	e2423c01 	sub	r3, r2, #256	@ 0x100
   1d9e0:	e3a00001 	mov	r0, #1
   1d9e4:	e1a03823 	lsr	r3, r3, #16
   1d9e8:	e2033008 	and	r3, r3, #8
   1d9ec:	e1a02312 	lsl	r2, r2, r3
   1d9f0:	e242ea01 	sub	lr, r2, #4096	@ 0x1000
   1d9f4:	e1a0e82e 	lsr	lr, lr, #16
   1d9f8:	e20ee004 	and	lr, lr, #4
   1d9fc:	e1a0ce12 	lsl	ip, r2, lr
   1da00:	e183200e 	orr	r2, r3, lr
   1da04:	e24c3901 	sub	r3, ip, #16384	@ 0x4000
   1da08:	e1a03823 	lsr	r3, r3, #16
   1da0c:	e2033002 	and	r3, r3, #2
   1da10:	e1a0c31c 	lsl	ip, ip, r3
   1da14:	e0822003 	add	r2, r2, r3
   1da18:	e06227ac 	rsb	r2, r2, ip, lsr #15
   1da1c:	e2823015 	add	r3, r2, #21
   1da20:	e282200e 	add	r2, r2, #14
   1da24:	e1a03331 	lsr	r3, r1, r3
   1da28:	e0033000 	and	r3, r3, r0
   1da2c:	e0833012 	add	r3, r3, r2, lsl r0
   1da30:	e283204c 	add	r2, r3, #76	@ 0x4c
   1da34:	e1a00310 	lsl	r0, r0, r3
   1da38:	e1a07102 	lsl	r7, r2, #2
   1da3c:	e595c01c 	ldr	ip, [r5, #28]
   1da40:	e3a0e000 	mov	lr, #0
   1da44:	e586301c 	str	r3, [r6, #28]
   1da48:	e586e010 	str	lr, [r6, #16]
   1da4c:	e11c0000 	tst	ip, r0
   1da50:	e586e014 	str	lr, [r6, #20]
   1da54:	1a000010 	bne	1da9c <malloc+0xe60>
   1da58:	e0852102 	add	r2, r5, r2, lsl #2
   1da5c:	e18cc000 	orr	ip, ip, r0
    if (nb < m->topsize) { /* Allocate from new or extended top space */
   1da60:	e5953024 	ldr	r3, [r5, #36]	@ 0x24
    insert_chunk(m, q, psize);
   1da64:	e5826018 	str	r6, [r2, #24]
   1da68:	e59f2438 	ldr	r2, [pc, #1080]	@ 1dea8 <malloc+0x126c>
   1da6c:	e585c01c 	str	ip, [r5, #28]
   1da70:	e5866008 	str	r6, [r6, #8]
   1da74:	e0822007 	add	r2, r2, r7
   1da78:	e586600c 	str	r6, [r6, #12]
   1da7c:	e5862018 	str	r2, [r6, #24]
   1da80:	eafffd4a 	b	1cfb0 <malloc+0x374>
    if (nb < m->topsize) { /* Allocate from new or extended top space */
   1da84:	e5953024 	ldr	r3, [r5, #36]	@ 0x24
   1da88:	eafffd48 	b	1cfb0 <malloc+0x374>
        v = t;
   1da8c:	e1a0c002 	mov	ip, r2
        if ((rsize = trem) == 0)
   1da90:	e1a06003 	mov	r6, r3
   1da94:	e1a00002 	mov	r0, r2
   1da98:	eafffed7 	b	1d5fc <malloc+0x9c0>
    insert_chunk(m, q, psize);
   1da9c:	e353001f 	cmp	r3, #31
   1daa0:	e0852102 	add	r2, r5, r2, lsl #2
   1daa4:	11a030a3 	lsrne	r3, r3, #1
   1daa8:	01a03001 	moveq	r3, r1
   1daac:	e5920018 	ldr	r0, [r2, #24]
   1dab0:	12633019 	rsbne	r3, r3, #25
   1dab4:	11a03311 	lslne	r3, r1, r3
   1dab8:	ea000006 	b	1dad8 <malloc+0xe9c>
   1dabc:	e1a0cfa3 	lsr	ip, r3, #31
   1dac0:	e1a03083 	lsl	r3, r3, #1
   1dac4:	e080e10c 	add	lr, r0, ip, lsl #2
   1dac8:	e59e2010 	ldr	r2, [lr, #16]
   1dacc:	e3520000 	cmp	r2, #0
   1dad0:	0a000096 	beq	1dd30 <malloc+0x10f4>
   1dad4:	e1a00002 	mov	r0, r2
   1dad8:	e5902004 	ldr	r2, [r0, #4]
   1dadc:	e3c22007 	bic	r2, r2, #7
   1dae0:	e1510002 	cmp	r1, r2
   1dae4:	1afffff4 	bne	1dabc <malloc+0xe80>
   1dae8:	e5903008 	ldr	r3, [r0, #8]
   1daec:	e5952028 	ldr	r2, [r5, #40]	@ 0x28
   1daf0:	e1500002 	cmp	r0, r2
   1daf4:	21530002 	cmpcs	r3, r2
   1daf8:	3afffdcc 	bcc	1d230 <malloc+0x5f4>
   1dafc:	e583600c 	str	r6, [r3, #12]
   1db00:	e5806008 	str	r6, [r0, #8]
   1db04:	e5863008 	str	r3, [r6, #8]
   1db08:	e3a03000 	mov	r3, #0
   1db0c:	e5863018 	str	r3, [r6, #24]
   1db10:	e586000c 	str	r0, [r6, #12]
    if (nb < m->topsize) { /* Allocate from new or extended top space */
   1db14:	e5953024 	ldr	r3, [r5, #36]	@ 0x24
    insert_chunk(m, q, psize);
   1db18:	eafffd24 	b	1cfb0 <malloc+0x374>
   1db1c:	e3a00102 	mov	r0, #-2147483648	@ 0x80000000
   1db20:	e3a07f6b 	mov	r7, #428	@ 0x1ac
   1db24:	e3a0301f 	mov	r3, #31
   1db28:	e3a0206b 	mov	r2, #107	@ 0x6b
   1db2c:	eaffffc2 	b	1da3c <malloc+0xe00>
        unlink_large_chunk(m, v);
   1db30:	e59c3014 	ldr	r3, [ip, #20]
   1db34:	e3530000 	cmp	r3, #0
   1db38:	128c2014 	addne	r2, ip, #20
   1db3c:	0a000094 	beq	1dd94 <malloc+0x1158>
   1db40:	e1a00002 	mov	r0, r2
   1db44:	e1a01003 	mov	r1, r3
   1db48:	e2832014 	add	r2, r3, #20
   1db4c:	e5933014 	ldr	r3, [r3, #20]
   1db50:	e3530000 	cmp	r3, #0
   1db54:	1afffff9 	bne	1db40 <malloc+0xf04>
   1db58:	e5913010 	ldr	r3, [r1, #16]
   1db5c:	e2812010 	add	r2, r1, #16
   1db60:	e3530000 	cmp	r3, #0
   1db64:	1afffff5 	bne	1db40 <malloc+0xf04>
   1db68:	e1580000 	cmp	r8, r0
   1db6c:	8afffdaf 	bhi	1d230 <malloc+0x5f4>
   1db70:	e35a0000 	cmp	sl, #0
   1db74:	e5803000 	str	r3, [r0]
   1db78:	0afffee6 	beq	1d718 <malloc+0xadc>
   1db7c:	e599301c 	ldr	r3, [r9, #28]
   1db80:	e283304c 	add	r3, r3, #76	@ 0x4c
   1db84:	e0853103 	add	r3, r5, r3, lsl #2
   1db88:	e5932018 	ldr	r2, [r3, #24]
   1db8c:	e1520009 	cmp	r2, r9
   1db90:	01a09001 	moveq	r9, r1
   1db94:	05831018 	streq	r1, [r3, #24]
   1db98:	0afffecd 	beq	1d6d4 <malloc+0xa98>
   1db9c:	e1a09001 	mov	r9, r1
   1dba0:	eafffec5 	b	1d6bc <malloc+0xa80>
          set_inuse_and_pinuse(m, v, (rsize + nb));
   1dba4:	e0846006 	add	r6, r4, r6
   1dba8:	e08c2006 	add	r2, ip, r6
   1dbac:	e3866003 	orr	r6, r6, #3
   1dbb0:	e5923004 	ldr	r3, [r2, #4]
   1dbb4:	e58c6004 	str	r6, [ip, #4]
   1dbb8:	e3833001 	orr	r3, r3, #1
   1dbbc:	e5823004 	str	r3, [r2, #4]
   1dbc0:	eafffda7 	b	1d264 <malloc+0x628>
          insert_chunk(m, r, rsize);
   1dbc4:	e3560401 	cmp	r6, #16777216	@ 0x1000000
   1dbc8:	e1a02426 	lsr	r2, r6, #8
   1dbcc:	2a00006b 	bcs	1dd80 <malloc+0x1144>
   1dbd0:	e2423c01 	sub	r3, r2, #256	@ 0x100
   1dbd4:	e3a01001 	mov	r1, #1
   1dbd8:	e1a03823 	lsr	r3, r3, #16
   1dbdc:	e2033008 	and	r3, r3, #8
   1dbe0:	e1a02312 	lsl	r2, r2, r3
   1dbe4:	e242ea01 	sub	lr, r2, #4096	@ 0x1000
   1dbe8:	e1a0e82e 	lsr	lr, lr, #16
   1dbec:	e20ee004 	and	lr, lr, #4
   1dbf0:	e1a00e12 	lsl	r0, r2, lr
   1dbf4:	e183200e 	orr	r2, r3, lr
   1dbf8:	e2403901 	sub	r3, r0, #16384	@ 0x4000
   1dbfc:	e1a03823 	lsr	r3, r3, #16
   1dc00:	e2033002 	and	r3, r3, #2
   1dc04:	e1a00310 	lsl	r0, r0, r3
   1dc08:	e0822003 	add	r2, r2, r3
   1dc0c:	e06227a0 	rsb	r2, r2, r0, lsr #15
   1dc10:	e2823015 	add	r3, r2, #21
   1dc14:	e282200e 	add	r2, r2, #14
   1dc18:	e1a03336 	lsr	r3, r6, r3
   1dc1c:	e0033001 	and	r3, r3, r1
   1dc20:	e0833112 	add	r3, r3, r2, lsl r1
   1dc24:	e283204c 	add	r2, r3, #76	@ 0x4c
   1dc28:	e1a01311 	lsl	r1, r1, r3
   1dc2c:	e1a04102 	lsl	r4, r2, #2
   1dc30:	e595001c 	ldr	r0, [r5, #28]
   1dc34:	e3a0e000 	mov	lr, #0
   1dc38:	e587301c 	str	r3, [r7, #28]
   1dc3c:	e587e010 	str	lr, [r7, #16]
   1dc40:	e1100001 	tst	r0, r1
   1dc44:	e587e014 	str	lr, [r7, #20]
   1dc48:	0a000056 	beq	1dda8 <malloc+0x116c>
   1dc4c:	e353001f 	cmp	r3, #31
   1dc50:	e0852102 	add	r2, r5, r2, lsl #2
   1dc54:	11a030a3 	lsrne	r3, r3, #1
   1dc58:	01a03006 	moveq	r3, r6
   1dc5c:	e5921018 	ldr	r1, [r2, #24]
   1dc60:	12633019 	rsbne	r3, r3, #25
   1dc64:	11a03316 	lslne	r3, r6, r3
   1dc68:	ea000006 	b	1dc88 <malloc+0x104c>
   1dc6c:	e1a00fa3 	lsr	r0, r3, #31
   1dc70:	e1a03083 	lsl	r3, r3, #1
   1dc74:	e081e100 	add	lr, r1, r0, lsl #2
   1dc78:	e59e2010 	ldr	r2, [lr, #16]
   1dc7c:	e3520000 	cmp	r2, #0
   1dc80:	0a00005c 	beq	1ddf8 <malloc+0x11bc>
   1dc84:	e1a01002 	mov	r1, r2
   1dc88:	e5912004 	ldr	r2, [r1, #4]
   1dc8c:	e3c22007 	bic	r2, r2, #7
   1dc90:	e1560002 	cmp	r6, r2
   1dc94:	1afffff4 	bne	1dc6c <malloc+0x1030>
   1dc98:	e5913008 	ldr	r3, [r1, #8]
   1dc9c:	e1580003 	cmp	r8, r3
   1dca0:	91580001 	cmpls	r8, r1
   1dca4:	8afffd61 	bhi	1d230 <malloc+0x5f4>
   1dca8:	e3a02000 	mov	r2, #0
   1dcac:	e583700c 	str	r7, [r3, #12]
   1dcb0:	e5817008 	str	r7, [r1, #8]
   1dcb4:	e5873008 	str	r3, [r7, #8]
   1dcb8:	e587100c 	str	r1, [r7, #12]
   1dcbc:	e5872018 	str	r2, [r7, #24]
   1dcc0:	eafffd67 	b	1d264 <malloc+0x628>
      unlink_large_chunk(m, v);
   1dcc4:	e59e3014 	ldr	r3, [lr, #20]
   1dcc8:	e3530000 	cmp	r3, #0
   1dccc:	128e0014 	addne	r0, lr, #20
   1dcd0:	0a000051 	beq	1de1c <malloc+0x11e0>
   1dcd4:	e1a06000 	mov	r6, r0
   1dcd8:	e1a08003 	mov	r8, r3
   1dcdc:	e2830014 	add	r0, r3, #20
   1dce0:	e5933014 	ldr	r3, [r3, #20]
   1dce4:	e3530000 	cmp	r3, #0
   1dce8:	1afffff9 	bne	1dcd4 <malloc+0x1098>
   1dcec:	e5983010 	ldr	r3, [r8, #16]
   1dcf0:	e2880010 	add	r0, r8, #16
   1dcf4:	e3530000 	cmp	r3, #0
   1dcf8:	1afffff5 	bne	1dcd4 <malloc+0x1098>
   1dcfc:	e1590006 	cmp	r9, r6
   1dd00:	8afffd4a 	bhi	1d230 <malloc+0x5f4>
   1dd04:	e35a0000 	cmp	sl, #0
   1dd08:	e5863000 	str	r3, [r6]
   1dd0c:	0afffd24 	beq	1d1a4 <malloc+0x568>
   1dd10:	e59e301c 	ldr	r3, [lr, #28]
   1dd14:	e283304c 	add	r3, r3, #76	@ 0x4c
   1dd18:	e0853103 	add	r3, r5, r3, lsl #2
   1dd1c:	e5930018 	ldr	r0, [r3, #24]
   1dd20:	e15e0000 	cmp	lr, r0
   1dd24:	1afffd07 	bne	1d148 <malloc+0x50c>
   1dd28:	e5838018 	str	r8, [r3, #24]
   1dd2c:	eafffd0b 	b	1d160 <malloc+0x524>
    insert_chunk(m, q, psize);
   1dd30:	e5952028 	ldr	r2, [r5, #40]	@ 0x28
   1dd34:	e28c3004 	add	r3, ip, #4
   1dd38:	e0803103 	add	r3, r0, r3, lsl #2
   1dd3c:	e1520003 	cmp	r2, r3
   1dd40:	8afffd3a 	bhi	1d230 <malloc+0x5f4>
   1dd44:	e58e6010 	str	r6, [lr, #16]
    if (nb < m->topsize) { /* Allocate from new or extended top space */
   1dd48:	e5953024 	ldr	r3, [r5, #36]	@ 0x24
    insert_chunk(m, q, psize);
   1dd4c:	e5860018 	str	r0, [r6, #24]
   1dd50:	e5866008 	str	r6, [r6, #8]
   1dd54:	e586600c 	str	r6, [r6, #12]
   1dd58:	eafffc94 	b	1cfb0 <malloc+0x374>
        set_inuse_and_pinuse(m, v, (rsize + nb));
   1dd5c:	e084c00c 	add	ip, r4, ip
      return chunk2mem(v);
   1dd60:	e28e0008 	add	r0, lr, #8
        set_inuse_and_pinuse(m, v, (rsize + nb));
   1dd64:	e08e200c 	add	r2, lr, ip
   1dd68:	e38cc003 	orr	ip, ip, #3
   1dd6c:	e5923004 	ldr	r3, [r2, #4]
   1dd70:	e58ec004 	str	ip, [lr, #4]
   1dd74:	e3833001 	orr	r3, r3, #1
   1dd78:	e5823004 	str	r3, [r2, #4]
      return chunk2mem(v);
   1dd7c:	eafffbda 	b	1ccec <malloc+0xb0>
   1dd80:	e3a01102 	mov	r1, #-2147483648	@ 0x80000000
   1dd84:	e3a04f6b 	mov	r4, #428	@ 0x1ac
          insert_chunk(m, r, rsize);
   1dd88:	e3a0301f 	mov	r3, #31
   1dd8c:	e3a0206b 	mov	r2, #107	@ 0x6b
   1dd90:	eaffffa6 	b	1dc30 <malloc+0xff4>
        unlink_large_chunk(m, v);
   1dd94:	e59c3010 	ldr	r3, [ip, #16]
   1dd98:	e3530000 	cmp	r3, #0
   1dd9c:	0a00002a 	beq	1de4c <malloc+0x1210>
   1dda0:	e28c2010 	add	r2, ip, #16
   1dda4:	eaffff65 	b	1db40 <malloc+0xf04>
          insert_chunk(m, r, rsize);
   1dda8:	e59f30f8 	ldr	r3, [pc, #248]	@ 1dea8 <malloc+0x126c>
   1ddac:	e0852102 	add	r2, r5, r2, lsl #2
   1ddb0:	e1800001 	orr	r0, r0, r1
   1ddb4:	e5827018 	str	r7, [r2, #24]
   1ddb8:	e0833004 	add	r3, r3, r4
   1ddbc:	e585001c 	str	r0, [r5, #28]
   1ddc0:	e5877008 	str	r7, [r7, #8]
   1ddc4:	e587700c 	str	r7, [r7, #12]
   1ddc8:	e5873018 	str	r3, [r7, #24]
   1ddcc:	eafffd24 	b	1d264 <malloc+0x628>
      unlink_large_chunk(m, v);
   1ddd0:	e0853103 	add	r3, r5, r3, lsl #2
   1ddd4:	eaffffd3 	b	1dd28 <malloc+0x10ec>
  asize = granularity_align(nb + SYS_ALLOC_PADDING);
   1ddd8:	e5951008 	ldr	r1, [r5, #8]
   1dddc:	e281802f 	add	r8, r1, #47	@ 0x2f
   1dde0:	e2611000 	rsb	r1, r1, #0
   1dde4:	e0888004 	add	r8, r8, r4
   1dde8:	e0088001 	and	r8, r8, r1
  if (asize <= nb)
   1ddec:	e1540008 	cmp	r4, r8
   1ddf0:	3afffc2f 	bcc	1ceb4 <malloc+0x278>
   1ddf4:	eafffc72 	b	1cfc4 <malloc+0x388>
          insert_chunk(m, r, rsize);
   1ddf8:	e2803004 	add	r3, r0, #4
   1ddfc:	e0813103 	add	r3, r1, r3, lsl #2
   1de00:	e1580003 	cmp	r8, r3
   1de04:	8afffd09 	bhi	1d230 <malloc+0x5f4>
   1de08:	e58e7010 	str	r7, [lr, #16]
   1de0c:	e5871018 	str	r1, [r7, #24]
   1de10:	e5877008 	str	r7, [r7, #8]
   1de14:	e587700c 	str	r7, [r7, #12]
   1de18:	eafffd11 	b	1d264 <malloc+0x628>
      unlink_large_chunk(m, v);
   1de1c:	e59e3010 	ldr	r3, [lr, #16]
   1de20:	e3530000 	cmp	r3, #0
   1de24:	0a000068 	beq	1dfcc <malloc+0x1390>
   1de28:	e28e0010 	add	r0, lr, #16
   1de2c:	eaffffa8 	b	1dcd4 <malloc+0x1098>
    size_t tsize = m->topsize += qsize;
   1de30:	e5953024 	ldr	r3, [r5, #36]	@ 0x24
    m->top = q;
   1de34:	e5854030 	str	r4, [r5, #48]	@ 0x30
    size_t tsize = m->topsize += qsize;
   1de38:	e0823003 	add	r3, r2, r3
    q->head = tsize | PINUSE_BIT;
   1de3c:	e3832001 	orr	r2, r3, #1
    size_t tsize = m->topsize += qsize;
   1de40:	e5853024 	str	r3, [r5, #36]	@ 0x24
    q->head = tsize | PINUSE_BIT;
   1de44:	e5842004 	str	r2, [r4, #4]
    check_top_chunk(m, q);
   1de48:	eafffd05 	b	1d264 <malloc+0x628>
        unlink_large_chunk(m, v);
   1de4c:	e35a0000 	cmp	sl, #0
   1de50:	0afffe30 	beq	1d718 <malloc+0xadc>
   1de54:	e59c101c 	ldr	r1, [ip, #28]
   1de58:	e281204c 	add	r2, r1, #76	@ 0x4c
   1de5c:	e0852102 	add	r2, r5, r2, lsl #2
   1de60:	e5920018 	ldr	r0, [r2, #24]
   1de64:	e150000c 	cmp	r0, ip
   1de68:	0a000007 	beq	1de8c <malloc+0x1250>
   1de6c:	e158000a 	cmp	r8, sl
   1de70:	8afffcee 	bhi	1d230 <malloc+0x5f4>
   1de74:	e59a3010 	ldr	r3, [sl, #16]
   1de78:	e1590003 	cmp	r9, r3
   1de7c:	e3a03000 	mov	r3, #0
   1de80:	058a3010 	streq	r3, [sl, #16]
   1de84:	158a3014 	strne	r3, [sl, #20]
   1de88:	eafffe22 	b	1d718 <malloc+0xadc>
   1de8c:	e5823018 	str	r3, [r2, #24]
   1de90:	e3a03001 	mov	r3, #1
   1de94:	e1cee113 	bic	lr, lr, r3, lsl r1
   1de98:	e585e01c 	str	lr, [r5, #28]
   1de9c:	eafffe1d 	b	1d718 <malloc+0xadc>
   1dea0:	0002b844 	.word	0x0002b844
   1dea4:	0002b6ac 	.word	0x0002b6ac
   1dea8:	0002b684 	.word	0x0002b684
    insert_chunk(m, q, qsize);
   1deac:	e3520401 	cmp	r2, #16777216	@ 0x1000000
   1deb0:	e1a00422 	lsr	r0, r2, #8
   1deb4:	23a0301f 	movcs	r3, #31
   1deb8:	2a000013 	bcs	1df0c <malloc+0x12d0>
   1debc:	e2403c01 	sub	r3, r0, #256	@ 0x100
   1dec0:	e1a03823 	lsr	r3, r3, #16
   1dec4:	e2033008 	and	r3, r3, #8
   1dec8:	e1a00310 	lsl	r0, r0, r3
   1decc:	e2401a01 	sub	r1, r0, #4096	@ 0x1000
   1ded0:	e1a01821 	lsr	r1, r1, #16
   1ded4:	e2011004 	and	r1, r1, #4
   1ded8:	e1a00110 	lsl	r0, r0, r1
   1dedc:	e1831001 	orr	r1, r3, r1
   1dee0:	e2403901 	sub	r3, r0, #16384	@ 0x4000
   1dee4:	e1a03823 	lsr	r3, r3, #16
   1dee8:	e2033002 	and	r3, r3, #2
   1deec:	e1a00310 	lsl	r0, r0, r3
   1def0:	e0811003 	add	r1, r1, r3
   1def4:	e06117a0 	rsb	r1, r1, r0, lsr #15
   1def8:	e2813015 	add	r3, r1, #21
   1defc:	e281100e 	add	r1, r1, #14
   1df00:	e1a03332 	lsr	r3, r2, r3
   1df04:	e2033001 	and	r3, r3, #1
   1df08:	e0833081 	add	r3, r3, r1, lsl #1
   1df0c:	e595101c 	ldr	r1, [r5, #28]
   1df10:	e3a00001 	mov	r0, #1
   1df14:	e584301c 	str	r3, [r4, #28]
   1df18:	e0116310 	ands	r6, r1, r0, lsl r3
   1df1c:	e3a06000 	mov	r6, #0
   1df20:	e1a00310 	lsl	r0, r0, r3
   1df24:	e5846010 	str	r6, [r4, #16]
   1df28:	e5846014 	str	r6, [r4, #20]
   1df2c:	1a000040 	bne	1e034 <malloc+0x13f8>
   1df30:	e51f2090 	ldr	r2, [pc, #-144]	@ 1dea8 <malloc+0x126c>
   1df34:	e283304c 	add	r3, r3, #76	@ 0x4c
   1df38:	e1811000 	orr	r1, r1, r0
   1df3c:	e585101c 	str	r1, [r5, #28]
   1df40:	e0855103 	add	r5, r5, r3, lsl #2
   1df44:	e0823103 	add	r3, r2, r3, lsl #2
   1df48:	e5854018 	str	r4, [r5, #24]
   1df4c:	e5844008 	str	r4, [r4, #8]
   1df50:	e584400c 	str	r4, [r4, #12]
   1df54:	e5843018 	str	r3, [r4, #24]
   1df58:	eafffcc1 	b	1d264 <malloc+0x628>
    size_t dsize = m->dvsize += qsize;
   1df5c:	e5953020 	ldr	r3, [r5, #32]
    m->dv = q;
   1df60:	e585402c 	str	r4, [r5, #44]	@ 0x2c
    size_t dsize = m->dvsize += qsize;
   1df64:	e0823003 	add	r3, r2, r3
    set_size_and_pinuse_of_free_chunk(q, dsize);
   1df68:	e3832001 	orr	r2, r3, #1
    size_t dsize = m->dvsize += qsize;
   1df6c:	e5853020 	str	r3, [r5, #32]
    set_size_and_pinuse_of_free_chunk(q, dsize);
   1df70:	e5842004 	str	r2, [r4, #4]
   1df74:	e7843003 	str	r3, [r4, r3]
   1df78:	eafffcb9 	b	1d264 <malloc+0x628>
      unlink_chunk(m, oldfirst, nsize);
   1df7c:	e35000ff 	cmp	r0, #255	@ 0xff
   1df80:	e1a081a0 	lsr	r8, r0, #3
   1df84:	e597300c 	ldr	r3, [r7, #12]
      size_t nsize = chunksize(oldfirst);
   1df88:	e3c00007 	bic	r0, r0, #7
      unlink_chunk(m, oldfirst, nsize);
   1df8c:	8a000050 	bhi	1e0d4 <malloc+0x1498>
   1df90:	e51f60f0 	ldr	r6, [pc, #-240]	@ 1dea8 <malloc+0x126c>
   1df94:	e5971008 	ldr	r1, [r7, #8]
   1df98:	e0866188 	add	r6, r6, r8, lsl #3
   1df9c:	e2866028 	add	r6, r6, #40	@ 0x28
   1dfa0:	e1510006 	cmp	r1, r6
   1dfa4:	1a00009e 	bne	1e224 <malloc+0x15e8>
   1dfa8:	e1510003 	cmp	r1, r3
   1dfac:	1a0000a9 	bne	1e258 <malloc+0x161c>
   1dfb0:	e5953018 	ldr	r3, [r5, #24]
   1dfb4:	e3a01001 	mov	r1, #1
   1dfb8:	e1c33811 	bic	r3, r3, r1, lsl r8
   1dfbc:	e5853018 	str	r3, [r5, #24]
      oldfirst = chunk_plus_offset(oldfirst, nsize);
   1dfc0:	e0877000 	add	r7, r7, r0
      qsize += nsize;
   1dfc4:	e0822000 	add	r2, r2, r0
   1dfc8:	eafffcd6 	b	1d328 <malloc+0x6ec>
      unlink_large_chunk(m, v);
   1dfcc:	e35a0000 	cmp	sl, #0
   1dfd0:	0afffc73 	beq	1d1a4 <malloc+0x568>
   1dfd4:	e59e801c 	ldr	r8, [lr, #28]
   1dfd8:	e288604c 	add	r6, r8, #76	@ 0x4c
   1dfdc:	e0856106 	add	r6, r5, r6, lsl #2
   1dfe0:	e596b018 	ldr	fp, [r6, #24]
   1dfe4:	e15e000b 	cmp	lr, fp
   1dfe8:	0a000007 	beq	1e00c <malloc+0x13d0>
   1dfec:	e159000a 	cmp	r9, sl
   1dff0:	8afffc8e 	bhi	1d230 <malloc+0x5f4>
   1dff4:	e59a3010 	ldr	r3, [sl, #16]
   1dff8:	e15e0003 	cmp	lr, r3
   1dffc:	e3a03000 	mov	r3, #0
   1e000:	058a3010 	streq	r3, [sl, #16]
   1e004:	158a3014 	strne	r3, [sl, #20]
   1e008:	eafffc65 	b	1d1a4 <malloc+0x568>
   1e00c:	e5863018 	str	r3, [r6, #24]
   1e010:	e3a03001 	mov	r3, #1
   1e014:	e1c00813 	bic	r0, r0, r3, lsl r8
   1e018:	e585001c 	str	r0, [r5, #28]
   1e01c:	eafffc60 	b	1d1a4 <malloc+0x568>
    insert_chunk(m, q, qsize);
   1e020:	e5932008 	ldr	r2, [r3, #8]
   1e024:	e5951028 	ldr	r1, [r5, #40]	@ 0x28
   1e028:	e1520001 	cmp	r2, r1
   1e02c:	2afffcd1 	bcs	1d378 <malloc+0x73c>
   1e030:	eafffc7e 	b	1d230 <malloc+0x5f4>
   1e034:	e353001f 	cmp	r3, #31
   1e038:	e0851103 	add	r1, r5, r3, lsl #2
   1e03c:	11a030a3 	lsrne	r3, r3, #1
   1e040:	e5911148 	ldr	r1, [r1, #328]	@ 0x148
   1e044:	1263e019 	rsbne	lr, r3, #25
   1e048:	e1a0ee12 	lsl	lr, r2, lr
   1e04c:	ea000006 	b	1e06c <malloc+0x1430>
   1e050:	e1a03fae 	lsr	r3, lr, #31
   1e054:	e1a0e08e 	lsl	lr, lr, #1
   1e058:	e0816103 	add	r6, r1, r3, lsl #2
   1e05c:	e5960010 	ldr	r0, [r6, #16]
   1e060:	e3500000 	cmp	r0, #0
   1e064:	0a000010 	beq	1e0ac <malloc+0x1470>
   1e068:	e1a01000 	mov	r1, r0
   1e06c:	e5913004 	ldr	r3, [r1, #4]
   1e070:	e3c33007 	bic	r3, r3, #7
   1e074:	e1520003 	cmp	r2, r3
   1e078:	1afffff4 	bne	1e050 <malloc+0x1414>
   1e07c:	e5913008 	ldr	r3, [r1, #8]
   1e080:	e5952028 	ldr	r2, [r5, #40]	@ 0x28
   1e084:	e1510002 	cmp	r1, r2
   1e088:	21530002 	cmpcs	r3, r2
   1e08c:	3afffc67 	bcc	1d230 <malloc+0x5f4>
   1e090:	e3a02000 	mov	r2, #0
   1e094:	e583400c 	str	r4, [r3, #12]
   1e098:	e5814008 	str	r4, [r1, #8]
   1e09c:	e5843008 	str	r3, [r4, #8]
   1e0a0:	e584100c 	str	r1, [r4, #12]
   1e0a4:	e5842018 	str	r2, [r4, #24]
   1e0a8:	eafffc6d 	b	1d264 <malloc+0x628>
   1e0ac:	e5952028 	ldr	r2, [r5, #40]	@ 0x28
   1e0b0:	e2833004 	add	r3, r3, #4
   1e0b4:	e0813103 	add	r3, r1, r3, lsl #2
   1e0b8:	e1520003 	cmp	r2, r3
   1e0bc:	8afffc5b 	bhi	1d230 <malloc+0x5f4>
   1e0c0:	e5864010 	str	r4, [r6, #16]
   1e0c4:	e5841018 	str	r1, [r4, #24]
   1e0c8:	e5844008 	str	r4, [r4, #8]
   1e0cc:	e584400c 	str	r4, [r4, #12]
   1e0d0:	eafffc63 	b	1d264 <malloc+0x628>
      unlink_chunk(m, oldfirst, nsize);
   1e0d4:	e1570003 	cmp	r7, r3
   1e0d8:	e5976018 	ldr	r6, [r7, #24]
   1e0dc:	0a00002f 	beq	1e1a0 <malloc+0x1564>
   1e0e0:	e5971008 	ldr	r1, [r7, #8]
   1e0e4:	e5958028 	ldr	r8, [r5, #40]	@ 0x28
   1e0e8:	e1510008 	cmp	r1, r8
   1e0ec:	3afffc4f 	bcc	1d230 <malloc+0x5f4>
   1e0f0:	e591800c 	ldr	r8, [r1, #12]
   1e0f4:	e1580007 	cmp	r8, r7
   1e0f8:	1afffc4c 	bne	1d230 <malloc+0x5f4>
   1e0fc:	e5938008 	ldr	r8, [r3, #8]
   1e100:	e1580007 	cmp	r8, r7
   1e104:	1afffc49 	bne	1d230 <malloc+0x5f4>
   1e108:	e581300c 	str	r3, [r1, #12]
   1e10c:	e5831008 	str	r1, [r3, #8]
   1e110:	e3560000 	cmp	r6, #0
   1e114:	0affffa9 	beq	1dfc0 <malloc+0x1384>
   1e118:	e597801c 	ldr	r8, [r7, #28]
   1e11c:	e288104c 	add	r1, r8, #76	@ 0x4c
   1e120:	e0851101 	add	r1, r5, r1, lsl #2
   1e124:	e5919018 	ldr	r9, [r1, #24]
   1e128:	e1590007 	cmp	r9, r7
   1e12c:	0a000034 	beq	1e204 <malloc+0x15c8>
   1e130:	e5951028 	ldr	r1, [r5, #40]	@ 0x28
   1e134:	e1560001 	cmp	r6, r1
   1e138:	3afffc3c 	bcc	1d230 <malloc+0x5f4>
   1e13c:	e5961010 	ldr	r1, [r6, #16]
   1e140:	e1510007 	cmp	r1, r7
   1e144:	05863010 	streq	r3, [r6, #16]
   1e148:	15863014 	strne	r3, [r6, #20]
   1e14c:	e3530000 	cmp	r3, #0
   1e150:	0affff9a 	beq	1dfc0 <malloc+0x1384>
   1e154:	e5958028 	ldr	r8, [r5, #40]	@ 0x28
   1e158:	e1530008 	cmp	r3, r8
   1e15c:	3afffc33 	bcc	1d230 <malloc+0x5f4>
   1e160:	e5971010 	ldr	r1, [r7, #16]
   1e164:	e5836018 	str	r6, [r3, #24]
   1e168:	e3510000 	cmp	r1, #0
   1e16c:	0a000003 	beq	1e180 <malloc+0x1544>
   1e170:	e1580001 	cmp	r8, r1
   1e174:	8afffc2d 	bhi	1d230 <malloc+0x5f4>
   1e178:	e5831010 	str	r1, [r3, #16]
   1e17c:	e5813018 	str	r3, [r1, #24]
   1e180:	e5971014 	ldr	r1, [r7, #20]
   1e184:	e3510000 	cmp	r1, #0
   1e188:	0affff8c 	beq	1dfc0 <malloc+0x1384>
   1e18c:	e1580001 	cmp	r8, r1
   1e190:	8afffc26 	bhi	1d230 <malloc+0x5f4>
   1e194:	e5831014 	str	r1, [r3, #20]
   1e198:	e5813018 	str	r3, [r1, #24]
   1e19c:	eaffff87 	b	1dfc0 <malloc+0x1384>
   1e1a0:	e5973014 	ldr	r3, [r7, #20]
   1e1a4:	e3530000 	cmp	r3, #0
   1e1a8:	12878014 	addne	r8, r7, #20
   1e1ac:	0a00000f 	beq	1e1f0 <malloc+0x15b4>
        sp = &m->seg;
   1e1b0:	e1a01003 	mov	r1, r3
      unlink_chunk(m, oldfirst, nsize);
   1e1b4:	e1a09008 	mov	r9, r8
   1e1b8:	e1a03001 	mov	r3, r1
   1e1bc:	e2818014 	add	r8, r1, #20
   1e1c0:	e5911014 	ldr	r1, [r1, #20]
   1e1c4:	e3510000 	cmp	r1, #0
   1e1c8:	1afffff9 	bne	1e1b4 <malloc+0x1578>
   1e1cc:	e5931010 	ldr	r1, [r3, #16]
   1e1d0:	e2838010 	add	r8, r3, #16
   1e1d4:	e3510000 	cmp	r1, #0
   1e1d8:	1afffff5 	bne	1e1b4 <malloc+0x1578>
   1e1dc:	e5958028 	ldr	r8, [r5, #40]	@ 0x28
   1e1e0:	e1580009 	cmp	r8, r9
   1e1e4:	8afffc11 	bhi	1d230 <malloc+0x5f4>
   1e1e8:	e5891000 	str	r1, [r9]
   1e1ec:	eaffffc7 	b	1e110 <malloc+0x14d4>
   1e1f0:	e5973010 	ldr	r3, [r7, #16]
   1e1f4:	e3530000 	cmp	r3, #0
   1e1f8:	0affffc4 	beq	1e110 <malloc+0x14d4>
   1e1fc:	e2878010 	add	r8, r7, #16
   1e200:	eaffffea 	b	1e1b0 <malloc+0x1574>
   1e204:	e3530000 	cmp	r3, #0
   1e208:	e5813018 	str	r3, [r1, #24]
   1e20c:	1affffd0 	bne	1e154 <malloc+0x1518>
   1e210:	e595301c 	ldr	r3, [r5, #28]
   1e214:	e3a01001 	mov	r1, #1
   1e218:	e1c33811 	bic	r3, r3, r1, lsl r8
   1e21c:	e585301c 	str	r3, [r5, #28]
   1e220:	eaffff66 	b	1dfc0 <malloc+0x1384>
   1e224:	e5959028 	ldr	r9, [r5, #40]	@ 0x28
   1e228:	e1510009 	cmp	r1, r9
   1e22c:	3afffbff 	bcc	1d230 <malloc+0x5f4>
   1e230:	e591900c 	ldr	r9, [r1, #12]
   1e234:	e1590007 	cmp	r9, r7
   1e238:	1afffbfc 	bne	1d230 <malloc+0x5f4>
   1e23c:	e1510003 	cmp	r1, r3
   1e240:	0affff5a 	beq	1dfb0 <malloc+0x1374>
   1e244:	e1560003 	cmp	r6, r3
   1e248:	1a000002 	bne	1e258 <malloc+0x161c>
   1e24c:	e581300c 	str	r3, [r1, #12]
   1e250:	e5831008 	str	r1, [r3, #8]
   1e254:	eaffff59 	b	1dfc0 <malloc+0x1384>
   1e258:	e5956028 	ldr	r6, [r5, #40]	@ 0x28
   1e25c:	e1560003 	cmp	r6, r3
   1e260:	8afffbf2 	bhi	1d230 <malloc+0x5f4>
   1e264:	e5936008 	ldr	r6, [r3, #8]
   1e268:	e1560007 	cmp	r6, r7
   1e26c:	0afffff6 	beq	1e24c <malloc+0x1610>
   1e270:	eafffbee 	b	1d230 <malloc+0x5f4>
  char* old_end = oldsp->base + oldsp->size;
   1e274:	e5933000 	ldr	r3, [r3]
   1e278:	e7f000f0 	udf	#0

0001e27c <ialloc.constprop.0>:
    all of the combinations that can result.
  The opts arg has:
    bit 0 set if all elements are same size (using sizes[0])
    bit 1 set if elements should be zeroed
*/
static void** ialloc(mstate m,
   1e27c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  mchunkptr array_chunk;    /* chunk for malloced ptr array */
  flag_t    was_enabled;    /* to disable mmap */
  size_t    size;
  size_t    i;

  ensure_initialization();
   1e280:	e30b466c 	movw	r4, #46700	@ 0xb66c
   1e284:	e3404002 	movt	r4, #2
static void** ialloc(mstate m,
   1e288:	e1a07003 	mov	r7, r3
   1e28c:	e24dd00c 	sub	sp, sp, #12
   1e290:	e1a09000 	mov	r9, r0
  ensure_initialization();
   1e294:	e5943000 	ldr	r3, [r4]
static void** ialloc(mstate m,
   1e298:	e1a05001 	mov	r5, r1
   1e29c:	e1a06002 	mov	r6, r2
  ensure_initialization();
   1e2a0:	e3530000 	cmp	r3, #0
   1e2a4:	0a000044 	beq	1e3bc <ialloc.constprop.0+0x140>
  /* compute array length, if needed */
  if (chunks != 0) {
   1e2a8:	e3570000 	cmp	r7, #0
   1e2ac:	0a000045 	beq	1e3c8 <ialloc.constprop.0+0x14c>
    if (n_elements == 0)
   1e2b0:	e3590000 	cmp	r9, #0
      return chunks; /* nothing to do */
   1e2b4:	01a0b007 	moveq	fp, r7
    if (n_elements == 0)
   1e2b8:	0a00003c 	beq	1e3b0 <ialloc.constprop.0+0x134>
    marray = 0;
    array_size = request2size(n_elements * (sizeof(void*)));
  }

  /* compute total element size */
  if (opts & 0x1) { /* all-same-size */
   1e2bc:	e2161001 	ands	r1, r6, #1
   1e2c0:	01a0c109 	lsleq	ip, r9, #2
   1e2c4:	0a000049 	beq	1e3f0 <ialloc.constprop.0+0x174>
    array_size = 0;
   1e2c8:	e3a01000 	mov	r1, #0
    element_size = request2size(*sizes);
   1e2cc:	e5958000 	ldr	r8, [r5]
   1e2d0:	e358000a 	cmp	r8, #10
   1e2d4:	8288800b 	addhi	r8, r8, #11
   1e2d8:	93a08010 	movls	r8, #16
   1e2dc:	83c88007 	bichi	r8, r8, #7
    contents_size = n_elements * element_size;
   1e2e0:	e00a0998 	mul	sl, r8, r9
  /*
     Allocate the aggregate chunk.  First disable direct-mmapping so
     malloc won't use it, since we would not be able to later
     free/realloc space internal to a segregated mmap region.
  */
  was_enabled = use_mmap(m);
   1e2e4:	e594b1d4 	ldr	fp, [r4, #468]	@ 0x1d4
  size = contents_size + array_size;
   1e2e8:	e08a0001 	add	r0, sl, r1
  disable_mmap(m);
  mem = internal_malloc(m, size - CHUNK_OVERHEAD);
   1e2ec:	e2400004 	sub	r0, r0, #4
  size = contents_size + array_size;
   1e2f0:	e58d1004 	str	r1, [sp, #4]
  disable_mmap(m);
   1e2f4:	e3cb3001 	bic	r3, fp, #1
   1e2f8:	e58431d4 	str	r3, [r4, #468]	@ 0x1d4
  mem = internal_malloc(m, size - CHUNK_OVERHEAD);
   1e2fc:	ebfffa4e 	bl	1cc3c <malloc>
  if (was_enabled)
   1e300:	e31b0001 	tst	fp, #1
   1e304:	e59d1004 	ldr	r1, [sp, #4]
    enable_mmap(m);
   1e308:	159431d4 	ldrne	r3, [r4, #468]	@ 0x1d4
  mem = internal_malloc(m, size - CHUNK_OVERHEAD);
   1e30c:	e1a0b000 	mov	fp, r0
    enable_mmap(m);
   1e310:	13833001 	orrne	r3, r3, #1
   1e314:	158431d4 	strne	r3, [r4, #468]	@ 0x1d4
  if (mem == 0)
   1e318:	e3500000 	cmp	r0, #0
   1e31c:	0a000023 	beq	1e3b0 <ialloc.constprop.0+0x134>
  p = mem2chunk(mem);
  remainder_size = chunksize(p);

  assert(!is_mmapped(p));

  if (opts & 0x2) {       /* optionally clear the elements */
   1e320:	e3160002 	tst	r6, #2
  remainder_size = chunksize(p);
   1e324:	e5106004 	ldr	r6, [r0, #-4]
  p = mem2chunk(mem);
   1e328:	e2404008 	sub	r4, r0, #8
  remainder_size = chunksize(p);
   1e32c:	e3c66007 	bic	r6, r6, #7
  if (opts & 0x2) {       /* optionally clear the elements */
   1e330:	1a00003b 	bne	1e424 <ialloc.constprop.0+0x1a8>
    memset((size_t*)mem, 0, remainder_size - SIZE_T_SIZE - array_size);
  }

  /* If not provided, allocate the pointer array as final part of chunk */
  if (marray == 0) {
   1e334:	e3570000 	cmp	r7, #0
   1e338:	0a00003f 	beq	1e43c <ialloc.constprop.0+0x1c0>
  }

  /* split out elements */
  for (i = 0; ; ++i) {
    marray[i] = chunk2mem(p);
    if (i != n_elements-1) {
   1e33c:	e3590001 	cmp	r9, #1
    marray[i] = chunk2mem(p);
   1e340:	e587b000 	str	fp, [r7]
    if (i != n_elements-1) {
   1e344:	0a000016 	beq	1e3a4 <ialloc.constprop.0+0x128>
   1e348:	e0879109 	add	r9, r7, r9, lsl #2
   1e34c:	e1a01005 	mov	r1, r5
   1e350:	e2870004 	add	r0, r7, #4
      if (element_size != 0)
        size = element_size;
      else
        size = request2size(sizes[i]);
      remainder_size -= size;
      set_size_and_pinuse_of_inuse_chunk(m, p, size);
   1e354:	e388e003 	orr	lr, r8, #3
      if (element_size != 0)
   1e358:	e3580000 	cmp	r8, #0
      set_size_and_pinuse_of_inuse_chunk(m, p, size);
   1e35c:	e1a0c00e 	mov	ip, lr
        size = element_size;
   1e360:	e1a02008 	mov	r2, r8
      if (element_size != 0)
   1e364:	1a000006 	bne	1e384 <ialloc.constprop.0+0x108>
        size = request2size(sizes[i]);
   1e368:	e5913000 	ldr	r3, [r1]
   1e36c:	e3a02010 	mov	r2, #16
   1e370:	e3a0c013 	mov	ip, #19
   1e374:	e353000a 	cmp	r3, #10
   1e378:	e283300b 	add	r3, r3, #11
   1e37c:	83c32007 	bichi	r2, r3, #7
      set_size_and_pinuse_of_inuse_chunk(m, p, size);
   1e380:	8382c003 	orrhi	ip, r2, #3
   1e384:	e584c004 	str	ip, [r4, #4]
      p = chunk_plus_offset(p, size);
   1e388:	e0844002 	add	r4, r4, r2
    marray[i] = chunk2mem(p);
   1e38c:	e2843008 	add	r3, r4, #8
      remainder_size -= size;
   1e390:	e0466002 	sub	r6, r6, r2
    marray[i] = chunk2mem(p);
   1e394:	e4803004 	str	r3, [r0], #4
    if (i != n_elements-1) {
   1e398:	e1590000 	cmp	r9, r0
   1e39c:	e2811004 	add	r1, r1, #4
   1e3a0:	1affffec 	bne	1e358 <ialloc.constprop.0+0xdc>
    check_inuse_chunk(m, mem2chunk(marray[i]));

#endif /* DEBUG */

  POSTACTION(m);
  return marray;
   1e3a4:	e1a0b007 	mov	fp, r7
      set_size_and_pinuse_of_inuse_chunk(m, p, remainder_size);
   1e3a8:	e3866003 	orr	r6, r6, #3
   1e3ac:	e5846004 	str	r6, [r4, #4]
}
   1e3b0:	e1a0000b 	mov	r0, fp
   1e3b4:	e28dd00c 	add	sp, sp, #12
   1e3b8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (mparams.magic == 0) {
   1e3bc:	ebfff5b4 	bl	1ba94 <init_mparams.part.0>
  if (chunks != 0) {
   1e3c0:	e3570000 	cmp	r7, #0
   1e3c4:	1affffb9 	bne	1e2b0 <ialloc.constprop.0+0x34>
    if (n_elements == 0)
   1e3c8:	e3590000 	cmp	r9, #0
   1e3cc:	0a000025 	beq	1e468 <ialloc.constprop.0+0x1ec>
    array_size = request2size(n_elements * (sizeof(void*)));
   1e3d0:	e1a0c109 	lsl	ip, r9, #2
  if (opts & 0x1) { /* all-same-size */
   1e3d4:	e2063001 	and	r3, r6, #1
    array_size = request2size(n_elements * (sizeof(void*)));
   1e3d8:	e35c000a 	cmp	ip, #10
   1e3dc:	9a00001d 	bls	1e458 <ialloc.constprop.0+0x1dc>
  if (opts & 0x1) { /* all-same-size */
   1e3e0:	e3530000 	cmp	r3, #0
    array_size = request2size(n_elements * (sizeof(void*)));
   1e3e4:	e28c100b 	add	r1, ip, #11
   1e3e8:	e3c11007 	bic	r1, r1, #7
  if (opts & 0x1) { /* all-same-size */
   1e3ec:	1affffb6 	bne	1e2cc <ialloc.constprop.0+0x50>
   1e3f0:	e085c00c 	add	ip, r5, ip
   1e3f4:	e1a02005 	mov	r2, r5
    contents_size = 0;
   1e3f8:	e3a0a000 	mov	sl, #0
      contents_size += request2size(sizes[i]);
   1e3fc:	e4923004 	ldr	r3, [r2], #4
   1e400:	e3a00010 	mov	r0, #16
   1e404:	e353000a 	cmp	r3, #10
   1e408:	e283300b 	add	r3, r3, #11
   1e40c:	83c30007 	bichi	r0, r3, #7
    for (i = 0; i != n_elements; ++i)
   1e410:	e152000c 	cmp	r2, ip
      contents_size += request2size(sizes[i]);
   1e414:	e08aa000 	add	sl, sl, r0
    for (i = 0; i != n_elements; ++i)
   1e418:	1afffff7 	bne	1e3fc <ialloc.constprop.0+0x180>
    element_size = 0;
   1e41c:	e3a08000 	mov	r8, #0
   1e420:	eaffffaf 	b	1e2e4 <ialloc.constprop.0+0x68>
    memset((size_t*)mem, 0, remainder_size - SIZE_T_SIZE - array_size);
   1e424:	e0462001 	sub	r2, r6, r1
   1e428:	e3a01000 	mov	r1, #0
   1e42c:	e2422004 	sub	r2, r2, #4
   1e430:	ebfff09e 	bl	1a6b0 <memset>
  if (marray == 0) {
   1e434:	e3570000 	cmp	r7, #0
   1e438:	1affffbf 	bne	1e33c <ialloc.constprop.0+0xc0>
    array_chunk_size = remainder_size - contents_size;
   1e43c:	e046600a 	sub	r6, r6, sl
    array_chunk = chunk_plus_offset(p, contents_size);
   1e440:	e084700a 	add	r7, r4, sl
    set_size_and_pinuse_of_inuse_chunk(m, array_chunk, array_chunk_size);
   1e444:	e3866003 	orr	r6, r6, #3
    marray = (void**) (chunk2mem(array_chunk));
   1e448:	e2877008 	add	r7, r7, #8
    set_size_and_pinuse_of_inuse_chunk(m, array_chunk, array_chunk_size);
   1e44c:	e5076004 	str	r6, [r7, #-4]
    remainder_size = contents_size;
   1e450:	e1a0600a 	mov	r6, sl
   1e454:	eaffffb8 	b	1e33c <ialloc.constprop.0+0xc0>
  if (opts & 0x1) { /* all-same-size */
   1e458:	e3530000 	cmp	r3, #0
    array_size = request2size(n_elements * (sizeof(void*)));
   1e45c:	e3a01010 	mov	r1, #16
  if (opts & 0x1) { /* all-same-size */
   1e460:	1affff99 	bne	1e2cc <ialloc.constprop.0+0x50>
   1e464:	eaffffe1 	b	1e3f0 <ialloc.constprop.0+0x174>
      return (void**)internal_malloc(m, 0);
   1e468:	e1a00009 	mov	r0, r9
}
   1e46c:	e28dd00c 	add	sp, sp, #12
   1e470:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
      return (void**)internal_malloc(m, 0);
   1e474:	eafff9f0 	b	1cc3c <malloc>

0001e478 <internal_memalign.constprop.0>:
  if (alignment <  MIN_CHUNK_SIZE) /* must be at least a minimum chunk size */
   1e478:	e3500010 	cmp	r0, #16
static void* internal_memalign(mstate m, size_t alignment, size_t bytes) {
   1e47c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  if (alignment <  MIN_CHUNK_SIZE) /* must be at least a minimum chunk size */
   1e480:	21a04000 	movcs	r4, r0
   1e484:	33a04010 	movcc	r4, #16
  if ((alignment & (alignment-SIZE_T_ONE)) != 0) {/* Ensure a power of 2 */
   1e488:	e2443001 	sub	r3, r4, #1
   1e48c:	e1130004 	tst	r3, r4
  if (bytes >= MAX_REQUEST - alignment) {
   1e490:	03e0303f 	mvneq	r3, #63	@ 0x3f
   1e494:	00433004 	subeq	r3, r3, r4
  if ((alignment & (alignment-SIZE_T_ONE)) != 0) {/* Ensure a power of 2 */
   1e498:	0a000008 	beq	1e4c0 <internal_memalign.constprop.0+0x48>
    while (a < alignment) a <<= 1;
   1e49c:	e3500010 	cmp	r0, #16
   1e4a0:	9a000032 	bls	1e570 <internal_memalign.constprop.0+0xf8>
    size_t a = MALLOC_ALIGNMENT << 1;
   1e4a4:	e3a03010 	mov	r3, #16
    while (a < alignment) a <<= 1;
   1e4a8:	e1a03083 	lsl	r3, r3, #1
   1e4ac:	e1540003 	cmp	r4, r3
   1e4b0:	8afffffc 	bhi	1e4a8 <internal_memalign.constprop.0+0x30>
  if (bytes >= MAX_REQUEST - alignment) {
   1e4b4:	e3e0203f 	mvn	r2, #63	@ 0x3f
    alignment = a;
   1e4b8:	e1a04003 	mov	r4, r3
  if (bytes >= MAX_REQUEST - alignment) {
   1e4bc:	e0423003 	sub	r3, r2, r3
   1e4c0:	e1510003 	cmp	r1, r3
   1e4c4:	2a00002c 	bcs	1e57c <internal_memalign.constprop.0+0x104>
    size_t nb = request2size(bytes);
   1e4c8:	e351000a 	cmp	r1, #10
    size_t req = nb + alignment + MIN_CHUNK_SIZE - CHUNK_OVERHEAD;
   1e4cc:	e284000c 	add	r0, r4, #12
    size_t nb = request2size(bytes);
   1e4d0:	8281100b 	addhi	r1, r1, #11
   1e4d4:	93a06010 	movls	r6, #16
   1e4d8:	83c16007 	bichi	r6, r1, #7
    mem = internal_malloc(m, req);
   1e4dc:	e0800006 	add	r0, r0, r6
   1e4e0:	ebfff9d5 	bl	1cc3c <malloc>
    if (mem != 0) {
   1e4e4:	e2507000 	subs	r7, r0, #0
   1e4e8:	0a000026 	beq	1e588 <internal_memalign.constprop.0+0x110>
      if ((((size_t)(mem)) & (alignment - 1)) != 0) { /* misaligned */
   1e4ec:	e2445001 	sub	r5, r4, #1
      mchunkptr p = mem2chunk(mem);
   1e4f0:	e2470008 	sub	r0, r7, #8
      if ((((size_t)(mem)) & (alignment - 1)) != 0) { /* misaligned */
   1e4f4:	e1170005 	tst	r7, r5
   1e4f8:	1a000009 	bne	1e524 <internal_memalign.constprop.0+0xac>
      if (!is_mmapped(p)) {
   1e4fc:	e5173004 	ldr	r3, [r7, #-4]
      mchunkptr p = mem2chunk(mem);
   1e500:	e1a05000 	mov	r5, r0
      if (!is_mmapped(p)) {
   1e504:	e3130003 	tst	r3, #3
   1e508:	0a000003 	beq	1e51c <internal_memalign.constprop.0+0xa4>
        size_t size = chunksize(p);
   1e50c:	e3c32007 	bic	r2, r3, #7
        if (size > nb + MIN_CHUNK_SIZE) {
   1e510:	e2861010 	add	r1, r6, #16
   1e514:	e1520001 	cmp	r2, r1
   1e518:	8a000032 	bhi	1e5e8 <internal_memalign.constprop.0+0x170>
}
   1e51c:	e1a00007 	mov	r0, r7
   1e520:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        char* br = (char*)mem2chunk((size_t)(((size_t)((char*)mem + alignment -
   1e524:	e2643000 	rsb	r3, r4, #0
   1e528:	e0875005 	add	r5, r7, r5
   1e52c:	e0055003 	and	r5, r5, r3
        size_t newsize = chunksize(p) - leadsize;
   1e530:	e5173004 	ldr	r3, [r7, #-4]
        char* br = (char*)mem2chunk((size_t)(((size_t)((char*)mem + alignment -
   1e534:	e2455008 	sub	r5, r5, #8
        char* pos = ((size_t)(br - (char*)(p)) >= MIN_CHUNK_SIZE)?
   1e538:	e0451000 	sub	r1, r5, r0
          br : br+alignment;
   1e53c:	e351000f 	cmp	r1, #15
   1e540:	90855004 	addls	r5, r5, r4
        size_t leadsize = pos - (char*)(p);
   1e544:	90451000 	subls	r1, r5, r0
        if (is_mmapped(p)) { /* For mmapped chunks, just adjust offset */
   1e548:	e3130003 	tst	r3, #3
        size_t newsize = chunksize(p) - leadsize;
   1e54c:	e3c33007 	bic	r3, r3, #7
      mem = chunk2mem(p);
   1e550:	e2854008 	add	r4, r5, #8
        size_t newsize = chunksize(p) - leadsize;
   1e554:	e0433001 	sub	r3, r3, r1
        if (is_mmapped(p)) { /* For mmapped chunks, just adjust offset */
   1e558:	1a00000d 	bne	1e594 <internal_memalign.constprop.0+0x11c>
          newp->prev_foot = p->prev_foot + leadsize;
   1e55c:	e5172008 	ldr	r2, [r7, #-8]
   1e560:	e1a07004 	mov	r7, r4
   1e564:	e0822001 	add	r2, r2, r1
          newp->head = newsize;
   1e568:	e1c520f0 	strd	r2, [r5]
   1e56c:	eaffffe4 	b	1e504 <internal_memalign.constprop.0+0x8c>
    while (a < alignment) a <<= 1;
   1e570:	e3e0304f 	mvn	r3, #79	@ 0x4f
    alignment = a;
   1e574:	e3a04010 	mov	r4, #16
   1e578:	eaffffd0 	b	1e4c0 <internal_memalign.constprop.0+0x48>
      MALLOC_FAILURE_ACTION;
   1e57c:	ebfff4a4 	bl	1b814 <__errno>
   1e580:	e3a0300c 	mov	r3, #12
   1e584:	e5803000 	str	r3, [r0]
  void* mem = 0;
   1e588:	e3a07000 	mov	r7, #0
}
   1e58c:	e1a00007 	mov	r0, r7
   1e590:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
          set_inuse(m, newp, newsize);
   1e594:	e5952004 	ldr	r2, [r5, #4]
   1e598:	e2022001 	and	r2, r2, #1
   1e59c:	e1822003 	orr	r2, r2, r3
   1e5a0:	e0853003 	add	r3, r5, r3
   1e5a4:	e3822002 	orr	r2, r2, #2
   1e5a8:	e5852004 	str	r2, [r5, #4]
   1e5ac:	e5932004 	ldr	r2, [r3, #4]
   1e5b0:	e3822001 	orr	r2, r2, #1
   1e5b4:	e5832004 	str	r2, [r3, #4]
          set_inuse(m, p, leadsize);
   1e5b8:	e5173004 	ldr	r3, [r7, #-4]
   1e5bc:	e2033001 	and	r3, r3, #1
   1e5c0:	e1833001 	orr	r3, r3, r1
   1e5c4:	e3833002 	orr	r3, r3, #2
   1e5c8:	e5073004 	str	r3, [r7, #-4]
      if (!is_mmapped(p)) {
   1e5cc:	e1a07004 	mov	r7, r4
          set_inuse(m, p, leadsize);
   1e5d0:	e5953004 	ldr	r3, [r5, #4]
   1e5d4:	e3833001 	orr	r3, r3, #1
   1e5d8:	e5853004 	str	r3, [r5, #4]
          dispose_chunk(m, p, leadsize);
   1e5dc:	ebfff548 	bl	1bb04 <dispose_chunk.constprop.0>
      if (!is_mmapped(p)) {
   1e5e0:	e5953004 	ldr	r3, [r5, #4]
   1e5e4:	eaffffc6 	b	1e504 <internal_memalign.constprop.0+0x8c>
          set_inuse(m, p, nb);
   1e5e8:	e2033001 	and	r3, r3, #1
          size_t remainder_size = size - nb;
   1e5ec:	e0421006 	sub	r1, r2, r6
          set_inuse(m, p, nb);
   1e5f0:	e1833006 	orr	r3, r3, r6
          mchunkptr remainder = chunk_plus_offset(p, nb);
   1e5f4:	e0850006 	add	r0, r5, r6
          set_inuse(m, p, nb);
   1e5f8:	e3833002 	orr	r3, r3, #2
   1e5fc:	e5853004 	str	r3, [r5, #4]
          set_inuse(m, remainder, remainder_size);
   1e600:	e0855002 	add	r5, r5, r2
   1e604:	e3813003 	orr	r3, r1, #3
   1e608:	e5803004 	str	r3, [r0, #4]
   1e60c:	e5953004 	ldr	r3, [r5, #4]
   1e610:	e3833001 	orr	r3, r3, #1
   1e614:	e5853004 	str	r3, [r5, #4]
          dispose_chunk(m, remainder, remainder_size);
   1e618:	ebfff539 	bl	1bb04 <dispose_chunk.constprop.0>
}
   1e61c:	e1a00007 	mov	r0, r7
   1e620:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

0001e624 <free>:
  if (mem != 0) {
   1e624:	e2502000 	subs	r2, r0, #0
   1e628:	012fff1e 	bxeq	lr
void dlfree(void* mem) {
   1e62c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
      if (RTCHECK(ok_address(fm, p) && ok_inuse(p))) {
   1e630:	e30b466c 	movw	r4, #46700	@ 0xb66c
   1e634:	e3404002 	movt	r4, #2
    mchunkptr p  = mem2chunk(mem);
   1e638:	e2420008 	sub	r0, r2, #8
      if (RTCHECK(ok_address(fm, p) && ok_inuse(p))) {
   1e63c:	e594c028 	ldr	ip, [r4, #40]	@ 0x28
   1e640:	e15c0000 	cmp	ip, r0
   1e644:	8a000046 	bhi	1e764 <free+0x140>
   1e648:	e5123004 	ldr	r3, [r2, #-4]
   1e64c:	e203e003 	and	lr, r3, #3
   1e650:	e35e0001 	cmp	lr, #1
   1e654:	0a000042 	beq	1e764 <free+0x140>
        if (!pinuse(p)) {
   1e658:	e3130001 	tst	r3, #1
        size_t psize = chunksize(p);
   1e65c:	e3c33007 	bic	r3, r3, #7
        mchunkptr next = chunk_plus_offset(p, psize);
   1e660:	e0801003 	add	r1, r0, r3
        if (!pinuse(p)) {
   1e664:	1a00001b 	bne	1e6d8 <free+0xb4>
          size_t prevsize = p->prev_foot;
   1e668:	e5122008 	ldr	r2, [r2, #-8]
          if (is_mmapped(p)) {
   1e66c:	e35e0000 	cmp	lr, #0
            if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
   1e670:	e0400002 	sub	r0, r0, r2
          if (is_mmapped(p)) {
   1e674:	0a00010f 	beq	1eab8 <free+0x494>
            if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
   1e678:	e15c0000 	cmp	ip, r0
            psize += prevsize;
   1e67c:	e0833002 	add	r3, r3, r2
            if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
   1e680:	8a000037 	bhi	1e764 <free+0x140>
              if (p != fm->dv) {
   1e684:	e594e02c 	ldr	lr, [r4, #44]	@ 0x2c
   1e688:	e15e0000 	cmp	lr, r0
   1e68c:	0a00004f 	beq	1e7d0 <free+0x1ac>
                unlink_chunk(fm, p, prevsize);
   1e690:	e35200ff 	cmp	r2, #255	@ 0xff
   1e694:	e590e00c 	ldr	lr, [r0, #12]
   1e698:	e1a021a2 	lsr	r2, r2, #3
   1e69c:	8a00009c 	bhi	1e914 <free+0x2f0>
   1e6a0:	e5905008 	ldr	r5, [r0, #8]
   1e6a4:	e0846182 	add	r6, r4, r2, lsl #3
   1e6a8:	e2866040 	add	r6, r6, #64	@ 0x40
   1e6ac:	e1560005 	cmp	r6, r5
   1e6b0:	1a000165 	bne	1ec4c <free+0x628>
   1e6b4:	e15e0005 	cmp	lr, r5
   1e6b8:	0a00011b 	beq	1eb2c <free+0x508>
   1e6bc:	e15c000e 	cmp	ip, lr
   1e6c0:	8a0000c1 	bhi	1e9cc <free+0x3a8>
   1e6c4:	e59e2008 	ldr	r2, [lr, #8]
   1e6c8:	e1500002 	cmp	r0, r2
   1e6cc:	1a0000be 	bne	1e9cc <free+0x3a8>
   1e6d0:	e585e00c 	str	lr, [r5, #12]
   1e6d4:	e58e5008 	str	r5, [lr, #8]
        if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
   1e6d8:	e1500001 	cmp	r0, r1
   1e6dc:	2a000020 	bcs	1e764 <free+0x140>
   1e6e0:	e5912004 	ldr	r2, [r1, #4]
   1e6e4:	e3120001 	tst	r2, #1
   1e6e8:	0a00001d 	beq	1e764 <free+0x140>
          if (!cinuse(next)) {  /* consolidate forward */
   1e6ec:	e212e002 	ands	lr, r2, #2
   1e6f0:	1a00001c 	bne	1e768 <free+0x144>
            if (next == fm->top) {
   1e6f4:	e5945030 	ldr	r5, [r4, #48]	@ 0x30
              if (p != fm->dv) {
   1e6f8:	e594702c 	ldr	r7, [r4, #44]	@ 0x2c
            if (next == fm->top) {
   1e6fc:	e1550001 	cmp	r5, r1
   1e700:	0a00013a 	beq	1ebf0 <free+0x5cc>
            else if (next == fm->dv) {
   1e704:	e1570001 	cmp	r7, r1
   1e708:	0a000147 	beq	1ec2c <free+0x608>
              size_t nsize = chunksize(next);
   1e70c:	e3c22007 	bic	r2, r2, #7
              unlink_chunk(fm, next, nsize);
   1e710:	e591e00c 	ldr	lr, [r1, #12]
   1e714:	e35200f8 	cmp	r2, #248	@ 0xf8
              psize += nsize;
   1e718:	e0833002 	add	r3, r3, r2
              unlink_chunk(fm, next, nsize);
   1e71c:	e1a021a2 	lsr	r2, r2, #3
   1e720:	8a0000af 	bhi	1e9e4 <free+0x3c0>
   1e724:	e59f5648 	ldr	r5, [pc, #1608]	@ 1ed74 <free+0x750>
   1e728:	e5916008 	ldr	r6, [r1, #8]
   1e72c:	e0855182 	add	r5, r5, r2, lsl #3
   1e730:	e2855028 	add	r5, r5, #40	@ 0x28
   1e734:	e1550006 	cmp	r5, r6
   1e738:	1a000152 	bne	1ec88 <free+0x664>
   1e73c:	e15e0006 	cmp	lr, r6
   1e740:	0a000112 	beq	1eb90 <free+0x56c>
   1e744:	e15c000e 	cmp	ip, lr
   1e748:	8a00009f 	bhi	1e9cc <free+0x3a8>
   1e74c:	e59e2008 	ldr	r2, [lr, #8]
   1e750:	e1520001 	cmp	r2, r1
   1e754:	1a00009c 	bne	1e9cc <free+0x3a8>
   1e758:	e586e00c 	str	lr, [r6, #12]
   1e75c:	e58e6008 	str	r6, [lr, #8]
   1e760:	ea0000cd 	b	1ea9c <free+0x478>
      USAGE_ERROR_ACTION(fm, p);
   1e764:	ebffdfe8 	bl	1670c <abort>
            set_free_with_pinuse(p, psize, next);
   1e768:	e3c22001 	bic	r2, r2, #1
   1e76c:	e5812004 	str	r2, [r1, #4]
   1e770:	e3832001 	orr	r2, r3, #1
   1e774:	e5802004 	str	r2, [r0, #4]
   1e778:	e7803003 	str	r3, [r0, r3]
          if (is_small(psize)) {
   1e77c:	e35300ff 	cmp	r3, #255	@ 0xff
   1e780:	e1a011a3 	lsr	r1, r3, #3
   1e784:	8a00001c 	bhi	1e7fc <free+0x1d8>
            insert_small_chunk(fm, p, psize);
   1e788:	e59f35e4 	ldr	r3, [pc, #1508]	@ 1ed74 <free+0x750>
   1e78c:	e3a02001 	mov	r2, #1
   1e790:	e594e018 	ldr	lr, [r4, #24]
   1e794:	e1a02112 	lsl	r2, r2, r1
   1e798:	e0833181 	add	r3, r3, r1, lsl #3
   1e79c:	e11e0002 	tst	lr, r2
   1e7a0:	018ee002 	orreq	lr, lr, r2
   1e7a4:	e2833028 	add	r3, r3, #40	@ 0x28
   1e7a8:	0584e018 	streq	lr, [r4, #24]
   1e7ac:	01a02003 	moveq	r2, r3
   1e7b0:	0a000002 	beq	1e7c0 <free+0x19c>
   1e7b4:	e5932008 	ldr	r2, [r3, #8]
   1e7b8:	e15c0002 	cmp	ip, r2
   1e7bc:	8a000082 	bhi	1e9cc <free+0x3a8>
   1e7c0:	e5830008 	str	r0, [r3, #8]
   1e7c4:	e582000c 	str	r0, [r2, #12]
   1e7c8:	e1c020f8 	strd	r2, [r0, #8]
            check_free_chunk(fm, p);
   1e7cc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
              else if ((next->head & INUSE_BITS) == INUSE_BITS) {
   1e7d0:	e5912004 	ldr	r2, [r1, #4]
   1e7d4:	e2025003 	and	r5, r2, #3
   1e7d8:	e3550003 	cmp	r5, #3
   1e7dc:	1affffbd 	bne	1e6d8 <free+0xb4>
                set_free_with_pinuse(p, psize, next);
   1e7e0:	e3c22001 	bic	r2, r2, #1
   1e7e4:	e3830001 	orr	r0, r3, #1
                fm->dvsize = psize;
   1e7e8:	e5843020 	str	r3, [r4, #32]
                set_free_with_pinuse(p, psize, next);
   1e7ec:	e5812004 	str	r2, [r1, #4]
   1e7f0:	e58e0004 	str	r0, [lr, #4]
   1e7f4:	e5813000 	str	r3, [r1]
                goto postaction;
   1e7f8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
            insert_large_chunk(fm, tp, psize);
   1e7fc:	e3530401 	cmp	r3, #16777216	@ 0x1000000
   1e800:	e1a02423 	lsr	r2, r3, #8
   1e804:	2a000071 	bcs	1e9d0 <free+0x3ac>
   1e808:	e2421c01 	sub	r1, r2, #256	@ 0x100
   1e80c:	e3a0e001 	mov	lr, #1
   1e810:	e1a01821 	lsr	r1, r1, #16
   1e814:	e2011008 	and	r1, r1, #8
   1e818:	e1a02112 	lsl	r2, r2, r1
   1e81c:	e2425a01 	sub	r5, r2, #4096	@ 0x1000
   1e820:	e1a05825 	lsr	r5, r5, #16
   1e824:	e2055004 	and	r5, r5, #4
   1e828:	e1a02512 	lsl	r2, r2, r5
   1e82c:	e1811005 	orr	r1, r1, r5
   1e830:	e2425901 	sub	r5, r2, #16384	@ 0x4000
   1e834:	e1a05825 	lsr	r5, r5, #16
   1e838:	e2055002 	and	r5, r5, #2
   1e83c:	e1a02512 	lsl	r2, r2, r5
   1e840:	e0811005 	add	r1, r1, r5
   1e844:	e06117a2 	rsb	r1, r1, r2, lsr #15
   1e848:	e2812015 	add	r2, r1, #21
   1e84c:	e281100e 	add	r1, r1, #14
   1e850:	e1a02233 	lsr	r2, r3, r2
   1e854:	e002200e 	and	r2, r2, lr
   1e858:	e0822e11 	add	r2, r2, r1, lsl lr
   1e85c:	e282104c 	add	r1, r2, #76	@ 0x4c
   1e860:	e1a0e21e 	lsl	lr, lr, r2
   1e864:	e1a07101 	lsl	r7, r1, #2
   1e868:	e594601c 	ldr	r6, [r4, #28]
   1e86c:	e3a05000 	mov	r5, #0
   1e870:	e580201c 	str	r2, [r0, #28]
   1e874:	e5805010 	str	r5, [r0, #16]
   1e878:	e11e0006 	tst	lr, r6
   1e87c:	e5805014 	str	r5, [r0, #20]
   1e880:	0a0000c7 	beq	1eba4 <free+0x580>
   1e884:	e352001f 	cmp	r2, #31
   1e888:	e0841101 	add	r1, r4, r1, lsl #2
   1e88c:	11a020a2 	lsrne	r2, r2, #1
   1e890:	01a02003 	moveq	r2, r3
   1e894:	e591e018 	ldr	lr, [r1, #24]
   1e898:	12622019 	rsbne	r2, r2, #25
   1e89c:	11a02213 	lslne	r2, r3, r2
   1e8a0:	ea000006 	b	1e8c0 <free+0x29c>
   1e8a4:	e1a05fa2 	lsr	r5, r2, #31
   1e8a8:	e1a02082 	lsl	r2, r2, #1
   1e8ac:	e08e6105 	add	r6, lr, r5, lsl #2
   1e8b0:	e5961010 	ldr	r1, [r6, #16]
   1e8b4:	e3510000 	cmp	r1, #0
   1e8b8:	0a0000c3 	beq	1ebcc <free+0x5a8>
   1e8bc:	e1a0e001 	mov	lr, r1
   1e8c0:	e59e1004 	ldr	r1, [lr, #4]
   1e8c4:	e3c11007 	bic	r1, r1, #7
   1e8c8:	e1510003 	cmp	r1, r3
   1e8cc:	1afffff4 	bne	1e8a4 <free+0x280>
   1e8d0:	e59e3008 	ldr	r3, [lr, #8]
   1e8d4:	e15c0003 	cmp	ip, r3
   1e8d8:	915c000e 	cmpls	ip, lr
   1e8dc:	8a00003a 	bhi	1e9cc <free+0x3a8>
   1e8e0:	e3a02000 	mov	r2, #0
   1e8e4:	e583000c 	str	r0, [r3, #12]
   1e8e8:	e58e0008 	str	r0, [lr, #8]
   1e8ec:	e5803008 	str	r3, [r0, #8]
   1e8f0:	e580e00c 	str	lr, [r0, #12]
   1e8f4:	e5802018 	str	r2, [r0, #24]
            if (--fm->release_checks == 0)
   1e8f8:	e5943038 	ldr	r3, [r4, #56]	@ 0x38
   1e8fc:	e2433001 	sub	r3, r3, #1
   1e900:	e3530000 	cmp	r3, #0
   1e904:	e5843038 	str	r3, [r4, #56]	@ 0x38
   1e908:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
}
   1e90c:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
              release_unused_segments(fm);
   1e910:	eafff646 	b	1c230 <release_unused_segments.constprop.0>
                unlink_chunk(fm, p, prevsize);
   1e914:	e15e0000 	cmp	lr, r0
   1e918:	e5907018 	ldr	r7, [r0, #24]
   1e91c:	0a00006e 	beq	1eadc <free+0x4b8>
   1e920:	e5902008 	ldr	r2, [r0, #8]
   1e924:	e15c0002 	cmp	ip, r2
   1e928:	8a000027 	bhi	1e9cc <free+0x3a8>
   1e92c:	e592500c 	ldr	r5, [r2, #12]
   1e930:	e1500005 	cmp	r0, r5
   1e934:	1a000024 	bne	1e9cc <free+0x3a8>
   1e938:	e59e5008 	ldr	r5, [lr, #8]
   1e93c:	e1500005 	cmp	r0, r5
   1e940:	1a000021 	bne	1e9cc <free+0x3a8>
   1e944:	e3570000 	cmp	r7, #0
   1e948:	e582e00c 	str	lr, [r2, #12]
   1e94c:	e58e2008 	str	r2, [lr, #8]
   1e950:	0affff60 	beq	1e6d8 <free+0xb4>
   1e954:	e590201c 	ldr	r2, [r0, #28]
   1e958:	e282204c 	add	r2, r2, #76	@ 0x4c
   1e95c:	e0842102 	add	r2, r4, r2, lsl #2
   1e960:	e5925018 	ldr	r5, [r2, #24]
   1e964:	e1500005 	cmp	r0, r5
   1e968:	0582e018 	streq	lr, [r2, #24]
   1e96c:	0a000005 	beq	1e988 <free+0x364>
   1e970:	e15c0007 	cmp	ip, r7
   1e974:	8a000014 	bhi	1e9cc <free+0x3a8>
   1e978:	e5972010 	ldr	r2, [r7, #16]
   1e97c:	e1500002 	cmp	r0, r2
   1e980:	0587e010 	streq	lr, [r7, #16]
   1e984:	1587e014 	strne	lr, [r7, #20]
   1e988:	e15c000e 	cmp	ip, lr
   1e98c:	8a00000e 	bhi	1e9cc <free+0x3a8>
   1e990:	e5902010 	ldr	r2, [r0, #16]
   1e994:	e58e7018 	str	r7, [lr, #24]
   1e998:	e3520000 	cmp	r2, #0
   1e99c:	0a000003 	beq	1e9b0 <free+0x38c>
   1e9a0:	e15c0002 	cmp	ip, r2
   1e9a4:	8a000008 	bhi	1e9cc <free+0x3a8>
   1e9a8:	e58e2010 	str	r2, [lr, #16]
   1e9ac:	e582e018 	str	lr, [r2, #24]
   1e9b0:	e5902014 	ldr	r2, [r0, #20]
   1e9b4:	e3520000 	cmp	r2, #0
   1e9b8:	0affff46 	beq	1e6d8 <free+0xb4>
   1e9bc:	e15c0002 	cmp	ip, r2
   1e9c0:	958e2014 	strls	r2, [lr, #20]
   1e9c4:	9582e018 	strls	lr, [r2, #24]
   1e9c8:	9affff42 	bls	1e6d8 <free+0xb4>
   1e9cc:	ebffdf4e 	bl	1670c <abort>
   1e9d0:	e3a07f6b 	mov	r7, #428	@ 0x1ac
   1e9d4:	e3a0e102 	mov	lr, #-2147483648	@ 0x80000000
            insert_large_chunk(fm, tp, psize);
   1e9d8:	e3a0201f 	mov	r2, #31
   1e9dc:	e3a0106b 	mov	r1, #107	@ 0x6b
   1e9e0:	eaffffa0 	b	1e868 <free+0x244>
              unlink_chunk(fm, next, nsize);
   1e9e4:	e15e0001 	cmp	lr, r1
   1e9e8:	e5918018 	ldr	r8, [r1, #24]
   1e9ec:	0a000053 	beq	1eb40 <free+0x51c>
   1e9f0:	e5912008 	ldr	r2, [r1, #8]
   1e9f4:	e15c0002 	cmp	ip, r2
   1e9f8:	8afffff3 	bhi	1e9cc <free+0x3a8>
   1e9fc:	e592500c 	ldr	r5, [r2, #12]
   1ea00:	e1550001 	cmp	r5, r1
   1ea04:	1afffff0 	bne	1e9cc <free+0x3a8>
   1ea08:	e59e5008 	ldr	r5, [lr, #8]
   1ea0c:	e1550001 	cmp	r5, r1
   1ea10:	1affffed 	bne	1e9cc <free+0x3a8>
   1ea14:	e3580000 	cmp	r8, #0
   1ea18:	e582e00c 	str	lr, [r2, #12]
   1ea1c:	e58e2008 	str	r2, [lr, #8]
   1ea20:	0a00001d 	beq	1ea9c <free+0x478>
   1ea24:	e591201c 	ldr	r2, [r1, #28]
   1ea28:	e282204c 	add	r2, r2, #76	@ 0x4c
   1ea2c:	e0842102 	add	r2, r4, r2, lsl #2
   1ea30:	e5925018 	ldr	r5, [r2, #24]
   1ea34:	e1550001 	cmp	r5, r1
   1ea38:	0582e018 	streq	lr, [r2, #24]
   1ea3c:	0a000005 	beq	1ea58 <free+0x434>
   1ea40:	e15c0008 	cmp	ip, r8
   1ea44:	8affffe0 	bhi	1e9cc <free+0x3a8>
   1ea48:	e5982010 	ldr	r2, [r8, #16]
   1ea4c:	e1520001 	cmp	r2, r1
   1ea50:	0588e010 	streq	lr, [r8, #16]
   1ea54:	1588e014 	strne	lr, [r8, #20]
   1ea58:	e15c000e 	cmp	ip, lr
   1ea5c:	8affffda 	bhi	1e9cc <free+0x3a8>
   1ea60:	e5912010 	ldr	r2, [r1, #16]
   1ea64:	e58e8018 	str	r8, [lr, #24]
   1ea68:	e3520000 	cmp	r2, #0
   1ea6c:	0a000003 	beq	1ea80 <free+0x45c>
   1ea70:	e15c0002 	cmp	ip, r2
   1ea74:	8affffd4 	bhi	1e9cc <free+0x3a8>
   1ea78:	e58e2010 	str	r2, [lr, #16]
   1ea7c:	e582e018 	str	lr, [r2, #24]
   1ea80:	e5912014 	ldr	r2, [r1, #20]
   1ea84:	e3520000 	cmp	r2, #0
   1ea88:	0a000003 	beq	1ea9c <free+0x478>
   1ea8c:	e15c0002 	cmp	ip, r2
   1ea90:	8affffcd 	bhi	1e9cc <free+0x3a8>
   1ea94:	e58e2014 	str	r2, [lr, #20]
   1ea98:	e582e018 	str	lr, [r2, #24]
              if (p == fm->dv) {
   1ea9c:	e1570000 	cmp	r7, r0
              set_size_and_pinuse_of_free_chunk(p, psize);
   1eaa0:	e3832001 	orr	r2, r3, #1
   1eaa4:	e5802004 	str	r2, [r0, #4]
   1eaa8:	e7803003 	str	r3, [r0, r3]
              if (p == fm->dv) {
   1eaac:	1affff32 	bne	1e77c <free+0x158>
                fm->dvsize = psize;
   1eab0:	e5843020 	str	r3, [r4, #32]
                goto postaction;
   1eab4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
            psize += prevsize + MMAP_FOOT_PAD;
   1eab8:	e2822010 	add	r2, r2, #16
   1eabc:	e0825003 	add	r5, r2, r3
            if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
   1eac0:	e1a01005 	mov	r1, r5
   1eac4:	eb0002b1 	bl	1f590 <munmap>
   1eac8:	e3500000 	cmp	r0, #0
              fm->footprint -= psize;
   1eacc:	059431c8 	ldreq	r3, [r4, #456]	@ 0x1c8
   1ead0:	00433005 	subeq	r3, r3, r5
   1ead4:	058431c8 	streq	r3, [r4, #456]	@ 0x1c8
   1ead8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                unlink_chunk(fm, p, prevsize);
   1eadc:	e5902014 	ldr	r2, [r0, #20]
   1eae0:	e3520000 	cmp	r2, #0
   1eae4:	12805014 	addne	r5, r0, #20
   1eae8:	0a000061 	beq	1ec74 <free+0x650>
   1eaec:	e1a06005 	mov	r6, r5
   1eaf0:	e1a0e002 	mov	lr, r2
   1eaf4:	e2825014 	add	r5, r2, #20
   1eaf8:	e5922014 	ldr	r2, [r2, #20]
   1eafc:	e3520000 	cmp	r2, #0
   1eb00:	1afffff9 	bne	1eaec <free+0x4c8>
   1eb04:	e59e2010 	ldr	r2, [lr, #16]
   1eb08:	e28e5010 	add	r5, lr, #16
   1eb0c:	e3520000 	cmp	r2, #0
   1eb10:	1afffff5 	bne	1eaec <free+0x4c8>
   1eb14:	e15c0006 	cmp	ip, r6
   1eb18:	8affffab 	bhi	1e9cc <free+0x3a8>
   1eb1c:	e3570000 	cmp	r7, #0
   1eb20:	e5862000 	str	r2, [r6]
   1eb24:	1affff8a 	bne	1e954 <free+0x330>
   1eb28:	eafffeea 	b	1e6d8 <free+0xb4>
   1eb2c:	e594e018 	ldr	lr, [r4, #24]
   1eb30:	e3a05001 	mov	r5, #1
   1eb34:	e1ce2215 	bic	r2, lr, r5, lsl r2
   1eb38:	e5842018 	str	r2, [r4, #24]
   1eb3c:	eafffee5 	b	1e6d8 <free+0xb4>
              unlink_chunk(fm, next, nsize);
   1eb40:	e5912014 	ldr	r2, [r1, #20]
   1eb44:	e3520000 	cmp	r2, #0
   1eb48:	12815014 	addne	r5, r1, #20
   1eb4c:	0a000057 	beq	1ecb0 <free+0x68c>
   1eb50:	e1a06005 	mov	r6, r5
   1eb54:	e1a0e002 	mov	lr, r2
   1eb58:	e2825014 	add	r5, r2, #20
   1eb5c:	e5922014 	ldr	r2, [r2, #20]
   1eb60:	e3520000 	cmp	r2, #0
   1eb64:	1afffff9 	bne	1eb50 <free+0x52c>
   1eb68:	e59e2010 	ldr	r2, [lr, #16]
   1eb6c:	e28e5010 	add	r5, lr, #16
   1eb70:	e3520000 	cmp	r2, #0
   1eb74:	1afffff5 	bne	1eb50 <free+0x52c>
   1eb78:	e15c0006 	cmp	ip, r6
   1eb7c:	8affff92 	bhi	1e9cc <free+0x3a8>
   1eb80:	e3580000 	cmp	r8, #0
   1eb84:	e5862000 	str	r2, [r6]
   1eb88:	1affffa5 	bne	1ea24 <free+0x400>
   1eb8c:	eaffffc2 	b	1ea9c <free+0x478>
   1eb90:	e5941018 	ldr	r1, [r4, #24]
   1eb94:	e3a0e001 	mov	lr, #1
   1eb98:	e1c1221e 	bic	r2, r1, lr, lsl r2
   1eb9c:	e5842018 	str	r2, [r4, #24]
   1eba0:	eaffffbd 	b	1ea9c <free+0x478>
            insert_large_chunk(fm, tp, psize);
   1eba4:	e59f31c8 	ldr	r3, [pc, #456]	@ 1ed74 <free+0x750>
   1eba8:	e0841101 	add	r1, r4, r1, lsl #2
   1ebac:	e18ee006 	orr	lr, lr, r6
   1ebb0:	e5810018 	str	r0, [r1, #24]
   1ebb4:	e0833007 	add	r3, r3, r7
   1ebb8:	e584e01c 	str	lr, [r4, #28]
   1ebbc:	e5800008 	str	r0, [r0, #8]
   1ebc0:	e580000c 	str	r0, [r0, #12]
   1ebc4:	e5803018 	str	r3, [r0, #24]
   1ebc8:	eaffff4a 	b	1e8f8 <free+0x2d4>
   1ebcc:	e2855004 	add	r5, r5, #4
   1ebd0:	e08e5105 	add	r5, lr, r5, lsl #2
   1ebd4:	e15c0005 	cmp	ip, r5
   1ebd8:	8affff7b 	bhi	1e9cc <free+0x3a8>
   1ebdc:	e5860010 	str	r0, [r6, #16]
   1ebe0:	e580e018 	str	lr, [r0, #24]
   1ebe4:	e5800008 	str	r0, [r0, #8]
   1ebe8:	e580000c 	str	r0, [r0, #12]
   1ebec:	eaffff41 	b	1e8f8 <free+0x2d4>
              size_t tsize = fm->topsize += psize;
   1ebf0:	e5942024 	ldr	r2, [r4, #36]	@ 0x24
              if (p == fm->dv) {
   1ebf4:	e1570000 	cmp	r7, r0
              fm->top = p;
   1ebf8:	e5840030 	str	r0, [r4, #48]	@ 0x30
              size_t tsize = fm->topsize += psize;
   1ebfc:	e0833002 	add	r3, r3, r2
              p->head = tsize | PINUSE_BIT;
   1ec00:	e3832001 	orr	r2, r3, #1
              size_t tsize = fm->topsize += psize;
   1ec04:	e5843024 	str	r3, [r4, #36]	@ 0x24
              p->head = tsize | PINUSE_BIT;
   1ec08:	e5802004 	str	r2, [r0, #4]
              if (should_trim(fm, tsize))
   1ec0c:	e5942034 	ldr	r2, [r4, #52]	@ 0x34
                fm->dv = 0;
   1ec10:	0584e02c 	streq	lr, [r4, #44]	@ 0x2c
                fm->dvsize = 0;
   1ec14:	0584e020 	streq	lr, [r4, #32]
              if (should_trim(fm, tsize))
   1ec18:	e1530002 	cmp	r3, r2
   1ec1c:	98bd81f0 	popls	{r4, r5, r6, r7, r8, pc}
}
   1ec20:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
                sys_trim(fm, 0);
   1ec24:	e3a00000 	mov	r0, #0
   1ec28:	eafff694 	b	1c680 <sys_trim.constprop.0>
              size_t dsize = fm->dvsize += psize;
   1ec2c:	e5942020 	ldr	r2, [r4, #32]
              fm->dv = p;
   1ec30:	e584002c 	str	r0, [r4, #44]	@ 0x2c
              size_t dsize = fm->dvsize += psize;
   1ec34:	e0833002 	add	r3, r3, r2
              set_size_and_pinuse_of_free_chunk(p, dsize);
   1ec38:	e3832001 	orr	r2, r3, #1
              size_t dsize = fm->dvsize += psize;
   1ec3c:	e5843020 	str	r3, [r4, #32]
              set_size_and_pinuse_of_free_chunk(p, dsize);
   1ec40:	e5802004 	str	r2, [r0, #4]
   1ec44:	e7803003 	str	r3, [r0, r3]
              goto postaction;
   1ec48:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                unlink_chunk(fm, p, prevsize);
   1ec4c:	e15c0005 	cmp	ip, r5
   1ec50:	8affff5d 	bhi	1e9cc <free+0x3a8>
   1ec54:	e595700c 	ldr	r7, [r5, #12]
   1ec58:	e1570000 	cmp	r7, r0
   1ec5c:	1affff5a 	bne	1e9cc <free+0x3a8>
   1ec60:	e15e0005 	cmp	lr, r5
   1ec64:	0affffb0 	beq	1eb2c <free+0x508>
   1ec68:	e156000e 	cmp	r6, lr
   1ec6c:	0afffe97 	beq	1e6d0 <free+0xac>
   1ec70:	eafffe91 	b	1e6bc <free+0x98>
   1ec74:	e5902010 	ldr	r2, [r0, #16]
   1ec78:	e3520000 	cmp	r2, #0
   1ec7c:	0a000010 	beq	1ecc4 <free+0x6a0>
   1ec80:	e2805010 	add	r5, r0, #16
   1ec84:	eaffff98 	b	1eaec <free+0x4c8>
              unlink_chunk(fm, next, nsize);
   1ec88:	e15c0006 	cmp	ip, r6
   1ec8c:	8affff4e 	bhi	1e9cc <free+0x3a8>
   1ec90:	e596800c 	ldr	r8, [r6, #12]
   1ec94:	e1580001 	cmp	r8, r1
   1ec98:	1affff4b 	bne	1e9cc <free+0x3a8>
   1ec9c:	e15e0006 	cmp	lr, r6
   1eca0:	0affffba 	beq	1eb90 <free+0x56c>
   1eca4:	e15e0005 	cmp	lr, r5
   1eca8:	0afffeaa 	beq	1e758 <free+0x134>
   1ecac:	eafffea4 	b	1e744 <free+0x120>
   1ecb0:	e5912010 	ldr	r2, [r1, #16]
   1ecb4:	e3520000 	cmp	r2, #0
   1ecb8:	0a000016 	beq	1ed18 <free+0x6f4>
   1ecbc:	e2815010 	add	r5, r1, #16
   1ecc0:	eaffffa2 	b	1eb50 <free+0x52c>
                unlink_chunk(fm, p, prevsize);
   1ecc4:	e3570000 	cmp	r7, #0
   1ecc8:	0afffe82 	beq	1e6d8 <free+0xb4>
   1eccc:	e590501c 	ldr	r5, [r0, #28]
   1ecd0:	e285e04c 	add	lr, r5, #76	@ 0x4c
   1ecd4:	e084e10e 	add	lr, r4, lr, lsl #2
   1ecd8:	e59e6018 	ldr	r6, [lr, #24]
   1ecdc:	e1500006 	cmp	r0, r6
   1ece0:	0a000006 	beq	1ed00 <free+0x6dc>
   1ece4:	e15c0007 	cmp	ip, r7
   1ece8:	8affff37 	bhi	1e9cc <free+0x3a8>
   1ecec:	e597e010 	ldr	lr, [r7, #16]
   1ecf0:	e150000e 	cmp	r0, lr
   1ecf4:	05872010 	streq	r2, [r7, #16]
   1ecf8:	15872014 	strne	r2, [r7, #20]
   1ecfc:	eafffe75 	b	1e6d8 <free+0xb4>
   1ed00:	e58e2018 	str	r2, [lr, #24]
   1ed04:	e3a0e001 	mov	lr, #1
   1ed08:	e594201c 	ldr	r2, [r4, #28]
   1ed0c:	e1c2251e 	bic	r2, r2, lr, lsl r5
   1ed10:	e584201c 	str	r2, [r4, #28]
   1ed14:	eafffe6f 	b	1e6d8 <free+0xb4>
              unlink_chunk(fm, next, nsize);
   1ed18:	e3580000 	cmp	r8, #0
   1ed1c:	0affff5e 	beq	1ea9c <free+0x478>
   1ed20:	e591501c 	ldr	r5, [r1, #28]
   1ed24:	e285e04c 	add	lr, r5, #76	@ 0x4c
   1ed28:	e084e10e 	add	lr, r4, lr, lsl #2
   1ed2c:	e59e2018 	ldr	r2, [lr, #24]
   1ed30:	e1510002 	cmp	r1, r2
   1ed34:	0a000007 	beq	1ed58 <free+0x734>
   1ed38:	e15c0008 	cmp	ip, r8
   1ed3c:	8affff22 	bhi	1e9cc <free+0x3a8>
   1ed40:	e5982010 	ldr	r2, [r8, #16]
   1ed44:	e1520001 	cmp	r2, r1
   1ed48:	e3a02000 	mov	r2, #0
   1ed4c:	05882010 	streq	r2, [r8, #16]
   1ed50:	15882014 	strne	r2, [r8, #20]
   1ed54:	eaffff50 	b	1ea9c <free+0x478>
   1ed58:	e594201c 	ldr	r2, [r4, #28]
   1ed5c:	e3a01001 	mov	r1, #1
   1ed60:	e1c22511 	bic	r2, r2, r1, lsl r5
   1ed64:	e584201c 	str	r2, [r4, #28]
   1ed68:	e3a02000 	mov	r2, #0
   1ed6c:	e58e2018 	str	r2, [lr, #24]
   1ed70:	eaffff49 	b	1ea9c <free+0x478>
   1ed74:	0002b684 	.word	0x0002b684

0001ed78 <calloc>:
void* dlcalloc(size_t n_elements, size_t elem_size) {
   1ed78:	e92d4070 	push	{r4, r5, r6, lr}
  if (n_elements != 0) {
   1ed7c:	e2504000 	subs	r4, r0, #0
   1ed80:	0a000005 	beq	1ed9c <calloc+0x24>
    req = n_elements * elem_size;
   1ed84:	e0060491 	mul	r6, r1, r4
    if (((n_elements | elem_size) & ~(size_t)0xffff) &&
   1ed88:	e1843001 	orr	r3, r4, r1
   1ed8c:	e3530801 	cmp	r3, #65536	@ 0x10000
   1ed90:	e1a05001 	mov	r5, r1
    req = n_elements * elem_size;
   1ed94:	31a04006 	movcc	r4, r6
    if (((n_elements | elem_size) & ~(size_t)0xffff) &&
   1ed98:	2a000008 	bcs	1edc0 <calloc+0x48>
  mem = dlmalloc(req);
   1ed9c:	e1a00004 	mov	r0, r4
   1eda0:	ebfff7a5 	bl	1cc3c <malloc>
  if (mem != 0 && calloc_must_clear(mem2chunk(mem)))
   1eda4:	e2505000 	subs	r5, r0, #0
   1eda8:	0a000002 	beq	1edb8 <calloc+0x40>
   1edac:	e5153004 	ldr	r3, [r5, #-4]
   1edb0:	e3130003 	tst	r3, #3
   1edb4:	1a000008 	bne	1eddc <calloc+0x64>
}
   1edb8:	e1a00005 	mov	r0, r5
   1edbc:	e8bd8070 	pop	{r4, r5, r6, pc}
        (req / n_elements != elem_size))
   1edc0:	e1a01004 	mov	r1, r4
   1edc4:	e1a00006 	mov	r0, r6
   1edc8:	ebffdce4 	bl	16160 <__udivsi3>
    req = n_elements * elem_size;
   1edcc:	e1500005 	cmp	r0, r5
   1edd0:	01a04006 	moveq	r4, r6
   1edd4:	13e04000 	mvnne	r4, #0
   1edd8:	eaffffef 	b	1ed9c <calloc+0x24>
    memset(mem, 0, req);
   1eddc:	e1a02004 	mov	r2, r4
   1ede0:	e3a01000 	mov	r1, #0
   1ede4:	ebffee31 	bl	1a6b0 <memset>
}
   1ede8:	e1a00005 	mov	r0, r5
   1edec:	e8bd8070 	pop	{r4, r5, r6, pc}

0001edf0 <realloc>:

/* ------------------ Exported realloc, memalign, etc -------------------- */

#if !ONLY_MSPACES

void* dlrealloc(void* oldmem, size_t bytes) {
   1edf0:	e92d4070 	push	{r4, r5, r6, lr}
  void* mem = 0;
  if (oldmem == 0) {
   1edf4:	e2506000 	subs	r6, r0, #0
void* dlrealloc(void* oldmem, size_t bytes) {
   1edf8:	e1a04001 	mov	r4, r1
  if (oldmem == 0) {
   1edfc:	0a00000c 	beq	1ee34 <realloc+0x44>
    mem = dlmalloc(bytes);
  }
  else if (bytes >= MAX_REQUEST) {
   1ee00:	e3710041 	cmn	r1, #65	@ 0x41
   1ee04:	8a00000d 	bhi	1ee40 <realloc+0x50>
  else if (bytes == 0) {
    dlfree(oldmem);
  }
#endif /* REALLOC_ZERO_BYTES_FREES */
  else {
    size_t nb = request2size(bytes);
   1ee08:	e351000a 	cmp	r1, #10
      USAGE_ERROR_ACTION(m, oldmem);
      return 0;
    }
#endif /* FOOTERS */
    if (!PREACTION(m)) {
      mchunkptr newp = try_realloc_chunk(m, oldp, nb, 1);
   1ee0c:	e2460008 	sub	r0, r6, #8
    size_t nb = request2size(bytes);
   1ee10:	8281100b 	addhi	r1, r1, #11
   1ee14:	93a01010 	movls	r1, #16
   1ee18:	83c11007 	bichi	r1, r1, #7
      mchunkptr newp = try_realloc_chunk(m, oldp, nb, 1);
   1ee1c:	ebfff681 	bl	1c828 <try_realloc_chunk.constprop.0.isra.0>
      POSTACTION(m);
      if (newp != 0) {
   1ee20:	e3500000 	cmp	r0, #0
        check_inuse_chunk(m, newp);
        mem = chunk2mem(newp);
   1ee24:	12805008 	addne	r5, r0, #8
      if (newp != 0) {
   1ee28:	0a000009 	beq	1ee54 <realloc+0x64>
        }
      }
    }
  }
  return mem;
}
   1ee2c:	e1a00005 	mov	r0, r5
   1ee30:	e8bd8070 	pop	{r4, r5, r6, pc}
   1ee34:	e8bd4070 	pop	{r4, r5, r6, lr}
    mem = dlmalloc(bytes);
   1ee38:	e1a00001 	mov	r0, r1
   1ee3c:	eafff77e 	b	1cc3c <malloc>
    MALLOC_FAILURE_ACTION;
   1ee40:	ebfff273 	bl	1b814 <__errno>
   1ee44:	e3a0300c 	mov	r3, #12
   1ee48:	e5803000 	str	r3, [r0]
  void* mem = 0;
   1ee4c:	e3a05000 	mov	r5, #0
   1ee50:	eafffff5 	b	1ee2c <realloc+0x3c>
        mem = internal_malloc(m, bytes);
   1ee54:	e1a00004 	mov	r0, r4
   1ee58:	ebfff777 	bl	1cc3c <malloc>
        if (mem != 0) {
   1ee5c:	e2505000 	subs	r5, r0, #0
   1ee60:	0afffff9 	beq	1ee4c <realloc+0x5c>
          size_t oc = chunksize(oldp) - overhead_for(oldp);
   1ee64:	e5162004 	ldr	r2, [r6, #-4]
          memcpy(mem, oldmem, (oc < bytes)? oc : bytes);
   1ee68:	e1a01006 	mov	r1, r6
          size_t oc = chunksize(oldp) - overhead_for(oldp);
   1ee6c:	e3120003 	tst	r2, #3
   1ee70:	e3c22007 	bic	r2, r2, #7
   1ee74:	13a03004 	movne	r3, #4
   1ee78:	03a03008 	moveq	r3, #8
   1ee7c:	e0422003 	sub	r2, r2, r3
          memcpy(mem, oldmem, (oc < bytes)? oc : bytes);
   1ee80:	e1520004 	cmp	r2, r4
   1ee84:	21a02004 	movcs	r2, r4
   1ee88:	eb0003fc 	bl	1fe80 <memcpy>
          internal_free(m, oldmem);
   1ee8c:	e1a00006 	mov	r0, r6
   1ee90:	ebfffde3 	bl	1e624 <free>
}
   1ee94:	e1a00005 	mov	r0, r5
   1ee98:	e8bd8070 	pop	{r4, r5, r6, pc}

0001ee9c <realloc_in_place>:

void* dlrealloc_in_place(void* oldmem, size_t bytes) {
   1ee9c:	e92d4070 	push	{r4, r5, r6, lr}
  void* mem = 0;
  if (oldmem != 0) {
   1eea0:	e2504000 	subs	r4, r0, #0
   1eea4:	0a00000f 	beq	1eee8 <realloc_in_place+0x4c>
    if (bytes >= MAX_REQUEST) {
   1eea8:	e3710041 	cmn	r1, #65	@ 0x41
   1eeac:	8a00000a 	bhi	1eedc <realloc_in_place+0x40>
      MALLOC_FAILURE_ACTION;
    }
    else {
      size_t nb = request2size(bytes);
   1eeb0:	e351000a 	cmp	r1, #10
      mchunkptr oldp = mem2chunk(oldmem);
   1eeb4:	e2445008 	sub	r5, r4, #8
      size_t nb = request2size(bytes);
   1eeb8:	8281100b 	addhi	r1, r1, #11
   1eebc:	93a01010 	movls	r1, #16
   1eec0:	83c11007 	bichi	r1, r1, #7
        USAGE_ERROR_ACTION(m, oldmem);
        return 0;
      }
#endif /* FOOTERS */
      if (!PREACTION(m)) {
        mchunkptr newp = try_realloc_chunk(m, oldp, nb, 0);
   1eec4:	e1a00005 	mov	r0, r5
   1eec8:	ebfff656 	bl	1c828 <try_realloc_chunk.constprop.0.isra.0>
        POSTACTION(m);
        if (newp == oldp) {
   1eecc:	e1550000 	cmp	r5, r0
   1eed0:	1a000004 	bne	1eee8 <realloc_in_place+0x4c>
          check_inuse_chunk(m, newp);
          mem = oldmem;
   1eed4:	e1a00004 	mov	r0, r4
        }
      }
    }
  }
  return mem;
}
   1eed8:	e8bd8070 	pop	{r4, r5, r6, pc}
      MALLOC_FAILURE_ACTION;
   1eedc:	ebfff24c 	bl	1b814 <__errno>
   1eee0:	e3a0300c 	mov	r3, #12
   1eee4:	e5803000 	str	r3, [r0]
  void* mem = 0;
   1eee8:	e3a00000 	mov	r0, #0
   1eeec:	e8bd8070 	pop	{r4, r5, r6, pc}

0001eef0 <memalign>:

void* dlmemalign(size_t alignment, size_t bytes) {
  if (alignment <= MALLOC_ALIGNMENT) {
   1eef0:	e3500008 	cmp	r0, #8
   1eef4:	9a000000 	bls	1eefc <memalign+0xc>
    return dlmalloc(bytes);
  }
  return internal_memalign(gm, alignment, bytes);
   1eef8:	eafffd5e 	b	1e478 <internal_memalign.constprop.0>
    return dlmalloc(bytes);
   1eefc:	e1a00001 	mov	r0, r1
   1ef00:	eafff74d 	b	1cc3c <malloc>

0001ef04 <posix_memalign>:
}

int dlposix_memalign(void** pp, size_t alignment, size_t bytes) {
  void* mem = 0;
  if (alignment == MALLOC_ALIGNMENT)
   1ef04:	e3510008 	cmp	r1, #8
int dlposix_memalign(void** pp, size_t alignment, size_t bytes) {
   1ef08:	e1a03001 	mov	r3, r1
   1ef0c:	e92d4010 	push	{r4, lr}
   1ef10:	e1a01002 	mov	r1, r2
   1ef14:	e1a04000 	mov	r4, r0
  if (alignment == MALLOC_ALIGNMENT)
   1ef18:	0a000019 	beq	1ef84 <posix_memalign+0x80>
    mem = dlmalloc(bytes);
  else {
    size_t d = alignment / sizeof(void*);
    size_t r = alignment % sizeof(void*);
    if (r != 0 || d == 0 || (d & (d-SIZE_T_ONE)) != 0)
   1ef1c:	e3530003 	cmp	r3, #3
    size_t d = alignment / sizeof(void*);
   1ef20:	e1a00123 	lsr	r0, r3, #2
    size_t r = alignment % sizeof(void*);
   1ef24:	e203c003 	and	ip, r3, #3
    if (r != 0 || d == 0 || (d & (d-SIZE_T_ONE)) != 0)
   1ef28:	9a000011 	bls	1ef74 <posix_memalign+0x70>
   1ef2c:	e2402001 	sub	r2, r0, #1
   1ef30:	e0022000 	and	r2, r2, r0
   1ef34:	e192200c 	orrs	r2, r2, ip
   1ef38:	1a00000d 	bne	1ef74 <posix_memalign+0x70>
      return EINVAL;
    else if (bytes <= MAX_REQUEST - alignment) {
   1ef3c:	e3e0203f 	mvn	r2, #63	@ 0x3f
   1ef40:	e0422003 	sub	r2, r2, r3
   1ef44:	e1520001 	cmp	r2, r1
   1ef48:	3a00000b 	bcc	1ef7c <posix_memalign+0x78>
      if (alignment <  MIN_CHUNK_SIZE)
        alignment = MIN_CHUNK_SIZE;
      mem = internal_memalign(gm, alignment, bytes);
   1ef4c:	e3530010 	cmp	r3, #16
   1ef50:	21a00003 	movcs	r0, r3
   1ef54:	33a00010 	movcc	r0, #16
   1ef58:	ebfffd46 	bl	1e478 <internal_memalign.constprop.0>
   1ef5c:	e1a03000 	mov	r3, r0
    }
  }
  if (mem == 0)
   1ef60:	e3530000 	cmp	r3, #0
   1ef64:	0a000004 	beq	1ef7c <posix_memalign+0x78>
    return ENOMEM;
  else {
    *pp = mem;
    return 0;
   1ef68:	e3a00000 	mov	r0, #0
    *pp = mem;
   1ef6c:	e5843000 	str	r3, [r4]
    return 0;
   1ef70:	e8bd8010 	pop	{r4, pc}
      return EINVAL;
   1ef74:	e3a00016 	mov	r0, #22
  }
}
   1ef78:	e8bd8010 	pop	{r4, pc}
    return ENOMEM;
   1ef7c:	e3a0000c 	mov	r0, #12
   1ef80:	e8bd8010 	pop	{r4, pc}
    mem = dlmalloc(bytes);
   1ef84:	e1a00002 	mov	r0, r2
   1ef88:	ebfff72b 	bl	1cc3c <malloc>
   1ef8c:	e1a03000 	mov	r3, r0
   1ef90:	eafffff2 	b	1ef60 <posix_memalign+0x5c>

0001ef94 <valloc>:

void* dlvalloc(size_t bytes) {
   1ef94:	e92d4070 	push	{r4, r5, r6, lr}
  size_t pagesz;
  ensure_initialization();
   1ef98:	e30b466c 	movw	r4, #46700	@ 0xb66c
   1ef9c:	e3404002 	movt	r4, #2
void* dlvalloc(size_t bytes) {
   1efa0:	e1a05000 	mov	r5, r0
  ensure_initialization();
   1efa4:	e5943000 	ldr	r3, [r4]
   1efa8:	e3530000 	cmp	r3, #0
   1efac:	0a000008 	beq	1efd4 <valloc+0x40>
  pagesz = mparams.page_size;
   1efb0:	e5940004 	ldr	r0, [r4, #4]
  if (alignment <= MALLOC_ALIGNMENT) {
   1efb4:	e3500008 	cmp	r0, #8
   1efb8:	9a000002 	bls	1efc8 <valloc+0x34>
  return internal_memalign(gm, alignment, bytes);
   1efbc:	e1a01005 	mov	r1, r5
  return dlmemalign(pagesz, bytes);
}
   1efc0:	e8bd4070 	pop	{r4, r5, r6, lr}
  return internal_memalign(gm, alignment, bytes);
   1efc4:	eafffd2b 	b	1e478 <internal_memalign.constprop.0>
    return dlmalloc(bytes);
   1efc8:	e1a00005 	mov	r0, r5
}
   1efcc:	e8bd4070 	pop	{r4, r5, r6, lr}
    return dlmalloc(bytes);
   1efd0:	eafff719 	b	1cc3c <malloc>
  if (mparams.magic == 0) {
   1efd4:	ebfff2ae 	bl	1ba94 <init_mparams.part.0>
  return 1;
   1efd8:	eafffff4 	b	1efb0 <valloc+0x1c>

0001efdc <pvalloc>:

void* dlpvalloc(size_t bytes) {
   1efdc:	e92d4070 	push	{r4, r5, r6, lr}
  size_t pagesz;
  ensure_initialization();
   1efe0:	e30b466c 	movw	r4, #46700	@ 0xb66c
   1efe4:	e3404002 	movt	r4, #2
void* dlpvalloc(size_t bytes) {
   1efe8:	e1a05000 	mov	r5, r0
  ensure_initialization();
   1efec:	e5943000 	ldr	r3, [r4]
   1eff0:	e3530000 	cmp	r3, #0
   1eff4:	0a00000b 	beq	1f028 <pvalloc+0x4c>
  pagesz = mparams.page_size;
   1eff8:	e5940004 	ldr	r0, [r4, #4]
  return dlmemalign(pagesz, (bytes + pagesz - SIZE_T_ONE) & ~(pagesz - SIZE_T_ONE));
   1effc:	e2401001 	sub	r1, r0, #1
  if (alignment <= MALLOC_ALIGNMENT) {
   1f000:	e3500008 	cmp	r0, #8
  return dlmemalign(pagesz, (bytes + pagesz - SIZE_T_ONE) & ~(pagesz - SIZE_T_ONE));
   1f004:	e0811005 	add	r1, r1, r5
   1f008:	e2603000 	rsb	r3, r0, #0
   1f00c:	e0011003 	and	r1, r1, r3
  if (alignment <= MALLOC_ALIGNMENT) {
   1f010:	9a000001 	bls	1f01c <pvalloc+0x40>
}
   1f014:	e8bd4070 	pop	{r4, r5, r6, lr}
  return internal_memalign(gm, alignment, bytes);
   1f018:	eafffd16 	b	1e478 <internal_memalign.constprop.0>
}
   1f01c:	e8bd4070 	pop	{r4, r5, r6, lr}
    return dlmalloc(bytes);
   1f020:	e1a00001 	mov	r0, r1
   1f024:	eafff704 	b	1cc3c <malloc>
  if (mparams.magic == 0) {
   1f028:	ebfff299 	bl	1ba94 <init_mparams.part.0>
  return 1;
   1f02c:	eafffff1 	b	1eff8 <pvalloc+0x1c>

0001f030 <independent_calloc>:

void** dlindependent_calloc(size_t n_elements, size_t elem_size,
                            void* chunks[]) {
   1f030:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
   1f034:	e24dd00c 	sub	sp, sp, #12
   1f038:	e1a0c001 	mov	ip, r1
   1f03c:	e1a03002 	mov	r3, r2
  size_t sz = elem_size; /* serves as 1-element array */
  return ialloc(gm, n_elements, &sz, 3, chunks);
   1f040:	e28d1004 	add	r1, sp, #4
   1f044:	e3a02003 	mov	r2, #3
  size_t sz = elem_size; /* serves as 1-element array */
   1f048:	e58dc004 	str	ip, [sp, #4]
  return ialloc(gm, n_elements, &sz, 3, chunks);
   1f04c:	ebfffc8a 	bl	1e27c <ialloc.constprop.0>
}
   1f050:	e28dd00c 	add	sp, sp, #12
   1f054:	e49df004 	pop	{pc}		@ (ldr pc, [sp], #4)

0001f058 <independent_comalloc>:

void** dlindependent_comalloc(size_t n_elements, size_t sizes[],
                              void* chunks[]) {
   1f058:	e1a03002 	mov	r3, r2
  return ialloc(gm, n_elements, sizes, 0, chunks);
   1f05c:	e3a02000 	mov	r2, #0
   1f060:	eafffc85 	b	1e27c <ialloc.constprop.0>

0001f064 <bulk_free>:
}

size_t dlbulk_free(void* array[], size_t nelem) {
   1f064:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    void** fence = &(array[nelem]);
   1f068:	e0805101 	add	r5, r0, r1, lsl #2
    for (a = array; a != fence; ++a) {
   1f06c:	e1500005 	cmp	r0, r5
   1f070:	130b666c 	movwne	r6, #46700	@ 0xb66c
   1f074:	11a04000 	movne	r4, r0
   1f078:	13406002 	movtne	r6, #2
        *a = 0;
   1f07c:	13a07000 	movne	r7, #0
    for (a = array; a != fence; ++a) {
   1f080:	0a000032 	beq	1f150 <bulk_free+0xec>
      void* mem = *a;
   1f084:	e4943004 	ldr	r3, [r4], #4
      if (mem != 0) {
   1f088:	e3530000 	cmp	r3, #0
   1f08c:	0a000011 	beq	1f0d8 <bulk_free+0x74>
        size_t psize = chunksize(p);
   1f090:	e5132004 	ldr	r2, [r3, #-4]
        mchunkptr p = mem2chunk(mem);
   1f094:	e2430008 	sub	r0, r3, #8
        *a = 0;
   1f098:	e5047004 	str	r7, [r4, #-4]
        if (RTCHECK(ok_address(m, p) && ok_inuse(p))) {
   1f09c:	e596c028 	ldr	ip, [r6, #40]	@ 0x28
        size_t psize = chunksize(p);
   1f0a0:	e3c21007 	bic	r1, r2, #7
        if (RTCHECK(ok_address(m, p) && ok_inuse(p))) {
   1f0a4:	e150000c 	cmp	r0, ip
   1f0a8:	3a00001f 	bcc	1f12c <bulk_free+0xc8>
   1f0ac:	e202c003 	and	ip, r2, #3
   1f0b0:	e35c0001 	cmp	ip, #1
   1f0b4:	0a00001c 	beq	1f12c <bulk_free+0xc8>
          if (b != fence && *b == chunk2mem(next)) {
   1f0b8:	e1550004 	cmp	r5, r4
          mchunkptr next = next_chunk(p);
   1f0bc:	e080c001 	add	ip, r0, r1
          if (b != fence && *b == chunk2mem(next)) {
   1f0c0:	0a00001a 	beq	1f130 <bulk_free+0xcc>
   1f0c4:	e5948000 	ldr	r8, [r4]
   1f0c8:	e28ce008 	add	lr, ip, #8
   1f0cc:	e158000e 	cmp	r8, lr
   1f0d0:	0a000008 	beq	1f0f8 <bulk_free+0x94>
            dispose_chunk(m, p, psize);
   1f0d4:	ebfff28a 	bl	1bb04 <dispose_chunk.constprop.0>
    for (a = array; a != fence; ++a) {
   1f0d8:	e1550004 	cmp	r5, r4
   1f0dc:	1affffe8 	bne	1f084 <bulk_free+0x20>
    if (should_trim(m, m->topsize))
   1f0e0:	e5962024 	ldr	r2, [r6, #36]	@ 0x24
   1f0e4:	e5963034 	ldr	r3, [r6, #52]	@ 0x34
   1f0e8:	e1520003 	cmp	r2, r3
   1f0ec:	8a000014 	bhi	1f144 <bulk_free+0xe0>
  return internal_bulk_free(gm, array, nelem);
}
   1f0f0:	e3a00000 	mov	r0, #0
   1f0f4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
            size_t newsize = chunksize(next) + psize;
   1f0f8:	e59cc004 	ldr	ip, [ip, #4]
            set_inuse(m, p, newsize);
   1f0fc:	e2022001 	and	r2, r2, #1
            size_t newsize = chunksize(next) + psize;
   1f100:	e3ccc007 	bic	ip, ip, #7
   1f104:	e08c1001 	add	r1, ip, r1
            set_inuse(m, p, newsize);
   1f108:	e1822001 	orr	r2, r2, r1
   1f10c:	e0801001 	add	r1, r0, r1
   1f110:	e3822002 	orr	r2, r2, #2
   1f114:	e5032004 	str	r2, [r3, #-4]
   1f118:	e5912004 	ldr	r2, [r1, #4]
   1f11c:	e3822001 	orr	r2, r2, #1
   1f120:	e5812004 	str	r2, [r1, #4]
            *b = chunk2mem(p);
   1f124:	e5843000 	str	r3, [r4]
    for (a = array; a != fence; ++a) {
   1f128:	eaffffd5 	b	1f084 <bulk_free+0x20>
          CORRUPTION_ERROR_ACTION(m);
   1f12c:	ebffdd76 	bl	1670c <abort>
            dispose_chunk(m, p, psize);
   1f130:	ebfff273 	bl	1bb04 <dispose_chunk.constprop.0>
    if (should_trim(m, m->topsize))
   1f134:	e5962024 	ldr	r2, [r6, #36]	@ 0x24
   1f138:	e5963034 	ldr	r3, [r6, #52]	@ 0x34
   1f13c:	e1520003 	cmp	r2, r3
   1f140:	9affffea 	bls	1f0f0 <bulk_free+0x8c>
      sys_trim(m, 0);
   1f144:	e3a00000 	mov	r0, #0
   1f148:	ebfff54c 	bl	1c680 <sys_trim.constprop.0>
   1f14c:	eaffffe7 	b	1f0f0 <bulk_free+0x8c>
   1f150:	e30b666c 	movw	r6, #46700	@ 0xb66c
   1f154:	e3406002 	movt	r6, #2
   1f158:	eaffffe0 	b	1f0e0 <bulk_free+0x7c>

0001f15c <malloc_trim>:
}
#endif /* MALLOC_INSPECT_ALL */

int dlmalloc_trim(size_t pad) {
  int result = 0;
  ensure_initialization();
   1f15c:	e30b366c 	movw	r3, #46700	@ 0xb66c
int dlmalloc_trim(size_t pad) {
   1f160:	e92d4010 	push	{r4, lr}
  ensure_initialization();
   1f164:	e3403002 	movt	r3, #2
int dlmalloc_trim(size_t pad) {
   1f168:	e1a04000 	mov	r4, r0
  ensure_initialization();
   1f16c:	e5933000 	ldr	r3, [r3]
   1f170:	e3530000 	cmp	r3, #0
   1f174:	0a000002 	beq	1f184 <malloc_trim+0x28>
  if (!PREACTION(gm)) {
    result = sys_trim(gm, pad);
   1f178:	e1a00004 	mov	r0, r4
    POSTACTION(gm);
  }
  return result;
}
   1f17c:	e8bd4010 	pop	{r4, lr}
    result = sys_trim(gm, pad);
   1f180:	eafff53e 	b	1c680 <sys_trim.constprop.0>
  if (mparams.magic == 0) {
   1f184:	ebfff242 	bl	1ba94 <init_mparams.part.0>
    result = sys_trim(gm, pad);
   1f188:	e1a00004 	mov	r0, r4
}
   1f18c:	e8bd4010 	pop	{r4, lr}
    result = sys_trim(gm, pad);
   1f190:	eafff53a 	b	1c680 <sys_trim.constprop.0>

0001f194 <malloc_footprint>:

size_t dlmalloc_footprint(void) {
  return gm->footprint;
   1f194:	e30b366c 	movw	r3, #46700	@ 0xb66c
   1f198:	e3403002 	movt	r3, #2
}
   1f19c:	e59301c8 	ldr	r0, [r3, #456]	@ 0x1c8
   1f1a0:	e12fff1e 	bx	lr

0001f1a4 <malloc_max_footprint>:

size_t dlmalloc_max_footprint(void) {
  return gm->max_footprint;
   1f1a4:	e30b366c 	movw	r3, #46700	@ 0xb66c
   1f1a8:	e3403002 	movt	r3, #2
}
   1f1ac:	e59301cc 	ldr	r0, [r3, #460]	@ 0x1cc
   1f1b0:	e12fff1e 	bx	lr

0001f1b4 <malloc_footprint_limit>:

size_t dlmalloc_footprint_limit(void) {
  size_t maf = gm->footprint_limit;
   1f1b4:	e30b366c 	movw	r3, #46700	@ 0xb66c
   1f1b8:	e3403002 	movt	r3, #2
   1f1bc:	e59301d0 	ldr	r0, [r3, #464]	@ 0x1d0
  return maf == 0 ? MAX_SIZE_T : maf;
   1f1c0:	e3500000 	cmp	r0, #0
}
   1f1c4:	03e00000 	mvneq	r0, #0
   1f1c8:	e12fff1e 	bx	lr

0001f1cc <malloc_set_footprint_limit>:

size_t dlmalloc_set_footprint_limit(size_t bytes) {
  size_t result;  /* invert sense of 0 */
  if (bytes == 0)
    result = granularity_align(1); /* Use minimal size */
  if (bytes == MAX_SIZE_T)
   1f1cc:	e3700001 	cmn	r0, #1
    result = 0;                    /* disable */
  else
    result = granularity_align(bytes);
   1f1d0:	e30b266c 	movw	r2, #46700	@ 0xb66c
   1f1d4:	13402002 	movtne	r2, #2
    result = 0;                    /* disable */
   1f1d8:	03a00000 	moveq	r0, #0
    result = granularity_align(bytes);
   1f1dc:	15921008 	ldrne	r1, [r2, #8]
   1f1e0:	03402002 	movteq	r2, #2
   1f1e4:	12413001 	subne	r3, r1, #1
   1f1e8:	12611000 	rsbne	r1, r1, #0
   1f1ec:	10830000 	addne	r0, r3, r0
   1f1f0:	10000001 	andne	r0, r0, r1
  return gm->footprint_limit = result;
   1f1f4:	e58201d0 	str	r0, [r2, #464]	@ 0x1d0
}
   1f1f8:	e12fff1e 	bx	lr

0001f1fc <mallinfo>:

#if !NO_MALLINFO
struct mallinfo dlmallinfo(void) {
   1f1fc:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
  ensure_initialization();
   1f200:	e30b766c 	movw	r7, #46700	@ 0xb66c
   1f204:	e3407002 	movt	r7, #2
  struct mallinfo nm = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
   1f208:	e3a03000 	mov	r3, #0
struct mallinfo dlmallinfo(void) {
   1f20c:	e24dd028 	sub	sp, sp, #40	@ 0x28
   1f210:	e1a04000 	mov	r4, r0
  ensure_initialization();
   1f214:	e5972000 	ldr	r2, [r7]
  struct mallinfo nm = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
   1f218:	e58d3008 	str	r3, [sp, #8]
   1f21c:	e58d300c 	str	r3, [sp, #12]
  ensure_initialization();
   1f220:	e1520003 	cmp	r2, r3
  struct mallinfo nm = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
   1f224:	e58d3010 	str	r3, [sp, #16]
   1f228:	e58d3014 	str	r3, [sp, #20]
   1f22c:	e58d3018 	str	r3, [sp, #24]
  ensure_initialization();
   1f230:	0a00003d 	beq	1f32c <mallinfo+0x130>
    if (is_initialized(m)) {
   1f234:	e5975030 	ldr	r5, [r7, #48]	@ 0x30
   1f238:	e3550000 	cmp	r5, #0
   1f23c:	0a00003e 	beq	1f33c <mallinfo+0x140>
      size_t mfree = m->topsize + TOP_FOOT_SIZE;
   1f240:	e597a024 	ldr	sl, [r7, #36]	@ 0x24
      size_t nfree = SIZE_T_ONE; /* top always free */
   1f244:	e3a08001 	mov	r8, #1
      msegmentptr s = &m->seg;
   1f248:	e59f910c 	ldr	r9, [pc, #268]	@ 1f35c <mallinfo+0x160>
      size_t mfree = m->topsize + TOP_FOOT_SIZE;
   1f24c:	e28a6028 	add	r6, sl, #40	@ 0x28
      size_t sum = mfree;
   1f250:	e1a01006 	mov	r1, r6
        mchunkptr q = align_as_chunk(s->base);
   1f254:	e599e000 	ldr	lr, [r9]
   1f258:	e31e0007 	tst	lr, #7
   1f25c:	e28e3008 	add	r3, lr, #8
   1f260:	0a00002f 	beq	1f324 <mallinfo+0x128>
   1f264:	e2632000 	rsb	r2, r3, #0
   1f268:	e2022007 	and	r2, r2, #7
               q != m->top && q->head != FENCEPOST_HEAD) {
   1f26c:	e09e2002 	adds	r2, lr, r2
   1f270:	2a000013 	bcs	1f2c4 <mallinfo+0xc8>
        while (segment_holds(s, q) &&
   1f274:	e5990004 	ldr	r0, [r9, #4]
   1f278:	e08e0000 	add	r0, lr, r0
   1f27c:	e1550002 	cmp	r5, r2
   1f280:	11520000 	cmpne	r2, r0
   1f284:	2a00000e 	bcs	1f2c4 <mallinfo+0xc8>
               q != m->top && q->head != FENCEPOST_HEAD) {
   1f288:	e5923004 	ldr	r3, [r2, #4]
   1f28c:	e3530007 	cmp	r3, #7
          if (!is_inuse(q)) {
   1f290:	e203c003 	and	ip, r3, #3
          size_t sz = chunksize(q);
   1f294:	e3c33007 	bic	r3, r3, #7
          q = next_chunk(q);
   1f298:	e0822003 	add	r2, r2, r3
               q != m->top && q->head != FENCEPOST_HEAD) {
   1f29c:	0a000008 	beq	1f2c4 <mallinfo+0xc8>
          if (!is_inuse(q)) {
   1f2a0:	e35c0001 	cmp	ip, #1
          sum += sz;
   1f2a4:	e0811003 	add	r1, r1, r3
            mfree += sz;
   1f2a8:	00866003 	addeq	r6, r6, r3
            ++nfree;
   1f2ac:	02888001 	addeq	r8, r8, #1
               q != m->top && q->head != FENCEPOST_HEAD) {
   1f2b0:	e15e0002 	cmp	lr, r2
   1f2b4:	8a000002 	bhi	1f2c4 <mallinfo+0xc8>
        while (segment_holds(s, q) &&
   1f2b8:	e1550002 	cmp	r5, r2
   1f2bc:	11520000 	cmpne	r2, r0
   1f2c0:	3afffff0 	bcc	1f288 <mallinfo+0x8c>
        s = s->next;
   1f2c4:	e5999008 	ldr	r9, [r9, #8]
      while (s != 0) {
   1f2c8:	e3590000 	cmp	r9, #0
   1f2cc:	1affffe0 	bne	1f254 <mallinfo+0x58>
      nm.hblkhd   = m->footprint - sum;
   1f2d0:	e59731c8 	ldr	r3, [r7, #456]	@ 0x1c8
      nm.usmblks  = m->max_footprint;
   1f2d4:	e59721cc 	ldr	r2, [r7, #460]	@ 0x1cc
      nm.hblkhd   = m->footprint - sum;
   1f2d8:	e0430001 	sub	r0, r3, r1
      nm.uordblks = m->footprint - mfree;
   1f2dc:	e0433006 	sub	r3, r3, r6
  return nm;
   1f2e0:	e1a0e00d 	mov	lr, sp
   1f2e4:	e58d0010 	str	r0, [sp, #16]
   1f2e8:	e58d2014 	str	r2, [sp, #20]
   1f2ec:	e1a0c004 	mov	ip, r4
   1f2f0:	e58d301c 	str	r3, [sp, #28]
   1f2f4:	e88d0102 	stm	sp, {r1, r8}
   1f2f8:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
   1f2fc:	e58d6020 	str	r6, [sp, #32]
   1f300:	e58da024 	str	sl, [sp, #36]	@ 0x24
   1f304:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
   1f308:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
   1f30c:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
   1f310:	e89e0003 	ldm	lr, {r0, r1}
   1f314:	e88c0003 	stm	ip, {r0, r1}
  return internal_mallinfo(gm);
}
   1f318:	e1a00004 	mov	r0, r4
   1f31c:	e28dd028 	add	sp, sp, #40	@ 0x28
   1f320:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        mchunkptr q = align_as_chunk(s->base);
   1f324:	e1a0200e 	mov	r2, lr
   1f328:	eaffffd1 	b	1f274 <mallinfo+0x78>
  if (mparams.magic == 0) {
   1f32c:	ebfff1d8 	bl	1ba94 <init_mparams.part.0>
    if (is_initialized(m)) {
   1f330:	e5975030 	ldr	r5, [r7, #48]	@ 0x30
   1f334:	e3550000 	cmp	r5, #0
   1f338:	1affffc0 	bne	1f240 <mallinfo+0x44>
  struct mallinfo nm = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
   1f33c:	e1a0a005 	mov	sl, r5
   1f340:	e1a06005 	mov	r6, r5
   1f344:	e1a03005 	mov	r3, r5
   1f348:	e1a02005 	mov	r2, r5
   1f34c:	e1a00005 	mov	r0, r5
   1f350:	e1a08005 	mov	r8, r5
   1f354:	e1a01005 	mov	r1, r5
   1f358:	eaffffe0 	b	1f2e0 <mallinfo+0xe4>
   1f35c:	0002b844 	.word	0x0002b844

0001f360 <malloc_stats>:
#endif /* NO_MALLINFO */

#if !NO_MALLOC_STATS
void dlmalloc_stats() {
   1f360:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  ensure_initialization();
   1f364:	e30b466c 	movw	r4, #46700	@ 0xb66c
   1f368:	e3404002 	movt	r4, #2
   1f36c:	e5943000 	ldr	r3, [r4]
   1f370:	e3530000 	cmp	r3, #0
   1f374:	0a00003b 	beq	1f468 <malloc_stats+0x108>
    if (is_initialized(m)) {
   1f378:	e5946030 	ldr	r6, [r4, #48]	@ 0x30
   1f37c:	e3560000 	cmp	r6, #0
   1f380:	0a00003c 	beq	1f478 <malloc_stats+0x118>
      fp = m->footprint;
   1f384:	e59451c8 	ldr	r5, [r4, #456]	@ 0x1c8
      used = fp - (m->topsize + TOP_FOOT_SIZE);
   1f388:	e5943024 	ldr	r3, [r4, #36]	@ 0x24
      msegmentptr s = &m->seg;
   1f38c:	e59f70f4 	ldr	r7, [pc, #244]	@ 1f488 <malloc_stats+0x128>
      maxfp = m->max_footprint;
   1f390:	e59421cc 	ldr	r2, [r4, #460]	@ 0x1cc
      used = fp - (m->topsize + TOP_FOOT_SIZE);
   1f394:	e2454028 	sub	r4, r5, #40	@ 0x28
   1f398:	e0444003 	sub	r4, r4, r3
        mchunkptr q = align_as_chunk(s->base);
   1f39c:	e597c000 	ldr	ip, [r7]
   1f3a0:	e31c0007 	tst	ip, #7
   1f3a4:	e28c3008 	add	r3, ip, #8
   1f3a8:	0a00002c 	beq	1f460 <malloc_stats+0x100>
   1f3ac:	e2633000 	rsb	r3, r3, #0
   1f3b0:	e2033007 	and	r3, r3, #7
               q != m->top && q->head != FENCEPOST_HEAD) {
   1f3b4:	e09c3003 	adds	r3, ip, r3
   1f3b8:	2a000011 	bcs	1f404 <malloc_stats+0xa4>
        while (segment_holds(s, q) &&
   1f3bc:	e597e004 	ldr	lr, [r7, #4]
   1f3c0:	e08ce00e 	add	lr, ip, lr
   1f3c4:	e1560003 	cmp	r6, r3
   1f3c8:	1153000e 	cmpne	r3, lr
   1f3cc:	2a00000c 	bcs	1f404 <malloc_stats+0xa4>
               q != m->top && q->head != FENCEPOST_HEAD) {
   1f3d0:	e5931004 	ldr	r1, [r3, #4]
   1f3d4:	e3510007 	cmp	r1, #7
          if (!is_inuse(q))
   1f3d8:	e2010003 	and	r0, r1, #3
            used -= chunksize(q);
   1f3dc:	e3c11007 	bic	r1, r1, #7
          q = next_chunk(q);
   1f3e0:	e0833001 	add	r3, r3, r1
               q != m->top && q->head != FENCEPOST_HEAD) {
   1f3e4:	0a000006 	beq	1f404 <malloc_stats+0xa4>
          if (!is_inuse(q))
   1f3e8:	e3500001 	cmp	r0, #1
            used -= chunksize(q);
   1f3ec:	00444001 	subeq	r4, r4, r1
               q != m->top && q->head != FENCEPOST_HEAD) {
   1f3f0:	e15c0003 	cmp	ip, r3
   1f3f4:	8a000002 	bhi	1f404 <malloc_stats+0xa4>
        while (segment_holds(s, q) &&
   1f3f8:	e1560003 	cmp	r6, r3
   1f3fc:	1153000e 	cmpne	r3, lr
   1f400:	3afffff2 	bcc	1f3d0 <malloc_stats+0x70>
        s = s->next;
   1f404:	e5977008 	ldr	r7, [r7, #8]
      while (s != 0) {
   1f408:	e3570000 	cmp	r7, #0
   1f40c:	1affffe2 	bne	1f39c <malloc_stats+0x3c>
    fprintf(stderr, "max system bytes = %10lu\n", (unsigned long)(maxfp));
   1f410:	e30b61e8 	movw	r6, #45544	@ 0xb1e8
   1f414:	e309133c 	movw	r1, #37692	@ 0x933c
   1f418:	e3406002 	movt	r6, #2
   1f41c:	e3401002 	movt	r1, #2
   1f420:	e5963000 	ldr	r3, [r6]
   1f424:	e593000c 	ldr	r0, [r3, #12]
   1f428:	ebffe4bd 	bl	18724 <fprintf>
    fprintf(stderr, "system bytes     = %10lu\n", (unsigned long)(fp));
   1f42c:	e5963000 	ldr	r3, [r6]
   1f430:	e3091358 	movw	r1, #37720	@ 0x9358
   1f434:	e1a02005 	mov	r2, r5
   1f438:	e3401002 	movt	r1, #2
   1f43c:	e593000c 	ldr	r0, [r3, #12]
   1f440:	ebffe4b7 	bl	18724 <fprintf>
    fprintf(stderr, "in use bytes     = %10lu\n", (unsigned long)(used));
   1f444:	e5963000 	ldr	r3, [r6]
   1f448:	e3091374 	movw	r1, #37748	@ 0x9374
   1f44c:	e1a02004 	mov	r2, r4
   1f450:	e3401002 	movt	r1, #2
  internal_malloc_stats(gm);
}
   1f454:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
    fprintf(stderr, "in use bytes     = %10lu\n", (unsigned long)(used));
   1f458:	e593000c 	ldr	r0, [r3, #12]
   1f45c:	eaffe4b0 	b	18724 <fprintf>
        mchunkptr q = align_as_chunk(s->base);
   1f460:	e1a0300c 	mov	r3, ip
   1f464:	eaffffd4 	b	1f3bc <malloc_stats+0x5c>
  if (mparams.magic == 0) {
   1f468:	ebfff189 	bl	1ba94 <init_mparams.part.0>
    if (is_initialized(m)) {
   1f46c:	e5946030 	ldr	r6, [r4, #48]	@ 0x30
   1f470:	e3560000 	cmp	r6, #0
   1f474:	1affffc2 	bne	1f384 <malloc_stats+0x24>
    size_t used = 0;
   1f478:	e1a04006 	mov	r4, r6
    size_t fp = 0;
   1f47c:	e1a05006 	mov	r5, r6
    size_t maxfp = 0;
   1f480:	e1a02006 	mov	r2, r6
   1f484:	eaffffe1 	b	1f410 <malloc_stats+0xb0>
   1f488:	0002b844 	.word	0x0002b844

0001f48c <mallopt>:
#endif /* NO_MALLOC_STATS */

int dlmallopt(int param_number, int value) {
   1f48c:	e92d4070 	push	{r4, r5, r6, lr}
  ensure_initialization();
   1f490:	e30b566c 	movw	r5, #46700	@ 0xb66c
   1f494:	e3405002 	movt	r5, #2
int dlmallopt(int param_number, int value) {
   1f498:	e1a04000 	mov	r4, r0
   1f49c:	e1a06001 	mov	r6, r1
  ensure_initialization();
   1f4a0:	e5953000 	ldr	r3, [r5]
   1f4a4:	e3530000 	cmp	r3, #0
   1f4a8:	0a000010 	beq	1f4f0 <mallopt+0x64>
  switch(param_number) {
   1f4ac:	e3740002 	cmn	r4, #2
   1f4b0:	0a000009 	beq	1f4dc <mallopt+0x50>
   1f4b4:	e3740001 	cmn	r4, #1
   1f4b8:	0a000004 	beq	1f4d0 <mallopt+0x44>
   1f4bc:	e3740003 	cmn	r4, #3
   1f4c0:	1a000008 	bne	1f4e8 <mallopt+0x5c>
    mparams.mmap_threshold = val;
   1f4c4:	e585600c 	str	r6, [r5, #12]
    return 1;
   1f4c8:	e3a00001 	mov	r0, #1
   1f4cc:	e8bd8070 	pop	{r4, r5, r6, pc}
   1f4d0:	e3a00001 	mov	r0, #1
    mparams.trim_threshold = val;
   1f4d4:	e5856010 	str	r6, [r5, #16]
    return 1;
   1f4d8:	e8bd8070 	pop	{r4, r5, r6, pc}
    if (val >= mparams.page_size && ((val & (val-1)) == 0)) {
   1f4dc:	e5953004 	ldr	r3, [r5, #4]
   1f4e0:	e1560003 	cmp	r6, r3
   1f4e4:	2a000003 	bcs	1f4f8 <mallopt+0x6c>
   1f4e8:	e3a00000 	mov	r0, #0
  return change_mparam(param_number, value);
}
   1f4ec:	e8bd8070 	pop	{r4, r5, r6, pc}
  if (mparams.magic == 0) {
   1f4f0:	ebfff167 	bl	1ba94 <init_mparams.part.0>
  return 1;
   1f4f4:	eaffffec 	b	1f4ac <mallopt+0x20>
    if (val >= mparams.page_size && ((val & (val-1)) == 0)) {
   1f4f8:	e2463001 	sub	r3, r6, #1
   1f4fc:	e1130006 	tst	r3, r6
   1f500:	1afffff8 	bne	1f4e8 <mallopt+0x5c>
      mparams.granularity = val;
   1f504:	e5856008 	str	r6, [r5, #8]
      return 1;
   1f508:	eaffffee 	b	1f4c8 <mallopt+0x3c>

0001f50c <malloc_usable_size>:

size_t dlmalloc_usable_size(void* mem) {
  if (mem != 0) {
   1f50c:	e3500000 	cmp	r0, #0
   1f510:	012fff1e 	bxeq	lr
    mchunkptr p = mem2chunk(mem);
    if (is_inuse(p))
   1f514:	e5100004 	ldr	r0, [r0, #-4]
   1f518:	e2003003 	and	r3, r0, #3
   1f51c:	e3530001 	cmp	r3, #1
   1f520:	0a000005 	beq	1f53c <malloc_usable_size+0x30>
      return chunksize(p) - overhead_for(p);
   1f524:	e3530000 	cmp	r3, #0
   1f528:	e3c00007 	bic	r0, r0, #7
   1f52c:	13a03004 	movne	r3, #4
   1f530:	03a03008 	moveq	r3, #8
   1f534:	e0400003 	sub	r0, r0, r3
   1f538:	e12fff1e 	bx	lr
  }
  return 0;
   1f53c:	e3a00000 	mov	r0, #0
}
   1f540:	e12fff1e 	bx	lr

0001f544 <_malloc_r>:
#include <stdlib.h>

void *
_malloc_r (struct _reent *r, size_t n)
{
  return malloc (n);
   1f544:	e1a00001 	mov	r0, r1
   1f548:	eafff5bb 	b	1cc3c <malloc>

0001f54c <_free_r>:
}

void
_free_r (struct _reent *r, void *p)
{
  free (p);
   1f54c:	e1a00001 	mov	r0, r1
   1f550:	eafffc33 	b	1e624 <free>

0001f554 <_realloc_r>:
#include <stdlib.h>

void *
_realloc_r (struct _reent *r, void *p, size_t n) _NOTHROW
{
   1f554:	e1a00001 	mov	r0, r1
  return realloc (p, n);
   1f558:	e1a01002 	mov	r1, r2
   1f55c:	eafffe23 	b	1edf0 <realloc>

0001f560 <mmap>:
#include <sys/mman.h>
#include <sys/syscall.h>

void *
mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off)
{
   1f560:	e92d4070 	push	{r4, r5, r6, lr}
  register int32_t r5 asm("r5") = a6;
   1f564:	e1cd41d0 	ldrd	r4, [sp, #16]
  asm volatile("svc %1\n"
   1f568:	ef000037 	svc	0x00000037
  int r = __syscall_r(__SYS_MMAP, (uintptr_t) addr, len, prot, flags, fildes,
                      off);

  if ((r < 0) && (r > -__ELASTERROR)) {
   1f56c:	e3700e7d 	cmn	r0, #2000	@ 0x7d0
  return r0;
   1f570:	e1a04000 	mov	r4, r0
   1f574:	98bd8070 	popls	{r4, r5, r6, pc}
    errno = -r;
   1f578:	ebfff0a5 	bl	1b814 <__errno>
   1f57c:	e2642000 	rsb	r2, r4, #0
   1f580:	e1a03000 	mov	r3, r0
   1f584:	e5832000 	str	r2, [r3]
    return (void *) -1;
   1f588:	e3e00000 	mvn	r0, #0
   1f58c:	e8bd8070 	pop	{r4, r5, r6, pc}

0001f590 <munmap>:
  register int32_t r2 asm("r2") = a3;
   1f590:	e3a02000 	mov	r2, #0
#include <sys/mman.h>
#include <sys/syscall.h>

int
munmap(void *addr, size_t len)
{
   1f594:	e92d4070 	push	{r4, r5, r6, lr}
  register int32_t r3 asm("r3") = a4;
   1f598:	e1a03002 	mov	r3, r2
  register int32_t r4 asm("r4") = a5;
   1f59c:	e1a04002 	mov	r4, r2
  register int32_t r5 asm("r5") = a6;
   1f5a0:	e1a05002 	mov	r5, r2
  asm volatile("svc %1\n"
   1f5a4:	ef000039 	svc	0x00000039
  if (r < 0) {
   1f5a8:	e2504000 	subs	r4, r0, #0
   1f5ac:	ba000001 	blt	1f5b8 <munmap+0x28>
  return __syscall2(__SYS_MUNMAP, addr, len);
}
   1f5b0:	e1a00004 	mov	r0, r4
   1f5b4:	e8bd8070 	pop	{r4, r5, r6, pc}
    errno = -r;
   1f5b8:	ebfff095 	bl	1b814 <__errno>
   1f5bc:	e2643000 	rsb	r3, r4, #0
    return -1;
   1f5c0:	e3e04000 	mvn	r4, #0
    errno = -r;
   1f5c4:	e5803000 	str	r3, [r0]
  return __syscall2(__SYS_MUNMAP, addr, len);
   1f5c8:	eafffff8 	b	1f5b0 <munmap+0x20>

0001f5cc <_fstat>:
  register int32_t r2 asm("r2") = a3;
   1f5cc:	e3a02000 	mov	r2, #0
#include <sys/stat.h>
#include <sys/syscall.h>

int
_fstat(int fildes, struct stat *buf)
{
   1f5d0:	e92d4070 	push	{r4, r5, r6, lr}
  register int32_t r3 asm("r3") = a4;
   1f5d4:	e1a03002 	mov	r3, r2
  register int32_t r4 asm("r4") = a5;
   1f5d8:	e1a04002 	mov	r4, r2
  register int32_t r5 asm("r5") = a6;
   1f5dc:	e1a05002 	mov	r5, r2
  asm volatile("svc %1\n"
   1f5e0:	ef000013 	svc	0x00000013
  if (r < 0) {
   1f5e4:	e2504000 	subs	r4, r0, #0
   1f5e8:	ba000001 	blt	1f5f4 <_fstat+0x28>
  return __syscall2(__SYS_STAT, fildes, buf);
}
   1f5ec:	e1a00004 	mov	r0, r4
   1f5f0:	e8bd8070 	pop	{r4, r5, r6, pc}
    errno = -r;
   1f5f4:	ebfff086 	bl	1b814 <__errno>
   1f5f8:	e2643000 	rsb	r3, r4, #0
    return -1;
   1f5fc:	e3e04000 	mvn	r4, #0
    errno = -r;
   1f600:	e5803000 	str	r3, [r0]
  return __syscall2(__SYS_STAT, fildes, buf);
   1f604:	eafffff8 	b	1f5ec <_fstat+0x20>

0001f608 <fstat>:
  register int32_t r2 asm("r2") = a3;
   1f608:	e3a02000 	mov	r2, #0

int
fstat(int fildes, struct stat *buf)
{
   1f60c:	e92d4070 	push	{r4, r5, r6, lr}
  register int32_t r3 asm("r3") = a4;
   1f610:	e1a03002 	mov	r3, r2
  register int32_t r4 asm("r4") = a5;
   1f614:	e1a04002 	mov	r4, r2
  register int32_t r5 asm("r5") = a6;
   1f618:	e1a05002 	mov	r5, r2
  asm volatile("svc %1\n"
   1f61c:	ef000013 	svc	0x00000013
  if (r < 0) {
   1f620:	e2504000 	subs	r4, r0, #0
   1f624:	ba000001 	blt	1f630 <fstat+0x28>
  return _fstat(fildes, buf);
}
   1f628:	e1a00004 	mov	r0, r4
   1f62c:	e8bd8070 	pop	{r4, r5, r6, pc}
    errno = -r;
   1f630:	ebfff077 	bl	1b814 <__errno>
   1f634:	e2643000 	rsb	r3, r4, #0
    return -1;
   1f638:	e3e04000 	mvn	r4, #0
    errno = -r;
   1f63c:	e5803000 	str	r3, [r0]
  return _fstat(fildes, buf);
   1f640:	eafffff8 	b	1f628 <fstat+0x20>

0001f644 <_stat>:
#include <unistd.h>
#include <stdio.h>

int
_stat(const char *path, struct stat *buf)
{
   1f644:	e92d4070 	push	{r4, r5, r6, lr}
   1f648:	e1a05001 	mov	r5, r1
  int fd, r;

  if ((fd = open(path, O_RDONLY)) < 0)
   1f64c:	e3a01000 	mov	r1, #0
   1f650:	ebfff0d9 	bl	1b9bc <open>
   1f654:	e2504000 	subs	r4, r0, #0
   1f658:	ba000005 	blt	1f674 <_stat+0x30>
    return fd;

  r = fstat(fd, buf);
   1f65c:	e1a01005 	mov	r1, r5
   1f660:	ebffffe8 	bl	1f608 <fstat>
   1f664:	e1a03000 	mov	r3, r0

  close(fd);
   1f668:	e1a00004 	mov	r0, r4
  r = fstat(fd, buf);
   1f66c:	e1a04003 	mov	r4, r3
  close(fd);
   1f670:	eb00002a 	bl	1f720 <close>

  return r;
}
   1f674:	e1a00004 	mov	r0, r4
   1f678:	e8bd8070 	pop	{r4, r5, r6, pc}

0001f67c <stat>:

int
stat(const char *path, struct stat *buf)
{
   1f67c:	e92d4070 	push	{r4, r5, r6, lr}
   1f680:	e1a05001 	mov	r5, r1
  if ((fd = open(path, O_RDONLY)) < 0)
   1f684:	e3a01000 	mov	r1, #0
   1f688:	ebfff0cb 	bl	1b9bc <open>
   1f68c:	e2504000 	subs	r4, r0, #0
   1f690:	ba000005 	blt	1f6ac <stat+0x30>
  r = fstat(fd, buf);
   1f694:	e1a01005 	mov	r1, r5
   1f698:	ebffffda 	bl	1f608 <fstat>
   1f69c:	e1a03000 	mov	r3, r0
  close(fd);
   1f6a0:	e1a00004 	mov	r0, r4
  r = fstat(fd, buf);
   1f6a4:	e1a04003 	mov	r4, r3
  close(fd);
   1f6a8:	eb00001c 	bl	1f720 <close>
  return _stat(path, buf);
}
   1f6ac:	e1a00004 	mov	r0, r4
   1f6b0:	e8bd8070 	pop	{r4, r5, r6, pc}

0001f6b4 <_exit>:
  register int32_t r1 asm("r1") = a2;
   1f6b4:	e3a01000 	mov	r1, #0
#include <unistd.h>
#include <sys/syscall.h>

void
_exit(int status)
{
   1f6b8:	e92d4010 	push	{r4, lr}
  register int32_t r2 asm("r2") = a3;
   1f6bc:	e1a02001 	mov	r2, r1
  register int32_t r3 asm("r3") = a4;
   1f6c0:	e1a03001 	mov	r3, r1
  register int32_t r4 asm("r4") = a5;
   1f6c4:	e1a04001 	mov	r4, r1
  register int32_t r5 asm("r5") = a6;
   1f6c8:	e1a05001 	mov	r5, r1
  asm volatile("svc %1\n"
   1f6cc:	ef000004 	svc	0x00000004
  return r0;
   1f6d0:	e1a04000 	mov	r4, r0
    errno = -r;
   1f6d4:	e2644000 	rsb	r4, r4, #0
   1f6d8:	ebfff04d 	bl	1b814 <__errno>
   1f6dc:	e5804000 	str	r4, [r0]

0001f6e0 <_close>:
  register int32_t r1 asm("r1") = a2;
   1f6e0:	e3a01000 	mov	r1, #0
#include <sys/syscall.h>
#include <unistd.h>

int
_close(int fildes)
{
   1f6e4:	e92d4070 	push	{r4, r5, r6, lr}
  register int32_t r2 asm("r2") = a3;
   1f6e8:	e1a02001 	mov	r2, r1
  register int32_t r3 asm("r3") = a4;
   1f6ec:	e1a03001 	mov	r3, r1
  register int32_t r4 asm("r4") = a5;
   1f6f0:	e1a04001 	mov	r4, r1
  register int32_t r5 asm("r5") = a6;
   1f6f4:	e1a05001 	mov	r5, r1
  asm volatile("svc %1\n"
   1f6f8:	ef000014 	svc	0x00000014
  if (r < 0) {
   1f6fc:	e2504000 	subs	r4, r0, #0
   1f700:	ba000001 	blt	1f70c <_close+0x2c>
  return __syscall1(__SYS_CLOSE, fildes);
}
   1f704:	e1a00004 	mov	r0, r4
   1f708:	e8bd8070 	pop	{r4, r5, r6, pc}
    errno = -r;
   1f70c:	ebfff040 	bl	1b814 <__errno>
   1f710:	e2643000 	rsb	r3, r4, #0
    return -1;
   1f714:	e3e04000 	mvn	r4, #0
    errno = -r;
   1f718:	e5803000 	str	r3, [r0]
  return __syscall1(__SYS_CLOSE, fildes);
   1f71c:	eafffff8 	b	1f704 <_close+0x24>

0001f720 <close>:
  register int32_t r1 asm("r1") = a2;
   1f720:	e3a01000 	mov	r1, #0

int
close(int fildes)
{
   1f724:	e92d4070 	push	{r4, r5, r6, lr}
  register int32_t r2 asm("r2") = a3;
   1f728:	e1a02001 	mov	r2, r1
  register int32_t r3 asm("r3") = a4;
   1f72c:	e1a03001 	mov	r3, r1
  register int32_t r4 asm("r4") = a5;
   1f730:	e1a04001 	mov	r4, r1
  register int32_t r5 asm("r5") = a6;
   1f734:	e1a05001 	mov	r5, r1
  asm volatile("svc %1\n"
   1f738:	ef000014 	svc	0x00000014
  if (r < 0) {
   1f73c:	e2504000 	subs	r4, r0, #0
   1f740:	ba000001 	blt	1f74c <close+0x2c>
  return _close(fildes);
}
   1f744:	e1a00004 	mov	r0, r4
   1f748:	e8bd8070 	pop	{r4, r5, r6, pc}
    errno = -r;
   1f74c:	ebfff030 	bl	1b814 <__errno>
   1f750:	e2643000 	rsb	r3, r4, #0
    return -1;
   1f754:	e3e04000 	mvn	r4, #0
    errno = -r;
   1f758:	e5803000 	str	r3, [r0]
  return _close(fildes);
   1f75c:	eafffff8 	b	1f744 <close+0x24>

0001f760 <_getpid>:
  register int32_t r0 asm("r0") = a1;
   1f760:	e3a00000 	mov	r0, #0
#include <sys/syscall.h>
#include <unistd.h>

pid_t
_getpid(void)
{
   1f764:	e92d4070 	push	{r4, r5, r6, lr}
  register int32_t r1 asm("r1") = a2;
   1f768:	e1a01000 	mov	r1, r0
  register int32_t r2 asm("r2") = a3;
   1f76c:	e1a02000 	mov	r2, r0
  register int32_t r3 asm("r3") = a4;
   1f770:	e1a03000 	mov	r3, r0
  register int32_t r4 asm("r4") = a5;
   1f774:	e1a04000 	mov	r4, r0
  register int32_t r5 asm("r5") = a6;
   1f778:	e1a05000 	mov	r5, r0
  asm volatile("svc %1\n"
   1f77c:	ef000006 	svc	0x00000006
  if (r < 0) {
   1f780:	e2504000 	subs	r4, r0, #0
   1f784:	ba000001 	blt	1f790 <_getpid+0x30>
  return __syscall0(__SYS_GETPID);
}
   1f788:	e1a00004 	mov	r0, r4
   1f78c:	e8bd8070 	pop	{r4, r5, r6, pc}
    errno = -r;
   1f790:	ebfff01f 	bl	1b814 <__errno>
   1f794:	e2643000 	rsb	r3, r4, #0
    return -1;
   1f798:	e3e04000 	mvn	r4, #0
    errno = -r;
   1f79c:	e5803000 	str	r3, [r0]
  return __syscall0(__SYS_GETPID);
   1f7a0:	eafffff8 	b	1f788 <_getpid+0x28>

0001f7a4 <getpid>:
  register int32_t r0 asm("r0") = a1;
   1f7a4:	e3a00000 	mov	r0, #0

pid_t
getpid(void)
{
   1f7a8:	e92d4070 	push	{r4, r5, r6, lr}
  register int32_t r1 asm("r1") = a2;
   1f7ac:	e1a01000 	mov	r1, r0
  register int32_t r2 asm("r2") = a3;
   1f7b0:	e1a02000 	mov	r2, r0
  register int32_t r3 asm("r3") = a4;
   1f7b4:	e1a03000 	mov	r3, r0
  register int32_t r4 asm("r4") = a5;
   1f7b8:	e1a04000 	mov	r4, r0
  register int32_t r5 asm("r5") = a6;
   1f7bc:	e1a05000 	mov	r5, r0
  asm volatile("svc %1\n"
   1f7c0:	ef000006 	svc	0x00000006
  if (r < 0) {
   1f7c4:	e2504000 	subs	r4, r0, #0
   1f7c8:	ba000001 	blt	1f7d4 <getpid+0x30>
  return _getpid();
}
   1f7cc:	e1a00004 	mov	r0, r4
   1f7d0:	e8bd8070 	pop	{r4, r5, r6, pc}
    errno = -r;
   1f7d4:	ebfff00e 	bl	1b814 <__errno>
   1f7d8:	e2643000 	rsb	r3, r4, #0
    return -1;
   1f7dc:	e3e04000 	mvn	r4, #0
    errno = -r;
   1f7e0:	e5803000 	str	r3, [r0]
  return _getpid();
   1f7e4:	eafffff8 	b	1f7cc <getpid+0x28>

0001f7e8 <_lseek>:
  register int32_t r3 asm("r3") = a4;
   1f7e8:	e3a03000 	mov	r3, #0
#include <sys/syscall.h>
#include <unistd.h>

off_t
_lseek(int fildes, off_t offset, int whence)
{
   1f7ec:	e92d4070 	push	{r4, r5, r6, lr}
  register int32_t r4 asm("r4") = a5;
   1f7f0:	e1a04003 	mov	r4, r3
  register int32_t r5 asm("r5") = a6;
   1f7f4:	e1a05003 	mov	r5, r3
  asm volatile("svc %1\n"
   1f7f8:	ef00000d 	svc	0x0000000d
  if (r < 0) {
   1f7fc:	e2504000 	subs	r4, r0, #0
   1f800:	ba000001 	blt	1f80c <_lseek+0x24>
  return __syscall3(__SYS_SEEK, fildes, offset, whence);
}
   1f804:	e1a00004 	mov	r0, r4
   1f808:	e8bd8070 	pop	{r4, r5, r6, pc}
    errno = -r;
   1f80c:	ebfff000 	bl	1b814 <__errno>
   1f810:	e2643000 	rsb	r3, r4, #0
    return -1;
   1f814:	e3e04000 	mvn	r4, #0
    errno = -r;
   1f818:	e5803000 	str	r3, [r0]
  return __syscall3(__SYS_SEEK, fildes, offset, whence);
   1f81c:	eafffff8 	b	1f804 <_lseek+0x1c>

0001f820 <lseek>:
  register int32_t r3 asm("r3") = a4;
   1f820:	e3a03000 	mov	r3, #0

off_t
lseek(int fildes, off_t offset, int whence)
{
   1f824:	e92d4070 	push	{r4, r5, r6, lr}
  register int32_t r4 asm("r4") = a5;
   1f828:	e1a04003 	mov	r4, r3
  register int32_t r5 asm("r5") = a6;
   1f82c:	e1a05003 	mov	r5, r3
  asm volatile("svc %1\n"
   1f830:	ef00000d 	svc	0x0000000d
  if (r < 0) {
   1f834:	e2504000 	subs	r4, r0, #0
   1f838:	ba000001 	blt	1f844 <lseek+0x24>
  return _lseek(fildes, offset, whence);
}
   1f83c:	e1a00004 	mov	r0, r4
   1f840:	e8bd8070 	pop	{r4, r5, r6, pc}
    errno = -r;
   1f844:	ebffeff2 	bl	1b814 <__errno>
   1f848:	e2643000 	rsb	r3, r4, #0
    return -1;
   1f84c:	e3e04000 	mvn	r4, #0
    errno = -r;
   1f850:	e5803000 	str	r3, [r0]
  return _lseek(fildes, offset, whence);
   1f854:	eafffff8 	b	1f83c <lseek+0x1c>

0001f858 <_read>:
  register int32_t r3 asm("r3") = a4;
   1f858:	e3a03000 	mov	r3, #0
#include <sys/syscall.h>
#include <unistd.h>

ssize_t
_read(int fildes, void *buf, size_t n)
{
   1f85c:	e92d4070 	push	{r4, r5, r6, lr}
  register int32_t r4 asm("r4") = a5;
   1f860:	e1a04003 	mov	r4, r3
  register int32_t r5 asm("r5") = a6;
   1f864:	e1a05003 	mov	r5, r3
  asm volatile("svc %1\n"
   1f868:	ef000015 	svc	0x00000015
  if (r < 0) {
   1f86c:	e2504000 	subs	r4, r0, #0
   1f870:	ba000001 	blt	1f87c <_read+0x24>
  return __syscall3(__SYS_READ, fildes, buf, n);
}
   1f874:	e1a00004 	mov	r0, r4
   1f878:	e8bd8070 	pop	{r4, r5, r6, pc}
    errno = -r;
   1f87c:	ebffefe4 	bl	1b814 <__errno>
   1f880:	e2643000 	rsb	r3, r4, #0
    return -1;
   1f884:	e3e04000 	mvn	r4, #0
    errno = -r;
   1f888:	e5803000 	str	r3, [r0]
  return __syscall3(__SYS_READ, fildes, buf, n);
   1f88c:	eafffff8 	b	1f874 <_read+0x1c>

0001f890 <read>:
  register int32_t r3 asm("r3") = a4;
   1f890:	e3a03000 	mov	r3, #0

ssize_t
read(int fildes, void *buf, size_t n)
{
   1f894:	e92d4070 	push	{r4, r5, r6, lr}
  register int32_t r4 asm("r4") = a5;
   1f898:	e1a04003 	mov	r4, r3
  register int32_t r5 asm("r5") = a6;
   1f89c:	e1a05003 	mov	r5, r3
  asm volatile("svc %1\n"
   1f8a0:	ef000015 	svc	0x00000015
  if (r < 0) {
   1f8a4:	e2504000 	subs	r4, r0, #0
   1f8a8:	ba000001 	blt	1f8b4 <read+0x24>
  return _read(fildes, buf, n);
}
   1f8ac:	e1a00004 	mov	r0, r4
   1f8b0:	e8bd8070 	pop	{r4, r5, r6, pc}
    errno = -r;
   1f8b4:	ebffefd6 	bl	1b814 <__errno>
   1f8b8:	e2643000 	rsb	r3, r4, #0
    return -1;
   1f8bc:	e3e04000 	mvn	r4, #0
    errno = -r;
   1f8c0:	e5803000 	str	r3, [r0]
  return _read(fildes, buf, n);
   1f8c4:	eafffff8 	b	1f8ac <read+0x1c>

0001f8c8 <sysconf>:

long
sysconf(int name)
{
  // TODO: map system page read-only to each process' address space
  switch (name) {
   1f8c8:	e350000b 	cmp	r0, #11
   1f8cc:	ca00000f 	bgt	1f910 <sysconf+0x48>
   1f8d0:	e3500001 	cmp	r0, #1
   1f8d4:	da000011 	ble	1f920 <sysconf+0x58>
   1f8d8:	e2403002 	sub	r3, r0, #2
   1f8dc:	e3530009 	cmp	r3, #9
   1f8e0:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   1f8e4:	ea00000d 	b	1f920 <sysconf+0x58>
   1f8e8:	0001f964 	.word	0x0001f964
   1f8ec:	0001f920 	.word	0x0001f920
   1f8f0:	0001f94c 	.word	0x0001f94c
   1f8f4:	0001f920 	.word	0x0001f920
   1f8f8:	0001f920 	.word	0x0001f920
   1f8fc:	0001f920 	.word	0x0001f920
   1f900:	0001f95c 	.word	0x0001f95c
   1f904:	0001f920 	.word	0x0001f920
   1f908:	0001f920 	.word	0x0001f920
   1f90c:	0001f954 	.word	0x0001f954
   1f910:	e3500044 	cmp	r0, #68	@ 0x44
   1f914:	1a000001 	bne	1f920 <sysconf+0x58>
  case _SC_PHYS_PAGES:
    return 256 * 1024 * 1024;
  case _SC_OPEN_MAX:
    return 20;
  case _SC_LINE_MAX:
    return 256;
   1f918:	e3a00c01 	mov	r0, #256	@ 0x100
  default:
    fprintf(stderr, "TODO: sysconf(%d)\n", name);
    return -1;
  }
}
   1f91c:	e12fff1e 	bx	lr
    fprintf(stderr, "TODO: sysconf(%d)\n", name);
   1f920:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
   1f924:	e3091390 	movw	r1, #37776	@ 0x9390
   1f928:	e3403002 	movt	r3, #2
   1f92c:	e1a02000 	mov	r2, r0
   1f930:	e5933000 	ldr	r3, [r3]
   1f934:	e3401002 	movt	r1, #2
{
   1f938:	e92d4010 	push	{r4, lr}
    fprintf(stderr, "TODO: sysconf(%d)\n", name);
   1f93c:	e593000c 	ldr	r0, [r3, #12]
   1f940:	ebffe377 	bl	18724 <fprintf>
    return -1;
   1f944:	e3e00000 	mvn	r0, #0
}
   1f948:	e8bd8010 	pop	{r4, pc}
    return 20;
   1f94c:	e3a00014 	mov	r0, #20
   1f950:	e12fff1e 	bx	lr
    return 256 * 1024 * 1024;
   1f954:	e3a00201 	mov	r0, #268435456	@ 0x10000000
   1f958:	e12fff1e 	bx	lr
  switch (name) {
   1f95c:	e3a00a01 	mov	r0, #4096	@ 0x1000
   1f960:	e12fff1e 	bx	lr
    return 100;
   1f964:	e3a00064 	mov	r0, #100	@ 0x64
   1f968:	e12fff1e 	bx	lr

0001f96c <_write>:
  register int32_t r3 asm("r3") = a4;
   1f96c:	e3a03000 	mov	r3, #0
#include <sys/syscall.h>
#include <unistd.h>

ssize_t
_write(int fildes, const void *buf, size_t n)
{
   1f970:	e92d4070 	push	{r4, r5, r6, lr}
  register int32_t r4 asm("r4") = a5;
   1f974:	e1a04003 	mov	r4, r3
  register int32_t r5 asm("r5") = a6;
   1f978:	e1a05003 	mov	r5, r3
  asm volatile("svc %1\n"
   1f97c:	ef000016 	svc	0x00000016
  if (r < 0) {
   1f980:	e2504000 	subs	r4, r0, #0
   1f984:	ba000001 	blt	1f990 <_write+0x24>
  return __syscall3(__SYS_WRITE, fildes, buf, n);
}
   1f988:	e1a00004 	mov	r0, r4
   1f98c:	e8bd8070 	pop	{r4, r5, r6, pc}
    errno = -r;
   1f990:	ebffef9f 	bl	1b814 <__errno>
   1f994:	e2643000 	rsb	r3, r4, #0
    return -1;
   1f998:	e3e04000 	mvn	r4, #0
    errno = -r;
   1f99c:	e5803000 	str	r3, [r0]
  return __syscall3(__SYS_WRITE, fildes, buf, n);
   1f9a0:	eafffff8 	b	1f988 <_write+0x1c>

0001f9a4 <write>:
  register int32_t r3 asm("r3") = a4;
   1f9a4:	e3a03000 	mov	r3, #0

ssize_t
write(int fildes, const void *buf, size_t n)
{
   1f9a8:	e92d4070 	push	{r4, r5, r6, lr}
  register int32_t r4 asm("r4") = a5;
   1f9ac:	e1a04003 	mov	r4, r3
  register int32_t r5 asm("r5") = a6;
   1f9b0:	e1a05003 	mov	r5, r3
  asm volatile("svc %1\n"
   1f9b4:	ef000016 	svc	0x00000016
  if (r < 0) {
   1f9b8:	e2504000 	subs	r4, r0, #0
   1f9bc:	ba000001 	blt	1f9c8 <write+0x24>
  return _write(fildes, buf, n);
}
   1f9c0:	e1a00004 	mov	r0, r4
   1f9c4:	e8bd8070 	pop	{r4, r5, r6, pc}
    errno = -r;
   1f9c8:	ebffef91 	bl	1b814 <__errno>
   1f9cc:	e2643000 	rsb	r3, r4, #0
    return -1;
   1f9d0:	e3e04000 	mvn	r4, #0
    errno = -r;
   1f9d4:	e5803000 	str	r3, [r0]
  return _write(fildes, buf, n);
   1f9d8:	eafffff8 	b	1f9c0 <write+0x1c>
   1f9dc:	00000000 	andeq	r0, r0, r0

0001f9e0 <strcmp>:
	.fnstart
	.cfi_sections .debug_frame
	.cfi_startproc
	prologue push_ip=HAVE_PAC_LEAF
#ifndef STRCMP_NO_PRECHECK
	ldrb	r2, [src1]
   1f9e0:	7802      	ldrb	r2, [r0, #0]
	ldrb	r3, [src2]
   1f9e2:	780b      	ldrb	r3, [r1, #0]
	cmp	r2, #1
   1f9e4:	2a01      	cmp	r2, #1
	it	cs
   1f9e6:	bf28      	it	cs
	cmpcs	r2, r3
   1f9e8:	429a      	cmpcs	r2, r3
	bne	.Lfastpath_exit
   1f9ea:	f040 80d8 	bne.w	1fb9e <strcmp+0x1be>
#endif
	strd	r4, r5, [sp, #-16]!
   1f9ee:	e96d 4504 	strd	r4, r5, [sp, #-16]!
	.cfi_adjust_cfa_offset 16
	.cfi_rel_offset 4, 0
	.cfi_rel_offset 5, 4
	orr	tmp1, src1, src2
   1f9f2:	ea40 0401 	orr.w	r4, r0, r1
	strd	r6, r7, [sp, #8]
   1f9f6:	e9cd 6702 	strd	r6, r7, [sp, #8]
	.cfi_rel_offset 6, 8
	.cfi_rel_offset 7, 12
	mvn	const_m1, #0
   1f9fa:	f06f 0c00 	mvn.w	ip, #0
	lsl	r2, tmp1, #29
   1f9fe:	ea4f 7244 	mov.w	r2, r4, lsl #29
	cbz	r2, .Lloop_aligned8
   1fa02:	b31a      	cbz	r2, 1fa4c <strcmp+0x6c>

.Lnot_aligned:
	eor	tmp1, src1, src2
   1fa04:	ea80 0401 	eor.w	r4, r0, r1
	tst	tmp1, #7
   1fa08:	f014 0f07 	tst.w	r4, #7
	bne	.Lmisaligned8
   1fa0c:	d16b      	bne.n	1fae6 <strcmp+0x106>

	/* Deal with mutual misalignment by aligning downwards and then
	   masking off the unwanted loaded data to prevent a difference.  */
	and	tmp1, src1, #7
   1fa0e:	f000 0407 	and.w	r4, r0, #7
	bic	src1, src1, #7
   1fa12:	f020 0007 	bic.w	r0, r0, #7
	and	tmp2, tmp1, #3
   1fa16:	f004 0503 	and.w	r5, r4, #3
	bic	src2, src2, #7
   1fa1a:	f021 0107 	bic.w	r1, r1, #7
	lsl	tmp2, tmp2, #3	/* Bytes -> bits.  */
   1fa1e:	ea4f 05c5 	mov.w	r5, r5, lsl #3
	ldrd	data1a, data1b, [src1], #16
   1fa22:	e8f0 2304 	ldrd	r2, r3, [r0], #16
	tst	tmp1, #4
   1fa26:	f014 0f04 	tst.w	r4, #4
	ldrd	data2a, data2b, [src2], #16
   1fa2a:	e8f1 6704 	ldrd	r6, r7, [r1], #16
	/* In thumb code we can't use MVN with a register shift, but
	   we do have ORN.  */
	S2HI	tmp1, const_m1, tmp2
   1fa2e:	fa0c f405 	lsl.w	r4, ip, r5
	orn	data1a, data1a, tmp1
   1fa32:	ea62 0204 	orn	r2, r2, r4
	orn	data2a, data2a, tmp1
   1fa36:	ea66 0604 	orn	r6, r6, r4
	beq	.Lstart_realigned8
   1fa3a:	d00b      	beq.n	1fa54 <strcmp+0x74>
	orn	data1b, data1b, tmp1
   1fa3c:	ea63 0304 	orn	r3, r3, r4
	mov	data1a, const_m1
   1fa40:	4662      	mov	r2, ip
	orn	data2b, data2b, tmp1
   1fa42:	ea67 0704 	orn	r7, r7, r4
	mov	data2a, const_m1
   1fa46:	4666      	mov	r6, ip
	b	.Lstart_realigned8
   1fa48:	e004      	b.n	1fa54 <strcmp+0x74>
   1fa4a:	bf00      	nop
	/* Unwind the inner loop by a factor of 2, giving 16 bytes per
	   pass.  */
	.p2align 5,,12  /* Don't start in the tail bytes of a cache line.  */
	.p2align 2	/* Always word aligned.  */
.Lloop_aligned8:
	ldrd	data1a, data1b, [src1], #16
   1fa4c:	e8f0 2304 	ldrd	r2, r3, [r0], #16
	ldrd	data2a, data2b, [src2], #16
   1fa50:	e8f1 6704 	ldrd	r6, r7, [r1], #16
.Lstart_realigned8:
	uadd8	syndrome_b, data1a, const_m1	/* Only want GE bits,  */
   1fa54:	fa82 f54c 	uadd8	r5, r2, ip
	eor	syndrome_a, data1a, data2a
   1fa58:	ea82 0406 	eor.w	r4, r2, r6
	sel	syndrome_a, syndrome_a, const_m1
   1fa5c:	faa4 f48c 	sel	r4, r4, ip
	cbnz	syndrome_a, .Ldiff_in_a
   1fa60:	bb6c      	cbnz	r4, 1fabe <strcmp+0xde>
	uadd8	syndrome_b, data1b, const_m1	/* Only want GE bits.  */
   1fa62:	fa83 f54c 	uadd8	r5, r3, ip
	eor	syndrome_b, data1b, data2b
   1fa66:	ea83 0507 	eor.w	r5, r3, r7
	sel	syndrome_b, syndrome_b, const_m1
   1fa6a:	faa5 f58c 	sel	r5, r5, ip
	cbnz	syndrome_b, .Ldiff_in_b
   1fa6e:	b995      	cbnz	r5, 1fa96 <strcmp+0xb6>

	ldrd	data1a, data1b, [src1, #-8]
   1fa70:	e950 2302 	ldrd	r2, r3, [r0, #-8]
	ldrd	data2a, data2b, [src2, #-8]
   1fa74:	e951 6702 	ldrd	r6, r7, [r1, #-8]
	uadd8	syndrome_b, data1a, const_m1	/* Only want GE bits,  */
   1fa78:	fa82 f54c 	uadd8	r5, r2, ip
	eor	syndrome_a, data1a, data2a
   1fa7c:	ea82 0406 	eor.w	r4, r2, r6
	sel	syndrome_a, syndrome_a, const_m1
   1fa80:	faa4 f48c 	sel	r4, r4, ip
	uadd8	syndrome_b, data1b, const_m1	/* Only want GE bits.  */
   1fa84:	fa83 f54c 	uadd8	r5, r3, ip
	eor	syndrome_b, data1b, data2b
   1fa88:	ea83 0507 	eor.w	r5, r3, r7
	sel	syndrome_b, syndrome_b, const_m1
   1fa8c:	faa5 f58c 	sel	r5, r5, ip
	/* Can't use CBZ for backwards branch.  */
	orrs	syndrome_b, syndrome_b, syndrome_a /* Only need if s_a == 0 */
   1fa90:	4325      	orrs	r5, r4
	beq	.Lloop_aligned8
   1fa92:	d0db      	beq.n	1fa4c <strcmp+0x6c>

.Ldiff_found:
	cbnz	syndrome_a, .Ldiff_in_a
   1fa94:	b99c      	cbnz	r4, 1fabe <strcmp+0xde>

.Ldiff_in_b:
	strcmp_epilogue_aligned syndrome_b, data1b, data2b 1
   1fa96:	ba2d      	rev	r5, r5
   1fa98:	fab5 f485 	clz	r4, r5
   1fa9c:	f024 0407 	bic.w	r4, r4, #7
   1faa0:	fa27 f104 	lsr.w	r1, r7, r4
   1faa4:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
   1faa8:	fa23 f304 	lsr.w	r3, r3, r4
   1faac:	f003 00ff 	and.w	r0, r3, #255	@ 0xff
   1fab0:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
   1fab4:	e8fd 4504 	ldrd	r4, r5, [sp], #16
   1fab8:	eba0 0001 	sub.w	r0, r0, r1
   1fabc:	4770      	bx	lr

.Ldiff_in_a:
	.cfi_restore_state
	strcmp_epilogue_aligned syndrome_a, data1a, data2a 1
   1fabe:	ba24      	rev	r4, r4
   1fac0:	fab4 f484 	clz	r4, r4
   1fac4:	f024 0407 	bic.w	r4, r4, #7
   1fac8:	fa26 f104 	lsr.w	r1, r6, r4
   1facc:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
   1fad0:	fa22 f204 	lsr.w	r2, r2, r4
   1fad4:	f002 00ff 	and.w	r0, r2, #255	@ 0xff
   1fad8:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
   1fadc:	e8fd 4504 	ldrd	r4, r5, [sp], #16
   1fae0:	eba0 0001 	sub.w	r0, r0, r1
   1fae4:	4770      	bx	lr

	.cfi_restore_state
.Lmisaligned8:
	tst	tmp1, #3
   1fae6:	f014 0f03 	tst.w	r4, #3
	bne	.Lmisaligned4
   1faea:	d13c      	bne.n	1fb66 <strcmp+0x186>
	ands	tmp1, src1, #3
   1faec:	f010 0403 	ands.w	r4, r0, #3
	bne	.Lmutual_align4
   1faf0:	d128      	bne.n	1fb44 <strcmp+0x164>

	/* Unrolled by a factor of 2, to reduce the number of post-increment
	   operations.  */
.Lloop_aligned4:
	ldr	data1, [src1], #8
   1faf2:	f850 2b08 	ldr.w	r2, [r0], #8
	ldr	data2, [src2], #8
   1faf6:	f851 3b08 	ldr.w	r3, [r1], #8
.Lstart_realigned4:
	uadd8	syndrome, data1, const_m1	/* Only need GE bits.  */
   1fafa:	fa82 f54c 	uadd8	r5, r2, ip
	eor	syndrome, data1, data2
   1fafe:	ea82 0503 	eor.w	r5, r2, r3
	sel	syndrome, syndrome, const_m1
   1fb02:	faa5 f58c 	sel	r5, r5, ip
	cbnz	syndrome, .Laligned4_done
   1fb06:	b95d      	cbnz	r5, 1fb20 <strcmp+0x140>
	ldr	data1, [src1, #-4]
   1fb08:	f850 2c04 	ldr.w	r2, [r0, #-4]
	ldr	data2, [src2, #-4]
   1fb0c:	f851 3c04 	ldr.w	r3, [r1, #-4]
	uadd8	syndrome, data1, const_m1
   1fb10:	fa82 f54c 	uadd8	r5, r2, ip
	eor	syndrome, data1, data2
   1fb14:	ea82 0503 	eor.w	r5, r2, r3
	sel	syndrome, syndrome, const_m1
   1fb18:	faa5 f58c 	sel	r5, r5, ip
	cmp	syndrome, #0
   1fb1c:	2d00      	cmp	r5, #0
	beq	.Lloop_aligned4
   1fb1e:	d0e8      	beq.n	1faf2 <strcmp+0x112>

.Laligned4_done:
	strcmp_epilogue_aligned syndrome, data1, data2, 0
   1fb20:	ba2d      	rev	r5, r5
   1fb22:	fab5 f485 	clz	r4, r5
   1fb26:	f024 0407 	bic.w	r4, r4, #7
   1fb2a:	fa23 f104 	lsr.w	r1, r3, r4
   1fb2e:	fa22 f204 	lsr.w	r2, r2, r4
   1fb32:	f002 00ff 	and.w	r0, r2, #255	@ 0xff
   1fb36:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
   1fb3a:	e8fd 4504 	ldrd	r4, r5, [sp], #16
   1fb3e:	eba0 0001 	sub.w	r0, r0, r1
   1fb42:	4770      	bx	lr

.Lmutual_align4:
	.cfi_restore_state
	/* Deal with mutual misalignment by aligning downwards and then
	   masking off the unwanted loaded data to prevent a difference.  */
	lsl	tmp1, tmp1, #3	/* Bytes -> bits.  */
   1fb44:	ea4f 04c4 	mov.w	r4, r4, lsl #3
	bic	src1, src1, #3
   1fb48:	f020 0003 	bic.w	r0, r0, #3
	ldr	data1, [src1], #8
   1fb4c:	f850 2b08 	ldr.w	r2, [r0], #8
	bic	src2, src2, #3
   1fb50:	f021 0103 	bic.w	r1, r1, #3
	ldr	data2, [src2], #8
   1fb54:	f851 3b08 	ldr.w	r3, [r1], #8

	/* In thumb code we can't use MVN with a register shift, but
	   we do have ORN.  */
	S2HI	tmp1, const_m1, tmp1
   1fb58:	fa0c f404 	lsl.w	r4, ip, r4
	orn	data1, data1, tmp1
   1fb5c:	ea62 0204 	orn	r2, r2, r4
	orn	data2, data2, tmp1
   1fb60:	ea63 0304 	orn	r3, r3, r4
	b	.Lstart_realigned4
   1fb64:	e7c9      	b.n	1fafa <strcmp+0x11a>

.Lmisaligned4:
	ands	tmp1, src1, #3
   1fb66:	f010 0403 	ands.w	r4, r0, #3
	beq	.Lsrc1_aligned
   1fb6a:	d01d      	beq.n	1fba8 <strcmp+0x1c8>
	sub	src2, src2, tmp1
   1fb6c:	eba1 0104 	sub.w	r1, r1, r4
	bic	src1, src1, #3
   1fb70:	f020 0003 	bic.w	r0, r0, #3
	lsls	tmp1, tmp1, #31
   1fb74:	07e4      	lsls	r4, r4, #31
	ldr	data1, [src1], #4
   1fb76:	f850 2b04 	ldr.w	r2, [r0], #4
	beq	.Laligned_m2
   1fb7a:	d006      	beq.n	1fb8a <strcmp+0x1aa>
	bcs	.Laligned_m1
   1fb7c:	d212      	bcs.n	1fba4 <strcmp+0x1c4>
	add	src2, src2, #4
	cbnz	data2, .Lsrc1_aligned
#else  /* STRCMP_NO_PRECHECK */
	/* If we've done the pre-check, then we don't need to check the
	   first byte again here.  */
	ldrb	data2, [src2, #2]
   1fb7e:	788b      	ldrb	r3, [r1, #2]
	uxtb	tmp1, data1, ror #BYTE2_OFFSET
   1fb80:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
	subs	tmp1, tmp1, data2
   1fb84:	1ae4      	subs	r4, r4, r3
	bne	.Lmisaligned_exit
   1fb86:	d106      	bne.n	1fb96 <strcmp+0x1b6>
	cbz	data2, .Lmisaligned_exit
   1fb88:	b12b      	cbz	r3, 1fb96 <strcmp+0x1b6>

.Laligned_m2:
	ldrb	data2, [src2, #3]
   1fb8a:	78cb      	ldrb	r3, [r1, #3]
	uxtb	tmp1, data1, ror #BYTE3_OFFSET
   1fb8c:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
	subs	tmp1, tmp1, data2
   1fb90:	1ae4      	subs	r4, r4, r3
	bne	.Lmisaligned_exit
   1fb92:	d100      	bne.n	1fb96 <strcmp+0x1b6>
	cbnz	data2, .Laligned_m1
   1fb94:	b933      	cbnz	r3, 1fba4 <strcmp+0x1c4>
#endif

.Lmisaligned_exit:
	.cfi_remember_state
	mov	result, tmp1
   1fb96:	4620      	mov	r0, r4
	ldr	r4, [sp], #16
   1fb98:	f85d 4b10 	ldr.w	r4, [sp], #16
	.cfi_restore 4
	.cfi_adjust_cfa_offset -16
	epilogue push_ip=HAVE_PAC_LEAF
   1fb9c:	4770      	bx	lr

#ifndef STRCMP_NO_PRECHECK
.Lfastpath_exit:
	.cfi_restore_state
	.cfi_remember_state
	sub	r0, r2, r3
   1fb9e:	eba2 0003 	sub.w	r0, r2, r3
	epilogue push_ip=HAVE_PAC_LEAF
   1fba2:	4770      	bx	lr

.Laligned_m1:
	.cfi_restore_state
	.cfi_remember_state
	add	src2, src2, #4
   1fba4:	f101 0104 	add.w	r1, r1, #4
#endif
.Lsrc1_aligned:
	.cfi_restore_state
	/* src1 is word aligned, but src2 has no common alignment
	   with it.  */
	ldr	data1, [src1], #4
   1fba8:	f850 2b04 	ldr.w	r2, [r0], #4
	lsls	tmp1, src2, #31		/* C=src2[1], Z=src2[0].  */
   1fbac:	07cc      	lsls	r4, r1, #31

	bic	src2, src2, #3
   1fbae:	f021 0103 	bic.w	r1, r1, #3
	ldr	data2, [src2], #4
   1fbb2:	f851 3b04 	ldr.w	r3, [r1], #4
	bhi	.Loverlap1		/* C=1, Z=0 => src2[1:0] = 0b11.  */
   1fbb6:	d848      	bhi.n	1fc4a <strcmp+0x26a>
	bcs	.Loverlap2		/* C=1, Z=1 => src2[1:0] = 0b10.  */
   1fbb8:	d224      	bcs.n	1fc04 <strcmp+0x224>

	/* (overlap3) C=0, Z=0 => src2[1:0] = 0b01.  */
.Loverlap3:
	bic	tmp1, data1, #MSB
   1fbba:	f022 447f 	bic.w	r4, r2, #4278190080	@ 0xff000000
	uadd8	syndrome, data1, const_m1
   1fbbe:	fa82 f54c 	uadd8	r5, r2, ip
	eors	syndrome, tmp1, data2, S2LO #8
   1fbc2:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
	sel	syndrome, syndrome, const_m1
   1fbc6:	faa5 f58c 	sel	r5, r5, ip
	bne	4f
   1fbca:	d10a      	bne.n	1fbe2 <strcmp+0x202>
	cbnz	syndrome, 5f
   1fbcc:	b965      	cbnz	r5, 1fbe8 <strcmp+0x208>
	ldr	data2, [src2], #4
   1fbce:	f851 3b04 	ldr.w	r3, [r1], #4
	eor	tmp1, tmp1, data1
   1fbd2:	ea84 0402 	eor.w	r4, r4, r2
	cmp	tmp1, data2, S2HI #24
   1fbd6:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
	bne	6f
   1fbda:	d10e      	bne.n	1fbfa <strcmp+0x21a>
	ldr	data1, [src1], #4
   1fbdc:	f850 2b04 	ldr.w	r2, [r0], #4
	b	.Loverlap3
   1fbe0:	e7eb      	b.n	1fbba <strcmp+0x1da>
4:
	S2LO	data2, data2, #8
   1fbe2:	ea4f 2313 	mov.w	r3, r3, lsr #8
	b	.Lstrcmp_tail
   1fbe6:	e055      	b.n	1fc94 <strcmp+0x2b4>

5:
	bics	syndrome, syndrome, #MSB
   1fbe8:	f035 457f 	bics.w	r5, r5, #4278190080	@ 0xff000000
	bne	.Lstrcmp_done_equal
   1fbec:	d14d      	bne.n	1fc8a <strcmp+0x2aa>

	/* We can only get here if the MSB of data1 contains 0, so
	   fast-path the exit.  */
	ldrb	result, [src2]
   1fbee:	7808      	ldrb	r0, [r1, #0]
	.cfi_remember_state
	ldrd	r4, r5, [sp], #16
   1fbf0:	e8fd 4504 	ldrd	r4, r5, [sp], #16
	.cfi_restore 5
	/* R6/7 Not used in this sequence.  */
	.cfi_restore 6
	.cfi_restore 7
	.cfi_adjust_cfa_offset -16
	neg	result, result
   1fbf4:	f1c0 0000 	rsb	r0, r0, #0
	epilogue push_ip=HAVE_PAC_LEAF
   1fbf8:	4770      	bx	lr

6:
	.cfi_restore_state
	S2LO	data1, data1, #24
   1fbfa:	ea4f 6212 	mov.w	r2, r2, lsr #24
	and	data2, data2, #LSB
   1fbfe:	f003 03ff 	and.w	r3, r3, #255	@ 0xff
	b	.Lstrcmp_tail
   1fc02:	e047      	b.n	1fc94 <strcmp+0x2b4>

	.p2align 5,,12	/* Ensure at least 3 instructions in cache line.  */
.Loverlap2:
	and	tmp1, data1, const_m1, S2LO #16
   1fc04:	ea02 441c 	and.w	r4, r2, ip, lsr #16
	uadd8	syndrome, data1, const_m1
   1fc08:	fa82 f54c 	uadd8	r5, r2, ip
	eors	syndrome, tmp1, data2, S2LO #16
   1fc0c:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
	sel	syndrome, syndrome, const_m1
   1fc10:	faa5 f58c 	sel	r5, r5, ip
	bne	4f
   1fc14:	d10a      	bne.n	1fc2c <strcmp+0x24c>
	cbnz	syndrome, 5f
   1fc16:	b965      	cbnz	r5, 1fc32 <strcmp+0x252>
	ldr	data2, [src2], #4
   1fc18:	f851 3b04 	ldr.w	r3, [r1], #4
	eor	tmp1, tmp1, data1
   1fc1c:	ea84 0402 	eor.w	r4, r4, r2
	cmp	tmp1, data2, S2HI #16
   1fc20:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
	bne	6f
   1fc24:	d10c      	bne.n	1fc40 <strcmp+0x260>
	ldr	data1, [src1], #4
   1fc26:	f850 2b04 	ldr.w	r2, [r0], #4
	b	.Loverlap2
   1fc2a:	e7eb      	b.n	1fc04 <strcmp+0x224>
4:
	S2LO	data2, data2, #16
   1fc2c:	ea4f 4313 	mov.w	r3, r3, lsr #16
	b	.Lstrcmp_tail
   1fc30:	e030      	b.n	1fc94 <strcmp+0x2b4>
5:
	ands	syndrome, syndrome, const_m1, S2LO #16
   1fc32:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
	bne	.Lstrcmp_done_equal
   1fc36:	d128      	bne.n	1fc8a <strcmp+0x2aa>

	ldrh	data2, [src2]
   1fc38:	880b      	ldrh	r3, [r1, #0]
	S2LO	data1, data1, #16
   1fc3a:	ea4f 4212 	mov.w	r2, r2, lsr #16
#ifdef __ARM_BIG_ENDIAN
	lsl	data2, data2, #16
#endif
	b	.Lstrcmp_tail
   1fc3e:	e029      	b.n	1fc94 <strcmp+0x2b4>

6:
	S2LO	data1, data1, #16
   1fc40:	ea4f 4212 	mov.w	r2, r2, lsr #16
	and	data2, data2, const_m1, S2LO #16
   1fc44:	ea03 431c 	and.w	r3, r3, ip, lsr #16
	b	.Lstrcmp_tail
   1fc48:	e024      	b.n	1fc94 <strcmp+0x2b4>

	.p2align 5,,12	/* Ensure at least 3 instructions in cache line.  */
.Loverlap1:
	and	tmp1, data1, #LSB
   1fc4a:	f002 04ff 	and.w	r4, r2, #255	@ 0xff
	uadd8	syndrome, data1, const_m1
   1fc4e:	fa82 f54c 	uadd8	r5, r2, ip
	eors	syndrome, tmp1, data2, S2LO #24
   1fc52:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
	sel	syndrome, syndrome, const_m1
   1fc56:	faa5 f58c 	sel	r5, r5, ip
	bne	4f
   1fc5a:	d10a      	bne.n	1fc72 <strcmp+0x292>
	cbnz	syndrome, 5f
   1fc5c:	b965      	cbnz	r5, 1fc78 <strcmp+0x298>
	ldr	data2, [src2], #4
   1fc5e:	f851 3b04 	ldr.w	r3, [r1], #4
	eor	tmp1, tmp1, data1
   1fc62:	ea84 0402 	eor.w	r4, r4, r2
	cmp	tmp1, data2, S2HI #8
   1fc66:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
	bne	6f
   1fc6a:	d109      	bne.n	1fc80 <strcmp+0x2a0>
	ldr	data1, [src1], #4
   1fc6c:	f850 2b04 	ldr.w	r2, [r0], #4
	b	.Loverlap1
   1fc70:	e7eb      	b.n	1fc4a <strcmp+0x26a>
4:
	S2LO	data2, data2, #24
   1fc72:	ea4f 6313 	mov.w	r3, r3, lsr #24
	b	.Lstrcmp_tail
   1fc76:	e00d      	b.n	1fc94 <strcmp+0x2b4>
5:
	tst	syndrome, #LSB
   1fc78:	f015 0fff 	tst.w	r5, #255	@ 0xff
	bne	.Lstrcmp_done_equal
   1fc7c:	d105      	bne.n	1fc8a <strcmp+0x2aa>
	ldr	data2, [src2]
   1fc7e:	680b      	ldr	r3, [r1, #0]
6:
	S2LO	data1, data1, #8
   1fc80:	ea4f 2212 	mov.w	r2, r2, lsr #8
	bic	data2, data2, #MSB
   1fc84:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
	b	.Lstrcmp_tail
   1fc88:	e004      	b.n	1fc94 <strcmp+0x2b4>

.Lstrcmp_done_equal:
	mov	result, #0
   1fc8a:	f04f 0000 	mov.w	r0, #0
	.cfi_remember_state
	ldrd	r4, r5, [sp], #16
   1fc8e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
	.cfi_restore 5
	/* R6/7 not used in this sequence.  */
	.cfi_restore 6
	.cfi_restore 7
	.cfi_adjust_cfa_offset -16
	epilogue push_ip=HAVE_PAC_LEAF
   1fc92:	4770      	bx	lr

.Lstrcmp_tail:
	.cfi_restore_state
#ifndef __ARM_BIG_ENDIAN
	rev	data1, data1
   1fc94:	ba12      	rev	r2, r2
	rev	data2, data2
   1fc96:	ba1b      	rev	r3, r3
	/* Now everything looks big-endian...  */
#endif
	uadd8	tmp1, data1, const_m1
   1fc98:	fa82 f44c 	uadd8	r4, r2, ip
	eor	tmp1, data1, data2
   1fc9c:	ea82 0403 	eor.w	r4, r2, r3
	sel	syndrome, tmp1, const_m1
   1fca0:	faa4 f58c 	sel	r5, r4, ip
	clz	tmp1, syndrome
   1fca4:	fab5 f485 	clz	r4, r5
	lsl	data1, data1, tmp1
   1fca8:	fa02 f204 	lsl.w	r2, r2, r4
	lsl	data2, data2, tmp1
   1fcac:	fa03 f304 	lsl.w	r3, r3, r4
	lsr	result, data1, #24
   1fcb0:	ea4f 6012 	mov.w	r0, r2, lsr #24
	ldrd	r4, r5, [sp], #16
   1fcb4:	e8fd 4504 	ldrd	r4, r5, [sp], #16
	.cfi_restore 5
	/* R6/7 not used in this sequence.  */
	.cfi_restore 6
	.cfi_restore 7
	.cfi_adjust_cfa_offset -16
	sub	result, result, data2, lsr #24
   1fcb8:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
	epilogue push_ip=HAVE_PAC_LEAF
   1fcbc:	4770      	bx	lr
   1fcbe:	bf00      	nop

0001fcc0 <strcpy>:
#endif

char* __attribute__((naked))
strcpy (char* dst, const char* src)
{
  asm (
   1fcc0:	f5d1f000 	pld	[r1]
   1fcc4:	e0202001 	eor	r2, r0, r1
   1fcc8:	e1a0c000 	mov	ip, r0
   1fccc:	e3120003 	tst	r2, #3
   1fcd0:	1a000033 	bne	1fda4 <strcpy+0xe4>
   1fcd4:	e3110003 	tst	r1, #3
   1fcd8:	1a000022 	bne	1fd68 <strcpy+0xa8>
   1fcdc:	e52d5004 	push	{r5}		@ (str r5, [sp, #-4]!)
   1fce0:	e3a05001 	mov	r5, #1
   1fce4:	e1855405 	orr	r5, r5, r5, lsl #8
   1fce8:	e1855805 	orr	r5, r5, r5, lsl #16
   1fcec:	e52d4004 	push	{r4}		@ (str r4, [sp, #-4]!)
   1fcf0:	e3110004 	tst	r1, #4
   1fcf4:	e4913004 	ldr	r3, [r1], #4
   1fcf8:	0a000005 	beq	1fd14 <strcpy+0x54>
   1fcfc:	e0432005 	sub	r2, r3, r5
   1fd00:	e1d22003 	bics	r2, r2, r3
   1fd04:	e1120385 	tst	r2, r5, lsl #7
   1fd08:	048c3004 	streq	r3, [ip], #4
   1fd0c:	04913004 	ldreq	r3, [r1], #4
   1fd10:	1a00000d 	bne	1fd4c <strcpy+0x8c>
   1fd14:	f5d1f008 	pld	[r1, #8]
   1fd18:	e4914004 	ldr	r4, [r1], #4
   1fd1c:	e0432005 	sub	r2, r3, r5
   1fd20:	e1d22003 	bics	r2, r2, r3
   1fd24:	e1120385 	tst	r2, r5, lsl #7
   1fd28:	e0442005 	sub	r2, r4, r5
   1fd2c:	1a000006 	bne	1fd4c <strcpy+0x8c>
   1fd30:	e48c3004 	str	r3, [ip], #4
   1fd34:	e1d22004 	bics	r2, r2, r4
   1fd38:	e1120385 	tst	r2, r5, lsl #7
   1fd3c:	04913004 	ldreq	r3, [r1], #4
   1fd40:	048c4004 	streq	r4, [ip], #4
   1fd44:	0afffff2 	beq	1fd14 <strcpy+0x54>
   1fd48:	e1a03004 	mov	r3, r4
   1fd4c:	e4cc3001 	strb	r3, [ip], #1
   1fd50:	e31300ff 	tst	r3, #255	@ 0xff
   1fd54:	e1a03463 	ror	r3, r3, #8
   1fd58:	1afffffb 	bne	1fd4c <strcpy+0x8c>
   1fd5c:	e49d4004 	pop	{r4}		@ (ldr r4, [sp], #4)
   1fd60:	e49d5004 	pop	{r5}		@ (ldr r5, [sp], #4)
   1fd64:	e12fff1e 	bx	lr
   1fd68:	e3110001 	tst	r1, #1
   1fd6c:	0a000003 	beq	1fd80 <strcpy+0xc0>
   1fd70:	e4d12001 	ldrb	r2, [r1], #1
   1fd74:	e4cc2001 	strb	r2, [ip], #1
   1fd78:	e3520000 	cmp	r2, #0
   1fd7c:	012fff1e 	bxeq	lr
   1fd80:	e3110002 	tst	r1, #2
   1fd84:	0affffd4 	beq	1fcdc <strcpy+0x1c>
   1fd88:	e0d120b2 	ldrh	r2, [r1], #2
   1fd8c:	e31200ff 	tst	r2, #255	@ 0xff
   1fd90:	10cc20b2 	strhne	r2, [ip], #2
   1fd94:	05cc2000 	strbeq	r2, [ip]
   1fd98:	13120cff 	tstne	r2, #65280	@ 0xff00
   1fd9c:	1affffce 	bne	1fcdc <strcpy+0x1c>
   1fda0:	e12fff1e 	bx	lr
   1fda4:	e4d12001 	ldrb	r2, [r1], #1
   1fda8:	e4cc2001 	strb	r2, [ip], #1
   1fdac:	e3520000 	cmp	r2, #0
   1fdb0:	1afffffb 	bne	1fda4 <strcpy+0xe4>
   1fdb4:	e12fff1e 	bx	lr
	...

0001fdc0 <memchr>:
	@ r0 = start of memory to scan
	@ r1 = character to look for
	@ r2 = length
	@ returns r0 = pointer to character or NULL if not found
	prologue
	and	r1,r1,#0xff	@ Don't trust the caller to pass a char
   1fdc0:	f001 01ff 	and.w	r1, r1, #255	@ 0xff

	cmp	r2,#16		@ If short don't bother with anything clever
   1fdc4:	2a10      	cmp	r2, #16
	blt	20f 
   1fdc6:	db2b      	blt.n	1fe20 <memchr+0x60>

	tst	r0, #7		@ If it's already aligned skip the next bit
   1fdc8:	f010 0f07 	tst.w	r0, #7
	beq	10f
   1fdcc:	d008      	beq.n	1fde0 <memchr+0x20>

	@ Work up to an aligned point
5:
	ldrb	r3, [r0],#1
   1fdce:	f810 3b01 	ldrb.w	r3, [r0], #1
	subs	r2, r2, #1
   1fdd2:	3a01      	subs	r2, #1
	cmp	r3, r1
   1fdd4:	428b      	cmp	r3, r1
	beq	50f		@ If it matches exit found
   1fdd6:	d02d      	beq.n	1fe34 <memchr+0x74>
	tst	r0, #7
   1fdd8:	f010 0f07 	tst.w	r0, #7
	cbz	r2, 40f		@ If we run off the end, exit not found
   1fddc:	b342      	cbz	r2, 1fe30 <memchr+0x70>
	bne	5b		@ If not aligned yet then do next byte
   1fdde:	d1f6      	bne.n	1fdce <memchr+0xe>
	
10:
	@ We are aligned, we know we have at least 8 bytes to work with
	push	{r4,r5,r6,r7}
   1fde0:	b4f0      	push	{r4, r5, r6, r7}
	.cfi_adjust_cfa_offset 16
	.cfi_rel_offset 4, 0
	.cfi_rel_offset 5, 4
	.cfi_rel_offset 6, 8
	.cfi_rel_offset 7, 12
	orr	r1, r1, r1, lsl #8	@ expand the match word across all bytes
   1fde2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
	orr	r1, r1, r1, lsl #16
   1fde6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
	bic	r4, r2, #7	@ Number of double words to work with * 8
   1fdea:	f022 0407 	bic.w	r4, r2, #7
	mvns	r7, #0		@ all F's
   1fdee:	f07f 0700 	mvns.w	r7, #0
	movs	r3, #0
   1fdf2:	2300      	movs	r3, #0
	
15:
	ldrd    r5,r6,[r0],#8
   1fdf4:	e8f0 5602 	ldrd	r5, r6, [r0], #8
	subs	r4, r4, #8
   1fdf8:	3c08      	subs	r4, #8
	eor	r5,r5, r1	@ r5,r6 have 00's where bytes match the target
   1fdfa:	ea85 0501 	eor.w	r5, r5, r1
	eor	r6,r6, r1
   1fdfe:	ea86 0601 	eor.w	r6, r6, r1
	uadd8	r5, r5, r7	@ Par add 0xff - sets GE bits for bytes!=0
   1fe02:	fa85 f547 	uadd8	r5, r5, r7
	sel	r5, r3, r7	@ bytes are 00 for none-00 bytes,
   1fe06:	faa3 f587 	sel	r5, r3, r7
				@ or ff for 00 bytes - NOTE INVERSION
	uadd8	r6, r6, r7	@ Par add 0xff - sets GE bits for bytes!=0
   1fe0a:	fa86 f647 	uadd8	r6, r6, r7
	sel	r6, r5, r7	@ chained....bytes are 00 for none-00 bytes
   1fe0e:	faa5 f687 	sel	r6, r5, r7
				@ or ff for 00 bytes - NOTE INVERSION
	cbnz	r6, 60f
   1fe12:	b98e      	cbnz	r6, 1fe38 <memchr+0x78>
	bne	15b		@ (Flags from the subs above)
   1fe14:	d1ee      	bne.n	1fdf4 <memchr+0x34>

	pop	{r4,r5,r6,r7}
   1fe16:	bcf0      	pop	{r4, r5, r6, r7}
	.cfi_restore 7
	.cfi_restore 6
	.cfi_restore 5
	.cfi_restore 4
	.cfi_adjust_cfa_offset -16
	and	r1,r1,#0xff	@ r1 back to a single character
   1fe18:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
	and	r2,r2,#7	@ Leave the count remaining as the number
   1fe1c:	f002 0207 	and.w	r2, r2, #7
				@ after the double words have been done
 
20:
	cbz	r2, 40f		@ 0 length or hit the end already then not found
   1fe20:	b132      	cbz	r2, 1fe30 <memchr+0x70>

21:  @ Post aligned section, or just a short call
	ldrb	r3,[r0],#1
   1fe22:	f810 3b01 	ldrb.w	r3, [r0], #1
	subs	r2,r2,#1
   1fe26:	3a01      	subs	r2, #1
	eor	r3,r3,r1	@ r3 = 0 if match - doesn't break flags from sub
   1fe28:	ea83 0301 	eor.w	r3, r3, r1
	cbz	r3, 50f
   1fe2c:	b113      	cbz	r3, 1fe34 <memchr+0x74>
	bne	21b		@ on r2 flags
   1fe2e:	d1f8      	bne.n	1fe22 <memchr+0x62>

40:
	.cfi_remember_state
	movs	r0,#0		@ not found
   1fe30:	2000      	movs	r0, #0
	epilogue
   1fe32:	4770      	bx	lr

50:
	.cfi_restore_state
	.cfi_remember_state
	subs	r0,r0,#1	@ found
   1fe34:	3801      	subs	r0, #1
	epilogue
   1fe36:	4770      	bx	lr
	.cfi_adjust_cfa_offset 16
	.cfi_rel_offset 4, 0
	.cfi_rel_offset 5, 4
	.cfi_rel_offset 6, 8
	.cfi_rel_offset 7, 12
	cmp	r5, #0
   1fe38:	2d00      	cmp	r5, #0
	itte	eq
   1fe3a:	bf06      	itte	eq
	moveq	r5, r6		@ the end is in the 2nd word
   1fe3c:	4635      	moveq	r5, r6
	subeq	r0,r0,#3	@ Points to 2nd byte of 2nd word
   1fe3e:	3803      	subeq	r0, #3
	subne	r0,r0,#7	@ or 2nd byte of 1st word
   1fe40:	3807      	subne	r0, #7

	@ r0 currently points to the 2nd byte of the word containing the hit
	tst	r5, # CHARTSTMASK(0)	@ 1st character
   1fe42:	f015 0f01 	tst.w	r5, #1
	bne	61f
   1fe46:	d107      	bne.n	1fe58 <memchr+0x98>
	adds	r0,r0,#1
   1fe48:	3001      	adds	r0, #1
	tst	r5, # CHARTSTMASK(1)	@ 2nd character
   1fe4a:	f415 7f80 	tst.w	r5, #256	@ 0x100
	ittt	eq
   1fe4e:	bf02      	ittt	eq
	addeq	r0,r0,#1
   1fe50:	3001      	addeq	r0, #1
	tsteq	r5, # (3<<15)		@ 2nd & 3rd character
   1fe52:	f415 3fc0 	tsteq.w	r5, #98304	@ 0x18000
	@ If not the 3rd must be the last one
	addeq	r0,r0,#1
   1fe56:	3001      	addeq	r0, #1

61:
	pop	{r4,r5,r6,r7}
   1fe58:	bcf0      	pop	{r4, r5, r6, r7}
	.cfi_restore 7
	.cfi_restore 6
	.cfi_restore 5
	.cfi_restore 4
	.cfi_adjust_cfa_offset -16
	subs	r0,r0,#1
   1fe5a:	3801      	subs	r0, #1
	epilogue
   1fe5c:	4770      	bx	lr
   1fe5e:	bf00      	nop
	...

0001fe80 <memcpy>:
\f:
	.endm

def_fn memcpy p2align=6

	mov	dst, dstin	/* Preserve dstin, we need to return it.  */
   1fe80:	e1a0c000 	mov	ip, r0
	cmp	count, #64
   1fe84:	e3520040 	cmp	r2, #64	@ 0x40
	bge	.Lcpy_not_short
   1fe88:	aa000028 	bge	1ff30 <memcpy+0xb0>
	ldrne	tmp1, [src], #4
	strne	tmp1, [dst], #4
#else
	/* Copy up to 15 full words of data.  May not be aligned.  */
	/* Cannot use VFP for unaligned data.  */
	and	tmp1, count, #0x3c
   1fe8c:	e202303c 	and	r3, r2, #60	@ 0x3c
	add	dst, dst, tmp1
   1fe90:	e08cc003 	add	ip, ip, r3
	add	src, src, tmp1
   1fe94:	e0811003 	add	r1, r1, r3
	rsb	tmp1, tmp1, #(60 - PC_OFFSET/2 + INSN_SIZE/2)
   1fe98:	e263303a 	rsb	r3, r3, #58	@ 0x3a
	/* Jump directly into the sequence below at the correct offset.  */
	add	pc, pc, tmp1, lsl #1
   1fe9c:	e08ff083 	add	pc, pc, r3, lsl #1

	ldr	tmp1, [src, #-60]	/* 15 words to go.  */
   1fea0:	e511303c 	ldr	r3, [r1, #-60]	@ 0xffffffc4
	str	tmp1, [dst, #-60]
   1fea4:	e50c303c 	str	r3, [ip, #-60]	@ 0xffffffc4

	ldr	tmp1, [src, #-56]	/* 14 words to go.  */
   1fea8:	e5113038 	ldr	r3, [r1, #-56]	@ 0xffffffc8
	str	tmp1, [dst, #-56]
   1feac:	e50c3038 	str	r3, [ip, #-56]	@ 0xffffffc8
	ldr	tmp1, [src, #-52]
   1feb0:	e5113034 	ldr	r3, [r1, #-52]	@ 0xffffffcc
	str	tmp1, [dst, #-52]
   1feb4:	e50c3034 	str	r3, [ip, #-52]	@ 0xffffffcc

	ldr	tmp1, [src, #-48]	/* 12 words to go.  */
   1feb8:	e5113030 	ldr	r3, [r1, #-48]	@ 0xffffffd0
	str	tmp1, [dst, #-48]
   1febc:	e50c3030 	str	r3, [ip, #-48]	@ 0xffffffd0
	ldr	tmp1, [src, #-44]
   1fec0:	e511302c 	ldr	r3, [r1, #-44]	@ 0xffffffd4
	str	tmp1, [dst, #-44]
   1fec4:	e50c302c 	str	r3, [ip, #-44]	@ 0xffffffd4

	ldr	tmp1, [src, #-40]	/* 10 words to go.  */
   1fec8:	e5113028 	ldr	r3, [r1, #-40]	@ 0xffffffd8
	str	tmp1, [dst, #-40]
   1fecc:	e50c3028 	str	r3, [ip, #-40]	@ 0xffffffd8
	ldr	tmp1, [src, #-36]
   1fed0:	e5113024 	ldr	r3, [r1, #-36]	@ 0xffffffdc
	str	tmp1, [dst, #-36]
   1fed4:	e50c3024 	str	r3, [ip, #-36]	@ 0xffffffdc

	ldr	tmp1, [src, #-32]	/* 8 words to go.  */
   1fed8:	e5113020 	ldr	r3, [r1, #-32]	@ 0xffffffe0
	str	tmp1, [dst, #-32]
   1fedc:	e50c3020 	str	r3, [ip, #-32]	@ 0xffffffe0
	ldr	tmp1, [src, #-28]
   1fee0:	e511301c 	ldr	r3, [r1, #-28]	@ 0xffffffe4
	str	tmp1, [dst, #-28]
   1fee4:	e50c301c 	str	r3, [ip, #-28]	@ 0xffffffe4

	ldr	tmp1, [src, #-24]	/* 6 words to go.  */
   1fee8:	e5113018 	ldr	r3, [r1, #-24]	@ 0xffffffe8
	str	tmp1, [dst, #-24]
   1feec:	e50c3018 	str	r3, [ip, #-24]	@ 0xffffffe8
	ldr	tmp1, [src, #-20]
   1fef0:	e5113014 	ldr	r3, [r1, #-20]	@ 0xffffffec
	str	tmp1, [dst, #-20]
   1fef4:	e50c3014 	str	r3, [ip, #-20]	@ 0xffffffec

	ldr	tmp1, [src, #-16]	/* 4 words to go.  */
   1fef8:	e5113010 	ldr	r3, [r1, #-16]
	str	tmp1, [dst, #-16]
   1fefc:	e50c3010 	str	r3, [ip, #-16]
	ldr	tmp1, [src, #-12]
   1ff00:	e511300c 	ldr	r3, [r1, #-12]
	str	tmp1, [dst, #-12]
   1ff04:	e50c300c 	str	r3, [ip, #-12]

	ldr	tmp1, [src, #-8]	/* 2 words to go.  */
   1ff08:	e5113008 	ldr	r3, [r1, #-8]
	str	tmp1, [dst, #-8]
   1ff0c:	e50c3008 	str	r3, [ip, #-8]
	ldr	tmp1, [src, #-4]
   1ff10:	e5113004 	ldr	r3, [r1, #-4]
	str	tmp1, [dst, #-4]
   1ff14:	e50c3004 	str	r3, [ip, #-4]
#endif

	lsls	count, count, #31
   1ff18:	e1b02f82 	lsls	r2, r2, #31
	ldrhcs	tmp1, [src], #2
   1ff1c:	20d130b2 	ldrhcs	r3, [r1], #2
	ldrbne	src, [src]		/* Src is dead, use as a scratch.  */
   1ff20:	15d11000 	ldrbne	r1, [r1]
	strhcs	tmp1, [dst], #2
   1ff24:	20cc30b2 	strhcs	r3, [ip], #2
	strbne	src, [dst]
   1ff28:	15cc1000 	strbne	r1, [ip]
	bx	lr
   1ff2c:	e12fff1e 	bx	lr

.Lcpy_not_short:
	/* At least 64 bytes to copy, but don't know the alignment yet.  */
	str	tmp2, [sp, #-FRAME_SIZE]!
   1ff30:	e52da020 	str	sl, [sp, #-32]!	@ 0xffffffe0
	and	tmp2, src, #7
   1ff34:	e201a007 	and	sl, r1, #7
	and	tmp1, dst, #7
   1ff38:	e20c3007 	and	r3, ip, #7
	cmp	tmp1, tmp2
   1ff3c:	e153000a 	cmp	r3, sl
	bne	.Lcpy_notaligned
   1ff40:	1a0000f1 	bne	2030c <memcpy+0x48c>

#ifdef USE_VFP
	/* Magic dust alert!  Force VFP on Cortex-A9.  Experiments show
	   that the FP pipeline is much better at streaming loads and
	   stores.  This is outside the critical loop.  */
	vmov.f32	s0, s0
   1ff44:	eeb00a40 	vmov.f32	s0, s0
#endif

	/* SRC and DST have the same mutual 32-bit alignment, but we may
	   still need to pre-copy some bytes to get to natural alignment.
	   We bring DST into full 64-bit alignment.  */
	lsls	tmp2, dst, #29
   1ff48:	e1b0ae8c 	lsls	sl, ip, #29
	beq	1f
   1ff4c:	0a000008 	beq	1ff74 <memcpy+0xf4>
	rsbs	tmp2, tmp2, #0
   1ff50:	e27aa000 	rsbs	sl, sl, #0
	sub	count, count, tmp2, lsr #29
   1ff54:	e0422eaa 	sub	r2, r2, sl, lsr #29
	ldrmi	tmp1, [src], #4
   1ff58:	44913004 	ldrmi	r3, [r1], #4
	strmi	tmp1, [dst], #4
   1ff5c:	448c3004 	strmi	r3, [ip], #4
	lsls	tmp2, tmp2, #2
   1ff60:	e1b0a10a 	lsls	sl, sl, #2
	ldrhcs	tmp1, [src], #2
   1ff64:	20d130b2 	ldrhcs	r3, [r1], #2
	ldrbne	tmp2, [src], #1
   1ff68:	14d1a001 	ldrbne	sl, [r1], #1
	strhcs	tmp1, [dst], #2
   1ff6c:	20cc30b2 	strhcs	r3, [ip], #2
	strbne	tmp2, [dst], #1
   1ff70:	14cca001 	strbne	sl, [ip], #1

1:
	subs	tmp2, count, #64	/* Use tmp2 for count.  */
   1ff74:	e252a040 	subs	sl, r2, #64	@ 0x40
	blt	.Ltail63aligned
   1ff78:	ba000017 	blt	1ffdc <memcpy+0x15c>

	cmp	tmp2, #512
   1ff7c:	e35a0c02 	cmp	sl, #512	@ 0x200
	bge	.Lcpy_body_long
   1ff80:	aa000032 	bge	20050 <memcpy+0x1d0>

.Lcpy_body_medium:			/* Count in tmp2.  */
#ifdef USE_VFP
1:
	vldr	d0, [src, #0]
   1ff84:	ed910b00 	vldr	d0, [r1]
	subs	tmp2, tmp2, #64
   1ff88:	e25aa040 	subs	sl, sl, #64	@ 0x40
	vldr	d1, [src, #8]
   1ff8c:	ed911b02 	vldr	d1, [r1, #8]
	vstr	d0, [dst, #0]
   1ff90:	ed8c0b00 	vstr	d0, [ip]
	vldr	d0, [src, #16]
   1ff94:	ed910b04 	vldr	d0, [r1, #16]
	vstr	d1, [dst, #8]
   1ff98:	ed8c1b02 	vstr	d1, [ip, #8]
	vldr	d1, [src, #24]
   1ff9c:	ed911b06 	vldr	d1, [r1, #24]
	vstr	d0, [dst, #16]
   1ffa0:	ed8c0b04 	vstr	d0, [ip, #16]
	vldr	d0, [src, #32]
   1ffa4:	ed910b08 	vldr	d0, [r1, #32]
	vstr	d1, [dst, #24]
   1ffa8:	ed8c1b06 	vstr	d1, [ip, #24]
	vldr	d1, [src, #40]
   1ffac:	ed911b0a 	vldr	d1, [r1, #40]	@ 0x28
	vstr	d0, [dst, #32]
   1ffb0:	ed8c0b08 	vstr	d0, [ip, #32]
	vldr	d0, [src, #48]
   1ffb4:	ed910b0c 	vldr	d0, [r1, #48]	@ 0x30
	vstr	d1, [dst, #40]
   1ffb8:	ed8c1b0a 	vstr	d1, [ip, #40]	@ 0x28
	vldr	d1, [src, #56]
   1ffbc:	ed911b0e 	vldr	d1, [r1, #56]	@ 0x38
	vstr	d0, [dst, #48]
   1ffc0:	ed8c0b0c 	vstr	d0, [ip, #48]	@ 0x30
	add	src, src, #64
   1ffc4:	e2811040 	add	r1, r1, #64	@ 0x40
	vstr	d1, [dst, #56]
   1ffc8:	ed8c1b0e 	vstr	d1, [ip, #56]	@ 0x38
	add	dst, dst, #64
   1ffcc:	e28cc040 	add	ip, ip, #64	@ 0x40
	bge	1b
   1ffd0:	aaffffeb 	bge	1ff84 <memcpy+0x104>
	tst	tmp2, #0x3f
   1ffd4:	e31a003f 	tst	sl, #63	@ 0x3f
	beq	.Ldone
   1ffd8:	0a00001a 	beq	20048 <memcpy+0x1c8>

.Ltail63aligned:			/* Count in tmp2.  */
	and	tmp1, tmp2, #0x38
   1ffdc:	e20a3038 	and	r3, sl, #56	@ 0x38
	add	dst, dst, tmp1
   1ffe0:	e08cc003 	add	ip, ip, r3
	add	src, src, tmp1
   1ffe4:	e0811003 	add	r1, r1, r3
	rsb	tmp1, tmp1, #(56 - PC_OFFSET + INSN_SIZE)
   1ffe8:	e2633034 	rsb	r3, r3, #52	@ 0x34
	add	pc, pc, tmp1
   1ffec:	e08ff003 	add	pc, pc, r3

	vldr	d0, [src, #-56]	/* 14 words to go.  */
   1fff0:	ed110b0e 	vldr	d0, [r1, #-56]	@ 0xffffffc8
	vstr	d0, [dst, #-56]
   1fff4:	ed0c0b0e 	vstr	d0, [ip, #-56]	@ 0xffffffc8
	vldr	d0, [src, #-48]	/* 12 words to go.  */
   1fff8:	ed110b0c 	vldr	d0, [r1, #-48]	@ 0xffffffd0
	vstr	d0, [dst, #-48]
   1fffc:	ed0c0b0c 	vstr	d0, [ip, #-48]	@ 0xffffffd0
	vldr	d0, [src, #-40]	/* 10 words to go.  */
   20000:	ed110b0a 	vldr	d0, [r1, #-40]	@ 0xffffffd8
	vstr	d0, [dst, #-40]
   20004:	ed0c0b0a 	vstr	d0, [ip, #-40]	@ 0xffffffd8
	vldr	d0, [src, #-32]	/* 8 words to go.  */
   20008:	ed110b08 	vldr	d0, [r1, #-32]	@ 0xffffffe0
	vstr	d0, [dst, #-32]
   2000c:	ed0c0b08 	vstr	d0, [ip, #-32]	@ 0xffffffe0
	vldr	d0, [src, #-24]	/* 6 words to go.  */
   20010:	ed110b06 	vldr	d0, [r1, #-24]	@ 0xffffffe8
	vstr	d0, [dst, #-24]
   20014:	ed0c0b06 	vstr	d0, [ip, #-24]	@ 0xffffffe8
	vldr	d0, [src, #-16]	/* 4 words to go.  */
   20018:	ed110b04 	vldr	d0, [r1, #-16]
	vstr	d0, [dst, #-16]
   2001c:	ed0c0b04 	vstr	d0, [ip, #-16]
	vldr	d0, [src, #-8]	/* 2 words to go.  */
   20020:	ed110b02 	vldr	d0, [r1, #-8]
	vstr	d0, [dst, #-8]
   20024:	ed0c0b02 	vstr	d0, [ip, #-8]
	strd	A_l, A_h, [dst, #-16]
	ldrd	A_l, A_h, [src, #-8]	/* 2 words to go.  */
	strd	A_l, A_h, [dst, #-8]

#endif
	tst	tmp2, #4
   20028:	e31a0004 	tst	sl, #4
	ldrne	tmp1, [src], #4
   2002c:	14913004 	ldrne	r3, [r1], #4
	strne	tmp1, [dst], #4
   20030:	148c3004 	strne	r3, [ip], #4
	lsls	tmp2, tmp2, #31		/* Count (tmp2) now dead. */
   20034:	e1b0af8a 	lsls	sl, sl, #31
	ldrhcs	tmp1, [src], #2
   20038:	20d130b2 	ldrhcs	r3, [r1], #2
	ldrbne	tmp2, [src]
   2003c:	15d1a000 	ldrbne	sl, [r1]
	strhcs	tmp1, [dst], #2
   20040:	20cc30b2 	strhcs	r3, [ip], #2
	strbne	tmp2, [dst]
   20044:	15cca000 	strbne	sl, [ip]

.Ldone:
	ldr	tmp2, [sp], #FRAME_SIZE
   20048:	e49da020 	ldr	sl, [sp], #32
	bx	lr
   2004c:	e12fff1e 	bx	lr
#ifdef USE_VFP
	/* Don't use PLD.  Instead, read some data in advance of the current
	   copy position into a register.  This should act like a PLD
	   operation but we won't have to repeat the transfer.  */

	vldr	d3, [src, #0]
   20050:	ed913b00 	vldr	d3, [r1]
	vldr	d4, [src, #64]
   20054:	ed914b10 	vldr	d4, [r1, #64]	@ 0x40
	vldr	d5, [src, #128]
   20058:	ed915b20 	vldr	d5, [r1, #128]	@ 0x80
	vldr	d6, [src, #192]
   2005c:	ed916b30 	vldr	d6, [r1, #192]	@ 0xc0
	vldr	d7, [src, #256]
   20060:	ed917b40 	vldr	d7, [r1, #256]	@ 0x100

	vldr	d0, [src, #8]
   20064:	ed910b02 	vldr	d0, [r1, #8]
	vldr	d1, [src, #16]
   20068:	ed911b04 	vldr	d1, [r1, #16]
	vldr	d2, [src, #24]
   2006c:	ed912b06 	vldr	d2, [r1, #24]
	add	src, src, #32
   20070:	e2811020 	add	r1, r1, #32

	subs	tmp2, tmp2, #prefetch_lines * 64 * 2
   20074:	e25aad0a 	subs	sl, sl, #640	@ 0x280
	blt	2f
   20078:	ba000055 	blt	201d4 <memcpy+0x354>
1:
	cpy_line_vfp	d3, 0
   2007c:	ed8c3b00 	vstr	d3, [ip]
   20080:	ed913b00 	vldr	d3, [r1]
   20084:	ed8c0b02 	vstr	d0, [ip, #8]
   20088:	ed910b02 	vldr	d0, [r1, #8]
   2008c:	ed8c1b04 	vstr	d1, [ip, #16]
   20090:	ed911b04 	vldr	d1, [r1, #16]
   20094:	ed8c2b06 	vstr	d2, [ip, #24]
   20098:	ed912b06 	vldr	d2, [r1, #24]
   2009c:	ed8c3b08 	vstr	d3, [ip, #32]
   200a0:	ed913b48 	vldr	d3, [r1, #288]	@ 0x120
   200a4:	ed8c0b0a 	vstr	d0, [ip, #40]	@ 0x28
   200a8:	ed910b0a 	vldr	d0, [r1, #40]	@ 0x28
   200ac:	ed8c1b0c 	vstr	d1, [ip, #48]	@ 0x30
   200b0:	ed911b0c 	vldr	d1, [r1, #48]	@ 0x30
   200b4:	ed8c2b0e 	vstr	d2, [ip, #56]	@ 0x38
   200b8:	ed912b0e 	vldr	d2, [r1, #56]	@ 0x38
	cpy_line_vfp	d4, 64
   200bc:	ed8c4b10 	vstr	d4, [ip, #64]	@ 0x40
   200c0:	ed914b10 	vldr	d4, [r1, #64]	@ 0x40
   200c4:	ed8c0b12 	vstr	d0, [ip, #72]	@ 0x48
   200c8:	ed910b12 	vldr	d0, [r1, #72]	@ 0x48
   200cc:	ed8c1b14 	vstr	d1, [ip, #80]	@ 0x50
   200d0:	ed911b14 	vldr	d1, [r1, #80]	@ 0x50
   200d4:	ed8c2b16 	vstr	d2, [ip, #88]	@ 0x58
   200d8:	ed912b16 	vldr	d2, [r1, #88]	@ 0x58
   200dc:	ed8c4b18 	vstr	d4, [ip, #96]	@ 0x60
   200e0:	ed914b58 	vldr	d4, [r1, #352]	@ 0x160
   200e4:	ed8c0b1a 	vstr	d0, [ip, #104]	@ 0x68
   200e8:	ed910b1a 	vldr	d0, [r1, #104]	@ 0x68
   200ec:	ed8c1b1c 	vstr	d1, [ip, #112]	@ 0x70
   200f0:	ed911b1c 	vldr	d1, [r1, #112]	@ 0x70
   200f4:	ed8c2b1e 	vstr	d2, [ip, #120]	@ 0x78
   200f8:	ed912b1e 	vldr	d2, [r1, #120]	@ 0x78
	cpy_line_vfp	d5, 128
   200fc:	ed8c5b20 	vstr	d5, [ip, #128]	@ 0x80
   20100:	ed915b20 	vldr	d5, [r1, #128]	@ 0x80
   20104:	ed8c0b22 	vstr	d0, [ip, #136]	@ 0x88
   20108:	ed910b22 	vldr	d0, [r1, #136]	@ 0x88
   2010c:	ed8c1b24 	vstr	d1, [ip, #144]	@ 0x90
   20110:	ed911b24 	vldr	d1, [r1, #144]	@ 0x90
   20114:	ed8c2b26 	vstr	d2, [ip, #152]	@ 0x98
   20118:	ed912b26 	vldr	d2, [r1, #152]	@ 0x98
   2011c:	ed8c5b28 	vstr	d5, [ip, #160]	@ 0xa0
   20120:	ed915b68 	vldr	d5, [r1, #416]	@ 0x1a0
   20124:	ed8c0b2a 	vstr	d0, [ip, #168]	@ 0xa8
   20128:	ed910b2a 	vldr	d0, [r1, #168]	@ 0xa8
   2012c:	ed8c1b2c 	vstr	d1, [ip, #176]	@ 0xb0
   20130:	ed911b2c 	vldr	d1, [r1, #176]	@ 0xb0
   20134:	ed8c2b2e 	vstr	d2, [ip, #184]	@ 0xb8
   20138:	ed912b2e 	vldr	d2, [r1, #184]	@ 0xb8
	add	dst, dst, #3 * 64
   2013c:	e28cc0c0 	add	ip, ip, #192	@ 0xc0
	add	src, src, #3 * 64
   20140:	e28110c0 	add	r1, r1, #192	@ 0xc0
	cpy_line_vfp	d6, 0
   20144:	ed8c6b00 	vstr	d6, [ip]
   20148:	ed916b00 	vldr	d6, [r1]
   2014c:	ed8c0b02 	vstr	d0, [ip, #8]
   20150:	ed910b02 	vldr	d0, [r1, #8]
   20154:	ed8c1b04 	vstr	d1, [ip, #16]
   20158:	ed911b04 	vldr	d1, [r1, #16]
   2015c:	ed8c2b06 	vstr	d2, [ip, #24]
   20160:	ed912b06 	vldr	d2, [r1, #24]
   20164:	ed8c6b08 	vstr	d6, [ip, #32]
   20168:	ed916b48 	vldr	d6, [r1, #288]	@ 0x120
   2016c:	ed8c0b0a 	vstr	d0, [ip, #40]	@ 0x28
   20170:	ed910b0a 	vldr	d0, [r1, #40]	@ 0x28
   20174:	ed8c1b0c 	vstr	d1, [ip, #48]	@ 0x30
   20178:	ed911b0c 	vldr	d1, [r1, #48]	@ 0x30
   2017c:	ed8c2b0e 	vstr	d2, [ip, #56]	@ 0x38
   20180:	ed912b0e 	vldr	d2, [r1, #56]	@ 0x38
	cpy_line_vfp	d7, 64
   20184:	ed8c7b10 	vstr	d7, [ip, #64]	@ 0x40
   20188:	ed917b10 	vldr	d7, [r1, #64]	@ 0x40
   2018c:	ed8c0b12 	vstr	d0, [ip, #72]	@ 0x48
   20190:	ed910b12 	vldr	d0, [r1, #72]	@ 0x48
   20194:	ed8c1b14 	vstr	d1, [ip, #80]	@ 0x50
   20198:	ed911b14 	vldr	d1, [r1, #80]	@ 0x50
   2019c:	ed8c2b16 	vstr	d2, [ip, #88]	@ 0x58
   201a0:	ed912b16 	vldr	d2, [r1, #88]	@ 0x58
   201a4:	ed8c7b18 	vstr	d7, [ip, #96]	@ 0x60
   201a8:	ed917b58 	vldr	d7, [r1, #352]	@ 0x160
   201ac:	ed8c0b1a 	vstr	d0, [ip, #104]	@ 0x68
   201b0:	ed910b1a 	vldr	d0, [r1, #104]	@ 0x68
   201b4:	ed8c1b1c 	vstr	d1, [ip, #112]	@ 0x70
   201b8:	ed911b1c 	vldr	d1, [r1, #112]	@ 0x70
   201bc:	ed8c2b1e 	vstr	d2, [ip, #120]	@ 0x78
   201c0:	ed912b1e 	vldr	d2, [r1, #120]	@ 0x78
	add	dst, dst, #2 * 64
   201c4:	e28cc080 	add	ip, ip, #128	@ 0x80
	add	src, src, #2 * 64
   201c8:	e2811080 	add	r1, r1, #128	@ 0x80
	subs	tmp2, tmp2, #prefetch_lines * 64
   201cc:	e25aad05 	subs	sl, sl, #320	@ 0x140
	bge	1b
   201d0:	aaffffa9 	bge	2007c <memcpy+0x1fc>

2:
	cpy_tail_vfp	d3, 0
   201d4:	ed8c3b00 	vstr	d3, [ip]
   201d8:	ed913b00 	vldr	d3, [r1]
   201dc:	ed8c0b02 	vstr	d0, [ip, #8]
   201e0:	ed910b02 	vldr	d0, [r1, #8]
   201e4:	ed8c1b04 	vstr	d1, [ip, #16]
   201e8:	ed911b04 	vldr	d1, [r1, #16]
   201ec:	ed8c2b06 	vstr	d2, [ip, #24]
   201f0:	ed912b06 	vldr	d2, [r1, #24]
   201f4:	ed8c3b08 	vstr	d3, [ip, #32]
   201f8:	ed8c0b0a 	vstr	d0, [ip, #40]	@ 0x28
   201fc:	ed910b0a 	vldr	d0, [r1, #40]	@ 0x28
   20200:	ed8c1b0c 	vstr	d1, [ip, #48]	@ 0x30
   20204:	ed911b0c 	vldr	d1, [r1, #48]	@ 0x30
   20208:	ed8c2b0e 	vstr	d2, [ip, #56]	@ 0x38
   2020c:	ed912b0e 	vldr	d2, [r1, #56]	@ 0x38
	cpy_tail_vfp	d4, 64
   20210:	ed8c4b10 	vstr	d4, [ip, #64]	@ 0x40
   20214:	ed914b10 	vldr	d4, [r1, #64]	@ 0x40
   20218:	ed8c0b12 	vstr	d0, [ip, #72]	@ 0x48
   2021c:	ed910b12 	vldr	d0, [r1, #72]	@ 0x48
   20220:	ed8c1b14 	vstr	d1, [ip, #80]	@ 0x50
   20224:	ed911b14 	vldr	d1, [r1, #80]	@ 0x50
   20228:	ed8c2b16 	vstr	d2, [ip, #88]	@ 0x58
   2022c:	ed912b16 	vldr	d2, [r1, #88]	@ 0x58
   20230:	ed8c4b18 	vstr	d4, [ip, #96]	@ 0x60
   20234:	ed8c0b1a 	vstr	d0, [ip, #104]	@ 0x68
   20238:	ed910b1a 	vldr	d0, [r1, #104]	@ 0x68
   2023c:	ed8c1b1c 	vstr	d1, [ip, #112]	@ 0x70
   20240:	ed911b1c 	vldr	d1, [r1, #112]	@ 0x70
   20244:	ed8c2b1e 	vstr	d2, [ip, #120]	@ 0x78
   20248:	ed912b1e 	vldr	d2, [r1, #120]	@ 0x78
	cpy_tail_vfp	d5, 128
   2024c:	ed8c5b20 	vstr	d5, [ip, #128]	@ 0x80
   20250:	ed915b20 	vldr	d5, [r1, #128]	@ 0x80
   20254:	ed8c0b22 	vstr	d0, [ip, #136]	@ 0x88
   20258:	ed910b22 	vldr	d0, [r1, #136]	@ 0x88
   2025c:	ed8c1b24 	vstr	d1, [ip, #144]	@ 0x90
   20260:	ed911b24 	vldr	d1, [r1, #144]	@ 0x90
   20264:	ed8c2b26 	vstr	d2, [ip, #152]	@ 0x98
   20268:	ed912b26 	vldr	d2, [r1, #152]	@ 0x98
   2026c:	ed8c5b28 	vstr	d5, [ip, #160]	@ 0xa0
   20270:	ed8c0b2a 	vstr	d0, [ip, #168]	@ 0xa8
   20274:	ed910b2a 	vldr	d0, [r1, #168]	@ 0xa8
   20278:	ed8c1b2c 	vstr	d1, [ip, #176]	@ 0xb0
   2027c:	ed911b2c 	vldr	d1, [r1, #176]	@ 0xb0
   20280:	ed8c2b2e 	vstr	d2, [ip, #184]	@ 0xb8
   20284:	ed912b2e 	vldr	d2, [r1, #184]	@ 0xb8
	add	src, src, #3 * 64
   20288:	e28110c0 	add	r1, r1, #192	@ 0xc0
	add	dst, dst, #3 * 64
   2028c:	e28cc0c0 	add	ip, ip, #192	@ 0xc0
	cpy_tail_vfp	d6, 0
   20290:	ed8c6b00 	vstr	d6, [ip]
   20294:	ed916b00 	vldr	d6, [r1]
   20298:	ed8c0b02 	vstr	d0, [ip, #8]
   2029c:	ed910b02 	vldr	d0, [r1, #8]
   202a0:	ed8c1b04 	vstr	d1, [ip, #16]
   202a4:	ed911b04 	vldr	d1, [r1, #16]
   202a8:	ed8c2b06 	vstr	d2, [ip, #24]
   202ac:	ed912b06 	vldr	d2, [r1, #24]
   202b0:	ed8c6b08 	vstr	d6, [ip, #32]
   202b4:	ed8c0b0a 	vstr	d0, [ip, #40]	@ 0x28
   202b8:	ed910b0a 	vldr	d0, [r1, #40]	@ 0x28
   202bc:	ed8c1b0c 	vstr	d1, [ip, #48]	@ 0x30
   202c0:	ed911b0c 	vldr	d1, [r1, #48]	@ 0x30
   202c4:	ed8c2b0e 	vstr	d2, [ip, #56]	@ 0x38
   202c8:	ed912b0e 	vldr	d2, [r1, #56]	@ 0x38
	vstr	d7, [dst, #64]
   202cc:	ed8c7b10 	vstr	d7, [ip, #64]	@ 0x40
	vldr	d7, [src, #64]
   202d0:	ed917b10 	vldr	d7, [r1, #64]	@ 0x40
	vstr	d0, [dst, #64 + 8]
   202d4:	ed8c0b12 	vstr	d0, [ip, #72]	@ 0x48
	vldr	d0, [src, #64 + 8]
   202d8:	ed910b12 	vldr	d0, [r1, #72]	@ 0x48
	vstr	d1, [dst, #64 + 16]
   202dc:	ed8c1b14 	vstr	d1, [ip, #80]	@ 0x50
	vldr	d1, [src, #64 + 16]
   202e0:	ed911b14 	vldr	d1, [r1, #80]	@ 0x50
	vstr	d2, [dst, #64 + 24]
   202e4:	ed8c2b16 	vstr	d2, [ip, #88]	@ 0x58
	vldr	d2, [src, #64 + 24]
   202e8:	ed912b16 	vldr	d2, [r1, #88]	@ 0x58
	vstr	d7, [dst, #64 + 32]
   202ec:	ed8c7b18 	vstr	d7, [ip, #96]	@ 0x60
	add	src, src, #96
   202f0:	e2811060 	add	r1, r1, #96	@ 0x60
	vstr	d0, [dst, #64 + 40]
   202f4:	ed8c0b1a 	vstr	d0, [ip, #104]	@ 0x68
	vstr	d1, [dst, #64 + 48]
   202f8:	ed8c1b1c 	vstr	d1, [ip, #112]	@ 0x70
	vstr	d2, [dst, #64 + 56]
   202fc:	ed8c2b1e 	vstr	d2, [ip, #120]	@ 0x78
	add	dst, dst, #128
   20300:	e28cc080 	add	ip, ip, #128	@ 0x80
	add	tmp2, tmp2, #prefetch_lines * 64
   20304:	e28aad05 	add	sl, sl, #320	@ 0x140
	b	.Lcpy_body_medium
   20308:	eaffff1d 	b	1ff84 <memcpy+0x104>
	ldr	tmp2, [sp], #FRAME_SIZE
	bx	lr
#endif

.Lcpy_notaligned:
	pld	[src]
   2030c:	f5d1f000 	pld	[r1]
	pld	[src, #64]
   20310:	f5d1f040 	pld	[r1, #64]	@ 0x40
	/* There's at least 64 bytes to copy, but there is no mutual
	   alignment.  */
	/* Bring DST to 64-bit alignment.  */
	lsls	tmp2, dst, #29
   20314:	e1b0ae8c 	lsls	sl, ip, #29
	pld	[src, #(2 * 64)]
   20318:	f5d1f080 	pld	[r1, #128]	@ 0x80
	beq	1f
   2031c:	0a000008 	beq	20344 <memcpy+0x4c4>
	rsbs	tmp2, tmp2, #0
   20320:	e27aa000 	rsbs	sl, sl, #0
	sub	count, count, tmp2, lsr #29
   20324:	e0422eaa 	sub	r2, r2, sl, lsr #29
	ldrmi	tmp1, [src], #4
   20328:	44913004 	ldrmi	r3, [r1], #4
	strmi	tmp1, [dst], #4
   2032c:	448c3004 	strmi	r3, [ip], #4
	lsls	tmp2, tmp2, #2
   20330:	e1b0a10a 	lsls	sl, sl, #2
	ldrbne	tmp1, [src], #1
   20334:	14d13001 	ldrbne	r3, [r1], #1
	ldrhcs	tmp2, [src], #2
   20338:	20d1a0b2 	ldrhcs	sl, [r1], #2
	strbne	tmp1, [dst], #1
   2033c:	14cc3001 	strbne	r3, [ip], #1
	strhcs	tmp2, [dst], #2
   20340:	20cca0b2 	strhcs	sl, [ip], #2
1:
	pld	[src, #(3 * 64)]
   20344:	f5d1f0c0 	pld	[r1, #192]	@ 0xc0
	subs	count, count, #64
   20348:	e2522040 	subs	r2, r2, #64	@ 0x40
	ldrmi	tmp2, [sp], #FRAME_SIZE
   2034c:	449da020 	ldrmi	sl, [sp], #32
	bmi	.Ltail63unaligned
   20350:	4afffecd 	bmi	1fe8c <memcpy+0xc>
	pld	[src, #(4 * 64)]
   20354:	f5d1f100 	pld	[r1, #256]	@ 0x100
	vst1.8	{d0-d3}, [ALIGN (dst, 64)]!
	vst1.8	{d4-d7}, [ALIGN (dst, 64)]!
	ands	count, count, #0x3f
#else
	/* Use an SMS style loop to maximize the I/O bandwidth.  */
	sub	src, src, #4
   20358:	e2411004 	sub	r1, r1, #4
	sub	dst, dst, #8
   2035c:	e24cc008 	sub	ip, ip, #8
	subs	tmp2, count, #64	/* Use tmp2 for count.  */
   20360:	e252a040 	subs	sl, r2, #64	@ 0x40
	ldr	A_l, [src, #4]
   20364:	e5912004 	ldr	r2, [r1, #4]
	ldr	A_h, [src, #8]
   20368:	e5913008 	ldr	r3, [r1, #8]
	strd	B_l, B_h, [sp, #8]
   2036c:	e1cd40f8 	strd	r4, [sp, #8]
	ldr	B_l, [src, #12]
   20370:	e591400c 	ldr	r4, [r1, #12]
	ldr	B_h, [src, #16]
   20374:	e5915010 	ldr	r5, [r1, #16]
	strd	C_l, C_h, [sp, #16]
   20378:	e1cd61f0 	strd	r6, [sp, #16]
	ldr	C_l, [src, #20]
   2037c:	e5916014 	ldr	r6, [r1, #20]
	ldr	C_h, [src, #24]
   20380:	e5917018 	ldr	r7, [r1, #24]
	strd	D_l, D_h, [sp, #24]
   20384:	e1cd81f8 	strd	r8, [sp, #24]
	ldr	D_l, [src, #28]
   20388:	e591801c 	ldr	r8, [r1, #28]
	ldr	D_h, [src, #32]!
   2038c:	e5b19020 	ldr	r9, [r1, #32]!
	b	1f
   20390:	ea000018 	b	203f8 <memcpy+0x578>
   20394:	e1a00000 	nop			@ (mov r0, r0)
   20398:	e1a00000 	nop			@ (mov r0, r0)
   2039c:	e1a00000 	nop			@ (mov r0, r0)
   203a0:	e1a00000 	nop			@ (mov r0, r0)
   203a4:	e1a00000 	nop			@ (mov r0, r0)
   203a8:	e1a00000 	nop			@ (mov r0, r0)
   203ac:	e1a00000 	nop			@ (mov r0, r0)
   203b0:	e1a00000 	nop			@ (mov r0, r0)
   203b4:	e1a00000 	nop			@ (mov r0, r0)
   203b8:	e1a00000 	nop			@ (mov r0, r0)
   203bc:	e1a00000 	nop			@ (mov r0, r0)
	.p2align	6
2:
	pld	[src, #(5 * 64) - (32 - 4)]
   203c0:	f5d1f124 	pld	[r1, #292]	@ 0x124
	strd	A_l, A_h, [dst, #40]
   203c4:	e1cc22f8 	strd	r2, [ip, #40]	@ 0x28
	ldr	A_l, [src, #36]
   203c8:	e5912024 	ldr	r2, [r1, #36]	@ 0x24
	ldr	A_h, [src, #40]
   203cc:	e5913028 	ldr	r3, [r1, #40]	@ 0x28
	strd	B_l, B_h, [dst, #48]
   203d0:	e1cc43f0 	strd	r4, [ip, #48]	@ 0x30
	ldr	B_l, [src, #44]
   203d4:	e591402c 	ldr	r4, [r1, #44]	@ 0x2c
	ldr	B_h, [src, #48]
   203d8:	e5915030 	ldr	r5, [r1, #48]	@ 0x30
	strd	C_l, C_h, [dst, #56]
   203dc:	e1cc63f8 	strd	r6, [ip, #56]	@ 0x38
	ldr	C_l, [src, #52]
   203e0:	e5916034 	ldr	r6, [r1, #52]	@ 0x34
	ldr	C_h, [src, #56]
   203e4:	e5917038 	ldr	r7, [r1, #56]	@ 0x38
	strd	D_l, D_h, [dst, #64]!
   203e8:	e1ec84f0 	strd	r8, [ip, #64]!	@ 0x40
	ldr	D_l, [src, #60]
   203ec:	e591803c 	ldr	r8, [r1, #60]	@ 0x3c
	ldr	D_h, [src, #64]!
   203f0:	e5b19040 	ldr	r9, [r1, #64]!	@ 0x40
	subs	tmp2, tmp2, #64
   203f4:	e25aa040 	subs	sl, sl, #64	@ 0x40
1:
	strd	A_l, A_h, [dst, #8]
   203f8:	e1cc20f8 	strd	r2, [ip, #8]
	ldr	A_l, [src, #4]
   203fc:	e5912004 	ldr	r2, [r1, #4]
	ldr	A_h, [src, #8]
   20400:	e5913008 	ldr	r3, [r1, #8]
	strd	B_l, B_h, [dst, #16]
   20404:	e1cc41f0 	strd	r4, [ip, #16]
	ldr	B_l, [src, #12]
   20408:	e591400c 	ldr	r4, [r1, #12]
	ldr	B_h, [src, #16]
   2040c:	e5915010 	ldr	r5, [r1, #16]
	strd	C_l, C_h, [dst, #24]
   20410:	e1cc61f8 	strd	r6, [ip, #24]
	ldr	C_l, [src, #20]
   20414:	e5916014 	ldr	r6, [r1, #20]
	ldr	C_h, [src, #24]
   20418:	e5917018 	ldr	r7, [r1, #24]
	strd	D_l, D_h, [dst, #32]
   2041c:	e1cc82f0 	strd	r8, [ip, #32]
	ldr	D_l, [src, #28]
   20420:	e591801c 	ldr	r8, [r1, #28]
	ldr	D_h, [src, #32]
   20424:	e5919020 	ldr	r9, [r1, #32]
	bcs	2b
   20428:	2affffe4 	bcs	203c0 <memcpy+0x540>

	/* Save the remaining bytes and restore the callee-saved regs.  */
	strd	A_l, A_h, [dst, #40]
   2042c:	e1cc22f8 	strd	r2, [ip, #40]	@ 0x28
	add	src, src, #36
   20430:	e2811024 	add	r1, r1, #36	@ 0x24
	strd	B_l, B_h, [dst, #48]
   20434:	e1cc43f0 	strd	r4, [ip, #48]	@ 0x30
	ldrd	B_l, B_h, [sp, #8]
   20438:	e1cd40d8 	ldrd	r4, [sp, #8]
	strd	C_l, C_h, [dst, #56]
   2043c:	e1cc63f8 	strd	r6, [ip, #56]	@ 0x38
	ldrd	C_l, C_h, [sp, #16]
   20440:	e1cd61d0 	ldrd	r6, [sp, #16]
	strd	D_l, D_h, [dst, #64]
   20444:	e1cc84f0 	strd	r8, [ip, #64]	@ 0x40
	ldrd	D_l, D_h, [sp, #24]
   20448:	e1cd81d8 	ldrd	r8, [sp, #24]
	add	dst, dst, #72
   2044c:	e28cc048 	add	ip, ip, #72	@ 0x48
	ands	count, tmp2, #0x3f
   20450:	e21a203f 	ands	r2, sl, #63	@ 0x3f
#endif
	ldr	tmp2, [sp], #FRAME_SIZE
   20454:	e49da020 	ldr	sl, [sp], #32
	bne	.Ltail63unaligned
   20458:	1afffe8b 	bne	1fe8c <memcpy+0xc>
	bx	lr
   2045c:	e12fff1e 	bx	lr
	...

00020480 <strlen>:
#define tmp2		r5

def_fn	strlen p2align=6
	.fnstart
	.cfi_startproc
	prologue 4 5 push_ip=HAVE_PAC_LEAF
   20480:	b430      	push	{r4, r5}
	pld	[srcin, #0]
   20482:	f890 f000 	pld	[r0]
	bic	src, srcin, #7
   20486:	f020 0107 	bic.w	r1, r0, #7
	mvn	const_m1, #0
   2048a:	f06f 0c00 	mvn.w	ip, #0
	ands	tmp1, srcin, #7		/* (8 - bytes) to alignment.  */
   2048e:	f010 0407 	ands.w	r4, r0, #7
	pld	[src, #32]
   20492:	f891 f020 	pld	[r1, #32]
	bne.w	.Lmisaligned8
   20496:	f040 8048 	bne.w	2052a <strlen+0xaa>
	mov	const_0, #0
   2049a:	f04f 0400 	mov.w	r4, #0
	mov	result, #-8
   2049e:	f06f 0007 	mvn.w	r0, #7
.Lloop_aligned:
	/* Bytes 0-7.  */
	ldrd	data1a, data1b, [src]
   204a2:	e9d1 2300 	ldrd	r2, r3, [r1]
	pld	[src, #64]
   204a6:	f891 f040 	pld	[r1, #64]	@ 0x40
	add	result, result, #8
   204aa:	f100 0008 	add.w	r0, r0, #8
.Lstart_realigned:
	uadd8	data1a, data1a, const_m1	/* Saturating GE<0:3> set.  */
   204ae:	fa82 f24c 	uadd8	r2, r2, ip
	sel	data1a, const_0, const_m1	/* Select based on GE<0:3>.  */
   204b2:	faa4 f28c 	sel	r2, r4, ip
	uadd8	data1b, data1b, const_m1
   204b6:	fa83 f34c 	uadd8	r3, r3, ip
	sel	data1b, data1a, const_m1	/* Only used if d1a == 0.  */
   204ba:	faa2 f38c 	sel	r3, r2, ip
	cbnz	data1b, .Lnull_found
   204be:	bb4b      	cbnz	r3, 20514 <strlen+0x94>

	/* Bytes 8-15.  */
	ldrd	data1a, data1b, [src, #8]
   204c0:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
	uadd8	data1a, data1a, const_m1	/* Saturating GE<0:3> set.  */
   204c4:	fa82 f24c 	uadd8	r2, r2, ip
	add	result, result, #8
   204c8:	f100 0008 	add.w	r0, r0, #8
	sel	data1a, const_0, const_m1	/* Select based on GE<0:3>.  */
   204cc:	faa4 f28c 	sel	r2, r4, ip
	uadd8	data1b, data1b, const_m1
   204d0:	fa83 f34c 	uadd8	r3, r3, ip
	sel	data1b, data1a, const_m1	/* Only used if d1a == 0.  */
   204d4:	faa2 f38c 	sel	r3, r2, ip
	cbnz	data1b, .Lnull_found
   204d8:	b9e3      	cbnz	r3, 20514 <strlen+0x94>

	/* Bytes 16-23.  */
	ldrd	data1a, data1b, [src, #16]
   204da:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
	uadd8	data1a, data1a, const_m1	/* Saturating GE<0:3> set.  */
   204de:	fa82 f24c 	uadd8	r2, r2, ip
	add	result, result, #8
   204e2:	f100 0008 	add.w	r0, r0, #8
	sel	data1a, const_0, const_m1	/* Select based on GE<0:3>.  */
   204e6:	faa4 f28c 	sel	r2, r4, ip
	uadd8	data1b, data1b, const_m1
   204ea:	fa83 f34c 	uadd8	r3, r3, ip
	sel	data1b, data1a, const_m1	/* Only used if d1a == 0.  */
   204ee:	faa2 f38c 	sel	r3, r2, ip
	cbnz	data1b, .Lnull_found
   204f2:	b97b      	cbnz	r3, 20514 <strlen+0x94>

	/* Bytes 24-31.  */
	ldrd	data1a, data1b, [src, #24]
   204f4:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
	add	src, src, #32
   204f8:	f101 0120 	add.w	r1, r1, #32
	uadd8	data1a, data1a, const_m1	/* Saturating GE<0:3> set.  */
   204fc:	fa82 f24c 	uadd8	r2, r2, ip
	add	result, result, #8
   20500:	f100 0008 	add.w	r0, r0, #8
	sel	data1a, const_0, const_m1	/* Select based on GE<0:3>.  */
   20504:	faa4 f28c 	sel	r2, r4, ip
	uadd8	data1b, data1b, const_m1
   20508:	fa83 f34c 	uadd8	r3, r3, ip
	sel	data1b, data1a, const_m1	/* Only used if d1a == 0.  */
   2050c:	faa2 f38c 	sel	r3, r2, ip
	cmp	data1b, #0
   20510:	2b00      	cmp	r3, #0
	beq	.Lloop_aligned
   20512:	d0c6      	beq.n	204a2 <strlen+0x22>

.Lnull_found:
	.cfi_remember_state
	cmp	data1a, #0
   20514:	2a00      	cmp	r2, #0
	itt	eq
   20516:	bf04      	itt	eq
	addeq	result, result, #4
   20518:	3004      	addeq	r0, #4
	moveq	data1a, data1b
   2051a:	461a      	moveq	r2, r3
#ifndef __ARMEB__
	rev	data1a, data1a
   2051c:	ba12      	rev	r2, r2
#endif
	clz	data1a, data1a
   2051e:	fab2 f282 	clz	r2, r2
	add	result, result, data1a, lsr #3	/* Bits -> Bytes.  */
   20522:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
	epilogue 4 5 push_ip=HAVE_PAC_LEAF
   20526:	bc30      	pop	{r4, r5}
   20528:	4770      	bx	lr

.Lmisaligned8:
	.cfi_restore_state
	ldrd	data1a, data1b, [src]
   2052a:	e9d1 2300 	ldrd	r2, r3, [r1]
	and	tmp2, tmp1, #3
   2052e:	f004 0503 	and.w	r5, r4, #3
	rsb	result, tmp1, #0
   20532:	f1c4 0000 	rsb	r0, r4, #0
	lsl	tmp2, tmp2, #3			/* Bytes -> bits.  */
   20536:	ea4f 05c5 	mov.w	r5, r5, lsl #3
	tst	tmp1, #4
   2053a:	f014 0f04 	tst.w	r4, #4
	pld	[src, #64]
   2053e:	f891 f040 	pld	[r1, #64]	@ 0x40
	S2HI	tmp2, const_m1, tmp2
   20542:	fa0c f505 	lsl.w	r5, ip, r5
	orn	data1a, data1a, tmp2
   20546:	ea62 0205 	orn	r2, r2, r5
	itt	ne
   2054a:	bf1c      	itt	ne
	ornne	data1b, data1b, tmp2
   2054c:	ea63 0305 	ornne	r3, r3, r5
	movne	data1a, const_m1
   20550:	4662      	movne	r2, ip
	mov	const_0, #0
   20552:	f04f 0400 	mov.w	r4, #0
	b	.Lstart_realigned
   20556:	e7aa      	b.n	204ae <strlen+0x2e>

00020558 <ldexp>:
   20558:	e92d4010 	push	{r4, lr}
	double ldexp(double value, int exp)
#else
	double ldexp(value, exp)
	double value; int exp;
#endif
{
   2055c:	e1a04000 	mov	r4, r0
   20560:	ed2d8b02 	vpush	{d8}
   20564:	eeb08b40 	vmov.f64	d8, d0
	if(!finite(value)||value==0.0) return value;
   20568:	eb00008a 	bl	20798 <finite>
   2056c:	eeb58b40 	vcmp.f64	d8, #0.0
   20570:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   20574:	03a03001 	moveq	r3, #1
   20578:	13a03000 	movne	r3, #0
   2057c:	e3500000 	cmp	r0, #0
   20580:	03833001 	orreq	r3, r3, #1
   20584:	e3530000 	cmp	r3, #0
   20588:	0a000002 	beq	20598 <ldexp+0x40>
	value = scalbn(value,exp);
	if(!finite(value)||value==0.0) errno = ERANGE;
	return value;
}
   2058c:	eeb00b48 	vmov.f64	d0, d8
   20590:	ecbd8b02 	vpop	{d8}
   20594:	e8bd8010 	pop	{r4, pc}
	value = scalbn(value,exp);
   20598:	e1a00004 	mov	r0, r4
   2059c:	eeb00b48 	vmov.f64	d0, d8
   205a0:	eb000034 	bl	20678 <scalbn>
   205a4:	eeb08b40 	vmov.f64	d8, d0
	if(!finite(value)||value==0.0) errno = ERANGE;
   205a8:	eb00007a 	bl	20798 <finite>
   205ac:	eeb58b40 	vcmp.f64	d8, #0.0
   205b0:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   205b4:	03a03001 	moveq	r3, #1
   205b8:	13a03000 	movne	r3, #0
   205bc:	e3500000 	cmp	r0, #0
   205c0:	03833001 	orreq	r3, r3, #1
   205c4:	e3530000 	cmp	r3, #0
   205c8:	0affffef 	beq	2058c <ldexp+0x34>
   205cc:	ebffec90 	bl	1b814 <__errno>
}
   205d0:	eeb00b48 	vmov.f64	d0, d8
	if(!finite(value)||value==0.0) errno = ERANGE;
   205d4:	e3a03022 	mov	r3, #34	@ 0x22
}
   205d8:	ecbd8b02 	vpop	{d8}
	if(!finite(value)||value==0.0) errno = ERANGE;
   205dc:	e5803000 	str	r3, [r0]
}
   205e0:	e8bd8010 	pop	{r4, pc}
   205e4:	00000000 	andeq	r0, r0, r0

000205e8 <frexp>:
{
	__int32_t hx, ix, lx;
	EXTRACT_WORDS(hx,lx,x);
	ix = 0x7fffffff&hx;
	*eptr = 0;
	if(ix>=0x7ff00000||((ix|lx)==0)) return x;	/* 0,inf,nan */
   205e8:	e30f1fff 	movw	r1, #65535	@ 0xffff
   205ec:	ee102a90 	vmov	r2, s1
   205f0:	e3471fef 	movt	r1, #32751	@ 0x7fef
   205f4:	e3c23102 	bic	r3, r2, #-2147483648	@ 0x80000000
   205f8:	e1530001 	cmp	r3, r1
	*eptr = 0;
   205fc:	e3a01000 	mov	r1, #0
   20600:	e5801000 	str	r1, [r0]
	if(ix>=0x7ff00000||((ix|lx)==0)) return x;	/* 0,inf,nan */
   20604:	812fff1e 	bxhi	lr
   20608:	ee10ca10 	vmov	ip, s0
   2060c:	e193c00c 	orrs	ip, r3, ip
   20610:	012fff1e 	bxeq	lr
	if (ix<0x00100000) {		/* subnormal */
   20614:	e1a0c001 	mov	ip, r1
   20618:	e347cff0 	movt	ip, #32752	@ 0x7ff0
   2061c:	e00cc002 	and	ip, ip, r2
   20620:	e15c0001 	cmp	ip, r1
	    x *= two54;
   20624:	0d9f7b0f 	vldreq	d7, [pc, #60]	@ 20668 <frexp+0x80>
	    GET_HIGH_WORD(hx,x);
	    ix = hx&0x7fffffff;
   20628:	03e01035 	mvneq	r1, #53	@ 0x35
	    x *= two54;
   2062c:	0e200b07 	vmuleq.f64	d0, d0, d7
	    GET_HIGH_WORD(hx,x);
   20630:	0e102a90 	vmoveq	r2, s1
	    ix = hx&0x7fffffff;
   20634:	03c23102 	biceq	r3, r2, #-2147483648	@ 0x80000000
	    *eptr = -54;
	}
	*eptr += (ix>>20)-1022;
	hx = (hx&0x800fffff)|0x3fe00000;
	SET_HIGH_WORD(x,hx);
   20638:	e3c2c47f 	bic	ip, r2, #2130706432	@ 0x7f000000
	*eptr += (ix>>20)-1022;
   2063c:	e1a03a43 	asr	r3, r3, #20
	SET_HIGH_WORD(x,hx);
   20640:	e3ccc60f 	bic	ip, ip, #15728640	@ 0xf00000
	*eptr += (ix>>20)-1022;
   20644:	e2433fff 	sub	r3, r3, #1020	@ 0x3fc
   20648:	e2433002 	sub	r3, r3, #2
   2064c:	e0831001 	add	r1, r3, r1
	SET_HIGH_WORD(x,hx);
   20650:	ec532b10 	vmov	r2, r3, d0
   20654:	e38c35ff 	orr	r3, ip, #1069547520	@ 0x3fc00000
	*eptr += (ix>>20)-1022;
   20658:	e5801000 	str	r1, [r0]
	SET_HIGH_WORD(x,hx);
   2065c:	e3833602 	orr	r3, r3, #2097152	@ 0x200000
   20660:	ec432b10 	vmov	d0, r2, r3
	return x;
}
   20664:	e12fff1e 	bx	lr
   20668:	00000000 	.word	0x00000000
   2066c:	43500000 	.word	0x43500000

00020670 <frexpl>:
/* On platforms where long double is as wide as double.  */
#if defined(_LDBL_EQ_DBL)
long double
frexpl (long double x, int *eptr)
{
  return frexp(x, eptr);
   20670:	eaffffdc 	b	205e8 <frexp>
   20674:	00000000 	andeq	r0, r0, r0

00020678 <scalbn>:
	double scalbn (x,n)
	double x; int n;
#endif
{
	__int32_t  k,hx,lx;
	EXTRACT_WORDS(hx,lx,x);
   20678:	ee101a90 	vmov	r1, s1
        k = (hx&0x7ff00000)>>20;		/* extract exponent */
   2067c:	e30027ff 	movw	r2, #2047	@ 0x7ff
   20680:	e7ea3a51 	ubfx	r3, r1, #20, #11
        if (k==0) {				/* 0 or subnormal x */
   20684:	e3530000 	cmp	r3, #0
   20688:	1a00001f 	bne	2070c <scalbn+0x94>
            if ((lx|(hx&0x7fffffff))==0) return x; /* +-0 */
   2068c:	e3c11102 	bic	r1, r1, #-2147483648	@ 0x80000000
   20690:	ee103a10 	vmov	r3, s0
   20694:	e1911003 	orrs	r1, r1, r3
   20698:	012fff1e 	bxeq	lr
	    x *= two54; 
   2069c:	ed9f7b31 	vldr	d7, [pc, #196]	@ 20768 <scalbn+0xf0>
	    GET_HIGH_WORD(hx,x);
	    k = ((hx&0x7ff00000)>>20) - 54; 
            if (n< -50000) return tiny*x; 	/*underflow*/
   206a0:	e3033cb0 	movw	r3, #15536	@ 0x3cb0
   206a4:	e34f3fff 	movt	r3, #65535	@ 0xffff
   206a8:	e1500003 	cmp	r0, r3
	    x *= two54; 
   206ac:	ee200b07 	vmul.f64	d0, d0, d7
            if (n< -50000) return tiny*x; 	/*underflow*/
   206b0:	ba000026 	blt	20750 <scalbn+0xd8>
	    GET_HIGH_WORD(hx,x);
   206b4:	ee101a90 	vmov	r1, s1
	    k = ((hx&0x7ff00000)>>20) - 54; 
   206b8:	e7ea3a51 	ubfx	r3, r1, #20, #11
   206bc:	e2433036 	sub	r3, r3, #54	@ 0x36
	    }
        if (k==0x7ff) return x+x;		/* NaN or Inf */
        if (n > 50000) 	/* in case integer overflow in n+k */
   206c0:	e30c2350 	movw	r2, #50000	@ 0xc350
   206c4:	e1500002 	cmp	r0, r2
   206c8:	ca000013 	bgt	2071c <scalbn+0xa4>
	    return huge*copysign(huge,x);	/*overflow*/
        k = k+n; 
   206cc:	e0800003 	add	r0, r0, r3
        if (k >  0x7fe) return huge*copysign(huge,x); /* overflow  */
   206d0:	e30037fe 	movw	r3, #2046	@ 0x7fe
   206d4:	e1500003 	cmp	r0, r3
   206d8:	ca00000f 	bgt	2071c <scalbn+0xa4>
        if (k > 0) 				/* normal result */
   206dc:	e3500000 	cmp	r0, #0
   206e0:	ca000015 	bgt	2073c <scalbn+0xc4>
	    {SET_HIGH_WORD(x,(hx&0x800fffff)|(k<<20)); return x;}
        if (k <= -54)
   206e4:	e3700035 	cmn	r0, #53	@ 0x35
   206e8:	ba00001b 	blt	2075c <scalbn+0xe4>
	    return tiny*copysign(tiny,x); 	/*underflow*/
        k += 54;				/* subnormal result */
   206ec:	e2800036 	add	r0, r0, #54	@ 0x36
	SET_HIGH_WORD(x,(hx&0x800fffff)|(k<<20));
   206f0:	e7de1a1f 	bfc	r1, #20, #11
   206f4:	ec532b10 	vmov	r2, r3, d0
   206f8:	e1813a00 	orr	r3, r1, r0, lsl #20
        return x*twom54;
   206fc:	ed9f7b1b 	vldr	d7, [pc, #108]	@ 20770 <scalbn+0xf8>
	SET_HIGH_WORD(x,(hx&0x800fffff)|(k<<20));
   20700:	ec432b10 	vmov	d0, r2, r3
        return x*twom54;
   20704:	ee200b07 	vmul.f64	d0, d0, d7
}
   20708:	e12fff1e 	bx	lr
        if (k==0x7ff) return x+x;		/* NaN or Inf */
   2070c:	e1530002 	cmp	r3, r2
   20710:	1affffea 	bne	206c0 <scalbn+0x48>
   20714:	ee300b00 	vadd.f64	d0, d0, d0
   20718:	e12fff1e 	bx	lr
        if (k >  0x7fe) return huge*copysign(huge,x); /* overflow  */
   2071c:	ed9f7b15 	vldr	d7, [pc, #84]	@ 20778 <scalbn+0x100>
   20720:	ed9f5b16 	vldr	d5, [pc, #88]	@ 20780 <scalbn+0x108>
	    return tiny*copysign(tiny,x); 	/*underflow*/
   20724:	ee103a90 	vmov	r3, s1
   20728:	e3530000 	cmp	r3, #0
   2072c:	eeb06b47 	vmov.f64	d6, d7
   20730:	beb07b45 	vmovlt.f64	d7, d5
   20734:	ee270b06 	vmul.f64	d0, d7, d6
   20738:	e12fff1e 	bx	lr
	    {SET_HIGH_WORD(x,(hx&0x800fffff)|(k<<20)); return x;}
   2073c:	e7de1a1f 	bfc	r1, #20, #11
   20740:	ec532b10 	vmov	r2, r3, d0
   20744:	e1813a00 	orr	r3, r1, r0, lsl #20
   20748:	ec432b10 	vmov	d0, r2, r3
   2074c:	e12fff1e 	bx	lr
            if (n< -50000) return tiny*x; 	/*underflow*/
   20750:	ed9f7b0c 	vldr	d7, [pc, #48]	@ 20788 <scalbn+0x110>
   20754:	ee200b07 	vmul.f64	d0, d0, d7
   20758:	e12fff1e 	bx	lr
	    return tiny*copysign(tiny,x); 	/*underflow*/
   2075c:	ed9f7b09 	vldr	d7, [pc, #36]	@ 20788 <scalbn+0x110>
   20760:	ed9f5b0a 	vldr	d5, [pc, #40]	@ 20790 <scalbn+0x118>
   20764:	eaffffee 	b	20724 <scalbn+0xac>
   20768:	00000000 	.word	0x00000000
   2076c:	43500000 	.word	0x43500000
   20770:	00000000 	.word	0x00000000
   20774:	3c900000 	.word	0x3c900000
   20778:	8800759c 	.word	0x8800759c
   2077c:	7e37e43c 	.word	0x7e37e43c
   20780:	8800759c 	.word	0x8800759c
   20784:	fe37e43c 	.word	0xfe37e43c
   20788:	c2f8f359 	.word	0xc2f8f359
   2078c:	01a56e1f 	.word	0x01a56e1f
   20790:	c2f8f359 	.word	0xc2f8f359
   20794:	81a56e1f 	.word	0x81a56e1f

00020798 <finite>:
	double x;
#endif
{
	__int32_t hx;
	GET_HIGH_WORD(hx,x);
	return  (int)((__uint32_t)((hx&0x7fffffff)-0x7ff00000)>>31);
   20798:	ee100a90 	vmov	r0, s1
   2079c:	e3800102 	orr	r0, r0, #-2147483648	@ 0x80000000
   207a0:	e2800601 	add	r0, r0, #1048576	@ 0x100000
}
   207a4:	e1a00fa0 	lsr	r0, r0, #31
   207a8:	e12fff1e 	bx	lr

000207ac <__register_exitproc>:
int
__register_exitproc (int type,
	void (*fn) (void),
	void *arg,
	void *d)
{
   207ac:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}

#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_recursive_mutex);
#endif

  p = __atexit;
   207b0:	e30b49f0 	movw	r4, #47600	@ 0xb9f0
   207b4:	e3404002 	movt	r4, #2
{
   207b8:	e1a05001 	mov	r5, r1
   207bc:	e1a07000 	mov	r7, r0
   207c0:	e1a08002 	mov	r8, r2
  p = __atexit;
   207c4:	e594c000 	ldr	ip, [r4]
{
   207c8:	e1a06003 	mov	r6, r3
  if (p == NULL)
   207cc:	e35c0000 	cmp	ip, #0
    {
      __atexit = p = &__atexit0;
   207d0:	030bc860 	movweq	ip, #47200	@ 0xb860
   207d4:	0340c002 	movteq	ip, #2
      extern struct _on_exit_args * const __on_exit_args _ATTRIBUTE ((weak));
      if (&__on_exit_args != NULL)
	p->_on_exit_args_ptr = __on_exit_args;
#endif	/* def _REENT_SMALL */
    }
  if (p->_ind >= _ATEXIT_SIZE)
   207d8:	e59ce004 	ldr	lr, [ip, #4]
      __atexit = p = &__atexit0;
   207dc:	0584c000 	streq	ip, [r4]
  if (p->_ind >= _ATEXIT_SIZE)
   207e0:	e35e001f 	cmp	lr, #31
      args->_fntypes |= (1 << p->_ind);
      args->_dso_handle[p->_ind] = d;
      if (type == __et_cxa)
	args->_is_cxa |= (1 << p->_ind);
    }
  p->_fns[p->_ind++] = fn;
   207e4:	d28e1001 	addle	r1, lr, #1
  if (p->_ind >= _ATEXIT_SIZE)
   207e8:	ca000012 	bgt	20838 <__register_exitproc+0x8c>
  if (type != __et_atexit)
   207ec:	e3570000 	cmp	r7, #0
   207f0:	0a00000b 	beq	20824 <__register_exitproc+0x78>
      args->_fnargs[p->_ind] = arg;
   207f4:	e08c310e 	add	r3, ip, lr, lsl #2
      args->_fntypes |= (1 << p->_ind);
   207f8:	e3a02001 	mov	r2, #1
   207fc:	e1a02e12 	lsl	r2, r2, lr
      if (type == __et_cxa)
   20800:	e3570002 	cmp	r7, #2
      args->_fnargs[p->_ind] = arg;
   20804:	e5838088 	str	r8, [r3, #136]	@ 0x88
      args->_fntypes |= (1 << p->_ind);
   20808:	e59c0188 	ldr	r0, [ip, #392]	@ 0x188
   2080c:	e1800002 	orr	r0, r0, r2
   20810:	e58c0188 	str	r0, [ip, #392]	@ 0x188
      args->_dso_handle[p->_ind] = d;
   20814:	e5836108 	str	r6, [r3, #264]	@ 0x108
	args->_is_cxa |= (1 << p->_ind);
   20818:	059c318c 	ldreq	r3, [ip, #396]	@ 0x18c
   2081c:	01833002 	orreq	r3, r3, r2
   20820:	058c318c 	streq	r3, [ip, #396]	@ 0x18c
  p->_fns[p->_ind++] = fn;
   20824:	e28ee002 	add	lr, lr, #2
   20828:	e58c1004 	str	r1, [ip, #4]
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_recursive_mutex);
#endif
  return 0;
   2082c:	e3a00000 	mov	r0, #0
  p->_fns[p->_ind++] = fn;
   20830:	e78c510e 	str	r5, [ip, lr, lsl #2]
  return 0;
   20834:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
      p = (struct _atexit *) malloc (sizeof *p);
   20838:	e3a00e19 	mov	r0, #400	@ 0x190
   2083c:	ebfff0fe 	bl	1cc3c <malloc>
      if (p == NULL)
   20840:	e250c000 	subs	ip, r0, #0
   20844:	0a000008 	beq	2086c <__register_exitproc+0xc0>
      p->_next = __atexit;
   20848:	e5943000 	ldr	r3, [r4]
      p->_ind = 0;
   2084c:	e3a0e000 	mov	lr, #0
      p->_on_exit_args._fntypes = 0;
   20850:	e3a01001 	mov	r1, #1
      p->_ind = 0;
   20854:	e58ce004 	str	lr, [ip, #4]
      __atexit = p;
   20858:	e584c000 	str	ip, [r4]
      p->_next = __atexit;
   2085c:	e58c3000 	str	r3, [ip]
      p->_on_exit_args._fntypes = 0;
   20860:	e58ce188 	str	lr, [ip, #392]	@ 0x188
   20864:	e58ce18c 	str	lr, [ip, #396]	@ 0x18c
   20868:	eaffffdf 	b	207ec <__register_exitproc+0x40>
	  return -1;
   2086c:	e3e00000 	mvn	r0, #0
}
   20870:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

00020874 <__call_exitprocs>:
 * otherwise only the handlers from that DSO are called.
 */

void 
__call_exitprocs (int code, void *d)
{
   20874:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   20878:	e30b49f0 	movw	r4, #47600	@ 0xb9f0
   2087c:	e1a07001 	mov	r7, r1
#endif
      for (n = p->_ind - 1; n >= 0; n--)
	{
	  int ind;

	  i = 1 << n;
   20880:	e3a08001 	mov	r8, #1
{
   20884:	e24dd00c 	sub	sp, sp, #12
   20888:	e3404002 	movt	r4, #2
   2088c:	e58d0000 	str	r0, [sp]
	  i = 1 << n;
   20890:	e58d4004 	str	r4, [sp, #4]
  p = __atexit;
   20894:	e59d3004 	ldr	r3, [sp, #4]
   20898:	e5939000 	ldr	r9, [r3]
  while (p)
   2089c:	e3590000 	cmp	r9, #0
   208a0:	0a000034 	beq	20978 <__call_exitprocs+0x104>
  lastp = &__atexit;
   208a4:	e30b49f0 	movw	r4, #47600	@ 0xb9f0
	     function calling exit recursively.  */
	  fn = p->_fns[n];
	  if (n == p->_ind - 1)
	    p->_ind--;
	  else
	    p->_fns[n] = NULL;
   208a8:	e3a0a000 	mov	sl, #0
  lastp = &__atexit;
   208ac:	e3404002 	movt	r4, #2
   208b0:	e1a05004 	mov	r5, r4
      for (n = p->_ind - 1; n >= 0; n--)
   208b4:	e5994004 	ldr	r4, [r9, #4]
   208b8:	e2546001 	subs	r6, r4, #1
   208bc:	4a000022 	bmi	2094c <__call_exitprocs+0xd8>
   208c0:	e284b001 	add	fp, r4, #1
   208c4:	e089b10b 	add	fp, r9, fp, lsl #2
   208c8:	ea000003 	b	208dc <__call_exitprocs+0x68>
   208cc:	e2466001 	sub	r6, r6, #1
   208d0:	e24bb004 	sub	fp, fp, #4
   208d4:	e3760001 	cmn	r6, #1
   208d8:	0a00001b 	beq	2094c <__call_exitprocs+0xd8>
	  if (d && (!args || args->_dso_handle[n] != d))
   208dc:	e3570000 	cmp	r7, #0
   208e0:	0a000002 	beq	208f0 <__call_exitprocs+0x7c>
   208e4:	e59b3100 	ldr	r3, [fp, #256]	@ 0x100
   208e8:	e1530007 	cmp	r3, r7
   208ec:	1afffff6 	bne	208cc <__call_exitprocs+0x58>
	  fn = p->_fns[n];
   208f0:	e59b2000 	ldr	r2, [fp]
	  if (n == p->_ind - 1)
   208f4:	e2443001 	sub	r3, r4, #1
   208f8:	e1530006 	cmp	r3, r6
	    p->_ind--;
   208fc:	01a04006 	moveq	r4, r6
   20900:	05896004 	streq	r6, [r9, #4]
	    p->_fns[n] = NULL;
   20904:	158ba000 	strne	sl, [fp]

	  /* Skip functions that have already been called.  */
	  if (!fn)
   20908:	e3520000 	cmp	r2, #0
   2090c:	0affffee 	beq	208cc <__call_exitprocs+0x58>
	    continue;

	  ind = p->_ind;

	  /* Call the function.  */
	  if (!args || (args->_fntypes & i) == 0)
   20910:	e5991188 	ldr	r1, [r9, #392]	@ 0x188
	  i = 1 << n;
   20914:	e1a03618 	lsl	r3, r8, r6
	  if (!args || (args->_fntypes & i) == 0)
   20918:	e1130001 	tst	r3, r1
   2091c:	1a000017 	bne	20980 <__call_exitprocs+0x10c>
	    fn ();
   20920:	e12fff32 	blx	r2
	    (*((void (*)(void *)) fn))(args->_fnargs[n]);

	  /* The function we called call atexit and registered another
	     function (or functions).  Call these new functions before
	     continuing with the already registered functions.  */
	  if (ind != p->_ind || *lastp != p)
   20924:	e5993004 	ldr	r3, [r9, #4]
   20928:	e1530004 	cmp	r3, r4
   2092c:	1affffd8 	bne	20894 <__call_exitprocs+0x20>
   20930:	e5953000 	ldr	r3, [r5]
   20934:	e1530009 	cmp	r3, r9
   20938:	1affffd5 	bne	20894 <__call_exitprocs+0x20>
      for (n = p->_ind - 1; n >= 0; n--)
   2093c:	e2466001 	sub	r6, r6, #1
   20940:	e24bb004 	sub	fp, fp, #4
   20944:	e3760001 	cmn	r6, #1
   20948:	1affffe3 	bne	208dc <__call_exitprocs+0x68>
#if !defined (_ATEXIT_DYNAMIC_ALLOC) || !defined (MALLOC_PROVIDED)
      break;
#else
      /* Move to the next block.  Free empty blocks except the last one,
	 which is part of _GLOBAL_REENT.  */
      if (p->_ind == 0 && p->_next)
   2094c:	e3540000 	cmp	r4, #0
   20950:	e5993000 	ldr	r3, [r9]
   20954:	1a000013 	bne	209a8 <__call_exitprocs+0x134>
   20958:	e3530000 	cmp	r3, #0
   2095c:	0a000005 	beq	20978 <__call_exitprocs+0x104>
	  *lastp = p->_next;
#ifdef _REENT_SMALL
	  if (args)
	    free (args);
#endif
	  free (p);
   20960:	e1a00009 	mov	r0, r9
	  *lastp = p->_next;
   20964:	e5853000 	str	r3, [r5]
	  free (p);
   20968:	ebfff72d 	bl	1e624 <free>
	  p = *lastp;
   2096c:	e5959000 	ldr	r9, [r5]
  while (p)
   20970:	e3590000 	cmp	r9, #0
   20974:	1affffce 	bne	208b4 <__call_exitprocs+0x40>
    }
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_recursive_mutex);
#endif

}
   20978:	e28dd00c 	add	sp, sp, #12
   2097c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
	  else if ((args->_is_cxa & i) == 0)
   20980:	e599018c 	ldr	r0, [r9, #396]	@ 0x18c
	    (*((void (*)(int, void *)) fn))(code, args->_fnargs[n]);
   20984:	e59b1080 	ldr	r1, [fp, #128]	@ 0x80
	  else if ((args->_is_cxa & i) == 0)
   20988:	e1130000 	tst	r3, r0
   2098c:	1a000002 	bne	2099c <__call_exitprocs+0x128>
	    (*((void (*)(int, void *)) fn))(code, args->_fnargs[n]);
   20990:	e59d0000 	ldr	r0, [sp]
   20994:	e12fff32 	blx	r2
   20998:	eaffffe1 	b	20924 <__call_exitprocs+0xb0>
	    (*((void (*)(void *)) fn))(args->_fnargs[n]);
   2099c:	e1a00001 	mov	r0, r1
   209a0:	e12fff32 	blx	r2
   209a4:	eaffffde 	b	20924 <__call_exitprocs+0xb0>
	  lastp = &p->_next;
   209a8:	e1a05009 	mov	r5, r9
	  p = p->_next;
   209ac:	e1a09003 	mov	r9, r3
   209b0:	eaffffee 	b	20970 <__call_exitprocs+0xfc>

000209b4 <__env_lock>:
     struct _reent *ptr;
{
#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive (__env_recursive_mutex);
#endif
}
   209b4:	e12fff1e 	bx	lr

000209b8 <__env_unlock>:

#define ENV_LOCK __env_lock(reent_ptr)
#define ENV_UNLOCK __env_unlock(reent_ptr)

void __env_lock (struct _reent *reent);
void __env_unlock (struct _reent *reent);
   209b8:	e12fff1e 	bx	lr

000209bc <_mbtowc_r>:
        wchar_t       *__restrict pwc,
        const char    *__restrict s,
        size_t         n,
        mbstate_t      *state)
{
  return __MBTOWC (r, pwc, s, n, state);
   209bc:	e30bc078 	movw	ip, #45176	@ 0xb078
{
   209c0:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
  return __MBTOWC (r, pwc, s, n, state);
   209c4:	e340c002 	movt	ip, #2
   209c8:	e59ce0e4 	ldr	lr, [ip, #228]	@ 0xe4
   209cc:	e1a0c00e 	mov	ip, lr
}
   209d0:	e49de004 	pop	{lr}		@ (ldr lr, [sp], #4)
  return __MBTOWC (r, pwc, s, n, state);
   209d4:	e12fff1c 	bx	ip

000209d8 <__ascii_mbtowc>:
        mbstate_t      *state)
{
  wchar_t dummy;
  unsigned char *t = (unsigned char *)s;

  if (pwc == NULL)
   209d8:	e3510000 	cmp	r1, #0
{
   209dc:	e24dd008 	sub	sp, sp, #8
    pwc = &dummy;
   209e0:	028d1004 	addeq	r1, sp, #4

  if (s == NULL)
   209e4:	e3520000 	cmp	r2, #0
    return 0;
   209e8:	01a00002 	moveq	r0, r2
  if (s == NULL)
   209ec:	0a000006 	beq	20a0c <__ascii_mbtowc+0x34>

  if (n == 0)
   209f0:	e3530000 	cmp	r3, #0
   209f4:	0a000006 	beq	20a14 <__ascii_mbtowc+0x3c>
    return -2;

  *pwc = (wchar_t)*t;
   209f8:	e5d23000 	ldrb	r3, [r2]
   209fc:	e5813000 	str	r3, [r1]
  
  if (*t == '\0')
   20a00:	e5d22000 	ldrb	r2, [r2]
   20a04:	e2520000 	subs	r0, r2, #0
   20a08:	13a00001 	movne	r0, #1
    return 0;

  return 1;
}
   20a0c:	e28dd008 	add	sp, sp, #8
   20a10:	e12fff1e 	bx	lr
    return -2;
   20a14:	e3e00001 	mvn	r0, #1
   20a18:	eafffffb 	b	20a0c <__ascii_mbtowc+0x34>

00020a1c <_wctomb_r>:
_wctomb_r (struct _reent *r,
        char          *s,
        wchar_t        _wchar,
        mbstate_t     *state)
{
  return __WCTOMB (r, s, _wchar, state);
   20a1c:	e30bc078 	movw	ip, #45176	@ 0xb078
{
   20a20:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
  return __WCTOMB (r, s, _wchar, state);
   20a24:	e340c002 	movt	ip, #2
   20a28:	e59ce0e0 	ldr	lr, [ip, #224]	@ 0xe0
   20a2c:	e1a0c00e 	mov	ip, lr
}
   20a30:	e49de004 	pop	{lr}		@ (ldr lr, [sp], #4)
  return __WCTOMB (r, s, _wchar, state);
   20a34:	e12fff1c 	bx	ip

00020a38 <__ascii_wctomb>:
  /* Avoids compiler warnings about comparisons that are always false
     due to limited range when sizeof(wchar_t) is 2 but sizeof(wint_t)
     is 4, as is the case on cygwin.  */
  wint_t wchar = _wchar;

  if (s == NULL)
   20a38:	e3510000 	cmp	r1, #0
{
   20a3c:	e1a03000 	mov	r3, r0
  if (s == NULL)
   20a40:	0a000006 	beq	20a60 <__ascii_wctomb+0x28>
    return 0;
 
  if ((size_t)wchar >= 0x100)
   20a44:	e35200ff 	cmp	r2, #255	@ 0xff
    {
      _REENT_ERRNO(r) = EILSEQ;
   20a48:	83a0208a 	movhi	r2, #138	@ 0x8a
      return -1;
   20a4c:	83e00000 	mvnhi	r0, #0
      _REENT_ERRNO(r) = EILSEQ;
   20a50:	85832000 	strhi	r2, [r3]
    }

  *s = (char) wchar;
  return 1;
   20a54:	93a00001 	movls	r0, #1
  *s = (char) wchar;
   20a58:	95c12000 	strbls	r2, [r1]
  return 1;
   20a5c:	e12fff1e 	bx	lr
    return 0;
   20a60:	e1a00001 	mov	r0, r1
}
   20a64:	e12fff1e 	bx	lr

00020a68 <_svfprintf_r>:
{
   20a68:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   20a6c:	e1a04001 	mov	r4, r1
   20a70:	ed2d8b04 	vpush	{d8-d9}
   20a74:	e24ddf4f 	sub	sp, sp, #316	@ 0x13c
   20a78:	e1a08002 	mov	r8, r2
   20a7c:	e58d1014 	str	r1, [sp, #20]
   20a80:	e58d3028 	str	r3, [sp, #40]	@ 0x28
   20a84:	e58d0010 	str	r0, [sp, #16]
	char *decimal_point = _localeconv_r (data)->decimal_point;
   20a88:	ebffe9b0 	bl	1b150 <_localeconv_r>
   20a8c:	e5903000 	ldr	r3, [r0]
	size_t decp_len = strlen (decimal_point);
   20a90:	e1a00003 	mov	r0, r3
	char *decimal_point = _localeconv_r (data)->decimal_point;
   20a94:	e58d3044 	str	r3, [sp, #68]	@ 0x44
	size_t decp_len = strlen (decimal_point);
   20a98:	fafffe78 	blx	20480 <strlen>
        if (fp->_flags & __SMBF && !fp->_bf._base)
   20a9c:	e1d430bc 	ldrh	r3, [r4, #12]
	size_t decp_len = strlen (decimal_point);
   20aa0:	e58d0040 	str	r0, [sp, #64]	@ 0x40
        if (fp->_flags & __SMBF && !fp->_bf._base)
   20aa4:	e3130080 	tst	r3, #128	@ 0x80
   20aa8:	0a000002 	beq	20ab8 <_svfprintf_r+0x50>
   20aac:	e5943010 	ldr	r3, [r4, #16]
   20ab0:	e3530000 	cmp	r3, #0
   20ab4:	0a000520 	beq	21f3c <_svfprintf_r+0x14d4>
	uio.uio_resid = 0;
   20ab8:	e3a03000 	mov	r3, #0
	union { int i; _PRINTF_FLOAT_TYPE fp; } _double_ = {0};
   20abc:	ed9f8bcb 	vldr	d8, [pc, #812]	@ 20df0 <_svfprintf_r+0x388>
	int ndig = 0;		/* actual number of digits returned by cvt */
   20ac0:	e1a0e003 	mov	lr, r3
	uio.uio_resid = 0;
   20ac4:	e58d3090 	str	r3, [sp, #144]	@ 0x90
	uio.uio_iovcnt = 0;
   20ac8:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
	uio.uio_iov = iovp = iov;
   20acc:	e28d3094 	add	r3, sp, #148	@ 0x94
   20ad0:	e1a0a003 	mov	sl, r3
   20ad4:	e1a0b008 	mov	fp, r8
   20ad8:	e58d3088 	str	r3, [sp, #136]	@ 0x88
	char *xdigs = NULL;	/* digits for [xX] conversion */
   20adc:	e58de04c 	str	lr, [sp, #76]	@ 0x4c
	int expsize = 0;	/* character count for expstr */
   20ae0:	e58de048 	str	lr, [sp, #72]	@ 0x48
	const char *grouping = NULL;
   20ae4:	e58de054 	str	lr, [sp, #84]	@ 0x54
	size_t thsnd_len = 0;
   20ae8:	e58de058 	str	lr, [sp, #88]	@ 0x58
	char *thousands_sep = NULL;
   20aec:	e58de050 	str	lr, [sp, #80]	@ 0x50
	ret = 0;
   20af0:	e58de01c 	str	lr, [sp, #28]
   20af4:	e58de034 	str	lr, [sp, #52]	@ 0x34
                while (*fmt != '\0' && *fmt != '%')
   20af8:	e5db3000 	ldrb	r3, [fp]
   20afc:	e1a0500b 	mov	r5, fp
   20b00:	e3530000 	cmp	r3, #0
   20b04:	13530025 	cmpne	r3, #37	@ 0x25
   20b08:	0a000015 	beq	20b64 <_svfprintf_r+0xfc>
                    fmt += 1;
   20b0c:	e1a04005 	mov	r4, r5
                while (*fmt != '\0' && *fmt != '%')
   20b10:	e5f53001 	ldrb	r3, [r5, #1]!
   20b14:	e3530000 	cmp	r3, #0
   20b18:	13530025 	cmpne	r3, #37	@ 0x25
   20b1c:	1afffffa 	bne	20b0c <_svfprintf_r+0xa4>
		if ((m = fmt - cp) != 0) {
   20b20:	e055600b 	subs	r6, r5, fp
   20b24:	0a00000e 	beq	20b64 <_svfprintf_r+0xfc>
			PRINT (cp, m);
   20b28:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   20b2c:	e58ab000 	str	fp, [sl]
   20b30:	e58a6004 	str	r6, [sl, #4]
   20b34:	e2833001 	add	r3, r3, #1
   20b38:	e3530007 	cmp	r3, #7
   20b3c:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   20b40:	e59d3090 	ldr	r3, [sp, #144]	@ 0x90
   20b44:	d28aa008 	addle	sl, sl, #8
   20b48:	e0833006 	add	r3, r3, r6
   20b4c:	e58d3090 	str	r3, [sp, #144]	@ 0x90
   20b50:	ca00008b 	bgt	20d84 <_svfprintf_r+0x31c>
			ret += m;
   20b54:	e59d301c 	ldr	r3, [sp, #28]
   20b58:	e0833006 	add	r3, r3, r6
   20b5c:	e58d301c 	str	r3, [sp, #28]
                if (*fmt == '\0')
   20b60:	e5d43001 	ldrb	r3, [r4, #1]
   20b64:	e3530000 	cmp	r3, #0
   20b68:	0a000646 	beq	22488 <_svfprintf_r+0x1a20>
rflag:		ch = *fmt++;
   20b6c:	e5d54001 	ldrb	r4, [r5, #1]
		sign = '\0';
   20b70:	e3a03000 	mov	r3, #0
		fmt++;		/* skip over '%' */
   20b74:	e285b001 	add	fp, r5, #1
		prec = -1;
   20b78:	e3e09000 	mvn	r9, #0
		flags = 0;
   20b7c:	e1a07003 	mov	r7, r3
		sign = '\0';
   20b80:	e5cd306b 	strb	r3, [sp, #107]	@ 0x6b
		width = 0;
   20b84:	e58d3018 	str	r3, [sp, #24]
rflag:		ch = *fmt++;
   20b88:	e28bb001 	add	fp, fp, #1
reswitch:	switch (ch) {
   20b8c:	e2443020 	sub	r3, r4, #32
   20b90:	e353005a 	cmp	r3, #90	@ 0x5a
   20b94:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   20b98:	ea000099 	b	20e04 <_svfprintf_r+0x39c>
   20b9c:	00021214 	.word	0x00021214
   20ba0:	00020e04 	.word	0x00020e04
   20ba4:	00020e04 	.word	0x00020e04
   20ba8:	00021208 	.word	0x00021208
   20bac:	00020e04 	.word	0x00020e04
   20bb0:	00020e04 	.word	0x00020e04
   20bb4:	00020e04 	.word	0x00020e04
   20bb8:	00020d30 	.word	0x00020d30
   20bbc:	00020e04 	.word	0x00020e04
   20bc0:	00020e04 	.word	0x00020e04
   20bc4:	000210d4 	.word	0x000210d4
   20bc8:	000211a0 	.word	0x000211a0
   20bcc:	00020e04 	.word	0x00020e04
   20bd0:	000210f8 	.word	0x000210f8
   20bd4:	000211bc 	.word	0x000211bc
   20bd8:	00020e04 	.word	0x00020e04
   20bdc:	000211b0 	.word	0x000211b0
   20be0:	00020d08 	.word	0x00020d08
   20be4:	00020d08 	.word	0x00020d08
   20be8:	00020d08 	.word	0x00020d08
   20bec:	00020d08 	.word	0x00020d08
   20bf0:	00020d08 	.word	0x00020d08
   20bf4:	00020d08 	.word	0x00020d08
   20bf8:	00020d08 	.word	0x00020d08
   20bfc:	00020d08 	.word	0x00020d08
   20c00:	00020d08 	.word	0x00020d08
   20c04:	00020e04 	.word	0x00020e04
   20c08:	00020e04 	.word	0x00020e04
   20c0c:	00020e04 	.word	0x00020e04
   20c10:	00020e04 	.word	0x00020e04
   20c14:	00020e04 	.word	0x00020e04
   20c18:	00020e04 	.word	0x00020e04
   20c1c:	00020e04 	.word	0x00020e04
   20c20:	00020f98 	.word	0x00020f98
   20c24:	00020e04 	.word	0x00020e04
   20c28:	00021048 	.word	0x00021048
   20c2c:	00021250 	.word	0x00021250
   20c30:	00020f98 	.word	0x00020f98
   20c34:	00020f98 	.word	0x00020f98
   20c38:	00020f98 	.word	0x00020f98
   20c3c:	00020e04 	.word	0x00020e04
   20c40:	00020e04 	.word	0x00020e04
   20c44:	00020e04 	.word	0x00020e04
   20c48:	00020e04 	.word	0x00020e04
   20c4c:	00021244 	.word	0x00021244
   20c50:	00020e04 	.word	0x00020e04
   20c54:	00020e04 	.word	0x00020e04
   20c58:	00021104 	.word	0x00021104
   20c5c:	00020e04 	.word	0x00020e04
   20c60:	00020e04 	.word	0x00020e04
   20c64:	00020e04 	.word	0x00020e04
   20c68:	00021064 	.word	0x00021064
   20c6c:	00020e04 	.word	0x00020e04
   20c70:	0002122c 	.word	0x0002122c
   20c74:	00020e04 	.word	0x00020e04
   20c78:	00020e04 	.word	0x00020e04
   20c7c:	00021eac 	.word	0x00021eac
   20c80:	00020e04 	.word	0x00020e04
   20c84:	00020e04 	.word	0x00020e04
   20c88:	00020e04 	.word	0x00020e04
   20c8c:	00020e04 	.word	0x00020e04
   20c90:	00020e04 	.word	0x00020e04
   20c94:	00020e04 	.word	0x00020e04
   20c98:	00020e04 	.word	0x00020e04
   20c9c:	00020e04 	.word	0x00020e04
   20ca0:	00020f98 	.word	0x00020f98
   20ca4:	00020e04 	.word	0x00020e04
   20ca8:	00021048 	.word	0x00021048
   20cac:	00021018 	.word	0x00021018
   20cb0:	00020f98 	.word	0x00020f98
   20cb4:	00020f98 	.word	0x00020f98
   20cb8:	00020f98 	.word	0x00020f98
   20cbc:	00021290 	.word	0x00021290
   20cc0:	00021018 	.word	0x00021018
   20cc4:	00020d78 	.word	0x00020d78
   20cc8:	00020e04 	.word	0x00020e04
   20ccc:	00021364 	.word	0x00021364
   20cd0:	00020e04 	.word	0x00020e04
   20cd4:	0002133c 	.word	0x0002133c
   20cd8:	00021310 	.word	0x00021310
   20cdc:	000212e0 	.word	0x000212e0
   20ce0:	00020d78 	.word	0x00020d78
   20ce4:	00020e04 	.word	0x00020e04
   20ce8:	00021064 	.word	0x00021064
   20cec:	00020d70 	.word	0x00020d70
   20cf0:	000212ac 	.word	0x000212ac
   20cf4:	00020e04 	.word	0x00020e04
   20cf8:	00020e04 	.word	0x00020e04
   20cfc:	00021f0c 	.word	0x00021f0c
   20d00:	00020e04 	.word	0x00020e04
   20d04:	00020d70 	.word	0x00020d70
   20d08:	e2443030 	sub	r3, r4, #48	@ 0x30
   20d0c:	e3a02000 	mov	r2, #0
				ch = *fmt++;
   20d10:	e4db4001 	ldrb	r4, [fp], #1
				n = 10 * n + to_digit (ch);
   20d14:	e0822102 	add	r2, r2, r2, lsl #2
   20d18:	e0832082 	add	r2, r3, r2, lsl #1
			} while (is_digit (ch));
   20d1c:	e2443030 	sub	r3, r4, #48	@ 0x30
   20d20:	e3530009 	cmp	r3, #9
   20d24:	9afffff9 	bls	20d10 <_svfprintf_r+0x2a8>
   20d28:	e58d2018 	str	r2, [sp, #24]
   20d2c:	eaffff96 	b	20b8c <_svfprintf_r+0x124>
			thousands_sep = _localeconv_r (data)->thousands_sep;
   20d30:	e59d5010 	ldr	r5, [sp, #16]
   20d34:	e1a00005 	mov	r0, r5
   20d38:	ebffe904 	bl	1b150 <_localeconv_r>
   20d3c:	e5903004 	ldr	r3, [r0, #4]
			thsnd_len = strlen (thousands_sep);
   20d40:	e1a00003 	mov	r0, r3
			thousands_sep = _localeconv_r (data)->thousands_sep;
   20d44:	e58d3050 	str	r3, [sp, #80]	@ 0x50
			thsnd_len = strlen (thousands_sep);
   20d48:	fafffdcc 	blx	20480 <strlen>
   20d4c:	e1a04000 	mov	r4, r0
   20d50:	e58d0058 	str	r0, [sp, #88]	@ 0x58
			grouping = _localeconv_r (data)->grouping;
   20d54:	e1a00005 	mov	r0, r5
   20d58:	ebffe8fc 	bl	1b150 <_localeconv_r>
   20d5c:	e5903008 	ldr	r3, [r0, #8]
			if (thsnd_len > 0 && grouping && *grouping)
   20d60:	e3540000 	cmp	r4, #0
   20d64:	13530000 	cmpne	r3, #0
			grouping = _localeconv_r (data)->grouping;
   20d68:	e58d3054 	str	r3, [sp, #84]	@ 0x54
			if (thsnd_len > 0 && grouping && *grouping)
   20d6c:	1a0003df 	bne	21cf0 <_svfprintf_r+0x1288>
			if ((ch = *fmt++) == '*') {
   20d70:	e5db4000 	ldrb	r4, [fp]
   20d74:	eaffff83 	b	20b88 <_svfprintf_r+0x120>
   20d78:	e5db4000 	ldrb	r4, [fp]
		    flags |= QUADINT;
   20d7c:	e3877010 	orr	r7, r7, #16
		  goto rflag;
   20d80:	eaffff80 	b	20b88 <_svfprintf_r+0x120>
			PRINT (cp, m);
   20d84:	e1cd01d0 	ldrd	r0, [sp, #16]
   20d88:	e28d2088 	add	r2, sp, #136	@ 0x88
   20d8c:	eb001103 	bl	251a0 <__ssprint_r>
   20d90:	e3500000 	cmp	r0, #0
   20d94:	1a00000c 	bne	20dcc <_svfprintf_r+0x364>
   20d98:	e28da094 	add	sl, sp, #148	@ 0x94
   20d9c:	eaffff6c 	b	20b54 <_svfprintf_r+0xec>
		FLUSH ();	/* copy out the I/O vectors */
   20da0:	e1cd01d0 	ldrd	r0, [sp, #16]
   20da4:	e28d2088 	add	r2, sp, #136	@ 0x88
   20da8:	eb0010fc 	bl	251a0 <__ssprint_r>
   20dac:	e3500000 	cmp	r0, #0
   20db0:	0a00006e 	beq	20f70 <_svfprintf_r+0x508>
	if (malloc_buf != NULL)
   20db4:	e59d3024 	ldr	r3, [sp, #36]	@ 0x24
   20db8:	e3530000 	cmp	r3, #0
   20dbc:	0a000002 	beq	20dcc <_svfprintf_r+0x364>
		_free_r (data, malloc_buf);
   20dc0:	e59d0010 	ldr	r0, [sp, #16]
   20dc4:	e1a01003 	mov	r1, r3
   20dc8:	ebfff9df 	bl	1f54c <_free_r>
	return (__sferror (fp) ? EOF : ret);
   20dcc:	e59d3014 	ldr	r3, [sp, #20]
   20dd0:	e1d330bc 	ldrh	r3, [r3, #12]
   20dd4:	e3130040 	tst	r3, #64	@ 0x40
   20dd8:	1a00075d 	bne	22b54 <_svfprintf_r+0x20ec>
}
   20ddc:	e59d001c 	ldr	r0, [sp, #28]
   20de0:	e28ddf4f 	add	sp, sp, #316	@ 0x13c
   20de4:	ecbd8b04 	vpop	{d8-d9}
   20de8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
   20dec:	e320f000 	nop	{0}
	...
   20df8:	ffffffff 	.word	0xffffffff
   20dfc:	7fefffff 	.word	0x7fefffff
   20e00:	0002a080 	.word	0x0002a080
			if (ch == '\0')
   20e04:	e3540000 	cmp	r4, #0
   20e08:	0a00059e 	beq	22488 <_svfprintf_r+0x1a20>
			sign = '\0';
   20e0c:	e3a01000 	mov	r1, #0
			*cp = ch;
   20e10:	e5cd40d4 	strb	r4, [sp, #212]	@ 0xd4
			sign = '\0';
   20e14:	e5cd106b 	strb	r1, [sp, #107]	@ 0x6b
		dprec = 0;
   20e18:	e1a09001 	mov	r9, r1
			cp = buf;
   20e1c:	e28d50d4 	add	r5, sp, #212	@ 0xd4
			break;
   20e20:	e3a03001 	mov	r3, #1
   20e24:	e58d1024 	str	r1, [sp, #36]	@ 0x24
   20e28:	e58d300c 	str	r3, [sp, #12]
			size = 1;
   20e2c:	e58d3020 	str	r3, [sp, #32]
		nseps = nrepeats = 0;
   20e30:	e58d103c 	str	r1, [sp, #60]	@ 0x3c
   20e34:	e58d1038 	str	r1, [sp, #56]	@ 0x38
		lead = 0;
   20e38:	e58d1030 	str	r1, [sp, #48]	@ 0x30
		if (flags & HEXPREFIX)
   20e3c:	e2173002 	ands	r3, r7, #2
			realsz+= 2;
   20e40:	159d200c 	ldrne	r2, [sp, #12]
   20e44:	12822002 	addne	r2, r2, #2
   20e48:	158d200c 	strne	r2, [sp, #12]
		if ((flags & (LADJUST|ZEROPAD)) == 0)
   20e4c:	e2172084 	ands	r2, r7, #132	@ 0x84
   20e50:	e58d202c 	str	r2, [sp, #44]	@ 0x2c
			PRINT (&sign, 1);
   20e54:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
		if ((flags & (LADJUST|ZEROPAD)) == 0)
   20e58:	1a000004 	bne	20e70 <_svfprintf_r+0x408>
			PAD (width - realsz, blanks);
   20e5c:	e59d0018 	ldr	r0, [sp, #24]
   20e60:	e59dc00c 	ldr	ip, [sp, #12]
   20e64:	e040600c 	sub	r6, r0, ip
   20e68:	e3560000 	cmp	r6, #0
   20e6c:	ca00026c 	bgt	21824 <_svfprintf_r+0xdbc>
		if (sign)
   20e70:	e3510000 	cmp	r1, #0
   20e74:	0a00000b 	beq	20ea8 <_svfprintf_r+0x440>
			PRINT (&sign, 1);
   20e78:	e59d108c 	ldr	r1, [sp, #140]	@ 0x8c
   20e7c:	e2822001 	add	r2, r2, #1
   20e80:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   20e84:	e2811001 	add	r1, r1, #1
   20e88:	e3510007 	cmp	r1, #7
   20e8c:	e58d108c 	str	r1, [sp, #140]	@ 0x8c
   20e90:	e28d106b 	add	r1, sp, #107	@ 0x6b
   20e94:	e58a1000 	str	r1, [sl]
   20e98:	e3a01001 	mov	r1, #1
   20e9c:	e58a1004 	str	r1, [sl, #4]
   20ea0:	d28aa008 	addle	sl, sl, #8
   20ea4:	ca000295 	bgt	21900 <_svfprintf_r+0xe98>
		if (flags & HEXPREFIX)
   20ea8:	e3530000 	cmp	r3, #0
   20eac:	0a00000b 	beq	20ee0 <_svfprintf_r+0x478>
			PRINT (ox, 2);
   20eb0:	e59d108c 	ldr	r1, [sp, #140]	@ 0x8c
   20eb4:	e2822002 	add	r2, r2, #2
   20eb8:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   20ebc:	e2811001 	add	r1, r1, #1
   20ec0:	e3510007 	cmp	r1, #7
   20ec4:	e58d108c 	str	r1, [sp, #140]	@ 0x8c
   20ec8:	e28d106c 	add	r1, sp, #108	@ 0x6c
   20ecc:	e58a1000 	str	r1, [sl]
   20ed0:	e3a01002 	mov	r1, #2
   20ed4:	e58a1004 	str	r1, [sl, #4]
   20ed8:	d28aa008 	addle	sl, sl, #8
   20edc:	ca000291 	bgt	21928 <_svfprintf_r+0xec0>
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   20ee0:	e59d302c 	ldr	r3, [sp, #44]	@ 0x2c
   20ee4:	e3530080 	cmp	r3, #128	@ 0x80
   20ee8:	0a000166 	beq	21488 <_svfprintf_r+0xa20>
		PAD (dprec - size, zeroes);
   20eec:	e59d3020 	ldr	r3, [sp, #32]
   20ef0:	e0496003 	sub	r6, r9, r3
   20ef4:	e3560000 	cmp	r6, #0
   20ef8:	ca0001a9 	bgt	215a4 <_svfprintf_r+0xb3c>
		if ((flags & FPT) == 0) {
   20efc:	e3170c01 	tst	r7, #256	@ 0x100
   20f00:	1a00011d 	bne	2137c <_svfprintf_r+0x914>
			PRINT (cp, size);
   20f04:	e59d3020 	ldr	r3, [sp, #32]
   20f08:	e58a5000 	str	r5, [sl]
   20f0c:	e0822003 	add	r2, r2, r3
   20f10:	e58a3004 	str	r3, [sl, #4]
   20f14:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   20f18:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   20f1c:	e2833001 	add	r3, r3, #1
   20f20:	e3530007 	cmp	r3, #7
   20f24:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   20f28:	ca000235 	bgt	21804 <_svfprintf_r+0xd9c>
					PRINTANDPAD (cp, convbuf + ndig,
   20f2c:	e28aa008 	add	sl, sl, #8
		if (flags & LADJUST)
   20f30:	e3170004 	tst	r7, #4
   20f34:	0a000004 	beq	20f4c <_svfprintf_r+0x4e4>
			PAD (width - realsz, blanks);
   20f38:	e59d3018 	ldr	r3, [sp, #24]
   20f3c:	e59d100c 	ldr	r1, [sp, #12]
   20f40:	e0434001 	sub	r4, r3, r1
   20f44:	e3540000 	cmp	r4, #0
   20f48:	ca00027e 	bgt	21948 <_svfprintf_r+0xee0>
		ret += width > realsz ? width : realsz;
   20f4c:	e59d301c 	ldr	r3, [sp, #28]
   20f50:	e59d1018 	ldr	r1, [sp, #24]
   20f54:	e59d000c 	ldr	r0, [sp, #12]
   20f58:	e1510000 	cmp	r1, r0
   20f5c:	a0833001 	addge	r3, r3, r1
   20f60:	b0833000 	addlt	r3, r3, r0
		FLUSH ();	/* copy out the I/O vectors */
   20f64:	e3520000 	cmp	r2, #0
		ret += width > realsz ? width : realsz;
   20f68:	e58d301c 	str	r3, [sp, #28]
		FLUSH ();	/* copy out the I/O vectors */
   20f6c:	1affff8b 	bne	20da0 <_svfprintf_r+0x338>
                if (malloc_buf != NULL) {
   20f70:	e59d3024 	ldr	r3, [sp, #36]	@ 0x24
   20f74:	e3530000 	cmp	r3, #0
		FLUSH ();	/* copy out the I/O vectors */
   20f78:	e3a03000 	mov	r3, #0
   20f7c:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
                if (malloc_buf != NULL) {
   20f80:	0a000002 	beq	20f90 <_svfprintf_r+0x528>
			_free_r (data, malloc_buf);
   20f84:	e59d1024 	ldr	r1, [sp, #36]	@ 0x24
   20f88:	e59d0010 	ldr	r0, [sp, #16]
   20f8c:	ebfff96e 	bl	1f54c <_free_r>
		FLUSH ();	/* copy out the I/O vectors */
   20f90:	e28da094 	add	sl, sp, #148	@ 0x94
   20f94:	eafffed7 	b	20af8 <_svfprintf_r+0x90>
				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
   20f98:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
			if (isinf (_fpvalue)) {
   20f9c:	ed1f7b6b 	vldr	d7, [pc, #-428]	@ 20df8 <_svfprintf_r+0x390>
				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
   20fa0:	e2833007 	add	r3, r3, #7
   20fa4:	e3c33007 	bic	r3, r3, #7
   20fa8:	ecb38b02 	vldmia	r3!, {d8}
   20fac:	e58d3028 	str	r3, [sp, #40]	@ 0x28
			if (isinf (_fpvalue)) {
   20fb0:	eeb06bc8 	vabs.f64	d6, d8
   20fb4:	eeb46b47 	vcmp.f64	d6, d7
   20fb8:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   20fbc:	da000354 	ble	21d14 <_svfprintf_r+0x12ac>
				if (_fpvalue < 0)
   20fc0:	eeb58bc0 	vcmpe.f64	d8, #0.0
   20fc4:	eef1fa10 	vmrs	APSR_nzcv, fpscr
					sign = '-';
   20fc8:	43a0102d 	movmi	r1, #45	@ 0x2d
   20fcc:	45cd106b 	strbmi	r1, [sp, #107]	@ 0x6b
			if (!sign)
   20fd0:	55dd106b 	ldrbpl	r1, [sp, #107]	@ 0x6b
					cp = "INF";
   20fd4:	e30953a8 	movw	r5, #37800	@ 0x93a8
   20fd8:	e30933a4 	movw	r3, #37796	@ 0x93a4
				flags &= ~ZEROPAD;
   20fdc:	e3c77080 	bic	r7, r7, #128	@ 0x80
					cp = "INF";
   20fe0:	e3405002 	movt	r5, #2
   20fe4:	e3403002 	movt	r3, #2
					cp = "NAN";
   20fe8:	e3540047 	cmp	r4, #71	@ 0x47
				break;
   20fec:	e3a02003 	mov	r2, #3
					cp = "NAN";
   20ff0:	d1a05003 	movle	r5, r3
				break;
   20ff4:	e3a03000 	mov	r3, #0
		dprec = 0;
   20ff8:	e1a09003 	mov	r9, r3
				break;
   20ffc:	e58d3024 	str	r3, [sp, #36]	@ 0x24
   21000:	e58d200c 	str	r2, [sp, #12]
				size = 3;
   21004:	e58d2020 	str	r2, [sp, #32]
		nseps = nrepeats = 0;
   21008:	e58d303c 	str	r3, [sp, #60]	@ 0x3c
   2100c:	e58d3038 	str	r3, [sp, #56]	@ 0x38
		lead = 0;
   21010:	e58d3030 	str	r3, [sp, #48]	@ 0x30
				break;
   21014:	ea00005b 	b	21188 <_svfprintf_r+0x720>
			width = GET_ARG (n, ap, int);
   21018:	e59d2028 	ldr	r2, [sp, #40]	@ 0x28
			_uquad = SARG ();
   2101c:	e3170010 	tst	r7, #16
			width = GET_ARG (n, ap, int);
   21020:	e4923004 	ldr	r3, [r2], #4
   21024:	e58d2028 	str	r2, [sp, #40]	@ 0x28
			_uquad = SARG ();
   21028:	1a00008c 	bne	21260 <_svfprintf_r+0x7f8>
   2102c:	e3170040 	tst	r7, #64	@ 0x40
   21030:	1a000334 	bne	21d08 <_svfprintf_r+0x12a0>
   21034:	e3170c02 	tst	r7, #512	@ 0x200
   21038:	0a000088 	beq	21260 <_svfprintf_r+0x7f8>
   2103c:	e6af3073 	sxtb	r3, r3
			if ((long) _uquad < 0)
   21040:	e1a06003 	mov	r6, r3
   21044:	ea000086 	b	21264 <_svfprintf_r+0x7fc>
				*cp = GET_ARG (N, ap, int);
   21048:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
			sign = '\0';
   2104c:	e3a01000 	mov	r1, #0
   21050:	e5cd106b 	strb	r1, [sp, #107]	@ 0x6b
				*cp = GET_ARG (N, ap, int);
   21054:	e4932004 	ldr	r2, [r3], #4
   21058:	e5cd20d4 	strb	r2, [sp, #212]	@ 0xd4
   2105c:	e58d3028 	str	r3, [sp, #40]	@ 0x28
   21060:	eaffff6c 	b	20e18 <_svfprintf_r+0x3b0>
			cp = GET_ARG (N, ap, char_ptr_t);
   21064:	e59d6028 	ldr	r6, [sp, #40]	@ 0x28
			sign = '\0';
   21068:	e3a08000 	mov	r8, #0
   2106c:	e5cd806b 	strb	r8, [sp, #107]	@ 0x6b
			cp = GET_ARG (N, ap, char_ptr_t);
   21070:	e4965004 	ldr	r5, [r6], #4
			if (cp == NULL) {
   21074:	e1550008 	cmp	r5, r8
   21078:	0a0004f3 	beq	2244c <_svfprintf_r+0x19e4>
			if (prec >= 0) {
   2107c:	e3590000 	cmp	r9, #0
   21080:	ba0003de 	blt	22000 <_svfprintf_r+0x1598>
				char *p = memchr (cp, 0, prec);
   21084:	e1a02009 	mov	r2, r9
   21088:	e1a01008 	mov	r1, r8
   2108c:	e1a00005 	mov	r0, r5
   21090:	fafffb4a 	blx	1fdc0 <memchr>
				if (p != NULL)
   21094:	e2503000 	subs	r3, r0, #0
   21098:	e58d3024 	str	r3, [sp, #36]	@ 0x24
   2109c:	0a000628 	beq	22944 <_svfprintf_r+0x1edc>
					size = p - cp;
   210a0:	e59d3024 	ldr	r3, [sp, #36]	@ 0x24
   210a4:	e1a09008 	mov	r9, r8
		if (sign)
   210a8:	e5dd106b 	ldrb	r1, [sp, #107]	@ 0x6b
			cp = GET_ARG (N, ap, char_ptr_t);
   210ac:	e58d6028 	str	r6, [sp, #40]	@ 0x28
					size = p - cp;
   210b0:	e0433005 	sub	r3, r3, r5
   210b4:	e58d3020 	str	r3, [sp, #32]
		realsz = dprec > size ? dprec : size;
   210b8:	e1c33fc3 	bic	r3, r3, r3, asr #31
   210bc:	e58d300c 	str	r3, [sp, #12]
		dprec = 0;
   210c0:	e58d9024 	str	r9, [sp, #36]	@ 0x24
		nseps = nrepeats = 0;
   210c4:	e58d903c 	str	r9, [sp, #60]	@ 0x3c
   210c8:	e58d9038 	str	r9, [sp, #56]	@ 0x38
		lead = 0;
   210cc:	e58d9030 	str	r9, [sp, #48]	@ 0x30
   210d0:	ea00002c 	b	21188 <_svfprintf_r+0x720>
			width = GET_ARG (n, ap, int);
   210d4:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
   210d8:	e4932004 	ldr	r2, [r3], #4
			if (width >= 0)
   210dc:	e3520000 	cmp	r2, #0
			width = GET_ARG (n, ap, int);
   210e0:	e58d2018 	str	r2, [sp, #24]
			if (width >= 0)
   210e4:	aa0002f7 	bge	21cc8 <_svfprintf_r+0x1260>
			width = -width;
   210e8:	e59d2018 	ldr	r2, [sp, #24]
			width = GET_ARG (n, ap, int);
   210ec:	e58d3028 	str	r3, [sp, #40]	@ 0x28
			width = -width;
   210f0:	e2622000 	rsb	r2, r2, #0
   210f4:	e58d2018 	str	r2, [sp, #24]
			if ((ch = *fmt++) == '*') {
   210f8:	e5db4000 	ldrb	r4, [fp]
			flags |= LADJUST;
   210fc:	e3877004 	orr	r7, r7, #4
			goto rflag;
   21100:	eafffea0 	b	20b88 <_svfprintf_r+0x120>
			width = GET_ARG (n, ap, int);
   21104:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
			flags |= LONGINT;
   21108:	e3877010 	orr	r7, r7, #16
			width = GET_ARG (n, ap, int);
   2110c:	e4936004 	ldr	r6, [r3], #4
   21110:	e58d3028 	str	r3, [sp, #40]	@ 0x28
			flags &= ~GROUPING;
   21114:	e3c70b01 	bic	r0, r7, #1024	@ 0x400
			base = OCT;
   21118:	e3a03000 	mov	r3, #0
nosign:			sign = '\0';
   2111c:	e3a02000 	mov	r2, #0
number:			if ((dprec = prec) >= 0)
   21120:	e3590000 	cmp	r9, #0
				sign = '-';
   21124:	e5cd206b 	strb	r2, [sp, #107]	@ 0x6b
number:			if ((dprec = prec) >= 0)
   21128:	ba00015e 	blt	216a8 <_svfprintf_r+0xc40>
			if (_uquad != 0 || prec != 0) {
   2112c:	e1992006 	orrs	r2, r9, r6
				flags &= ~ZEROPAD;
   21130:	e3c07080 	bic	r7, r0, #128	@ 0x80
			if (_uquad != 0 || prec != 0) {
   21134:	1a00015a 	bne	216a4 <_svfprintf_r+0xc3c>
                       else if (base == OCT && (flags & ALT))
   21138:	e3530000 	cmp	r3, #0
   2113c:	1a000230 	bne	21a04 <_svfprintf_r+0xf9c>
   21140:	e2102001 	ands	r2, r0, #1
                         *--cp = '0';
   21144:	e1a09003 	mov	r9, r3
			cp = buf + BUF;
   21148:	028d5f4e 	addeq	r5, sp, #312	@ 0x138
                       else if (base == OCT && (flags & ALT))
   2114c:	e58d2020 	str	r2, [sp, #32]
						*--cp = to_char(_uquad);
   21150:	128d5f4d 	addne	r5, sp, #308	@ 0x134
                         *--cp = '0';
   21154:	13a03030 	movne	r3, #48	@ 0x30
						*--cp = to_char(_uquad);
   21158:	12855003 	addne	r5, r5, #3
                         *--cp = '0';
   2115c:	15cd3137 	strbne	r3, [sp, #311]	@ 0x137
		realsz = dprec > size ? dprec : size;
   21160:	e59d2020 	ldr	r2, [sp, #32]
   21164:	e3a03000 	mov	r3, #0
		if (sign)
   21168:	e5dd106b 	ldrb	r1, [sp, #107]	@ 0x6b
		realsz = dprec > size ? dprec : size;
   2116c:	e58d3024 	str	r3, [sp, #36]	@ 0x24
   21170:	e1590002 	cmp	r9, r2
		nseps = nrepeats = 0;
   21174:	e58d303c 	str	r3, [sp, #60]	@ 0x3c
		realsz = dprec > size ? dprec : size;
   21178:	a1a02009 	movge	r2, r9
		nseps = nrepeats = 0;
   2117c:	e58d3038 	str	r3, [sp, #56]	@ 0x38
		realsz = dprec > size ? dprec : size;
   21180:	e58d200c 	str	r2, [sp, #12]
		lead = 0;
   21184:	e58d3030 	str	r3, [sp, #48]	@ 0x30
		if (sign)
   21188:	e3510000 	cmp	r1, #0
   2118c:	0affff2a 	beq	20e3c <_svfprintf_r+0x3d4>
			realsz++;
   21190:	e59d300c 	ldr	r3, [sp, #12]
   21194:	e2833001 	add	r3, r3, #1
   21198:	e58d300c 	str	r3, [sp, #12]
   2119c:	eaffff26 	b	20e3c <_svfprintf_r+0x3d4>
			sign = '+';
   211a0:	e3a0302b 	mov	r3, #43	@ 0x2b
			if ((ch = *fmt++) == '*') {
   211a4:	e5db4000 	ldrb	r4, [fp]
			sign = '+';
   211a8:	e5cd306b 	strb	r3, [sp, #107]	@ 0x6b
			goto rflag;
   211ac:	eafffe75 	b	20b88 <_svfprintf_r+0x120>
			if ((ch = *fmt++) == '*') {
   211b0:	e5db4000 	ldrb	r4, [fp]
			flags |= ZEROPAD;
   211b4:	e3877080 	orr	r7, r7, #128	@ 0x80
			goto rflag;
   211b8:	eafffe72 	b	20b88 <_svfprintf_r+0x120>
			if ((ch = *fmt++) == '*') {
   211bc:	e1a0200b 	mov	r2, fp
   211c0:	e4d24001 	ldrb	r4, [r2], #1
   211c4:	e354002a 	cmp	r4, #42	@ 0x2a
   211c8:	0a0006c0 	beq	22cd0 <_svfprintf_r+0x2268>
			while (is_digit (ch)) {
   211cc:	e2443030 	sub	r3, r4, #48	@ 0x30
   211d0:	e3530009 	cmp	r3, #9
			if ((ch = *fmt++) == '*') {
   211d4:	81a0b002 	movhi	fp, r2
			while (is_digit (ch)) {
   211d8:	83a09000 	movhi	r9, #0
   211dc:	8afffe6a 	bhi	20b8c <_svfprintf_r+0x124>
			n = 0;
   211e0:	e3a09000 	mov	r9, #0
				ch = *fmt++;
   211e4:	e4d24001 	ldrb	r4, [r2], #1
				n = 10 * n + to_digit (ch);
   211e8:	e0899109 	add	r9, r9, r9, lsl #2
   211ec:	e0839089 	add	r9, r3, r9, lsl #1
			while (is_digit (ch)) {
   211f0:	e2443030 	sub	r3, r4, #48	@ 0x30
   211f4:	e3530009 	cmp	r3, #9
   211f8:	9afffff9 	bls	211e4 <_svfprintf_r+0x77c>
			prec = n < 0 ? -1 : n;
   211fc:	e1899fc9 	orr	r9, r9, r9, asr #31
   21200:	e1a0b002 	mov	fp, r2
			goto reswitch;
   21204:	eafffe60 	b	20b8c <_svfprintf_r+0x124>
			if ((ch = *fmt++) == '*') {
   21208:	e5db4000 	ldrb	r4, [fp]
			flags |= ALT;
   2120c:	e3877001 	orr	r7, r7, #1
			goto rflag;
   21210:	eafffe5c 	b	20b88 <_svfprintf_r+0x120>
			if (!sign)
   21214:	e5dd306b 	ldrb	r3, [sp, #107]	@ 0x6b
			if ((ch = *fmt++) == '*') {
   21218:	e5db4000 	ldrb	r4, [fp]
			if (!sign)
   2121c:	e3530000 	cmp	r3, #0
				sign = ' ';
   21220:	03a03020 	moveq	r3, #32
   21224:	05cd306b 	strbeq	r3, [sp, #107]	@ 0x6b
   21228:	eafffe56 	b	20b88 <_svfprintf_r+0x120>
			width = GET_ARG (n, ap, int);
   2122c:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
			flags |= LONGINT;
   21230:	e3870010 	orr	r0, r7, #16
			width = GET_ARG (n, ap, int);
   21234:	e4936004 	ldr	r6, [r3], #4
   21238:	e58d3028 	str	r3, [sp, #40]	@ 0x28
			base = DEC;
   2123c:	e3a03001 	mov	r3, #1
   21240:	eaffffb5 	b	2111c <_svfprintf_r+0x6b4>
			if ((ch = *fmt++) == '*') {
   21244:	e5db4000 	ldrb	r4, [fp]
			flags |= LONGDBL;
   21248:	e3877008 	orr	r7, r7, #8
			goto rflag;
   2124c:	eafffe4d 	b	20b88 <_svfprintf_r+0x120>
			width = GET_ARG (n, ap, int);
   21250:	e59d2028 	ldr	r2, [sp, #40]	@ 0x28
			flags |= LONGINT;
   21254:	e3877010 	orr	r7, r7, #16
			width = GET_ARG (n, ap, int);
   21258:	e4923004 	ldr	r3, [r2], #4
   2125c:	e58d2028 	str	r2, [sp, #40]	@ 0x28
   21260:	e1a06003 	mov	r6, r3
			if ((long) _uquad < 0)
   21264:	e3530000 	cmp	r3, #0
   21268:	ba00027c 	blt	21c60 <_svfprintf_r+0x11f8>
number:			if ((dprec = prec) >= 0)
   2126c:	e3590000 	cmp	r9, #0
   21270:	ba0001e7 	blt	21a14 <_svfprintf_r+0xfac>
			if (_uquad != 0 || prec != 0) {
   21274:	e1993003 	orrs	r3, r9, r3
				flags &= ~ZEROPAD;
   21278:	e3c77080 	bic	r7, r7, #128	@ 0x80
			if (_uquad != 0 || prec != 0) {
   2127c:	1a0001e4 	bne	21a14 <_svfprintf_r+0xfac>
   21280:	e1a09003 	mov	r9, r3
			cp = buf + BUF;
   21284:	e28d5f4e 	add	r5, sp, #312	@ 0x138
			if (_uquad != 0 || prec != 0) {
   21288:	e58d3020 	str	r3, [sp, #32]
   2128c:	eaffffb3 	b	21160 <_svfprintf_r+0x6f8>
			if (*fmt == 'h') {
   21290:	e5db4000 	ldrb	r4, [fp]
   21294:	e3540068 	cmp	r4, #104	@ 0x68
rflag:		ch = *fmt++;
   21298:	05db4001 	ldrbeq	r4, [fp, #1]
				flags |= CHARINT;
   2129c:	03877c02 	orreq	r7, r7, #512	@ 0x200
				fmt++;
   212a0:	028bb001 	addeq	fp, fp, #1
				flags |= SHORTINT;
   212a4:	13877040 	orrne	r7, r7, #64	@ 0x40
   212a8:	eafffe36 	b	20b88 <_svfprintf_r+0x120>
			width = GET_ARG (n, ap, int);
   212ac:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
			_uquad = UARG ();
   212b0:	e3170010 	tst	r7, #16
			width = GET_ARG (n, ap, int);
   212b4:	e4936004 	ldr	r6, [r3], #4
   212b8:	e58d3028 	str	r3, [sp, #40]	@ 0x28
			_uquad = UARG ();
   212bc:	1a00041f 	bne	22340 <_svfprintf_r+0x18d8>
   212c0:	e3170040 	tst	r7, #64	@ 0x40
   212c4:	1a0002f4 	bne	21e9c <_svfprintf_r+0x1434>
   212c8:	e3170c02 	tst	r7, #512	@ 0x200
   212cc:	0a00041b 	beq	22340 <_svfprintf_r+0x18d8>
   212d0:	e6ef6076 	uxtb	r6, r6
   212d4:	e1a00007 	mov	r0, r7
			base = DEC;
   212d8:	e3a03001 	mov	r3, #1
   212dc:	eaffff8e 	b	2111c <_svfprintf_r+0x6b4>
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   212e0:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
			flags |= HEXPREFIX;
   212e4:	e3870002 	orr	r0, r7, #2
			ox[1] = ch = 'x';
   212e8:	e3a04078 	mov	r4, #120	@ 0x78
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   212ec:	e4936004 	ldr	r6, [r3], #4
   212f0:	e58d3028 	str	r3, [sp, #40]	@ 0x28
			ox[0] = '0';
   212f4:	e3073830 	movw	r3, #30768	@ 0x7830
   212f8:	e1cd36bc 	strh	r3, [sp, #108]	@ 0x6c
			xdigs = "0123456789abcdef";
   212fc:	e30931b8 	movw	r3, #37304	@ 0x91b8
   21300:	e3403002 	movt	r3, #2
   21304:	e58d304c 	str	r3, [sp, #76]	@ 0x4c
			base = HEX;
   21308:	e3a03002 	mov	r3, #2
			goto nosign;
   2130c:	eaffff82 	b	2111c <_svfprintf_r+0x6b4>
			width = GET_ARG (n, ap, int);
   21310:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
			_uquad = UARG ();
   21314:	e3170010 	tst	r7, #16
			width = GET_ARG (n, ap, int);
   21318:	e4936004 	ldr	r6, [r3], #4
   2131c:	e58d3028 	str	r3, [sp, #40]	@ 0x28
			_uquad = UARG ();
   21320:	1affff7b 	bne	21114 <_svfprintf_r+0x6ac>
   21324:	e3170040 	tst	r7, #64	@ 0x40
   21328:	16ff6076 	uxthne	r6, r6
   2132c:	1affff78 	bne	21114 <_svfprintf_r+0x6ac>
   21330:	e3170c02 	tst	r7, #512	@ 0x200
   21334:	16ef6076 	uxtbne	r6, r6
   21338:	eaffff75 	b	21114 <_svfprintf_r+0x6ac>
			if (flags & LONGINT)
   2133c:	e3170010 	tst	r7, #16
   21340:	0a000263 	beq	21cd4 <_svfprintf_r+0x126c>
				*GET_ARG (N, ap, int_ptr_t) = ret;
   21344:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
   21348:	e59d201c 	ldr	r2, [sp, #28]
   2134c:	e5933000 	ldr	r3, [r3]
   21350:	e5832000 	str	r2, [r3]
			width = GET_ARG (n, ap, int);
   21354:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
   21358:	e2833004 	add	r3, r3, #4
   2135c:	e58d3028 	str	r3, [sp, #40]	@ 0x28
   21360:	eafffde4 	b	20af8 <_svfprintf_r+0x90>
			if (*fmt == 'l') {
   21364:	e5db4000 	ldrb	r4, [fp]
				flags |= QUADINT;
   21368:	e3877010 	orr	r7, r7, #16
			if (*fmt == 'l') {
   2136c:	e354006c 	cmp	r4, #108	@ 0x6c
rflag:		ch = *fmt++;
   21370:	05db4001 	ldrbeq	r4, [fp, #1]
				fmt++;
   21374:	028bb001 	addeq	fp, fp, #1
   21378:	eafffe02 	b	20b88 <_svfprintf_r+0x120>
			if (ch >= 'f') {	/* 'f' or 'g' */
   2137c:	e3540065 	cmp	r4, #101	@ 0x65
   21380:	da0000ec 	ble	21738 <_svfprintf_r+0xcd0>
				if (_fpvalue == 0) {
   21384:	eeb58b40 	vcmp.f64	d8, #0.0
   21388:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   2138c:	1a0001ab 	bne	21a40 <_svfprintf_r+0xfd8>
					PRINT ("0", 1);
   21390:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   21394:	e2822001 	add	r2, r2, #1
   21398:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   2139c:	e2833001 	add	r3, r3, #1
   213a0:	e3530007 	cmp	r3, #7
   213a4:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   213a8:	e30933b4 	movw	r3, #37812	@ 0x93b4
   213ac:	e3403002 	movt	r3, #2
   213b0:	e58a3000 	str	r3, [sl]
   213b4:	e3a03001 	mov	r3, #1
   213b8:	e58a3004 	str	r3, [sl, #4]
   213bc:	d28aa008 	addle	sl, sl, #8
   213c0:	ca0003d6 	bgt	22320 <_svfprintf_r+0x18b8>
					if (expt < ndig || flags & ALT) {
   213c4:	e59d3070 	ldr	r3, [sp, #112]	@ 0x70
   213c8:	e59d1034 	ldr	r1, [sp, #52]	@ 0x34
   213cc:	e1530001 	cmp	r3, r1
   213d0:	aa000239 	bge	21cbc <_svfprintf_r+0x1254>
						PRINT (decimal_point, decp_len);
   213d4:	e59d3040 	ldr	r3, [sp, #64]	@ 0x40
   213d8:	e59d1044 	ldr	r1, [sp, #68]	@ 0x44
   213dc:	e0822003 	add	r2, r2, r3
   213e0:	e88a000a 	stm	sl, {r1, r3}
   213e4:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   213e8:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   213ec:	e2833001 	add	r3, r3, #1
   213f0:	e3530007 	cmp	r3, #7
   213f4:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   213f8:	d28aa008 	addle	sl, sl, #8
   213fc:	ca0002c6 	bgt	21f1c <_svfprintf_r+0x14b4>
						PAD (ndig - 1, zeroes);
   21400:	e59d3034 	ldr	r3, [sp, #52]	@ 0x34
   21404:	e2434001 	sub	r4, r3, #1
   21408:	e3540000 	cmp	r4, #0
   2140c:	dafffec7 	ble	20f30 <_svfprintf_r+0x4c8>
   21410:	e3540010 	cmp	r4, #16
   21414:	e51f861c 	ldr	r8, [pc, #-1564]	@ 20e00 <_svfprintf_r+0x398>
   21418:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   2141c:	da0003c9 	ble	22348 <_svfprintf_r+0x18e0>
   21420:	e59d6010 	ldr	r6, [sp, #16]
   21424:	e3a05010 	mov	r5, #16
   21428:	e59d9014 	ldr	r9, [sp, #20]
   2142c:	ea000002 	b	2143c <_svfprintf_r+0x9d4>
   21430:	e2444010 	sub	r4, r4, #16
   21434:	e3540010 	cmp	r4, #16
   21438:	da0003c2 	ble	22348 <_svfprintf_r+0x18e0>
   2143c:	e2833001 	add	r3, r3, #1
   21440:	e2822010 	add	r2, r2, #16
   21444:	e3530007 	cmp	r3, #7
   21448:	e58a8000 	str	r8, [sl]
   2144c:	e58a5004 	str	r5, [sl, #4]
   21450:	d28aa008 	addle	sl, sl, #8
   21454:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   21458:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   2145c:	dafffff3 	ble	21430 <_svfprintf_r+0x9c8>
   21460:	e28d2088 	add	r2, sp, #136	@ 0x88
   21464:	e1a01009 	mov	r1, r9
   21468:	e1a00006 	mov	r0, r6
   2146c:	eb000f4b 	bl	251a0 <__ssprint_r>
   21470:	e3500000 	cmp	r0, #0
   21474:	1afffe4e 	bne	20db4 <_svfprintf_r+0x34c>
   21478:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   2147c:	e28da094 	add	sl, sp, #148	@ 0x94
   21480:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   21484:	eaffffe9 	b	21430 <_svfprintf_r+0x9c8>
			PAD (width - realsz, zeroes);
   21488:	e59d3018 	ldr	r3, [sp, #24]
   2148c:	e59d100c 	ldr	r1, [sp, #12]
   21490:	e0436001 	sub	r6, r3, r1
   21494:	e3560000 	cmp	r6, #0
   21498:	dafffe93 	ble	20eec <_svfprintf_r+0x484>
   2149c:	e3560010 	cmp	r6, #16
   214a0:	e51f86a8 	ldr	r8, [pc, #-1704]	@ 20e00 <_svfprintf_r+0x398>
   214a4:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   214a8:	da000029 	ble	21554 <_svfprintf_r+0xaec>
   214ac:	e1a0000a 	mov	r0, sl
   214b0:	e58d402c 	str	r4, [sp, #44]	@ 0x2c
   214b4:	e1a0a009 	mov	sl, r9
   214b8:	e59d4010 	ldr	r4, [sp, #16]
   214bc:	e1a09007 	mov	r9, r7
   214c0:	e1a01003 	mov	r1, r3
   214c4:	e1a07008 	mov	r7, r8
   214c8:	e1a08005 	mov	r8, r5
   214cc:	e59d5014 	ldr	r5, [sp, #20]
   214d0:	ea000002 	b	214e0 <_svfprintf_r+0xa78>
   214d4:	e2466010 	sub	r6, r6, #16
   214d8:	e3560010 	cmp	r6, #16
   214dc:	da000015 	ble	21538 <_svfprintf_r+0xad0>
   214e0:	e2811001 	add	r1, r1, #1
   214e4:	e2822010 	add	r2, r2, #16
   214e8:	e3510007 	cmp	r1, #7
   214ec:	e3a03010 	mov	r3, #16
   214f0:	e5807000 	str	r7, [r0]
   214f4:	e5803004 	str	r3, [r0, #4]
   214f8:	d2800008 	addle	r0, r0, #8
   214fc:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   21500:	e58d108c 	str	r1, [sp, #140]	@ 0x8c
   21504:	dafffff2 	ble	214d4 <_svfprintf_r+0xa6c>
   21508:	e28d2088 	add	r2, sp, #136	@ 0x88
   2150c:	e1a01005 	mov	r1, r5
   21510:	e1a00004 	mov	r0, r4
   21514:	eb000f21 	bl	251a0 <__ssprint_r>
   21518:	e3500000 	cmp	r0, #0
   2151c:	e28d0094 	add	r0, sp, #148	@ 0x94
   21520:	1afffe23 	bne	20db4 <_svfprintf_r+0x34c>
   21524:	e2466010 	sub	r6, r6, #16
   21528:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   2152c:	e3560010 	cmp	r6, #16
   21530:	e59d108c 	ldr	r1, [sp, #140]	@ 0x8c
   21534:	caffffe9 	bgt	214e0 <_svfprintf_r+0xa78>
   21538:	e59d402c 	ldr	r4, [sp, #44]	@ 0x2c
   2153c:	e1a05008 	mov	r5, r8
   21540:	e1a03001 	mov	r3, r1
   21544:	e1a08007 	mov	r8, r7
   21548:	e1a07009 	mov	r7, r9
   2154c:	e1a0900a 	mov	r9, sl
   21550:	e1a0a000 	mov	sl, r0
   21554:	e2833001 	add	r3, r3, #1
   21558:	e0822006 	add	r2, r2, r6
   2155c:	e3530007 	cmp	r3, #7
   21560:	e58a8000 	str	r8, [sl]
   21564:	e58a6004 	str	r6, [sl, #4]
   21568:	d28aa008 	addle	sl, sl, #8
   2156c:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   21570:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   21574:	dafffe5c 	ble	20eec <_svfprintf_r+0x484>
   21578:	e1cd01d0 	ldrd	r0, [sp, #16]
   2157c:	e28d2088 	add	r2, sp, #136	@ 0x88
   21580:	eb000f06 	bl	251a0 <__ssprint_r>
   21584:	e3500000 	cmp	r0, #0
   21588:	1afffe09 	bne	20db4 <_svfprintf_r+0x34c>
		PAD (dprec - size, zeroes);
   2158c:	e59d3020 	ldr	r3, [sp, #32]
			PAD (width - realsz, zeroes);
   21590:	e28da094 	add	sl, sp, #148	@ 0x94
		PAD (dprec - size, zeroes);
   21594:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   21598:	e0496003 	sub	r6, r9, r3
   2159c:	e3560000 	cmp	r6, #0
   215a0:	dafffe55 	ble	20efc <_svfprintf_r+0x494>
   215a4:	e3560010 	cmp	r6, #16
   215a8:	e51f87b0 	ldr	r8, [pc, #-1968]	@ 20e00 <_svfprintf_r+0x398>
   215ac:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   215b0:	da00002a 	ble	21660 <_svfprintf_r+0xbf8>
   215b4:	e1a0c006 	mov	ip, r6
   215b8:	e1a0000a 	mov	r0, sl
   215bc:	e1a06004 	mov	r6, r4
   215c0:	e1a0a008 	mov	sl, r8
   215c4:	e3a09010 	mov	r9, #16
   215c8:	e1a08007 	mov	r8, r7
   215cc:	e1a01003 	mov	r1, r3
   215d0:	e1a07005 	mov	r7, r5
   215d4:	e1a0400c 	mov	r4, ip
   215d8:	e59d5014 	ldr	r5, [sp, #20]
   215dc:	ea000002 	b	215ec <_svfprintf_r+0xb84>
   215e0:	e2444010 	sub	r4, r4, #16
   215e4:	e3540010 	cmp	r4, #16
   215e8:	da000014 	ble	21640 <_svfprintf_r+0xbd8>
   215ec:	e2811001 	add	r1, r1, #1
   215f0:	e51f37f8 	ldr	r3, [pc, #-2040]	@ 20e00 <_svfprintf_r+0x398>
   215f4:	e3510007 	cmp	r1, #7
   215f8:	e2822010 	add	r2, r2, #16
   215fc:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   21600:	e8800208 	stm	r0, {r3, r9}
   21604:	d2800008 	addle	r0, r0, #8
   21608:	e58d108c 	str	r1, [sp, #140]	@ 0x8c
   2160c:	dafffff3 	ble	215e0 <_svfprintf_r+0xb78>
   21610:	e59d0010 	ldr	r0, [sp, #16]
   21614:	e28d2088 	add	r2, sp, #136	@ 0x88
   21618:	e1a01005 	mov	r1, r5
   2161c:	eb000edf 	bl	251a0 <__ssprint_r>
   21620:	e3500000 	cmp	r0, #0
   21624:	e28d0094 	add	r0, sp, #148	@ 0x94
   21628:	1afffde1 	bne	20db4 <_svfprintf_r+0x34c>
   2162c:	e2444010 	sub	r4, r4, #16
   21630:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   21634:	e3540010 	cmp	r4, #16
   21638:	e59d108c 	ldr	r1, [sp, #140]	@ 0x8c
   2163c:	caffffea 	bgt	215ec <_svfprintf_r+0xb84>
   21640:	e1a0c004 	mov	ip, r4
   21644:	e1a05007 	mov	r5, r7
   21648:	e1a04006 	mov	r4, r6
   2164c:	e1a07008 	mov	r7, r8
   21650:	e1a03001 	mov	r3, r1
   21654:	e1a0800a 	mov	r8, sl
   21658:	e1a0600c 	mov	r6, ip
   2165c:	e1a0a000 	mov	sl, r0
   21660:	e2833001 	add	r3, r3, #1
   21664:	e0822006 	add	r2, r2, r6
   21668:	e3530007 	cmp	r3, #7
   2166c:	e58a8000 	str	r8, [sl]
   21670:	e58a6004 	str	r6, [sl, #4]
   21674:	d28aa008 	addle	sl, sl, #8
   21678:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   2167c:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   21680:	dafffe1d 	ble	20efc <_svfprintf_r+0x494>
   21684:	e1cd01d0 	ldrd	r0, [sp, #16]
   21688:	e28d2088 	add	r2, sp, #136	@ 0x88
   2168c:	eb000ec3 	bl	251a0 <__ssprint_r>
   21690:	e3500000 	cmp	r0, #0
   21694:	1afffdc6 	bne	20db4 <_svfprintf_r+0x34c>
			PRINT (cp, size);
   21698:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
		PAD (dprec - size, zeroes);
   2169c:	e28da094 	add	sl, sp, #148	@ 0x94
   216a0:	eafffe15 	b	20efc <_svfprintf_r+0x494>
   216a4:	e1a00007 	mov	r0, r7
				switch (base) {
   216a8:	e3530001 	cmp	r3, #1
   216ac:	0a0000d9 	beq	21a18 <_svfprintf_r+0xfb0>
   216b0:	e3530002 	cmp	r3, #2
   216b4:	e28d5f4e 	add	r5, sp, #312	@ 0x138
   216b8:	1a00000a 	bne	216e8 <_svfprintf_r+0xc80>
   216bc:	e59d204c 	ldr	r2, [sp, #76]	@ 0x4c
						*--cp = xdigs[_uquad & 15];
   216c0:	e206300f 	and	r3, r6, #15
					} while (_uquad);
   216c4:	e1b06226 	lsrs	r6, r6, #4
						*--cp = xdigs[_uquad & 15];
   216c8:	e7d23003 	ldrb	r3, [r2, r3]
   216cc:	e5653001 	strb	r3, [r5, #-1]!
					} while (_uquad);
   216d0:	1afffffa 	bne	216c0 <_svfprintf_r+0xc58>
			size = buf + BUF - cp;
   216d4:	e28d3f4e 	add	r3, sp, #312	@ 0x138
   216d8:	e1a07000 	mov	r7, r0
   216dc:	e0433005 	sub	r3, r3, r5
   216e0:	e58d3020 	str	r3, [sp, #32]
   216e4:	eafffe9d 	b	21160 <_svfprintf_r+0x6f8>
						*--cp = to_char (_uquad & 7);
   216e8:	e2063007 	and	r3, r6, #7
					} while (_uquad);
   216ec:	e1b061a6 	lsrs	r6, r6, #3
						*--cp = to_char (_uquad & 7);
   216f0:	e2833030 	add	r3, r3, #48	@ 0x30
   216f4:	e1a02005 	mov	r2, r5
   216f8:	e5653001 	strb	r3, [r5, #-1]!
					} while (_uquad);
   216fc:	1afffff9 	bne	216e8 <_svfprintf_r+0xc80>
					if (flags & ALT && *cp != '0')
   21700:	e3530030 	cmp	r3, #48	@ 0x30
   21704:	03a01000 	moveq	r1, #0
   21708:	12001001 	andne	r1, r0, #1
   2170c:	e3510000 	cmp	r1, #0
   21710:	0affffef 	beq	216d4 <_svfprintf_r+0xc6c>
						*--cp = '0';
   21714:	e3a03030 	mov	r3, #48	@ 0x30
   21718:	e2422002 	sub	r2, r2, #2
   2171c:	e5453001 	strb	r3, [r5, #-1]
			size = buf + BUF - cp;
   21720:	e28d3f4e 	add	r3, sp, #312	@ 0x138
   21724:	e0433002 	sub	r3, r3, r2
   21728:	e1a07000 	mov	r7, r0
						*--cp = '0';
   2172c:	e1a05002 	mov	r5, r2
			size = buf + BUF - cp;
   21730:	e58d3020 	str	r3, [sp, #32]
   21734:	eafffe89 	b	21160 <_svfprintf_r+0x6f8>
				if (ndig > 1 || flags & ALT) {
   21738:	e59d3034 	ldr	r3, [sp, #52]	@ 0x34
					PRINT (cp, 1);
   2173c:	e2822001 	add	r2, r2, #1
			PRINT (cp, size);
   21740:	e28a1008 	add	r1, sl, #8
				if (ndig > 1 || flags & ALT) {
   21744:	e3530001 	cmp	r3, #1
					PRINT (cp, 1);
   21748:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   2174c:	e2833001 	add	r3, r3, #1
				if (ndig > 1 || flags & ALT) {
   21750:	da000110 	ble	21b98 <_svfprintf_r+0x1130>
					PRINT (cp, 1);
   21754:	e3530007 	cmp	r3, #7
   21758:	e3a00001 	mov	r0, #1
   2175c:	e58a5000 	str	r5, [sl]
   21760:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   21764:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   21768:	e58a0004 	str	r0, [sl, #4]
   2176c:	ca000149 	bgt	21c98 <_svfprintf_r+0x1230>
					PRINT (decimal_point, decp_len);
   21770:	e59d0040 	ldr	r0, [sp, #64]	@ 0x40
   21774:	e2833001 	add	r3, r3, #1
   21778:	e59dc044 	ldr	ip, [sp, #68]	@ 0x44
   2177c:	e3530007 	cmp	r3, #7
   21780:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   21784:	e0822000 	add	r2, r2, r0
   21788:	e5810004 	str	r0, [r1, #4]
   2178c:	e581c000 	str	ip, [r1]
   21790:	d2811008 	addle	r1, r1, #8
   21794:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   21798:	ca000135 	bgt	21c74 <_svfprintf_r+0x120c>
						PAD (ndig - 1, zeroes);
   2179c:	e59d0034 	ldr	r0, [sp, #52]	@ 0x34
					if (_fpvalue) {
   217a0:	eeb58b40 	vcmp.f64	d8, #0.0
   217a4:	eef1fa10 	vmrs	APSR_nzcv, fpscr
						PAD (ndig - 1, zeroes);
   217a8:	e2406001 	sub	r6, r0, #1
					if (_fpvalue) {
   217ac:	0a00010b 	beq	21be0 <_svfprintf_r+0x1178>
						PRINT (cp, ndig - 1);
   217b0:	e2833001 	add	r3, r3, #1
					cp++;
   217b4:	e2855001 	add	r5, r5, #1
						PRINT (cp, ndig - 1);
   217b8:	e5815000 	str	r5, [r1]
						PAD (ndig - 1, zeroes);
   217bc:	e3530007 	cmp	r3, #7
   217c0:	e0822006 	add	r2, r2, r6
   217c4:	e5816004 	str	r6, [r1, #4]
   217c8:	d2811008 	addle	r1, r1, #8
   217cc:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   217d0:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   217d4:	ca0000f8 	bgt	21bbc <_svfprintf_r+0x1154>
				PRINT (expstr, expsize);
   217d8:	e59d0048 	ldr	r0, [sp, #72]	@ 0x48
   217dc:	e2833001 	add	r3, r3, #1
   217e0:	e3530007 	cmp	r3, #7
   217e4:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   217e8:	e28d3078 	add	r3, sp, #120	@ 0x78
   217ec:	d281a008 	addle	sl, r1, #8
   217f0:	e0802002 	add	r2, r0, r2
   217f4:	e5810004 	str	r0, [r1, #4]
   217f8:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   217fc:	e5813000 	str	r3, [r1]
   21800:	dafffdca 	ble	20f30 <_svfprintf_r+0x4c8>
   21804:	e1cd01d0 	ldrd	r0, [sp, #16]
   21808:	e28d2088 	add	r2, sp, #136	@ 0x88
   2180c:	eb000e63 	bl	251a0 <__ssprint_r>
   21810:	e3500000 	cmp	r0, #0
   21814:	1afffd66 	bne	20db4 <_svfprintf_r+0x34c>
			PAD (width - realsz, blanks);
   21818:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
				PRINT (expstr, expsize);
   2181c:	e28da094 	add	sl, sp, #148	@ 0x94
   21820:	eafffdc2 	b	20f30 <_svfprintf_r+0x4c8>
			PAD (width - realsz, blanks);
   21824:	e3560010 	cmp	r6, #16
   21828:	e30a8070 	movw	r8, #41072	@ 0xa070
   2182c:	e59d108c 	ldr	r1, [sp, #140]	@ 0x8c
   21830:	e3408002 	movt	r8, #2
   21834:	da000026 	ble	218d4 <_svfprintf_r+0xe6c>
   21838:	e1a0000a 	mov	r0, sl
   2183c:	e1a0a009 	mov	sl, r9
   21840:	e1a09007 	mov	r9, r7
   21844:	e1a07004 	mov	r7, r4
   21848:	e1a04008 	mov	r4, r8
   2184c:	e1a08005 	mov	r8, r5
   21850:	e1a05003 	mov	r5, r3
   21854:	ea000002 	b	21864 <_svfprintf_r+0xdfc>
   21858:	e2466010 	sub	r6, r6, #16
   2185c:	e3560010 	cmp	r6, #16
   21860:	da000014 	ble	218b8 <_svfprintf_r+0xe50>
   21864:	e2811001 	add	r1, r1, #1
   21868:	e2822010 	add	r2, r2, #16
   2186c:	e3510007 	cmp	r1, #7
   21870:	e3a03010 	mov	r3, #16
   21874:	e5804000 	str	r4, [r0]
   21878:	e5803004 	str	r3, [r0, #4]
   2187c:	d2800008 	addle	r0, r0, #8
   21880:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   21884:	e58d108c 	str	r1, [sp, #140]	@ 0x8c
   21888:	dafffff2 	ble	21858 <_svfprintf_r+0xdf0>
   2188c:	e1cd01d0 	ldrd	r0, [sp, #16]
   21890:	e28d2088 	add	r2, sp, #136	@ 0x88
   21894:	eb000e41 	bl	251a0 <__ssprint_r>
   21898:	e3500000 	cmp	r0, #0
   2189c:	e28d0094 	add	r0, sp, #148	@ 0x94
   218a0:	1afffd43 	bne	20db4 <_svfprintf_r+0x34c>
   218a4:	e2466010 	sub	r6, r6, #16
   218a8:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   218ac:	e3560010 	cmp	r6, #16
   218b0:	e59d108c 	ldr	r1, [sp, #140]	@ 0x8c
   218b4:	caffffea 	bgt	21864 <_svfprintf_r+0xdfc>
   218b8:	e1a03005 	mov	r3, r5
   218bc:	e1a05008 	mov	r5, r8
   218c0:	e1a08004 	mov	r8, r4
   218c4:	e1a04007 	mov	r4, r7
   218c8:	e1a07009 	mov	r7, r9
   218cc:	e1a0900a 	mov	r9, sl
   218d0:	e1a0a000 	mov	sl, r0
   218d4:	e2811001 	add	r1, r1, #1
   218d8:	e0822006 	add	r2, r2, r6
   218dc:	e3510007 	cmp	r1, #7
   218e0:	e58a8000 	str	r8, [sl]
   218e4:	e58d108c 	str	r1, [sp, #140]	@ 0x8c
   218e8:	e58a6004 	str	r6, [sl, #4]
   218ec:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   218f0:	ca000250 	bgt	22238 <_svfprintf_r+0x17d0>
		if (sign)
   218f4:	e5dd106b 	ldrb	r1, [sp, #107]	@ 0x6b
			PAD (width - realsz, blanks);
   218f8:	e28aa008 	add	sl, sl, #8
   218fc:	eafffd5b 	b	20e70 <_svfprintf_r+0x408>
			PRINT (&sign, 1);
   21900:	e1cd01d0 	ldrd	r0, [sp, #16]
   21904:	e28d2088 	add	r2, sp, #136	@ 0x88
   21908:	e58d305c 	str	r3, [sp, #92]	@ 0x5c
   2190c:	eb000e23 	bl	251a0 <__ssprint_r>
   21910:	e3500000 	cmp	r0, #0
   21914:	1afffd26 	bne	20db4 <_svfprintf_r+0x34c>
			PRINT (ox, 2);
   21918:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
			PRINT (&sign, 1);
   2191c:	e28da094 	add	sl, sp, #148	@ 0x94
   21920:	e59d305c 	ldr	r3, [sp, #92]	@ 0x5c
   21924:	eafffd5f 	b	20ea8 <_svfprintf_r+0x440>
			PRINT (ox, 2);
   21928:	e1cd01d0 	ldrd	r0, [sp, #16]
   2192c:	e28d2088 	add	r2, sp, #136	@ 0x88
   21930:	eb000e1a 	bl	251a0 <__ssprint_r>
   21934:	e3500000 	cmp	r0, #0
   21938:	1afffd1d 	bne	20db4 <_svfprintf_r+0x34c>
		PAD (dprec - size, zeroes);
   2193c:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
			PRINT (ox, 2);
   21940:	e28da094 	add	sl, sp, #148	@ 0x94
   21944:	eafffd65 	b	20ee0 <_svfprintf_r+0x478>
			PAD (width - realsz, blanks);
   21948:	e3540010 	cmp	r4, #16
   2194c:	e30a8070 	movw	r8, #41072	@ 0xa070
   21950:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   21954:	e3408002 	movt	r8, #2
   21958:	c1cd61d0 	ldrdgt	r6, [sp, #16]
   2195c:	c3a05010 	movgt	r5, #16
   21960:	ca000003 	bgt	21974 <_svfprintf_r+0xf0c>
   21964:	ea000017 	b	219c8 <_svfprintf_r+0xf60>
   21968:	e2444010 	sub	r4, r4, #16
   2196c:	e3540010 	cmp	r4, #16
   21970:	da000014 	ble	219c8 <_svfprintf_r+0xf60>
   21974:	e2833001 	add	r3, r3, #1
   21978:	e2822010 	add	r2, r2, #16
   2197c:	e3530007 	cmp	r3, #7
   21980:	e58a8000 	str	r8, [sl]
   21984:	e58a5004 	str	r5, [sl, #4]
   21988:	d28aa008 	addle	sl, sl, #8
   2198c:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   21990:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   21994:	dafffff3 	ble	21968 <_svfprintf_r+0xf00>
   21998:	e28d2088 	add	r2, sp, #136	@ 0x88
   2199c:	e1a01007 	mov	r1, r7
   219a0:	e1a00006 	mov	r0, r6
   219a4:	e28da094 	add	sl, sp, #148	@ 0x94
   219a8:	eb000dfc 	bl	251a0 <__ssprint_r>
   219ac:	e3500000 	cmp	r0, #0
   219b0:	1afffcff 	bne	20db4 <_svfprintf_r+0x34c>
   219b4:	e2444010 	sub	r4, r4, #16
   219b8:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   219bc:	e3540010 	cmp	r4, #16
   219c0:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   219c4:	caffffea 	bgt	21974 <_svfprintf_r+0xf0c>
   219c8:	e2833001 	add	r3, r3, #1
   219cc:	e0822004 	add	r2, r2, r4
   219d0:	e3530007 	cmp	r3, #7
   219d4:	e58a8000 	str	r8, [sl]
   219d8:	e58a4004 	str	r4, [sl, #4]
   219dc:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   219e0:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   219e4:	dafffd58 	ble	20f4c <_svfprintf_r+0x4e4>
   219e8:	e1cd01d0 	ldrd	r0, [sp, #16]
   219ec:	e28d2088 	add	r2, sp, #136	@ 0x88
   219f0:	eb000dea 	bl	251a0 <__ssprint_r>
   219f4:	e3500000 	cmp	r0, #0
   219f8:	1afffced 	bne	20db4 <_svfprintf_r+0x34c>
		FLUSH ();	/* copy out the I/O vectors */
   219fc:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   21a00:	eafffd51 	b	20f4c <_svfprintf_r+0x4e4>
   21a04:	e1a09002 	mov	r9, r2
			cp = buf + BUF;
   21a08:	e28d5f4e 	add	r5, sp, #312	@ 0x138
   21a0c:	e58d2020 	str	r2, [sp, #32]
   21a10:	eafffdd2 	b	21160 <_svfprintf_r+0x6f8>
				flags &= ~ZEROPAD;
   21a14:	e1a00007 	mov	r0, r7
					if (_uquad < 10) {
   21a18:	e3560009 	cmp	r6, #9
   21a1c:	8a000252 	bhi	2236c <_svfprintf_r+0x1904>
						*--cp = to_char(_uquad);
   21a20:	e2866030 	add	r6, r6, #48	@ 0x30
						break;
   21a24:	e3a03001 	mov	r3, #1
						*--cp = to_char(_uquad);
   21a28:	e28d5f4d 	add	r5, sp, #308	@ 0x134
						break;
   21a2c:	e1a07000 	mov	r7, r0
						*--cp = to_char(_uquad);
   21a30:	e2855003 	add	r5, r5, #3
   21a34:	e5cd6137 	strb	r6, [sp, #311]	@ 0x137
						break;
   21a38:	e58d3020 	str	r3, [sp, #32]
   21a3c:	eafffdc7 	b	21160 <_svfprintf_r+0x6f8>
				} else if (expt <= 0) {
   21a40:	e59d4070 	ldr	r4, [sp, #112]	@ 0x70
   21a44:	e3540000 	cmp	r4, #0
   21a48:	da000205 	ble	22264 <_svfprintf_r+0x17fc>
					PRINTANDPAD(cp, convbuf + ndig,
   21a4c:	e59d3030 	ldr	r3, [sp, #48]	@ 0x30
   21a50:	e59d1034 	ldr	r1, [sp, #52]	@ 0x34
   21a54:	e1530001 	cmp	r3, r1
   21a58:	b1a06003 	movlt	r6, r3
   21a5c:	a1a06001 	movge	r6, r1
   21a60:	e3560000 	cmp	r6, #0
   21a64:	da000008 	ble	21a8c <_svfprintf_r+0x1024>
   21a68:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   21a6c:	e0822006 	add	r2, r2, r6
   21a70:	e88a0060 	stm	sl, {r5, r6}
   21a74:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   21a78:	e2833001 	add	r3, r3, #1
   21a7c:	e3530007 	cmp	r3, #7
   21a80:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   21a84:	d28aa008 	addle	sl, sl, #8
   21a88:	ca00032f 	bgt	2274c <_svfprintf_r+0x1ce4>
   21a8c:	e59d4030 	ldr	r4, [sp, #48]	@ 0x30
   21a90:	e3560000 	cmp	r6, #0
   21a94:	a0444006 	subge	r4, r4, r6
   21a98:	e3540000 	cmp	r4, #0
   21a9c:	ca000135 	bgt	21f78 <_svfprintf_r+0x1510>
					cp += lead;
   21aa0:	e59d3030 	ldr	r3, [sp, #48]	@ 0x30
					if (flags & GROUPING) {
   21aa4:	e3170b01 	tst	r7, #1024	@ 0x400
					cp += lead;
   21aa8:	e0858003 	add	r8, r5, r3
					if (flags & GROUPING) {
   21aac:	1a00015b 	bne	22020 <_svfprintf_r+0x15b8>
					if (expt < ndig || flags & ALT)
   21ab0:	e59d4070 	ldr	r4, [sp, #112]	@ 0x70
   21ab4:	e59d3034 	ldr	r3, [sp, #52]	@ 0x34
   21ab8:	e1540003 	cmp	r4, r3
   21abc:	ba0001c9 	blt	221e8 <_svfprintf_r+0x1780>
   21ac0:	e3170001 	tst	r7, #1
   21ac4:	1a0001c7 	bne	221e8 <_svfprintf_r+0x1780>
					PRINTANDPAD (cp, convbuf + ndig,
   21ac8:	e59d3034 	ldr	r3, [sp, #52]	@ 0x34
   21acc:	e0855003 	add	r5, r5, r3
   21ad0:	e0434004 	sub	r4, r3, r4
   21ad4:	e0455008 	sub	r5, r5, r8
   21ad8:	e1550004 	cmp	r5, r4
   21adc:	a1a05004 	movge	r5, r4
   21ae0:	e3550000 	cmp	r5, #0
   21ae4:	da000009 	ble	21b10 <_svfprintf_r+0x10a8>
   21ae8:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   21aec:	e0822005 	add	r2, r2, r5
   21af0:	e58a8000 	str	r8, [sl]
   21af4:	e58a5004 	str	r5, [sl, #4]
   21af8:	e2833001 	add	r3, r3, #1
   21afc:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   21b00:	e3530007 	cmp	r3, #7
   21b04:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   21b08:	d28aa008 	addle	sl, sl, #8
   21b0c:	ca000399 	bgt	22978 <_svfprintf_r+0x1f10>
   21b10:	e3550000 	cmp	r5, #0
   21b14:	a0444005 	subge	r4, r4, r5
   21b18:	e3540000 	cmp	r4, #0
   21b1c:	dafffd03 	ble	20f30 <_svfprintf_r+0x4c8>
   21b20:	e3540010 	cmp	r4, #16
   21b24:	e51f8d2c 	ldr	r8, [pc, #-3372]	@ 20e00 <_svfprintf_r+0x398>
   21b28:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   21b2c:	da000205 	ble	22348 <_svfprintf_r+0x18e0>
   21b30:	e59d6010 	ldr	r6, [sp, #16]
   21b34:	e3a05010 	mov	r5, #16
   21b38:	e59d9014 	ldr	r9, [sp, #20]
   21b3c:	ea000002 	b	21b4c <_svfprintf_r+0x10e4>
   21b40:	e2444010 	sub	r4, r4, #16
   21b44:	e3540010 	cmp	r4, #16
   21b48:	da0001fe 	ble	22348 <_svfprintf_r+0x18e0>
   21b4c:	e2833001 	add	r3, r3, #1
   21b50:	e2822010 	add	r2, r2, #16
   21b54:	e3530007 	cmp	r3, #7
   21b58:	e58a8000 	str	r8, [sl]
   21b5c:	e58a5004 	str	r5, [sl, #4]
   21b60:	d28aa008 	addle	sl, sl, #8
   21b64:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   21b68:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   21b6c:	dafffff3 	ble	21b40 <_svfprintf_r+0x10d8>
   21b70:	e28d2088 	add	r2, sp, #136	@ 0x88
   21b74:	e1a01009 	mov	r1, r9
   21b78:	e1a00006 	mov	r0, r6
   21b7c:	eb000d87 	bl	251a0 <__ssprint_r>
   21b80:	e3500000 	cmp	r0, #0
   21b84:	1afffc8a 	bne	20db4 <_svfprintf_r+0x34c>
   21b88:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   21b8c:	e28da094 	add	sl, sp, #148	@ 0x94
   21b90:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   21b94:	eaffffe9 	b	21b40 <_svfprintf_r+0x10d8>
				if (ndig > 1 || flags & ALT) {
   21b98:	e3170001 	tst	r7, #1
   21b9c:	1afffeec 	bne	21754 <_svfprintf_r+0xcec>
					PRINT (cp, 1);
   21ba0:	e3530007 	cmp	r3, #7
   21ba4:	e3a00001 	mov	r0, #1
   21ba8:	e58a5000 	str	r5, [sl]
   21bac:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   21bb0:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   21bb4:	e58a0004 	str	r0, [sl, #4]
   21bb8:	daffff06 	ble	217d8 <_svfprintf_r+0xd70>
   21bbc:	e1cd01d0 	ldrd	r0, [sp, #16]
   21bc0:	e28d2088 	add	r2, sp, #136	@ 0x88
   21bc4:	eb000d75 	bl	251a0 <__ssprint_r>
   21bc8:	e3500000 	cmp	r0, #0
   21bcc:	1afffc78 	bne	20db4 <_svfprintf_r+0x34c>
				PRINT (expstr, expsize);
   21bd0:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
					PRINT (cp, 1);
   21bd4:	e28d1094 	add	r1, sp, #148	@ 0x94
				PRINT (expstr, expsize);
   21bd8:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   21bdc:	eafffefd 	b	217d8 <_svfprintf_r+0xd70>
						PAD (ndig - 1, zeroes);
   21be0:	e59d0034 	ldr	r0, [sp, #52]	@ 0x34
   21be4:	e3500001 	cmp	r0, #1
   21be8:	dafffefa 	ble	217d8 <_svfprintf_r+0xd70>
   21bec:	e3500011 	cmp	r0, #17
   21bf0:	e51f8df8 	ldr	r8, [pc, #-3576]	@ 20e00 <_svfprintf_r+0x398>
   21bf4:	da00022a 	ble	224a4 <_svfprintf_r+0x1a3c>
   21bf8:	e59d5010 	ldr	r5, [sp, #16]
   21bfc:	e3a04010 	mov	r4, #16
   21c00:	e59d9014 	ldr	r9, [sp, #20]
   21c04:	ea000002 	b	21c14 <_svfprintf_r+0x11ac>
   21c08:	e2466010 	sub	r6, r6, #16
   21c0c:	e3560010 	cmp	r6, #16
   21c10:	da000223 	ble	224a4 <_svfprintf_r+0x1a3c>
   21c14:	e2833001 	add	r3, r3, #1
   21c18:	e2822010 	add	r2, r2, #16
   21c1c:	e3530007 	cmp	r3, #7
   21c20:	e5818000 	str	r8, [r1]
   21c24:	e5814004 	str	r4, [r1, #4]
   21c28:	d2811008 	addle	r1, r1, #8
   21c2c:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   21c30:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   21c34:	dafffff3 	ble	21c08 <_svfprintf_r+0x11a0>
   21c38:	e28d2088 	add	r2, sp, #136	@ 0x88
   21c3c:	e1a01009 	mov	r1, r9
   21c40:	e1a00005 	mov	r0, r5
   21c44:	eb000d55 	bl	251a0 <__ssprint_r>
   21c48:	e3500000 	cmp	r0, #0
   21c4c:	1afffc58 	bne	20db4 <_svfprintf_r+0x34c>
   21c50:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   21c54:	e28d1094 	add	r1, sp, #148	@ 0x94
   21c58:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   21c5c:	eaffffe9 	b	21c08 <_svfprintf_r+0x11a0>
				_uquad = -_uquad;
   21c60:	e2636000 	rsb	r6, r3, #0
   21c64:	e1a00007 	mov	r0, r7
   21c68:	e3a0202d 	mov	r2, #45	@ 0x2d
			base = DEC;
   21c6c:	e3a03001 	mov	r3, #1
   21c70:	eafffd2a 	b	21120 <_svfprintf_r+0x6b8>
					PRINT (decimal_point, decp_len);
   21c74:	e1cd01d0 	ldrd	r0, [sp, #16]
   21c78:	e28d2088 	add	r2, sp, #136	@ 0x88
   21c7c:	eb000d47 	bl	251a0 <__ssprint_r>
   21c80:	e3500000 	cmp	r0, #0
   21c84:	1afffc4a 	bne	20db4 <_svfprintf_r+0x34c>
						PRINT (cp, ndig - 1);
   21c88:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
					PRINT (decimal_point, decp_len);
   21c8c:	e28d1094 	add	r1, sp, #148	@ 0x94
						PRINT (cp, ndig - 1);
   21c90:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   21c94:	eafffec0 	b	2179c <_svfprintf_r+0xd34>
					PRINT (cp, 1);
   21c98:	e1cd01d0 	ldrd	r0, [sp, #16]
   21c9c:	e28d2088 	add	r2, sp, #136	@ 0x88
   21ca0:	eb000d3e 	bl	251a0 <__ssprint_r>
   21ca4:	e3500000 	cmp	r0, #0
   21ca8:	1afffc41 	bne	20db4 <_svfprintf_r+0x34c>
					PRINT (decimal_point, decp_len);
   21cac:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
					PRINT (cp, 1);
   21cb0:	e28d1094 	add	r1, sp, #148	@ 0x94
					PRINT (decimal_point, decp_len);
   21cb4:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   21cb8:	eafffeac 	b	21770 <_svfprintf_r+0xd08>
					if (expt < ndig || flags & ALT) {
   21cbc:	e3170001 	tst	r7, #1
   21cc0:	0afffc9a 	beq	20f30 <_svfprintf_r+0x4c8>
   21cc4:	eafffdc2 	b	213d4 <_svfprintf_r+0x96c>
			if ((ch = *fmt++) == '*') {
   21cc8:	e5db4000 	ldrb	r4, [fp]
			width = GET_ARG (n, ap, int);
   21ccc:	e58d3028 	str	r3, [sp, #40]	@ 0x28
   21cd0:	eafffbac 	b	20b88 <_svfprintf_r+0x120>
			else if (flags & SHORTINT)
   21cd4:	e3170040 	tst	r7, #64	@ 0x40
   21cd8:	0a0001f4 	beq	224b0 <_svfprintf_r+0x1a48>
				*GET_ARG (N, ap, short_ptr_t) = ret;
   21cdc:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
   21ce0:	e59d201c 	ldr	r2, [sp, #28]
   21ce4:	e5933000 	ldr	r3, [r3]
   21ce8:	e1c320b0 	strh	r2, [r3]
   21cec:	eafffd98 	b	21354 <_svfprintf_r+0x8ec>
			if (thsnd_len > 0 && grouping && *grouping)
   21cf0:	e59d3054 	ldr	r3, [sp, #84]	@ 0x54
rflag:		ch = *fmt++;
   21cf4:	e5db4000 	ldrb	r4, [fp]
			if (thsnd_len > 0 && grouping && *grouping)
   21cf8:	e5d33000 	ldrb	r3, [r3]
   21cfc:	e3530000 	cmp	r3, #0
			  flags |= GROUPING;
   21d00:	13877b01 	orrne	r7, r7, #1024	@ 0x400
   21d04:	eafffb9f 	b	20b88 <_svfprintf_r+0x120>
			_uquad = SARG ();
   21d08:	e6bf3073 	sxth	r3, r3
			if ((long) _uquad < 0)
   21d0c:	e1a06003 	mov	r6, r3
   21d10:	eafffd53 	b	21264 <_svfprintf_r+0x7fc>
			if (isnan (_fpvalue)) {
   21d14:	eeb48b48 	vcmp.f64	d8, d8
   21d18:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   21d1c:	6a0003b3 	bvs	22bf0 <_svfprintf_r+0x2188>
			if (ch == 'a' || ch == 'A') {
   21d20:	e3c46020 	bic	r6, r4, #32
   21d24:	e3560041 	cmp	r6, #65	@ 0x41
   21d28:	1a0001e7 	bne	224cc <_svfprintf_r+0x1a64>
				ox[0] = '0';
   21d2c:	e3a03030 	mov	r3, #48	@ 0x30
				ox[1] = ch == 'a' ? 'x' : 'X';
   21d30:	e3540061 	cmp	r4, #97	@ 0x61
				ox[0] = '0';
   21d34:	e5cd306c 	strb	r3, [sp, #108]	@ 0x6c
				ox[1] = ch == 'a' ? 'x' : 'X';
   21d38:	13a03058 	movne	r3, #88	@ 0x58
   21d3c:	03a03078 	moveq	r3, #120	@ 0x78
				if (prec >= BUF)
   21d40:	e3590063 	cmp	r9, #99	@ 0x63
				ox[1] = ch == 'a' ? 'x' : 'X';
   21d44:	e5cd306d 	strb	r3, [sp, #109]	@ 0x6d
				if (prec >= BUF)
   21d48:	d3a03000 	movle	r3, #0
				  cp = buf;
   21d4c:	d28d50d4 	addle	r5, sp, #212	@ 0xd4
   21d50:	d58d3024 	strle	r3, [sp, #36]	@ 0x24
				if (prec >= BUF)
   21d54:	ca000284 	bgt	2276c <_svfprintf_r+0x1d04>
	char *digits, *bp, *rve;
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
   21d58:	ee183a90 	vmov	r3, s17
   21d5c:	e3530000 	cmp	r3, #0
		value = -value;
		*sign = '-';
	} else
		*sign = '\000';
   21d60:	a3a08000 	movge	r8, #0
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
   21d64:	aeb00b48 	vmovge.f64	d0, d8
		value = -value;
   21d68:	beb10b48 	vneglt.f64	d0, d8
   21d6c:	b3a0802d 	movlt	r8, #45	@ 0x2d
	if (ch == 'a' || ch == 'A') {
		/* This code assumes FLT_RADIX is a power of 2.  The initial
		   division ensures the digit before the decimal will be less
		   than FLT_RADIX (unless it is rounded later).	 There is no
		   loss of precision in these calculations.  */
		value = FREXP (value, decpt) / 8;
   21d70:	e28d0070 	add	r0, sp, #112	@ 0x70
   21d74:	ebfffa1b 	bl	205e8 <frexp>
   21d78:	ed9f7bee 	vldr	d7, [pc, #952]	@ 22138 <_svfprintf_r+0x16d0>
		if (!value)
			*decpt = 1;
		digits = ch == 'a' ? "0123456789abcdef" : "0123456789ABCDEF";
   21d7c:	e30911a4 	movw	r1, #37284	@ 0x91a4
   21d80:	e3401002 	movt	r1, #2
		bp = buf;
		do {
			value *= 16;
   21d84:	ed9f4bed 	vldr	d4, [pc, #948]	@ 22140 <_svfprintf_r+0x16d8>
   21d88:	e2492001 	sub	r2, r9, #1
		value = FREXP (value, decpt) / 8;
   21d8c:	ee207b07 	vmul.f64	d7, d0, d7
		if (!value)
   21d90:	eeb57b40 	vcmp.f64	d7, #0.0
   21d94:	eef1fa10 	vmrs	APSR_nzcv, fpscr
			*decpt = 1;
   21d98:	03a03001 	moveq	r3, #1
   21d9c:	058d3070 	streq	r3, [sp, #112]	@ 0x70
		digits = ch == 'a' ? "0123456789abcdef" : "0123456789ABCDEF";
   21da0:	e30931b8 	movw	r3, #37304	@ 0x91b8
   21da4:	e3403002 	movt	r3, #2
   21da8:	e3540061 	cmp	r4, #97	@ 0x61
   21dac:	01a0e003 	moveq	lr, r3
   21db0:	11a0e001 	movne	lr, r1
		bp = buf;
   21db4:	e1a03005 	mov	r3, r5
   21db8:	ea000003 	b	21dcc <_svfprintf_r+0x1364>
			mode = (int) value;
			value -= mode;
			*bp++ = digits[mode];
		} while (ndigits-- && value);
   21dbc:	eeb57b40 	vcmp.f64	d7, #0.0
   21dc0:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   21dc4:	0a0003a6 	beq	22c64 <_svfprintf_r+0x21fc>
   21dc8:	e1a02000 	mov	r2, r0
			value *= 16;
   21dcc:	ee277b04 	vmul.f64	d7, d7, d4
		} while (ndigits-- && value);
   21dd0:	e3720001 	cmn	r2, #1
   21dd4:	e1a0c003 	mov	ip, r3
   21dd8:	e2420001 	sub	r0, r2, #1
			mode = (int) value;
   21ddc:	eefd6bc7 	vcvt.s32.f64	s13, d7
			*bp++ = digits[mode];
   21de0:	ee161a90 	vmov	r1, s13
			value -= mode;
   21de4:	eeb85be6 	vcvt.f64.s32	d5, s13
			*bp++ = digits[mode];
   21de8:	e7de1001 	ldrb	r1, [lr, r1]
			value -= mode;
   21dec:	ee377b45 	vsub.f64	d7, d7, d5
			*bp++ = digits[mode];
   21df0:	e4c31001 	strb	r1, [r3], #1
		} while (ndigits-- && value);
   21df4:	1afffff0 	bne	21dbc <_svfprintf_r+0x1354>
		if (value > 0.5 || (value == 0.5 && mode & 1)) {
   21df8:	ed9f5bd2 	vldr	d5, [pc, #840]	@ 22148 <_svfprintf_r+0x16e0>
   21dfc:	eeb47bc5 	vcmpe.f64	d7, d5
   21e00:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   21e04:	ca000005 	bgt	21e20 <_svfprintf_r+0x13b8>
   21e08:	eeb47b45 	vcmp.f64	d7, d5
   21e0c:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   21e10:	1a000015 	bne	21e6c <_svfprintf_r+0x1404>
   21e14:	ee162a90 	vmov	r2, s13
   21e18:	e3120001 	tst	r2, #1
   21e1c:	0a000012 	beq	21e6c <_svfprintf_r+0x1404>
			/* round to even */
			rve = bp;
			while (*--rve == digits[0xf]) {
   21e20:	e5de000f 	ldrb	r0, [lr, #15]
   21e24:	e1a02003 	mov	r2, r3
   21e28:	e58dc080 	str	ip, [sp, #128]	@ 0x80
   21e2c:	e5531001 	ldrb	r1, [r3, #-1]
   21e30:	e1500001 	cmp	r0, r1
   21e34:	1a000007 	bne	21e58 <_svfprintf_r+0x13f0>
				*rve = '0';
   21e38:	e3a0c030 	mov	ip, #48	@ 0x30
   21e3c:	e542c001 	strb	ip, [r2, #-1]
			while (*--rve == digits[0xf]) {
   21e40:	e59d2080 	ldr	r2, [sp, #128]	@ 0x80
   21e44:	e2421001 	sub	r1, r2, #1
   21e48:	e58d1080 	str	r1, [sp, #128]	@ 0x80
   21e4c:	e5521001 	ldrb	r1, [r2, #-1]
   21e50:	e1500001 	cmp	r0, r1
   21e54:	0afffff8 	beq	21e3c <_svfprintf_r+0x13d4>
			}
			*rve = *rve == '9' ? digits[0xa] : *rve + 1;
   21e58:	e3510039 	cmp	r1, #57	@ 0x39
   21e5c:	12811001 	addne	r1, r1, #1
   21e60:	05de100a 	ldrbeq	r1, [lr, #10]
   21e64:	16ef1071 	uxtbne	r1, r1
   21e68:	e5421001 	strb	r1, [r2, #-1]
			*bp++ = digits[mode];
   21e6c:	e1a02003 	mov	r2, r3
		} else {
			while (ndigits-- >= 0) {
				*bp++ = '0';
			}
		}
		*length = bp - buf;
   21e70:	e0423005 	sub	r3, r2, r5
# else
#  define isa 0
# endif

	p = p0;
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
   21e74:	e284200f 	add	r2, r4, #15
		*length = bp - buf;
   21e78:	e58d3034 	str	r3, [sp, #52]	@ 0x34
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
   21e7c:	e6ef2072 	uxtb	r2, r2
				--expt;
   21e80:	e59d3070 	ldr	r3, [sp, #112]	@ 0x70
				flags |= HEXPREFIX;
   21e84:	e3877002 	orr	r7, r7, #2
				--expt;
   21e88:	e3a01001 	mov	r1, #1
   21e8c:	e58d3030 	str	r3, [sp, #48]	@ 0x30
   21e90:	e2433001 	sub	r3, r3, #1
   21e94:	e58d3070 	str	r3, [sp, #112]	@ 0x70
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
   21e98:	ea0001cf 	b	225dc <_svfprintf_r+0x1b74>
			_uquad = UARG ();
   21e9c:	e6ff6076 	uxth	r6, r6
   21ea0:	e1a00007 	mov	r0, r7
			base = DEC;
   21ea4:	e3a03001 	mov	r3, #1
   21ea8:	eafffc9b 	b	2111c <_svfprintf_r+0x6b4>
reswitch:	switch (ch) {
   21eac:	e30931a4 	movw	r3, #37284	@ 0x91a4
   21eb0:	e3403002 	movt	r3, #2
   21eb4:	e58d304c 	str	r3, [sp, #76]	@ 0x4c
			width = GET_ARG (n, ap, int);
   21eb8:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
hex:			_uquad = UARG ();
   21ebc:	e3170010 	tst	r7, #16
			width = GET_ARG (n, ap, int);
   21ec0:	e4936004 	ldr	r6, [r3], #4
   21ec4:	e58d3028 	str	r3, [sp, #40]	@ 0x28
hex:			_uquad = UARG ();
   21ec8:	1a000004 	bne	21ee0 <_svfprintf_r+0x1478>
   21ecc:	e3170040 	tst	r7, #64	@ 0x40
   21ed0:	16ff6076 	uxthne	r6, r6
   21ed4:	1a000001 	bne	21ee0 <_svfprintf_r+0x1478>
   21ed8:	e3170c02 	tst	r7, #512	@ 0x200
   21edc:	16ef6076 	uxtbne	r6, r6
			if (flags & ALT && _uquad != 0) {
   21ee0:	e3560000 	cmp	r6, #0
   21ee4:	03a03000 	moveq	r3, #0
   21ee8:	12073001 	andne	r3, r7, #1
   21eec:	e3530000 	cmp	r3, #0
				ox[0] = '0';
   21ef0:	13a03030 	movne	r3, #48	@ 0x30
				flags |= HEXPREFIX;
   21ef4:	13877002 	orrne	r7, r7, #2
				ox[0] = '0';
   21ef8:	15cd306c 	strbne	r3, [sp, #108]	@ 0x6c
			flags &= ~GROUPING;
   21efc:	e3c70b01 	bic	r0, r7, #1024	@ 0x400
			base = HEX;
   21f00:	e3a03002 	mov	r3, #2
				ox[1] = ch;
   21f04:	15cd406d 	strbne	r4, [sp, #109]	@ 0x6d
   21f08:	eafffc83 	b	2111c <_svfprintf_r+0x6b4>
			xdigs = "0123456789abcdef";
   21f0c:	e30931b8 	movw	r3, #37304	@ 0x91b8
   21f10:	e3403002 	movt	r3, #2
   21f14:	e58d304c 	str	r3, [sp, #76]	@ 0x4c
   21f18:	eaffffe6 	b	21eb8 <_svfprintf_r+0x1450>
						PRINT (decimal_point, decp_len);
   21f1c:	e1cd01d0 	ldrd	r0, [sp, #16]
   21f20:	e28d2088 	add	r2, sp, #136	@ 0x88
   21f24:	eb000c9d 	bl	251a0 <__ssprint_r>
   21f28:	e3500000 	cmp	r0, #0
   21f2c:	1afffba0 	bne	20db4 <_svfprintf_r+0x34c>
						PAD (ndig - 1, zeroes);
   21f30:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
						PRINT (decimal_point, decp_len);
   21f34:	e28da094 	add	sl, sp, #148	@ 0x94
   21f38:	eafffd30 	b	21400 <_svfprintf_r+0x998>
		fp->_bf._base = fp->_p = _malloc_r (data, 64);
   21f3c:	e59d0010 	ldr	r0, [sp, #16]
   21f40:	e3a01040 	mov	r1, #64	@ 0x40
   21f44:	ebfff57e 	bl	1f544 <_malloc_r>
   21f48:	e59d3014 	ldr	r3, [sp, #20]
		if (!fp->_p)
   21f4c:	e3500000 	cmp	r0, #0
			_REENT_ERRNO(data) = ENOMEM;
   21f50:	059d2010 	ldreq	r2, [sp, #16]
		fp->_bf._base = fp->_p = _malloc_r (data, 64);
   21f54:	e5830000 	str	r0, [r3]
   21f58:	e5830010 	str	r0, [r3, #16]
			_REENT_ERRNO(data) = ENOMEM;
   21f5c:	03a0300c 	moveq	r3, #12
   21f60:	05823000 	streq	r3, [r2]
		if (!fp->_p)
   21f64:	0a0002fa 	beq	22b54 <_svfprintf_r+0x20ec>
		fp->_bf._size = 64;
   21f68:	e59d2014 	ldr	r2, [sp, #20]
   21f6c:	e3a03040 	mov	r3, #64	@ 0x40
   21f70:	e5823014 	str	r3, [r2, #20]
   21f74:	eafffacf 	b	20ab8 <_svfprintf_r+0x50>
					PRINTANDPAD(cp, convbuf + ndig,
   21f78:	e3540010 	cmp	r4, #16
   21f7c:	e59f81cc 	ldr	r8, [pc, #460]	@ 22150 <_svfprintf_r+0x16e8>
   21f80:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   21f84:	da0001d6 	ble	226e4 <_svfprintf_r+0x1c7c>
   21f88:	e1a0100a 	mov	r1, sl
   21f8c:	e59d9010 	ldr	r9, [sp, #16]
   21f90:	e1a0a008 	mov	sl, r8
   21f94:	e3a06010 	mov	r6, #16
   21f98:	e1a08007 	mov	r8, r7
   21f9c:	e1a07005 	mov	r7, r5
   21fa0:	e59d5014 	ldr	r5, [sp, #20]
   21fa4:	ea000002 	b	21fb4 <_svfprintf_r+0x154c>
   21fa8:	e2444010 	sub	r4, r4, #16
   21fac:	e3540010 	cmp	r4, #16
   21fb0:	da0001c7 	ble	226d4 <_svfprintf_r+0x1c6c>
   21fb4:	e2833001 	add	r3, r3, #1
   21fb8:	e2822010 	add	r2, r2, #16
   21fbc:	e3530007 	cmp	r3, #7
   21fc0:	e581a000 	str	sl, [r1]
   21fc4:	e5816004 	str	r6, [r1, #4]
   21fc8:	d2811008 	addle	r1, r1, #8
   21fcc:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   21fd0:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   21fd4:	dafffff3 	ble	21fa8 <_svfprintf_r+0x1540>
   21fd8:	e28d2088 	add	r2, sp, #136	@ 0x88
   21fdc:	e1a01005 	mov	r1, r5
   21fe0:	e1a00009 	mov	r0, r9
   21fe4:	eb000c6d 	bl	251a0 <__ssprint_r>
   21fe8:	e3500000 	cmp	r0, #0
   21fec:	1afffb70 	bne	20db4 <_svfprintf_r+0x34c>
   21ff0:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   21ff4:	e28d1094 	add	r1, sp, #148	@ 0x94
   21ff8:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   21ffc:	eaffffe9 	b	21fa8 <_svfprintf_r+0x1540>
				size = strlen (cp);
   22000:	e1a00005 	mov	r0, r5
		realsz = dprec > size ? dprec : size;
   22004:	e1a09008 	mov	r9, r8
				size = strlen (cp);
   22008:	fafff91c 	blx	20480 <strlen>
		if (sign)
   2200c:	e5dd106b 	ldrb	r1, [sp, #107]	@ 0x6b
		realsz = dprec > size ? dprec : size;
   22010:	e1c03fc0 	bic	r3, r0, r0, asr #31
				size = strlen (cp);
   22014:	e58d0020 	str	r0, [sp, #32]
			cp = GET_ARG (N, ap, char_ptr_t);
   22018:	e58d6028 	str	r6, [sp, #40]	@ 0x28
   2201c:	eafffc26 	b	210bc <_svfprintf_r+0x654>
					    while (nseps > 0 || nrepeats > 0) {
   22020:	e59d3038 	ldr	r3, [sp, #56]	@ 0x38
   22024:	e59d603c 	ldr	r6, [sp, #60]	@ 0x3c
   22028:	e3560000 	cmp	r6, #0
   2202c:	d3530000 	cmple	r3, #0
   22030:	da000335 	ble	22d0c <_svfprintf_r+0x22a4>
						PRINTANDPAD (cp, convbuf + ndig,
   22034:	e59d3034 	ldr	r3, [sp, #52]	@ 0x34
   22038:	e1a0100a 	mov	r1, sl
   2203c:	e58d7060 	str	r7, [sp, #96]	@ 0x60
   22040:	e58db064 	str	fp, [sp, #100]	@ 0x64
   22044:	e0853003 	add	r3, r5, r3
   22048:	e59f9100 	ldr	r9, [pc, #256]	@ 22150 <_svfprintf_r+0x16e8>
   2204c:	e59d7054 	ldr	r7, [sp, #84]	@ 0x54
   22050:	e1a0a003 	mov	sl, r3
   22054:	e59db058 	ldr	fp, [sp, #88]	@ 0x58
   22058:	e58d505c 	str	r5, [sp, #92]	@ 0x5c
   2205c:	ea000004 	b	22074 <_svfprintf_r+0x160c>
					    while (nseps > 0 || nrepeats > 0) {
   22060:	e59d3038 	ldr	r3, [sp, #56]	@ 0x38
						cp += *grouping;
   22064:	e0888000 	add	r8, r8, r0
					    while (nseps > 0 || nrepeats > 0) {
   22068:	e3560000 	cmp	r6, #0
   2206c:	d3530000 	cmple	r3, #0
   22070:	da0002ec 	ble	22c28 <_svfprintf_r+0x21c0>
						if (nrepeats > 0)
   22074:	e3560000 	cmp	r6, #0
						PRINT(thousands_sep, thsnd_len);
   22078:	e59d008c 	ldr	r0, [sp, #140]	@ 0x8c
						    nseps--;
   2207c:	d59d3038 	ldrle	r3, [sp, #56]	@ 0x38
						    nrepeats--;
   22080:	c2466001 	subgt	r6, r6, #1
						    grouping--;
   22084:	d2477001 	suble	r7, r7, #1
						PRINT(thousands_sep, thsnd_len);
   22088:	e082200b 	add	r2, r2, fp
   2208c:	e2800001 	add	r0, r0, #1
   22090:	e58d2090 	str	r2, [sp, #144]	@ 0x90
						    nseps--;
   22094:	d2433001 	suble	r3, r3, #1
						PRINT(thousands_sep, thsnd_len);
   22098:	e58d008c 	str	r0, [sp, #140]	@ 0x8c
						    nseps--;
   2209c:	d58d3038 	strle	r3, [sp, #56]	@ 0x38
						PRINT(thousands_sep, thsnd_len);
   220a0:	e3500007 	cmp	r0, #7
   220a4:	e59d3050 	ldr	r3, [sp, #80]	@ 0x50
   220a8:	e8810808 	stm	r1, {r3, fp}
   220ac:	d2811008 	addle	r1, r1, #8
   220b0:	ca000092 	bgt	22300 <_svfprintf_r+0x1898>
						PRINTANDPAD (cp, convbuf + ndig,
   220b4:	e5d70000 	ldrb	r0, [r7]
   220b8:	e04a5008 	sub	r5, sl, r8
   220bc:	e58da020 	str	sl, [sp, #32]
   220c0:	e1550000 	cmp	r5, r0
   220c4:	a1a05000 	movge	r5, r0
   220c8:	e3550000 	cmp	r5, #0
   220cc:	da00000a 	ble	220fc <_svfprintf_r+0x1694>
   220d0:	e59d008c 	ldr	r0, [sp, #140]	@ 0x8c
   220d4:	e0822005 	add	r2, r2, r5
   220d8:	e5818000 	str	r8, [r1]
   220dc:	e5815004 	str	r5, [r1, #4]
   220e0:	e2800001 	add	r0, r0, #1
   220e4:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   220e8:	e3500007 	cmp	r0, #7
   220ec:	e58d008c 	str	r0, [sp, #140]	@ 0x8c
   220f0:	ca0000cc 	bgt	22428 <_svfprintf_r+0x19c0>
   220f4:	e5d70000 	ldrb	r0, [r7]
   220f8:	e2811008 	add	r1, r1, #8
   220fc:	e3550000 	cmp	r5, #0
   22100:	a0404005 	subge	r4, r0, r5
   22104:	b1a04000 	movlt	r4, r0
   22108:	e3540000 	cmp	r4, #0
   2210c:	daffffd3 	ble	22060 <_svfprintf_r+0x15f8>
   22110:	e3540010 	cmp	r4, #16
   22114:	e59d008c 	ldr	r0, [sp, #140]	@ 0x8c
   22118:	d59fc030 	ldrle	ip, [pc, #48]	@ 22150 <_svfprintf_r+0x16e8>
   2211c:	da000026 	ble	221bc <_svfprintf_r+0x1754>
   22120:	e1cd62fc 	strd	r6, [sp, #44]	@ 0x2c
   22124:	e3a05010 	mov	r5, #16
   22128:	e1cd61d0 	ldrd	r6, [sp, #16]
   2212c:	e58d903c 	str	r9, [sp, #60]	@ 0x3c
   22130:	ea00000a 	b	22160 <_svfprintf_r+0x16f8>
   22134:	e320f000 	nop	{0}
   22138:	00000000 	.word	0x00000000
   2213c:	3fc00000 	.word	0x3fc00000
   22140:	00000000 	.word	0x00000000
   22144:	40300000 	.word	0x40300000
   22148:	00000000 	.word	0x00000000
   2214c:	3fe00000 	.word	0x3fe00000
   22150:	0002a080 	.word	0x0002a080
   22154:	e2444010 	sub	r4, r4, #16
   22158:	e3540010 	cmp	r4, #16
   2215c:	da000014 	ble	221b4 <_svfprintf_r+0x174c>
   22160:	e2800001 	add	r0, r0, #1
   22164:	e2822010 	add	r2, r2, #16
   22168:	e3500007 	cmp	r0, #7
   2216c:	e5819000 	str	r9, [r1]
   22170:	e5815004 	str	r5, [r1, #4]
   22174:	d2811008 	addle	r1, r1, #8
   22178:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   2217c:	e58d008c 	str	r0, [sp, #140]	@ 0x8c
   22180:	dafffff3 	ble	22154 <_svfprintf_r+0x16ec>
   22184:	e28d2088 	add	r2, sp, #136	@ 0x88
   22188:	e1a01007 	mov	r1, r7
   2218c:	e1a00006 	mov	r0, r6
   22190:	eb000c02 	bl	251a0 <__ssprint_r>
   22194:	e3500000 	cmp	r0, #0
   22198:	1afffb05 	bne	20db4 <_svfprintf_r+0x34c>
   2219c:	e2444010 	sub	r4, r4, #16
   221a0:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   221a4:	e3540010 	cmp	r4, #16
   221a8:	e59d008c 	ldr	r0, [sp, #140]	@ 0x8c
   221ac:	e28d1094 	add	r1, sp, #148	@ 0x94
   221b0:	caffffea 	bgt	22160 <_svfprintf_r+0x16f8>
   221b4:	e1cd62dc 	ldrd	r6, [sp, #44]	@ 0x2c
   221b8:	e59dc03c 	ldr	ip, [sp, #60]	@ 0x3c
   221bc:	e2800001 	add	r0, r0, #1
   221c0:	e0822004 	add	r2, r2, r4
   221c4:	e3500007 	cmp	r0, #7
   221c8:	e581c000 	str	ip, [r1]
   221cc:	e58d008c 	str	r0, [sp, #140]	@ 0x8c
   221d0:	e5814004 	str	r4, [r1, #4]
   221d4:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   221d8:	ca0001bf 	bgt	228dc <_svfprintf_r+0x1e74>
						cp += *grouping;
   221dc:	e5d70000 	ldrb	r0, [r7]
						PRINTANDPAD (cp, convbuf + ndig,
   221e0:	e2811008 	add	r1, r1, #8
   221e4:	eaffff9d 	b	22060 <_svfprintf_r+0x15f8>
					    PRINT (decimal_point, decp_len);
   221e8:	e59d3040 	ldr	r3, [sp, #64]	@ 0x40
   221ec:	e59d1044 	ldr	r1, [sp, #68]	@ 0x44
   221f0:	e0822003 	add	r2, r2, r3
   221f4:	e88a000a 	stm	sl, {r1, r3}
   221f8:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   221fc:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   22200:	e2833001 	add	r3, r3, #1
   22204:	e3530007 	cmp	r3, #7
   22208:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   2220c:	d28aa008 	addle	sl, sl, #8
   22210:	dafffe2c 	ble	21ac8 <_svfprintf_r+0x1060>
   22214:	e1cd01d0 	ldrd	r0, [sp, #16]
   22218:	e28d2088 	add	r2, sp, #136	@ 0x88
   2221c:	eb000bdf 	bl	251a0 <__ssprint_r>
   22220:	e3500000 	cmp	r0, #0
   22224:	1afffae2 	bne	20db4 <_svfprintf_r+0x34c>
					PRINTANDPAD (cp, convbuf + ndig,
   22228:	e59d4070 	ldr	r4, [sp, #112]	@ 0x70
					    PRINT (decimal_point, decp_len);
   2222c:	e28da094 	add	sl, sp, #148	@ 0x94
					PRINTANDPAD (cp, convbuf + ndig,
   22230:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   22234:	eafffe23 	b	21ac8 <_svfprintf_r+0x1060>
			PAD (width - realsz, blanks);
   22238:	e1cd01d0 	ldrd	r0, [sp, #16]
   2223c:	e28d2088 	add	r2, sp, #136	@ 0x88
   22240:	e58d305c 	str	r3, [sp, #92]	@ 0x5c
   22244:	eb000bd5 	bl	251a0 <__ssprint_r>
   22248:	e3500000 	cmp	r0, #0
   2224c:	1afffad8 	bne	20db4 <_svfprintf_r+0x34c>
		if (sign)
   22250:	e5dd106b 	ldrb	r1, [sp, #107]	@ 0x6b
			PAD (width - realsz, blanks);
   22254:	e28da094 	add	sl, sp, #148	@ 0x94
			PRINT (&sign, 1);
   22258:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
			PAD (width - realsz, blanks);
   2225c:	e59d305c 	ldr	r3, [sp, #92]	@ 0x5c
   22260:	eafffb02 	b	20e70 <_svfprintf_r+0x408>
					PRINT ("0", 1);
   22264:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   22268:	e2822001 	add	r2, r2, #1
   2226c:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   22270:	e2833001 	add	r3, r3, #1
   22274:	e3530007 	cmp	r3, #7
   22278:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   2227c:	e30933b4 	movw	r3, #37812	@ 0x93b4
   22280:	e3403002 	movt	r3, #2
   22284:	e58a3000 	str	r3, [sl]
   22288:	e3a03001 	mov	r3, #1
   2228c:	e58a3004 	str	r3, [sl, #4]
   22290:	d28aa008 	addle	sl, sl, #8
   22294:	ca000123 	bgt	22728 <_svfprintf_r+0x1cc0>
					if (expt || ndig || flags & ALT) {
   22298:	e59d3034 	ldr	r3, [sp, #52]	@ 0x34
   2229c:	e1933004 	orrs	r3, r3, r4
   222a0:	0a00017f 	beq	228a4 <_svfprintf_r+0x1e3c>
						PRINT (decimal_point, decp_len);
   222a4:	e59d3040 	ldr	r3, [sp, #64]	@ 0x40
   222a8:	e59d1044 	ldr	r1, [sp, #68]	@ 0x44
   222ac:	e0832002 	add	r2, r3, r2
   222b0:	e88a000a 	stm	sl, {r1, r3}
   222b4:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   222b8:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   222bc:	e2833001 	add	r3, r3, #1
   222c0:	e3530007 	cmp	r3, #7
   222c4:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   222c8:	d28aa008 	addle	sl, sl, #8
   222cc:	ca00016a 	bgt	2287c <_svfprintf_r+0x1e14>
						PAD (-expt, zeroes);
   222d0:	e3540000 	cmp	r4, #0
   222d4:	ba0001b2 	blt	229a4 <_svfprintf_r+0x1f3c>
						PRINT (cp, ndig);
   222d8:	e2833001 	add	r3, r3, #1
   222dc:	e58a5000 	str	r5, [sl]
   222e0:	e3530007 	cmp	r3, #7
   222e4:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   222e8:	e59d3034 	ldr	r3, [sp, #52]	@ 0x34
   222ec:	e0832002 	add	r2, r3, r2
   222f0:	e58a3004 	str	r3, [sl, #4]
   222f4:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   222f8:	dafffb0b 	ble	20f2c <_svfprintf_r+0x4c4>
   222fc:	eafffd40 	b	21804 <_svfprintf_r+0xd9c>
						PRINT(thousands_sep, thsnd_len);
   22300:	e1cd01d0 	ldrd	r0, [sp, #16]
   22304:	e28d2088 	add	r2, sp, #136	@ 0x88
   22308:	eb000ba4 	bl	251a0 <__ssprint_r>
   2230c:	e3500000 	cmp	r0, #0
   22310:	1afffaa7 	bne	20db4 <_svfprintf_r+0x34c>
						PRINTANDPAD (cp, convbuf + ndig,
   22314:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
						PRINT(thousands_sep, thsnd_len);
   22318:	e28d1094 	add	r1, sp, #148	@ 0x94
   2231c:	eaffff64 	b	220b4 <_svfprintf_r+0x164c>
					PRINT ("0", 1);
   22320:	e1cd01d0 	ldrd	r0, [sp, #16]
   22324:	e28d2088 	add	r2, sp, #136	@ 0x88
   22328:	eb000b9c 	bl	251a0 <__ssprint_r>
   2232c:	e3500000 	cmp	r0, #0
   22330:	1afffa9f 	bne	20db4 <_svfprintf_r+0x34c>
						PRINT (decimal_point, decp_len);
   22334:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
					PRINT ("0", 1);
   22338:	e28da094 	add	sl, sp, #148	@ 0x94
   2233c:	eafffc20 	b	213c4 <_svfprintf_r+0x95c>
   22340:	e1a00007 	mov	r0, r7
   22344:	eafffbbc 	b	2123c <_svfprintf_r+0x7d4>
					PRINTANDPAD (cp, convbuf + ndig,
   22348:	e2833001 	add	r3, r3, #1
   2234c:	e0822004 	add	r2, r2, r4
   22350:	e3530007 	cmp	r3, #7
   22354:	e58a8000 	str	r8, [sl]
   22358:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   2235c:	e58a4004 	str	r4, [sl, #4]
   22360:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   22364:	dafffaf0 	ble	20f2c <_svfprintf_r+0x4c4>
   22368:	eafffd25 	b	21804 <_svfprintf_r+0xd9c>
					  *--cp = to_char (_uquad % 10);
   2236c:	e30c7ccd 	movw	r7, #52429	@ 0xcccd
			cp = buf + BUF;
   22370:	e58db00c 	str	fp, [sp, #12]
   22374:	e59d3054 	ldr	r3, [sp, #84]	@ 0x54
   22378:	e1a0b00a 	mov	fp, sl
					  *--cp = to_char (_uquad % 10);
   2237c:	e34c7ccc 	movt	r7, #52428	@ 0xcccc
			cp = buf + BUF;
   22380:	e1a0a009 	mov	sl, r9
					  if ((flags & GROUPING)
   22384:	e2008b01 	and	r8, r0, #1024	@ 0x400
					ndig = 0;
   22388:	e3a0c000 	mov	ip, #0
			cp = buf + BUF;
   2238c:	e28d1f4e 	add	r1, sp, #312	@ 0x138
   22390:	e1a09000 	mov	r9, r0
   22394:	ea000003 	b	223a8 <_svfprintf_r+0x1940>
					} while (_uquad != 0);
   22398:	e3560009 	cmp	r6, #9
   2239c:	9a000016 	bls	223fc <_svfprintf_r+0x1994>
					  _uquad /= 10;
   223a0:	e1a06000 	mov	r6, r0
   223a4:	e1a01005 	mov	r1, r5
					  *--cp = to_char (_uquad % 10);
   223a8:	e0820697 	umull	r0, r2, r7, r6
					  if ((flags & GROUPING)
   223ac:	e3580000 	cmp	r8, #0
					  *--cp = to_char (_uquad % 10);
   223b0:	e2415001 	sub	r5, r1, #1
					  ndig++;
   223b4:	e28cc001 	add	ip, ip, #1
					  *--cp = to_char (_uquad % 10);
   223b8:	e1a021a2 	lsr	r2, r2, #3
					  _uquad /= 10;
   223bc:	e1a00002 	mov	r0, r2
					  *--cp = to_char (_uquad % 10);
   223c0:	e0822102 	add	r2, r2, r2, lsl #2
   223c4:	e0462082 	sub	r2, r6, r2, lsl #1
   223c8:	e2822030 	add	r2, r2, #48	@ 0x30
   223cc:	e5412001 	strb	r2, [r1, #-1]
					  if ((flags & GROUPING)
   223d0:	0afffff0 	beq	22398 <_svfprintf_r+0x1930>
					      && ndig == *grouping
   223d4:	e5d32000 	ldrb	r2, [r3]
					      && *grouping != CHAR_MAX
   223d8:	e042100c 	sub	r1, r2, ip
   223dc:	e35200ff 	cmp	r2, #255	@ 0xff
   223e0:	e16f1f11 	clz	r1, r1
   223e4:	e1a012a1 	lsr	r1, r1, #5
   223e8:	03a01000 	moveq	r1, #0
   223ec:	e3510000 	cmp	r1, #0
   223f0:	0affffe8 	beq	22398 <_svfprintf_r+0x1930>
					      && _uquad > 9) {
   223f4:	e3560009 	cmp	r6, #9
   223f8:	8a000140 	bhi	22900 <_svfprintf_r+0x1e98>
			size = buf + BUF - cp;
   223fc:	e58d3054 	str	r3, [sp, #84]	@ 0x54
   22400:	e28d3f4e 	add	r3, sp, #312	@ 0x138
   22404:	e1a00009 	mov	r0, r9
   22408:	e0433005 	sub	r3, r3, r5
   2240c:	e1a0900a 	mov	r9, sl
   22410:	e1a07000 	mov	r7, r0
   22414:	e1a0a00b 	mov	sl, fp
   22418:	e58dc034 	str	ip, [sp, #52]	@ 0x34
   2241c:	e59db00c 	ldr	fp, [sp, #12]
   22420:	e58d3020 	str	r3, [sp, #32]
   22424:	eafffb4d 	b	21160 <_svfprintf_r+0x6f8>
						PRINTANDPAD (cp, convbuf + ndig,
   22428:	e1cd01d0 	ldrd	r0, [sp, #16]
   2242c:	e28d2088 	add	r2, sp, #136	@ 0x88
   22430:	eb000b5a 	bl	251a0 <__ssprint_r>
   22434:	e3500000 	cmp	r0, #0
   22438:	1afffa5d 	bne	20db4 <_svfprintf_r+0x34c>
   2243c:	e5d70000 	ldrb	r0, [r7]
   22440:	e28d1094 	add	r1, sp, #148	@ 0x94
   22444:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   22448:	eaffff2b 	b	220fc <_svfprintf_r+0x1694>
				size = ((unsigned) prec > 6U) ? 6 : prec;
   2244c:	e3590006 	cmp	r9, #6
   22450:	e1a01005 	mov	r1, r5
   22454:	31a03009 	movcc	r3, r9
   22458:	23a03006 	movcs	r3, #6
   2245c:	e1a09005 	mov	r9, r5
   22460:	e58d5024 	str	r5, [sp, #36]	@ 0x24
				cp = "(null)";
   22464:	e30951cc 	movw	r5, #37324	@ 0x91cc
			cp = GET_ARG (N, ap, char_ptr_t);
   22468:	e58d6028 	str	r6, [sp, #40]	@ 0x28
				cp = "(null)";
   2246c:	e3405002 	movt	r5, #2
				size = ((unsigned) prec > 6U) ? 6 : prec;
   22470:	e58d300c 	str	r3, [sp, #12]
   22474:	e58d3020 	str	r3, [sp, #32]
		nseps = nrepeats = 0;
   22478:	e58d903c 	str	r9, [sp, #60]	@ 0x3c
   2247c:	e58d9038 	str	r9, [sp, #56]	@ 0x38
		lead = 0;
   22480:	e58d9030 	str	r9, [sp, #48]	@ 0x30
   22484:	eafffb3f 	b	21188 <_svfprintf_r+0x720>
	FLUSH ();
   22488:	e59d3090 	ldr	r3, [sp, #144]	@ 0x90
   2248c:	e3530000 	cmp	r3, #0
   22490:	0afffa4d 	beq	20dcc <_svfprintf_r+0x364>
   22494:	e1cd01d0 	ldrd	r0, [sp, #16]
   22498:	e28d2088 	add	r2, sp, #136	@ 0x88
   2249c:	eb000b3f 	bl	251a0 <__ssprint_r>
   224a0:	eafffa49 	b	20dcc <_svfprintf_r+0x364>
						PAD (ndig - 1, zeroes);
   224a4:	e2833001 	add	r3, r3, #1
   224a8:	e5818000 	str	r8, [r1]
   224ac:	eafffcc2 	b	217bc <_svfprintf_r+0xd54>
			else if (flags & CHARINT)
   224b0:	e3170c02 	tst	r7, #512	@ 0x200
   224b4:	0afffba2 	beq	21344 <_svfprintf_r+0x8dc>
				*GET_ARG (N, ap, char_ptr_t) = ret;
   224b8:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
   224bc:	e59d201c 	ldr	r2, [sp, #28]
   224c0:	e5933000 	ldr	r3, [r3]
   224c4:	e5c32000 	strb	r2, [r3]
   224c8:	eafffba1 	b	21354 <_svfprintf_r+0x8ec>
			if (prec == -1) {
   224cc:	e3790001 	cmn	r9, #1
				prec = DEFPREC;
   224d0:	03a09006 	moveq	r9, #6
			if (prec == -1) {
   224d4:	0a000002 	beq	224e4 <_svfprintf_r+0x1a7c>
				prec = 1;
   224d8:	e3590000 	cmp	r9, #0
   224dc:	03560047 	cmpeq	r6, #71	@ 0x47
   224e0:	03a09001 	moveq	r9, #1
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
   224e4:	ee183a90 	vmov	r3, s17
   224e8:	e3530000 	cmp	r3, #0
			flags |= FPT;
   224ec:	e3873c01 	orr	r3, r7, #256	@ 0x100
   224f0:	e58d3024 	str	r3, [sp, #36]	@ 0x24
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
   224f4:	ba0001c8 	blt	22c1c <_svfprintf_r+0x21b4>
   224f8:	eeb09b48 	vmov.f64	d9, d8
		*sign = '\000';
   224fc:	e3a08000 	mov	r8, #0
	if (ch == 'f' || ch == 'F') {
   22500:	e3540065 	cmp	r4, #101	@ 0x65
   22504:	0a00009f 	beq	22788 <_svfprintf_r+0x1d20>
   22508:	ca0000ca 	bgt	22838 <_svfprintf_r+0x1dd0>
   2250c:	e3540045 	cmp	r4, #69	@ 0x45
   22510:	0a00009c 	beq	22788 <_svfprintf_r+0x1d20>
   22514:	e3540046 	cmp	r4, #70	@ 0x46
   22518:	1a0000c8 	bne	22840 <_svfprintf_r+0x1dd8>
		mode = 2;		/* ndigits significant digits */
   2251c:	e1a02009 	mov	r2, r9
   22520:	e3a01003 	mov	r1, #3
	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   22524:	e28d3080 	add	r3, sp, #128	@ 0x80
   22528:	e59d0010 	ldr	r0, [sp, #16]
   2252c:	e58d3004 	str	r3, [sp, #4]
   22530:	e28d3074 	add	r3, sp, #116	@ 0x74
   22534:	e58d3000 	str	r3, [sp]
   22538:	e28d3070 	add	r3, sp, #112	@ 0x70
   2253c:	eeb00b49 	vmov.f64	d0, d9
   22540:	e58d200c 	str	r2, [sp, #12]
   22544:	eb000eda 	bl	260b4 <_dtoa_r>
		bp = digits + ndigits;
   22548:	e59d200c 	ldr	r2, [sp, #12]
		if (ch == 'f' || ch == 'F') {
   2254c:	e3560046 	cmp	r6, #70	@ 0x46
	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   22550:	e1a05000 	mov	r5, r0
		bp = digits + ndigits;
   22554:	e0801002 	add	r1, r0, r2
		if (ch == 'f' || ch == 'F') {
   22558:	1a000004 	bne	22570 <_svfprintf_r+0x1b08>
			if (*digits == '0' && value)
   2255c:	e5d53000 	ldrb	r3, [r5]
   22560:	e3530030 	cmp	r3, #48	@ 0x30
   22564:	0a000130 	beq	22a2c <_svfprintf_r+0x1fc4>
			bp += *decpt;
   22568:	e59d3070 	ldr	r3, [sp, #112]	@ 0x70
   2256c:	e0811003 	add	r1, r1, r3
		if (value == 0)	/* kludge for __dtoa irregularity */
   22570:	eeb59b40 	vcmp.f64	d9, #0.0
   22574:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   22578:	0a0000fa 	beq	22968 <_svfprintf_r+0x1f00>
		while (rve < bp)
   2257c:	e59d3080 	ldr	r3, [sp, #128]	@ 0x80
   22580:	e1530001 	cmp	r3, r1
   22584:	2a000006 	bcs	225a4 <_svfprintf_r+0x1b3c>
			*rve++ = '0';
   22588:	e3a00030 	mov	r0, #48	@ 0x30
   2258c:	e2832001 	add	r2, r3, #1
   22590:	e58d2080 	str	r2, [sp, #128]	@ 0x80
   22594:	e5c30000 	strb	r0, [r3]
		while (rve < bp)
   22598:	e59d3080 	ldr	r3, [sp, #128]	@ 0x80
   2259c:	e1510003 	cmp	r1, r3
   225a0:	8afffff9 	bhi	2258c <_svfprintf_r+0x1b24>
				if (expt <= -4 || expt > prec)
   225a4:	e59d2070 	ldr	r2, [sp, #112]	@ 0x70
   225a8:	e58d2030 	str	r2, [sp, #48]	@ 0x30
			if (ch == 'g' || ch == 'G') {
   225ac:	e3560047 	cmp	r6, #71	@ 0x47
	*length = rve - digits;
   225b0:	e0433005 	sub	r3, r3, r5
   225b4:	e58d3034 	str	r3, [sp, #52]	@ 0x34
			if (ch == 'g' || ch == 'G') {
   225b8:	0a00007a 	beq	227a8 <_svfprintf_r+0x1d40>
			else if (ch == 'F')
   225bc:	e3560046 	cmp	r6, #70	@ 0x46
				--expt;
   225c0:	159d3030 	ldrne	r3, [sp, #48]	@ 0x30
   225c4:	12433001 	subne	r3, r3, #1
			else if (ch == 'F')
   225c8:	0a00011f 	beq	22a4c <_svfprintf_r+0x1fe4>
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
   225cc:	e6ef2074 	uxtb	r2, r4
   225d0:	e3a01000 	mov	r1, #0
				--expt;
   225d4:	e58d3070 	str	r3, [sp, #112]	@ 0x70
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
   225d8:	e58d1024 	str	r1, [sp, #36]	@ 0x24
	if (exp < 0) {
   225dc:	e3530000 	cmp	r3, #0
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
   225e0:	e5cd2078 	strb	r2, [sp, #120]	@ 0x78
		exp = -exp;
   225e4:	b59d3030 	ldrlt	r3, [sp, #48]	@ 0x30
		*p++ = '-';
   225e8:	b3a0202d 	movlt	r2, #45	@ 0x2d
	}
	else
		*p++ = '+';
   225ec:	a3a0202b 	movge	r2, #43	@ 0x2b
   225f0:	e5cd2079 	strb	r2, [sp, #121]	@ 0x79
		exp = -exp;
   225f4:	b2633001 	rsblt	r3, r3, #1
	t = expbuf + MAXEXPLEN;
	if (exp > 9) {
   225f8:	e3530009 	cmp	r3, #9
   225fc:	da000146 	ble	22b1c <_svfprintf_r+0x20b4>
	t = expbuf + MAXEXPLEN;
   22600:	e28de087 	add	lr, sp, #135	@ 0x87
		do {
			*--t = to_char (exp % 10);
   22604:	e30c6ccd 	movw	r6, #52429	@ 0xcccd
   22608:	e34c6ccc 	movt	r6, #52428	@ 0xcccc
	t = expbuf + MAXEXPLEN;
   2260c:	e1a0c00e 	mov	ip, lr
			*--t = to_char (exp % 10);
   22610:	e0812396 	umull	r2, r1, r6, r3
		} while ((exp /= 10) > 9);
   22614:	e3530063 	cmp	r3, #99	@ 0x63
   22618:	e1a0000c 	mov	r0, ip
			*--t = to_char (exp % 10);
   2261c:	e24cc001 	sub	ip, ip, #1
   22620:	e1a011a1 	lsr	r1, r1, #3
   22624:	e0812101 	add	r2, r1, r1, lsl #2
   22628:	e0432082 	sub	r2, r3, r2, lsl #1
		} while ((exp /= 10) > 9);
   2262c:	e1a03001 	mov	r3, r1
			*--t = to_char (exp % 10);
   22630:	e2822030 	add	r2, r2, #48	@ 0x30
   22634:	e5402001 	strb	r2, [r0, #-1]
		} while ((exp /= 10) > 9);
   22638:	cafffff4 	bgt	22610 <_svfprintf_r+0x1ba8>
		*--t = to_char (exp);
   2263c:	e2813030 	add	r3, r1, #48	@ 0x30
   22640:	e54c3001 	strb	r3, [ip, #-1]
   22644:	e2403002 	sub	r3, r0, #2
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
   22648:	e153000e 	cmp	r3, lr
   2264c:	2a0001a6 	bcs	22cec <_svfprintf_r+0x2284>
   22650:	e28d2079 	add	r2, sp, #121	@ 0x79
   22654:	e4d31001 	ldrb	r1, [r3], #1
   22658:	e153000e 	cmp	r3, lr
   2265c:	e5e21001 	strb	r1, [r2, #1]!
   22660:	1afffffb 	bne	22654 <_svfprintf_r+0x1bec>
	else {
		if (!isa)
			*p++ = '0';
		*p++ = to_char (exp);
	}
	return (p - p0);
   22664:	e28d3f4e 	add	r3, sp, #312	@ 0x138
   22668:	e0430000 	sub	r0, r3, r0
   2266c:	e24030ad 	sub	r3, r0, #173	@ 0xad
   22670:	e58d3048 	str	r3, [sp, #72]	@ 0x48
				if (ndig > 1 || flags & ALT)
   22674:	e59d3034 	ldr	r3, [sp, #52]	@ 0x34
				size = expsize + ndig;
   22678:	e59d2048 	ldr	r2, [sp, #72]	@ 0x48
				if (ndig > 1 || flags & ALT)
   2267c:	e3530001 	cmp	r3, #1
				size = expsize + ndig;
   22680:	e0833002 	add	r3, r3, r2
   22684:	e58d3020 	str	r3, [sp, #32]
				if (ndig > 1 || flags & ALT)
   22688:	da00012e 	ble	22b48 <_svfprintf_r+0x20e0>
					size += decp_len;
   2268c:	e59d3020 	ldr	r3, [sp, #32]
   22690:	e59d2040 	ldr	r2, [sp, #64]	@ 0x40
   22694:	e0833002 	add	r3, r3, r2
   22698:	e58d3020 	str	r3, [sp, #32]
		realsz = dprec > size ? dprec : size;
   2269c:	e59d2020 	ldr	r2, [sp, #32]
   226a0:	e3c73b01 	bic	r3, r7, #1024	@ 0x400
				flags &= ~GROUPING;
   226a4:	e3837c01 	orr	r7, r3, #256	@ 0x100
		nseps = nrepeats = 0;
   226a8:	e3a03000 	mov	r3, #0
   226ac:	e58d303c 	str	r3, [sp, #60]	@ 0x3c
   226b0:	e58d3038 	str	r3, [sp, #56]	@ 0x38
		realsz = dprec > size ? dprec : size;
   226b4:	e1c22fc2 	bic	r2, r2, r2, asr #31
		lead = 0;
   226b8:	e58d3030 	str	r3, [sp, #48]	@ 0x30
		realsz = dprec > size ? dprec : size;
   226bc:	e58d200c 	str	r2, [sp, #12]
			if (softsign)
   226c0:	e3580000 	cmp	r8, #0
   226c4:	1a00003e 	bne	227c4 <_svfprintf_r+0x1d5c>
		if (sign)
   226c8:	e5dd106b 	ldrb	r1, [sp, #107]	@ 0x6b
		dprec = 0;
   226cc:	e1a09008 	mov	r9, r8
   226d0:	eafffaac 	b	21188 <_svfprintf_r+0x720>
   226d4:	e1a05007 	mov	r5, r7
   226d8:	e1a07008 	mov	r7, r8
   226dc:	e1a0800a 	mov	r8, sl
   226e0:	e1a0a001 	mov	sl, r1
					PRINTANDPAD(cp, convbuf + ndig,
   226e4:	e2833001 	add	r3, r3, #1
   226e8:	e0822004 	add	r2, r2, r4
   226ec:	e3530007 	cmp	r3, #7
   226f0:	e58a8000 	str	r8, [sl]
   226f4:	e58a4004 	str	r4, [sl, #4]
   226f8:	d28aa008 	addle	sl, sl, #8
   226fc:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   22700:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   22704:	dafffce5 	ble	21aa0 <_svfprintf_r+0x1038>
   22708:	e1cd01d0 	ldrd	r0, [sp, #16]
   2270c:	e28d2088 	add	r2, sp, #136	@ 0x88
   22710:	eb000aa2 	bl	251a0 <__ssprint_r>
   22714:	e3500000 	cmp	r0, #0
   22718:	1afff9a5 	bne	20db4 <_svfprintf_r+0x34c>
					    PRINT (decimal_point, decp_len);
   2271c:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
					PRINTANDPAD(cp, convbuf + ndig,
   22720:	e28da094 	add	sl, sp, #148	@ 0x94
   22724:	eafffcdd 	b	21aa0 <_svfprintf_r+0x1038>
					PRINT ("0", 1);
   22728:	e1cd01d0 	ldrd	r0, [sp, #16]
   2272c:	e28d2088 	add	r2, sp, #136	@ 0x88
   22730:	eb000a9a 	bl	251a0 <__ssprint_r>
   22734:	e3500000 	cmp	r0, #0
   22738:	1afff99d 	bne	20db4 <_svfprintf_r+0x34c>
					if (expt || ndig || flags & ALT) {
   2273c:	e59d4070 	ldr	r4, [sp, #112]	@ 0x70
					PRINT ("0", 1);
   22740:	e28da094 	add	sl, sp, #148	@ 0x94
						PRINT (decimal_point, decp_len);
   22744:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   22748:	eafffed2 	b	22298 <_svfprintf_r+0x1830>
					PRINTANDPAD(cp, convbuf + ndig,
   2274c:	e1cd01d0 	ldrd	r0, [sp, #16]
   22750:	e28d2088 	add	r2, sp, #136	@ 0x88
   22754:	eb000a91 	bl	251a0 <__ssprint_r>
   22758:	e3500000 	cmp	r0, #0
   2275c:	1afff994 	bne	20db4 <_svfprintf_r+0x34c>
   22760:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   22764:	e28da094 	add	sl, sp, #148	@ 0x94
   22768:	eafffcc7 	b	21a8c <_svfprintf_r+0x1024>
					 (char *)_malloc_r (data, prec + 1))
   2276c:	e59d0010 	ldr	r0, [sp, #16]
   22770:	e2891001 	add	r1, r9, #1
   22774:	ebfff372 	bl	1f544 <_malloc_r>
				    if ((malloc_buf =
   22778:	e2505000 	subs	r5, r0, #0
   2277c:	0a00015d 	beq	22cf8 <_svfprintf_r+0x2290>
					 (char *)_malloc_r (data, prec + 1))
   22780:	e58d5024 	str	r5, [sp, #36]	@ 0x24
   22784:	eafffd73 	b	21d58 <_svfprintf_r+0x12f0>
			ndigits++;
   22788:	e2892001 	add	r2, r9, #1
		mode = 2;		/* ndigits significant digits */
   2278c:	e3a01002 	mov	r1, #2
   22790:	eaffff63 	b	22524 <_svfprintf_r+0x1abc>
	*length = rve - digits;
   22794:	e59d3080 	ldr	r3, [sp, #128]	@ 0x80
   22798:	e0433000 	sub	r3, r3, r0
   2279c:	e58d3034 	str	r3, [sp, #52]	@ 0x34
				if (expt <= -4 || expt > prec)
   227a0:	e59d3070 	ldr	r3, [sp, #112]	@ 0x70
   227a4:	e58d3030 	str	r3, [sp, #48]	@ 0x30
   227a8:	e59d3030 	ldr	r3, [sp, #48]	@ 0x30
   227ac:	e3730003 	cmn	r3, #3
   227b0:	a1590003 	cmpge	r9, r3
   227b4:	aa000006 	bge	227d4 <_svfprintf_r+0x1d6c>
					ch -= 2; /* 'e' or 'E' */
   227b8:	e2444002 	sub	r4, r4, #2
				--expt;
   227bc:	e2433001 	sub	r3, r3, #1
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
   227c0:	eaffff81 	b	225cc <_svfprintf_r+0x1b64>
				sign = '-';
   227c4:	e3a0102d 	mov	r1, #45	@ 0x2d
		dprec = 0;
   227c8:	e3a09000 	mov	r9, #0
				sign = '-';
   227cc:	e5cd106b 	strb	r1, [sp, #107]	@ 0x6b
   227d0:	eafffa6e 	b	21190 <_svfprintf_r+0x728>
				} else if (expt >= ndig) { /* fixed g fmt */
   227d4:	e59d3030 	ldr	r3, [sp, #48]	@ 0x30
   227d8:	e59d2034 	ldr	r2, [sp, #52]	@ 0x34
   227dc:	e1530002 	cmp	r3, r2
   227e0:	ba0000a9 	blt	22a8c <_svfprintf_r+0x2024>
						size += decp_len;
   227e4:	e59d3030 	ldr	r3, [sp, #48]	@ 0x30
					if (flags & ALT)
   227e8:	e3170001 	tst	r7, #1
					size = expt;
   227ec:	058d3020 	streq	r3, [sp, #32]
						size += decp_len;
   227f0:	159d2040 	ldrne	r2, [sp, #64]	@ 0x40
   227f4:	10833002 	addne	r3, r3, r2
   227f8:	158d3020 	strne	r3, [sp, #32]
				if ((flags & GROUPING) && expt > 0) {
   227fc:	e3170b01 	tst	r7, #1024	@ 0x400
   22800:	0a000002 	beq	22810 <_svfprintf_r+0x1da8>
   22804:	e59d3030 	ldr	r3, [sp, #48]	@ 0x30
   22808:	e3530000 	cmp	r3, #0
   2280c:	ca0000d3 	bgt	22b60 <_svfprintf_r+0x20f8>
		realsz = dprec > size ? dprec : size;
   22810:	e59d3020 	ldr	r3, [sp, #32]
   22814:	e3a04067 	mov	r4, #103	@ 0x67
   22818:	e1c33fc3 	bic	r3, r3, r3, asr #31
   2281c:	e58d300c 	str	r3, [sp, #12]
			flags |= FPT;
   22820:	e3a03000 	mov	r3, #0
   22824:	e59d7024 	ldr	r7, [sp, #36]	@ 0x24
		nseps = nrepeats = 0;
   22828:	e58d303c 	str	r3, [sp, #60]	@ 0x3c
			flags |= FPT;
   2282c:	e58d3024 	str	r3, [sp, #36]	@ 0x24
		nseps = nrepeats = 0;
   22830:	e58d3038 	str	r3, [sp, #56]	@ 0x38
   22834:	eaffffa1 	b	226c0 <_svfprintf_r+0x1c58>
   22838:	e3540066 	cmp	r4, #102	@ 0x66
   2283c:	0affff36 	beq	2251c <_svfprintf_r+0x1ab4>
	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   22840:	e28d3080 	add	r3, sp, #128	@ 0x80
   22844:	e59d0010 	ldr	r0, [sp, #16]
   22848:	e58d3004 	str	r3, [sp, #4]
   2284c:	e28d3074 	add	r3, sp, #116	@ 0x74
   22850:	e58d3000 	str	r3, [sp]
   22854:	e1a02009 	mov	r2, r9
   22858:	eeb00b49 	vmov.f64	d0, d9
   2285c:	e28d3070 	add	r3, sp, #112	@ 0x70
   22860:	e3a01002 	mov	r1, #2
   22864:	eb000e12 	bl	260b4 <_dtoa_r>
	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   22868:	e3170001 	tst	r7, #1
	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   2286c:	e1a05000 	mov	r5, r0
	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   22870:	0affffc7 	beq	22794 <_svfprintf_r+0x1d2c>
		bp = digits + ndigits;
   22874:	e0801009 	add	r1, r0, r9
		if (ch == 'f' || ch == 'F') {
   22878:	eaffff3c 	b	22570 <_svfprintf_r+0x1b08>
						PRINT (decimal_point, decp_len);
   2287c:	e1cd01d0 	ldrd	r0, [sp, #16]
   22880:	e28d2088 	add	r2, sp, #136	@ 0x88
   22884:	eb000a45 	bl	251a0 <__ssprint_r>
   22888:	e3500000 	cmp	r0, #0
   2288c:	1afff948 	bne	20db4 <_svfprintf_r+0x34c>
						PAD (-expt, zeroes);
   22890:	e59d4070 	ldr	r4, [sp, #112]	@ 0x70
						PRINT (decimal_point, decp_len);
   22894:	e28da094 	add	sl, sp, #148	@ 0x94
						PAD (-expt, zeroes);
   22898:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   2289c:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   228a0:	eafffe8a 	b	222d0 <_svfprintf_r+0x1868>
					if (expt || ndig || flags & ALT) {
   228a4:	e3170001 	tst	r7, #1
   228a8:	0afff9a0 	beq	20f30 <_svfprintf_r+0x4c8>
						PRINT (decimal_point, decp_len);
   228ac:	e59d3040 	ldr	r3, [sp, #64]	@ 0x40
   228b0:	e59d1044 	ldr	r1, [sp, #68]	@ 0x44
   228b4:	e0832002 	add	r2, r3, r2
   228b8:	e88a000a 	stm	sl, {r1, r3}
   228bc:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   228c0:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   228c4:	e2833001 	add	r3, r3, #1
   228c8:	e3530007 	cmp	r3, #7
   228cc:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   228d0:	caffffe9 	bgt	2287c <_svfprintf_r+0x1e14>
   228d4:	e28aa008 	add	sl, sl, #8
   228d8:	eafffe7e 	b	222d8 <_svfprintf_r+0x1870>
						PRINTANDPAD (cp, convbuf + ndig,
   228dc:	e1cd01d0 	ldrd	r0, [sp, #16]
   228e0:	e28d2088 	add	r2, sp, #136	@ 0x88
   228e4:	eb000a2d 	bl	251a0 <__ssprint_r>
   228e8:	e3500000 	cmp	r0, #0
   228ec:	1afff930 	bne	20db4 <_svfprintf_r+0x34c>
						cp += *grouping;
   228f0:	e5d70000 	ldrb	r0, [r7]
						PRINTANDPAD (cp, convbuf + ndig,
   228f4:	e28d1094 	add	r1, sp, #148	@ 0x94
					    PRINT (decimal_point, decp_len);
   228f8:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   228fc:	eafffdd7 	b	22060 <_svfprintf_r+0x15f8>
   22900:	e58d3020 	str	r3, [sp, #32]
					    cp -= thsnd_len;
   22904:	e59d3058 	ldr	r3, [sp, #88]	@ 0x58
					    strncpy (cp, thousands_sep,
   22908:	e59d1050 	ldr	r1, [sp, #80]	@ 0x50
					    cp -= thsnd_len;
   2290c:	e0455003 	sub	r5, r5, r3
					    strncpy (cp, thousands_sep,
   22910:	e1a02003 	mov	r2, r3
   22914:	e1a00005 	mov	r0, r5
   22918:	ebffe03d 	bl	1aa14 <strncpy>
					    if (grouping[1] != '\0')
   2291c:	e59d3020 	ldr	r3, [sp, #32]
					  _uquad /= 10;
   22920:	e3a0c000 	mov	ip, #0
					    if (grouping[1] != '\0')
   22924:	e5d32001 	ldrb	r2, [r3, #1]
   22928:	e3520000 	cmp	r2, #0
					  _uquad /= 10;
   2292c:	e30c2ccd 	movw	r2, #52429	@ 0xcccd
   22930:	e34c2ccc 	movt	r2, #52428	@ 0xcccc
					      grouping++;
   22934:	12833001 	addne	r3, r3, #1
					  _uquad /= 10;
   22938:	e0826692 	umull	r6, r2, r2, r6
   2293c:	e1a001a2 	lsr	r0, r2, #3
					} while (_uquad != 0);
   22940:	eafffe96 	b	223a0 <_svfprintf_r+0x1938>
		if (sign)
   22944:	e58d900c 	str	r9, [sp, #12]
					size = prec;
   22948:	e58d9020 	str	r9, [sp, #32]
		dprec = 0;
   2294c:	e1a09000 	mov	r9, r0
		if (sign)
   22950:	e5dd106b 	ldrb	r1, [sp, #107]	@ 0x6b
			cp = GET_ARG (N, ap, char_ptr_t);
   22954:	e58d6028 	str	r6, [sp, #40]	@ 0x28
		nseps = nrepeats = 0;
   22958:	e58d003c 	str	r0, [sp, #60]	@ 0x3c
   2295c:	e58d0038 	str	r0, [sp, #56]	@ 0x38
		lead = 0;
   22960:	e58d0030 	str	r0, [sp, #48]	@ 0x30
   22964:	eafffa07 	b	21188 <_svfprintf_r+0x720>
				if (expt <= -4 || expt > prec)
   22968:	e59d2070 	ldr	r2, [sp, #112]	@ 0x70
   2296c:	e1a03001 	mov	r3, r1
   22970:	e58d2030 	str	r2, [sp, #48]	@ 0x30
		while (rve < bp)
   22974:	eaffff0c 	b	225ac <_svfprintf_r+0x1b44>
					PRINTANDPAD (cp, convbuf + ndig,
   22978:	e1cd01d0 	ldrd	r0, [sp, #16]
   2297c:	e28d2088 	add	r2, sp, #136	@ 0x88
   22980:	eb000a06 	bl	251a0 <__ssprint_r>
   22984:	e3500000 	cmp	r0, #0
   22988:	1afff909 	bne	20db4 <_svfprintf_r+0x34c>
   2298c:	e59d4070 	ldr	r4, [sp, #112]	@ 0x70
   22990:	e28da094 	add	sl, sp, #148	@ 0x94
   22994:	e59d3034 	ldr	r3, [sp, #52]	@ 0x34
			PAD (width - realsz, blanks);
   22998:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
					PRINTANDPAD (cp, convbuf + ndig,
   2299c:	e0434004 	sub	r4, r3, r4
   229a0:	eafffc5a 	b	21b10 <_svfprintf_r+0x10a8>
						PAD (-expt, zeroes);
   229a4:	e3740010 	cmn	r4, #16
   229a8:	e51f8860 	ldr	r8, [pc, #-2144]	@ 22150 <_svfprintf_r+0x16e8>
   229ac:	e2644000 	rsb	r4, r4, #0
   229b0:	aa000048 	bge	22ad8 <_svfprintf_r+0x2070>
   229b4:	e1a0100a 	mov	r1, sl
   229b8:	e59d9010 	ldr	r9, [sp, #16]
   229bc:	e1a0a008 	mov	sl, r8
   229c0:	e3a06010 	mov	r6, #16
   229c4:	e1a08007 	mov	r8, r7
   229c8:	e1a07005 	mov	r7, r5
   229cc:	e59d5014 	ldr	r5, [sp, #20]
   229d0:	ea000002 	b	229e0 <_svfprintf_r+0x1f78>
   229d4:	e2444010 	sub	r4, r4, #16
   229d8:	e3540010 	cmp	r4, #16
   229dc:	da000039 	ble	22ac8 <_svfprintf_r+0x2060>
   229e0:	e2833001 	add	r3, r3, #1
   229e4:	e2822010 	add	r2, r2, #16
   229e8:	e3530007 	cmp	r3, #7
   229ec:	e581a000 	str	sl, [r1]
   229f0:	e5816004 	str	r6, [r1, #4]
   229f4:	d2811008 	addle	r1, r1, #8
   229f8:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   229fc:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   22a00:	dafffff3 	ble	229d4 <_svfprintf_r+0x1f6c>
   22a04:	e28d2088 	add	r2, sp, #136	@ 0x88
   22a08:	e1a01005 	mov	r1, r5
   22a0c:	e1a00009 	mov	r0, r9
   22a10:	eb0009e2 	bl	251a0 <__ssprint_r>
   22a14:	e3500000 	cmp	r0, #0
   22a18:	1afff8e5 	bne	20db4 <_svfprintf_r+0x34c>
   22a1c:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   22a20:	e28d1094 	add	r1, sp, #148	@ 0x94
   22a24:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   22a28:	eaffffe9 	b	229d4 <_svfprintf_r+0x1f6c>
			if (*digits == '0' && value)
   22a2c:	eeb59b40 	vcmp.f64	d9, #0.0
   22a30:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   22a34:	1a00009a 	bne	22ca4 <_svfprintf_r+0x223c>
			bp += *decpt;
   22a38:	e59d3070 	ldr	r3, [sp, #112]	@ 0x70
   22a3c:	e0811003 	add	r1, r1, r3
   22a40:	e58d3030 	str	r3, [sp, #48]	@ 0x30
	*length = rve - digits;
   22a44:	e0413005 	sub	r3, r1, r5
   22a48:	e58d3034 	str	r3, [sp, #52]	@ 0x34
					if (expt > 0) {
   22a4c:	e59d2030 	ldr	r2, [sp, #48]	@ 0x30
   22a50:	e2073001 	and	r3, r7, #1
   22a54:	e1833009 	orr	r3, r3, r9
   22a58:	e3520000 	cmp	r2, #0
   22a5c:	da000089 	ble	22c88 <_svfprintf_r+0x2220>
						if (prec || flags & ALT)
   22a60:	e3530000 	cmp	r3, #0
   22a64:	1a000078 	bne	22c4c <_svfprintf_r+0x21e4>
						size = expt;
   22a68:	e59d3030 	ldr	r3, [sp, #48]	@ 0x30
   22a6c:	e3a04066 	mov	r4, #102	@ 0x66
   22a70:	e58d3020 	str	r3, [sp, #32]
				if ((flags & GROUPING) && expt > 0) {
   22a74:	e3170b01 	tst	r7, #1024	@ 0x400
   22a78:	1a000039 	bne	22b64 <_svfprintf_r+0x20fc>
		realsz = dprec > size ? dprec : size;
   22a7c:	e59d3020 	ldr	r3, [sp, #32]
   22a80:	e1c33fc3 	bic	r3, r3, r3, asr #31
   22a84:	e58d300c 	str	r3, [sp, #12]
   22a88:	eaffff64 	b	22820 <_svfprintf_r+0x1db8>
					if (expt <= 0)
   22a8c:	e59d3030 	ldr	r3, [sp, #48]	@ 0x30
					size = ndig + decp_len;
   22a90:	e59d2034 	ldr	r2, [sp, #52]	@ 0x34
   22a94:	e59d1040 	ldr	r1, [sp, #64]	@ 0x40
					if (expt <= 0)
   22a98:	e3530000 	cmp	r3, #0
					ch = 'g';
   22a9c:	c3a04067 	movgt	r4, #103	@ 0x67
					size = ndig + decp_len;
   22aa0:	e0822001 	add	r2, r2, r1
   22aa4:	e58d2020 	str	r2, [sp, #32]
					if (expt <= 0)
   22aa8:	cafffff1 	bgt	22a74 <_svfprintf_r+0x200c>
						size += 1 - expt;
   22aac:	e2633001 	rsb	r3, r3, #1
					ch = 'g';
   22ab0:	e3a04067 	mov	r4, #103	@ 0x67
						size += 1 - expt;
   22ab4:	e0823003 	add	r3, r2, r3
   22ab8:	e58d3020 	str	r3, [sp, #32]
		realsz = dprec > size ? dprec : size;
   22abc:	e1c33fc3 	bic	r3, r3, r3, asr #31
   22ac0:	e58d300c 	str	r3, [sp, #12]
   22ac4:	eaffff55 	b	22820 <_svfprintf_r+0x1db8>
   22ac8:	e1a05007 	mov	r5, r7
   22acc:	e1a07008 	mov	r7, r8
   22ad0:	e1a0800a 	mov	r8, sl
   22ad4:	e1a0a001 	mov	sl, r1
						PAD (-expt, zeroes);
   22ad8:	e2833001 	add	r3, r3, #1
   22adc:	e0822004 	add	r2, r2, r4
   22ae0:	e3530007 	cmp	r3, #7
   22ae4:	e58a8000 	str	r8, [sl]
   22ae8:	e58a4004 	str	r4, [sl, #4]
   22aec:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   22af0:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   22af4:	daffff76 	ble	228d4 <_svfprintf_r+0x1e6c>
   22af8:	e1cd01d0 	ldrd	r0, [sp, #16]
   22afc:	e28d2088 	add	r2, sp, #136	@ 0x88
   22b00:	eb0009a6 	bl	251a0 <__ssprint_r>
   22b04:	e3500000 	cmp	r0, #0
   22b08:	1afff8a9 	bne	20db4 <_svfprintf_r+0x34c>
						PRINT (cp, ndig);
   22b0c:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
						PAD (-expt, zeroes);
   22b10:	e28da094 	add	sl, sp, #148	@ 0x94
						PRINT (cp, ndig);
   22b14:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   22b18:	eafffdee 	b	222d8 <_svfprintf_r+0x1870>
		if (!isa)
   22b1c:	e3510000 	cmp	r1, #0
		*p++ = to_char (exp);
   22b20:	e2833030 	add	r3, r3, #48	@ 0x30
			*p++ = '0';
   22b24:	03a02030 	moveq	r2, #48	@ 0x30
   22b28:	128d207a 	addne	r2, sp, #122	@ 0x7a
   22b2c:	05cd207a 	strbeq	r2, [sp, #122]	@ 0x7a
   22b30:	028d207b 	addeq	r2, sp, #123	@ 0x7b
		*p++ = to_char (exp);
   22b34:	e4c23001 	strb	r3, [r2], #1
	return (p - p0);
   22b38:	e28d3078 	add	r3, sp, #120	@ 0x78
   22b3c:	e0423003 	sub	r3, r2, r3
   22b40:	e58d3048 	str	r3, [sp, #72]	@ 0x48
   22b44:	eafffeca 	b	22674 <_svfprintf_r+0x1c0c>
				if (ndig > 1 || flags & ALT)
   22b48:	e3170001 	tst	r7, #1
   22b4c:	0afffed2 	beq	2269c <_svfprintf_r+0x1c34>
   22b50:	eafffecd 	b	2268c <_svfprintf_r+0x1c24>
			return EOF;
   22b54:	e3e03000 	mvn	r3, #0
   22b58:	e58d301c 	str	r3, [sp, #28]
   22b5c:	eafff89e 	b	20ddc <_svfprintf_r+0x374>
   22b60:	e3a04067 	mov	r4, #103	@ 0x67
					while (*grouping != CHAR_MAX) {
   22b64:	e59d1054 	ldr	r1, [sp, #84]	@ 0x54
   22b68:	e5d13000 	ldrb	r3, [r1]
   22b6c:	e35300ff 	cmp	r3, #255	@ 0xff
   22b70:	0a000069 	beq	22d1c <_svfprintf_r+0x22b4>
					nseps = nrepeats = 0;
   22b74:	e3a00000 	mov	r0, #0
   22b78:	e59d2030 	ldr	r2, [sp, #48]	@ 0x30
   22b7c:	e1a0c000 	mov	ip, r0
   22b80:	ea000008 	b	22ba8 <_svfprintf_r+0x2140>
						lead -= *grouping;
   22b84:	e0422003 	sub	r2, r2, r3
						if (grouping[1]) {
   22b88:	e5d13001 	ldrb	r3, [r1, #1]
   22b8c:	e3530000 	cmp	r3, #0
					while (*grouping != CHAR_MAX) {
   22b90:	05d13000 	ldrbeq	r3, [r1]
							nseps++;
   22b94:	128cc001 	addne	ip, ip, #1
							grouping++;
   22b98:	12811001 	addne	r1, r1, #1
							nrepeats++;
   22b9c:	02800001 	addeq	r0, r0, #1
					while (*grouping != CHAR_MAX) {
   22ba0:	e35300ff 	cmp	r3, #255	@ 0xff
   22ba4:	0a000001 	beq	22bb0 <_svfprintf_r+0x2148>
						if (lead <= *grouping)
   22ba8:	e1530002 	cmp	r3, r2
   22bac:	bafffff4 	blt	22b84 <_svfprintf_r+0x211c>
   22bb0:	e58d003c 	str	r0, [sp, #60]	@ 0x3c
   22bb4:	e58d1054 	str	r1, [sp, #84]	@ 0x54
   22bb8:	e58dc038 	str	ip, [sp, #56]	@ 0x38
   22bbc:	e58d2030 	str	r2, [sp, #48]	@ 0x30
					size += (nseps + nrepeats) * thsnd_len;
   22bc0:	e1cd23d8 	ldrd	r2, [sp, #56]	@ 0x38
   22bc4:	e59d1058 	ldr	r1, [sp, #88]	@ 0x58
			flags |= FPT;
   22bc8:	e59d7024 	ldr	r7, [sp, #36]	@ 0x24
					size += (nseps + nrepeats) * thsnd_len;
   22bcc:	e0833002 	add	r3, r3, r2
   22bd0:	e59d2020 	ldr	r2, [sp, #32]
   22bd4:	e0232391 	mla	r3, r1, r3, r2
   22bd8:	e3a02000 	mov	r2, #0
   22bdc:	e58d2024 	str	r2, [sp, #36]	@ 0x24
   22be0:	e58d3020 	str	r3, [sp, #32]
		realsz = dprec > size ? dprec : size;
   22be4:	e1c33fc3 	bic	r3, r3, r3, asr #31
   22be8:	e58d300c 	str	r3, [sp, #12]
					size += (nseps + nrepeats) * thsnd_len;
   22bec:	eafffeb3 	b	226c0 <_svfprintf_r+0x1c58>
				if (signbit (_fpvalue))
   22bf0:	ee183a90 	vmov	r3, s17
					cp = "NAN";
   22bf4:	e30953b0 	movw	r5, #37808	@ 0x93b0
				if (signbit (_fpvalue))
   22bf8:	e3530000 	cmp	r3, #0
					cp = "NAN";
   22bfc:	e30933ac 	movw	r3, #37804	@ 0x93ac
					sign = '-';
   22c00:	b3a0102d 	movlt	r1, #45	@ 0x2d
			if (!sign)
   22c04:	a5dd106b 	ldrbge	r1, [sp, #107]	@ 0x6b
				flags &= ~ZEROPAD;
   22c08:	e3c77080 	bic	r7, r7, #128	@ 0x80
					cp = "NAN";
   22c0c:	e3405002 	movt	r5, #2
   22c10:	e3403002 	movt	r3, #2
					sign = '-';
   22c14:	b5cd106b 	strblt	r1, [sp, #107]	@ 0x6b
   22c18:	eafff8f2 	b	20fe8 <_svfprintf_r+0x580>
		value = -value;
   22c1c:	eeb19b48 	vneg.f64	d9, d8
   22c20:	e3a0802d 	mov	r8, #45	@ 0x2d
   22c24:	eafffe35 	b	22500 <_svfprintf_r+0x1a98>
   22c28:	e58d7054 	str	r7, [sp, #84]	@ 0x54
   22c2c:	e1a0a001 	mov	sl, r1
   22c30:	e59d505c 	ldr	r5, [sp, #92]	@ 0x5c
   22c34:	e59d7060 	ldr	r7, [sp, #96]	@ 0x60
   22c38:	e59db064 	ldr	fp, [sp, #100]	@ 0x64
					    if (cp > convbuf + ndig)
   22c3c:	e59d3020 	ldr	r3, [sp, #32]
   22c40:	e1580003 	cmp	r8, r3
   22c44:	21a08003 	movcs	r8, r3
   22c48:	eafffb98 	b	21ab0 <_svfprintf_r+0x1048>
							size += prec + decp_len;
   22c4c:	e59d3040 	ldr	r3, [sp, #64]	@ 0x40
   22c50:	e3a04066 	mov	r4, #102	@ 0x66
   22c54:	e0893003 	add	r3, r9, r3
   22c58:	e0833002 	add	r3, r3, r2
   22c5c:	e58d3020 	str	r3, [sp, #32]
   22c60:	eaffff83 	b	22a74 <_svfprintf_r+0x200c>
			while (ndigits-- >= 0) {
   22c64:	e3520000 	cmp	r2, #0
   22c68:	a2822001 	addge	r2, r2, #1
				*bp++ = '0';
   22c6c:	a3a01030 	movge	r1, #48	@ 0x30
   22c70:	a0832002 	addge	r2, r3, r2
			while (ndigits-- >= 0) {
   22c74:	bafffc7c 	blt	21e6c <_svfprintf_r+0x1404>
				*bp++ = '0';
   22c78:	e4c31001 	strb	r1, [r3], #1
			while (ndigits-- >= 0) {
   22c7c:	e1520003 	cmp	r2, r3
   22c80:	1afffffc 	bne	22c78 <_svfprintf_r+0x2210>
   22c84:	eafffc79 	b	21e70 <_svfprintf_r+0x1408>
						size = (prec || flags & ALT)
   22c88:	e3530000 	cmp	r3, #0
   22c8c:	1a000007 	bne	22cb0 <_svfprintf_r+0x2248>
   22c90:	e3a03001 	mov	r3, #1
   22c94:	e3a04066 	mov	r4, #102	@ 0x66
   22c98:	e58d300c 	str	r3, [sp, #12]
							  : 1;
   22c9c:	e58d3020 	str	r3, [sp, #32]
				if ((flags & GROUPING) && expt > 0) {
   22ca0:	eafffede 	b	22820 <_svfprintf_r+0x1db8>
				*decpt = -ndigits + 1;
   22ca4:	e2623001 	rsb	r3, r2, #1
   22ca8:	e58d3070 	str	r3, [sp, #112]	@ 0x70
   22cac:	eafffe2e 	b	2256c <_svfprintf_r+0x1b04>
							  ? prec + 1 + decp_len
   22cb0:	e59d3040 	ldr	r3, [sp, #64]	@ 0x40
							  : 1;
   22cb4:	e3a04066 	mov	r4, #102	@ 0x66
							  ? prec + 1 + decp_len
   22cb8:	e2837001 	add	r7, r3, #1
   22cbc:	e0873009 	add	r3, r7, r9
   22cc0:	e58d3020 	str	r3, [sp, #32]
		realsz = dprec > size ? dprec : size;
   22cc4:	e1c33fc3 	bic	r3, r3, r3, asr #31
   22cc8:	e58d300c 	str	r3, [sp, #12]
							  : 1;
   22ccc:	eafffed3 	b	22820 <_svfprintf_r+0x1db8>
				prec = GET_ARG (n, ap, int);
   22cd0:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
rflag:		ch = *fmt++;
   22cd4:	e5db4001 	ldrb	r4, [fp, #1]
			if ((ch = *fmt++) == '*') {
   22cd8:	e1a0b002 	mov	fp, r2
				if (prec < 0)
   22cdc:	e4939004 	ldr	r9, [r3], #4
				prec = GET_ARG (n, ap, int);
   22ce0:	e58d3028 	str	r3, [sp, #40]	@ 0x28
				if (prec < 0)
   22ce4:	e1899fc9 	orr	r9, r9, r9, asr #31
				goto rflag;
   22ce8:	eafff7a6 	b	20b88 <_svfprintf_r+0x120>
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
   22cec:	e3a03002 	mov	r3, #2
   22cf0:	e58d3048 	str	r3, [sp, #72]	@ 0x48
   22cf4:	eafffe5e 	b	22674 <_svfprintf_r+0x1c0c>
					fp->_flags |= __SERR;
   22cf8:	e59d2014 	ldr	r2, [sp, #20]
   22cfc:	e1d230bc 	ldrh	r3, [r2, #12]
   22d00:	e3833040 	orr	r3, r3, #64	@ 0x40
   22d04:	e1c230bc 	strh	r3, [r2, #12]
	if (malloc_buf != NULL)
   22d08:	eafff82f 	b	20dcc <_svfprintf_r+0x364>
					    if (cp > convbuf + ndig)
   22d0c:	e59d3034 	ldr	r3, [sp, #52]	@ 0x34
   22d10:	e0853003 	add	r3, r5, r3
   22d14:	e58d3020 	str	r3, [sp, #32]
   22d18:	eaffffc7 	b	22c3c <_svfprintf_r+0x21d4>
					nseps = nrepeats = 0;
   22d1c:	e3a03000 	mov	r3, #0
   22d20:	e58d303c 	str	r3, [sp, #60]	@ 0x3c
   22d24:	e58d3038 	str	r3, [sp, #56]	@ 0x38
   22d28:	eaffffa4 	b	22bc0 <_svfprintf_r+0x2158>
   22d2c:	00000000 	andeq	r0, r0, r0

00022d30 <_vfprintf_r>:
{
   22d30:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   22d34:	e1a04003 	mov	r4, r3
   22d38:	ed2d8b04 	vpush	{d8-d9}
   22d3c:	e24ddf4f 	sub	sp, sp, #316	@ 0x13c
   22d40:	e1a05000 	mov	r5, r0
   22d44:	e1a08002 	mov	r8, r2
   22d48:	e58d1014 	str	r1, [sp, #20]
   22d4c:	e58d3028 	str	r3, [sp, #40]	@ 0x28
   22d50:	e58d000c 	str	r0, [sp, #12]
	char *decimal_point = _localeconv_r (data)->decimal_point;
   22d54:	ebffe0fd 	bl	1b150 <_localeconv_r>
   22d58:	e5903000 	ldr	r3, [r0]
	size_t decp_len = strlen (decimal_point);
   22d5c:	e1a00003 	mov	r0, r3
	char *decimal_point = _localeconv_r (data)->decimal_point;
   22d60:	e58d3044 	str	r3, [sp, #68]	@ 0x44
	size_t decp_len = strlen (decimal_point);
   22d64:	fafff5c5 	blx	20480 <strlen>
	CHECK_INIT (data, fp);
   22d68:	e3550000 	cmp	r5, #0
	size_t decp_len = strlen (decimal_point);
   22d6c:	e58d0040 	str	r0, [sp, #64]	@ 0x40
	CHECK_INIT (data, fp);
   22d70:	0a000002 	beq	22d80 <_vfprintf_r+0x50>
   22d74:	e5953034 	ldr	r3, [r5, #52]	@ 0x34
   22d78:	e3530000 	cmp	r3, #0
   22d7c:	0a0005df 	beq	24500 <_vfprintf_r+0x17d0>
	if (ORIENT(fp, -1) != -1) {
   22d80:	e59d1014 	ldr	r1, [sp, #20]
   22d84:	e1d120fc 	ldrsh	r2, [r1, #12]
	_newlib_flockfile_start (fp);
   22d88:	e5913064 	ldr	r3, [r1, #100]	@ 0x64
	if (ORIENT(fp, -1) != -1) {
   22d8c:	e3120a02 	tst	r2, #8192	@ 0x2000
   22d90:	03822a02 	orreq	r2, r2, #8192	@ 0x2000
   22d94:	03c33a02 	biceq	r3, r3, #8192	@ 0x2000
   22d98:	01c120bc 	strheq	r2, [r1, #12]
   22d9c:	05813064 	streq	r3, [r1, #100]	@ 0x64
   22da0:	e3130a02 	tst	r3, #8192	@ 0x2000
   22da4:	1a0007bb 	bne	24c98 <_vfprintf_r+0x1f68>
	if (cantwrite (data, fp)) {
   22da8:	e59d3014 	ldr	r3, [sp, #20]
   22dac:	e1d320fc 	ldrsh	r2, [r3, #12]
   22db0:	e3120008 	tst	r2, #8
   22db4:	0a0000b8 	beq	2309c <_vfprintf_r+0x36c>
   22db8:	e5933010 	ldr	r3, [r3, #16]
   22dbc:	e3530000 	cmp	r3, #0
   22dc0:	0a0000b5 	beq	2309c <_vfprintf_r+0x36c>
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   22dc4:	e202201a 	and	r2, r2, #26
   22dc8:	e352000a 	cmp	r2, #10
   22dcc:	0a0000bc 	beq	230c4 <_vfprintf_r+0x394>
	uio.uio_resid = 0;
   22dd0:	e3a03000 	mov	r3, #0
	union { int i; _PRINTF_FLOAT_TYPE fp; } _double_ = {0};
   22dd4:	ed9f8be3 	vldr	d8, [pc, #908]	@ 23168 <_vfprintf_r+0x438>
	int ndig = 0;		/* actual number of digits returned by cvt */
   22dd8:	e1a0e003 	mov	lr, r3
	uio.uio_resid = 0;
   22ddc:	e58d3090 	str	r3, [sp, #144]	@ 0x90
	uio.uio_iovcnt = 0;
   22de0:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
	uio.uio_iov = iovp = iov;
   22de4:	e28d3094 	add	r3, sp, #148	@ 0x94
   22de8:	e1a0a003 	mov	sl, r3
   22dec:	e1a0b008 	mov	fp, r8
   22df0:	e58d3088 	str	r3, [sp, #136]	@ 0x88
	char *xdigs = NULL;	/* digits for [xX] conversion */
   22df4:	e58de04c 	str	lr, [sp, #76]	@ 0x4c
	int expsize = 0;	/* character count for expstr */
   22df8:	e58de048 	str	lr, [sp, #72]	@ 0x48
	const char *grouping = NULL;
   22dfc:	e58de054 	str	lr, [sp, #84]	@ 0x54
	size_t thsnd_len = 0;
   22e00:	e58de058 	str	lr, [sp, #88]	@ 0x58
	char *thousands_sep = NULL;
   22e04:	e58de050 	str	lr, [sp, #80]	@ 0x50
	ret = 0;
   22e08:	e58de01c 	str	lr, [sp, #28]
   22e0c:	e58de034 	str	lr, [sp, #52]	@ 0x34
                while (*fmt != '\0' && *fmt != '%')
   22e10:	e5db3000 	ldrb	r3, [fp]
   22e14:	e1a0500b 	mov	r5, fp
   22e18:	e3530000 	cmp	r3, #0
   22e1c:	13530025 	cmpne	r3, #37	@ 0x25
   22e20:	0a000015 	beq	22e7c <_vfprintf_r+0x14c>
                    fmt += 1;
   22e24:	e1a04005 	mov	r4, r5
                while (*fmt != '\0' && *fmt != '%')
   22e28:	e5f53001 	ldrb	r3, [r5, #1]!
   22e2c:	e3530000 	cmp	r3, #0
   22e30:	13530025 	cmpne	r3, #37	@ 0x25
   22e34:	1afffffa 	bne	22e24 <_vfprintf_r+0xf4>
		if ((m = fmt - cp) != 0) {
   22e38:	e055600b 	subs	r6, r5, fp
   22e3c:	0a00000e 	beq	22e7c <_vfprintf_r+0x14c>
			PRINT (cp, m);
   22e40:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   22e44:	e58ab000 	str	fp, [sl]
   22e48:	e58a6004 	str	r6, [sl, #4]
   22e4c:	e2833001 	add	r3, r3, #1
   22e50:	e3530007 	cmp	r3, #7
   22e54:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   22e58:	e59d3090 	ldr	r3, [sp, #144]	@ 0x90
   22e5c:	d28aa008 	addle	sl, sl, #8
   22e60:	e0833006 	add	r3, r3, r6
   22e64:	e58d3090 	str	r3, [sp, #144]	@ 0x90
   22e68:	ca0000a1 	bgt	230f4 <_vfprintf_r+0x3c4>
			ret += m;
   22e6c:	e59d301c 	ldr	r3, [sp, #28]
   22e70:	e0833006 	add	r3, r3, r6
   22e74:	e58d301c 	str	r3, [sp, #28]
                if (*fmt == '\0')
   22e78:	e5d43001 	ldrb	r3, [r4, #1]
   22e7c:	e3530000 	cmp	r3, #0
   22e80:	0a0005d9 	beq	245ec <_vfprintf_r+0x18bc>
rflag:		ch = *fmt++;
   22e84:	e5d54001 	ldrb	r4, [r5, #1]
		sign = '\0';
   22e88:	e3a03000 	mov	r3, #0
		fmt++;		/* skip over '%' */
   22e8c:	e285b001 	add	fp, r5, #1
		prec = -1;
   22e90:	e3e09000 	mvn	r9, #0
		flags = 0;
   22e94:	e1a07003 	mov	r7, r3
		sign = '\0';
   22e98:	e5cd306b 	strb	r3, [sp, #107]	@ 0x6b
		width = 0;
   22e9c:	e58d3018 	str	r3, [sp, #24]
rflag:		ch = *fmt++;
   22ea0:	e28bb001 	add	fp, fp, #1
reswitch:	switch (ch) {
   22ea4:	e2443020 	sub	r3, r4, #32
   22ea8:	e353005a 	cmp	r3, #90	@ 0x5a
   22eac:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   22eb0:	ea0000b1 	b	2317c <_vfprintf_r+0x44c>
   22eb4:	000234f0 	.word	0x000234f0
   22eb8:	0002317c 	.word	0x0002317c
   22ebc:	0002317c 	.word	0x0002317c
   22ec0:	000234e4 	.word	0x000234e4
   22ec4:	0002317c 	.word	0x0002317c
   22ec8:	0002317c 	.word	0x0002317c
   22ecc:	0002317c 	.word	0x0002317c
   22ed0:	00023048 	.word	0x00023048
   22ed4:	0002317c 	.word	0x0002317c
   22ed8:	0002317c 	.word	0x0002317c
   22edc:	0002344c 	.word	0x0002344c
   22ee0:	0002347c 	.word	0x0002347c
   22ee4:	0002317c 	.word	0x0002317c
   22ee8:	00023470 	.word	0x00023470
   22eec:	00023498 	.word	0x00023498
   22ef0:	0002317c 	.word	0x0002317c
   22ef4:	0002348c 	.word	0x0002348c
   22ef8:	00023020 	.word	0x00023020
   22efc:	00023020 	.word	0x00023020
   22f00:	00023020 	.word	0x00023020
   22f04:	00023020 	.word	0x00023020
   22f08:	00023020 	.word	0x00023020
   22f0c:	00023020 	.word	0x00023020
   22f10:	00023020 	.word	0x00023020
   22f14:	00023020 	.word	0x00023020
   22f18:	00023020 	.word	0x00023020
   22f1c:	0002317c 	.word	0x0002317c
   22f20:	0002317c 	.word	0x0002317c
   22f24:	0002317c 	.word	0x0002317c
   22f28:	0002317c 	.word	0x0002317c
   22f2c:	0002317c 	.word	0x0002317c
   22f30:	0002317c 	.word	0x0002317c
   22f34:	0002317c 	.word	0x0002317c
   22f38:	00023310 	.word	0x00023310
   22f3c:	0002317c 	.word	0x0002317c
   22f40:	00023390 	.word	0x00023390
   22f44:	00023514 	.word	0x00023514
   22f48:	00023310 	.word	0x00023310
   22f4c:	00023310 	.word	0x00023310
   22f50:	00023310 	.word	0x00023310
   22f54:	0002317c 	.word	0x0002317c
   22f58:	0002317c 	.word	0x0002317c
   22f5c:	0002317c 	.word	0x0002317c
   22f60:	0002317c 	.word	0x0002317c
   22f64:	00023508 	.word	0x00023508
   22f68:	0002317c 	.word	0x0002317c
   22f6c:	0002317c 	.word	0x0002317c
   22f70:	000235ec 	.word	0x000235ec
   22f74:	0002317c 	.word	0x0002317c
   22f78:	0002317c 	.word	0x0002317c
   22f7c:	0002317c 	.word	0x0002317c
   22f80:	000233dc 	.word	0x000233dc
   22f84:	0002317c 	.word	0x0002317c
   22f88:	00023554 	.word	0x00023554
   22f8c:	0002317c 	.word	0x0002317c
   22f90:	0002317c 	.word	0x0002317c
   22f94:	000241f4 	.word	0x000241f4
   22f98:	0002317c 	.word	0x0002317c
   22f9c:	0002317c 	.word	0x0002317c
   22fa0:	0002317c 	.word	0x0002317c
   22fa4:	0002317c 	.word	0x0002317c
   22fa8:	0002317c 	.word	0x0002317c
   22fac:	0002317c 	.word	0x0002317c
   22fb0:	0002317c 	.word	0x0002317c
   22fb4:	0002317c 	.word	0x0002317c
   22fb8:	00023310 	.word	0x00023310
   22fbc:	0002317c 	.word	0x0002317c
   22fc0:	00023390 	.word	0x00023390
   22fc4:	000233ac 	.word	0x000233ac
   22fc8:	00023310 	.word	0x00023310
   22fcc:	00023310 	.word	0x00023310
   22fd0:	00023310 	.word	0x00023310
   22fd4:	00023608 	.word	0x00023608
   22fd8:	000233ac 	.word	0x000233ac
   22fdc:	00023090 	.word	0x00023090
   22fe0:	0002317c 	.word	0x0002317c
   22fe4:	0002364c 	.word	0x0002364c
   22fe8:	0002317c 	.word	0x0002317c
   22fec:	00023624 	.word	0x00023624
   22ff0:	000236c8 	.word	0x000236c8
   22ff4:	00023698 	.word	0x00023698
   22ff8:	00023090 	.word	0x00023090
   22ffc:	0002317c 	.word	0x0002317c
   23000:	000233dc 	.word	0x000233dc
   23004:	00023088 	.word	0x00023088
   23008:	00023664 	.word	0x00023664
   2300c:	0002317c 	.word	0x0002317c
   23010:	0002317c 	.word	0x0002317c
   23014:	00024254 	.word	0x00024254
   23018:	0002317c 	.word	0x0002317c
   2301c:	00023088 	.word	0x00023088
   23020:	e2443030 	sub	r3, r4, #48	@ 0x30
   23024:	e3a02000 	mov	r2, #0
				ch = *fmt++;
   23028:	e4db4001 	ldrb	r4, [fp], #1
				n = 10 * n + to_digit (ch);
   2302c:	e0822102 	add	r2, r2, r2, lsl #2
   23030:	e0832082 	add	r2, r3, r2, lsl #1
			} while (is_digit (ch));
   23034:	e2443030 	sub	r3, r4, #48	@ 0x30
   23038:	e3530009 	cmp	r3, #9
   2303c:	9afffff9 	bls	23028 <_vfprintf_r+0x2f8>
   23040:	e58d2018 	str	r2, [sp, #24]
   23044:	eaffff96 	b	22ea4 <_vfprintf_r+0x174>
			thousands_sep = _localeconv_r (data)->thousands_sep;
   23048:	e59d500c 	ldr	r5, [sp, #12]
   2304c:	e1a00005 	mov	r0, r5
   23050:	ebffe03e 	bl	1b150 <_localeconv_r>
   23054:	e5903004 	ldr	r3, [r0, #4]
			thsnd_len = strlen (thousands_sep);
   23058:	e1a00003 	mov	r0, r3
			thousands_sep = _localeconv_r (data)->thousands_sep;
   2305c:	e58d3050 	str	r3, [sp, #80]	@ 0x50
			thsnd_len = strlen (thousands_sep);
   23060:	fafff506 	blx	20480 <strlen>
   23064:	e1a04000 	mov	r4, r0
   23068:	e58d0058 	str	r0, [sp, #88]	@ 0x58
			grouping = _localeconv_r (data)->grouping;
   2306c:	e1a00005 	mov	r0, r5
   23070:	ebffe036 	bl	1b150 <_localeconv_r>
   23074:	e5903008 	ldr	r3, [r0, #8]
			if (thsnd_len > 0 && grouping && *grouping)
   23078:	e3540000 	cmp	r4, #0
   2307c:	13530000 	cmpne	r3, #0
			grouping = _localeconv_r (data)->grouping;
   23080:	e58d3054 	str	r3, [sp, #84]	@ 0x54
			if (thsnd_len > 0 && grouping && *grouping)
   23084:	1a00044d 	bne	241c0 <_vfprintf_r+0x1490>
			if ((ch = *fmt++) == '*') {
   23088:	e5db4000 	ldrb	r4, [fp]
   2308c:	eaffff83 	b	22ea0 <_vfprintf_r+0x170>
   23090:	e5db4000 	ldrb	r4, [fp]
		    flags |= QUADINT;
   23094:	e3877010 	orr	r7, r7, #16
		  goto rflag;
   23098:	eaffff80 	b	22ea0 <_vfprintf_r+0x170>
	if (cantwrite (data, fp)) {
   2309c:	e59d5014 	ldr	r5, [sp, #20]
   230a0:	e59d000c 	ldr	r0, [sp, #12]
   230a4:	e1a01005 	mov	r1, r5
   230a8:	ebffda17 	bl	1990c <__swsetup_r>
   230ac:	e3500000 	cmp	r0, #0
   230b0:	1a0006f8 	bne	24c98 <_vfprintf_r+0x1f68>
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   230b4:	e1d520fc 	ldrsh	r2, [r5, #12]
   230b8:	e202201a 	and	r2, r2, #26
   230bc:	e352000a 	cmp	r2, #10
   230c0:	1affff42 	bne	22dd0 <_vfprintf_r+0xa0>
   230c4:	e59d3014 	ldr	r3, [sp, #20]
   230c8:	e1d330fe 	ldrsh	r3, [r3, #14]
   230cc:	e3530000 	cmp	r3, #0
   230d0:	baffff3e 	blt	22dd0 <_vfprintf_r+0xa0>
		return (__sbprintf (data, fp, fmt0, ap));
   230d4:	e59d1014 	ldr	r1, [sp, #20]
   230d8:	e1a03004 	mov	r3, r4
   230dc:	e59d000c 	ldr	r0, [sp, #12]
   230e0:	e1a02008 	mov	r2, r8
}
   230e4:	e28ddf4f 	add	sp, sp, #316	@ 0x13c
   230e8:	ecbd8b04 	vpop	{d8-d9}
   230ec:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
		return (__sbprintf (data, fp, fmt0, ap));
   230f0:	ea0007ff 	b	250f4 <__sbprintf>
			PRINT (cp, m);
   230f4:	e59d1014 	ldr	r1, [sp, #20]
   230f8:	e28d2088 	add	r2, sp, #136	@ 0x88
   230fc:	e59d000c 	ldr	r0, [sp, #12]
   23100:	ebffd2c1 	bl	17c0c <__sprint_r>
   23104:	e3500000 	cmp	r0, #0
   23108:	1a00000d 	bne	23144 <_vfprintf_r+0x414>
   2310c:	e28da094 	add	sl, sp, #148	@ 0x94
   23110:	eaffff55 	b	22e6c <_vfprintf_r+0x13c>
		FLUSH ();	/* copy out the I/O vectors */
   23114:	e59d1014 	ldr	r1, [sp, #20]
   23118:	e28d2088 	add	r2, sp, #136	@ 0x88
   2311c:	e59d000c 	ldr	r0, [sp, #12]
   23120:	ebffd2b9 	bl	17c0c <__sprint_r>
   23124:	e3500000 	cmp	r0, #0
   23128:	0a00006e 	beq	232e8 <_vfprintf_r+0x5b8>
	if (malloc_buf != NULL)
   2312c:	e59d3024 	ldr	r3, [sp, #36]	@ 0x24
   23130:	e3530000 	cmp	r3, #0
   23134:	0a000002 	beq	23144 <_vfprintf_r+0x414>
		_free_r (data, malloc_buf);
   23138:	e59d000c 	ldr	r0, [sp, #12]
   2313c:	e1a01003 	mov	r1, r3
   23140:	ebfff101 	bl	1f54c <_free_r>
	return (__sferror (fp) ? EOF : ret);
   23144:	e59d3014 	ldr	r3, [sp, #20]
   23148:	e1d330bc 	ldrh	r3, [r3, #12]
   2314c:	e3130040 	tst	r3, #64	@ 0x40
   23150:	1a0006d0 	bne	24c98 <_vfprintf_r+0x1f68>
}
   23154:	e59d001c 	ldr	r0, [sp, #28]
   23158:	e28ddf4f 	add	sp, sp, #316	@ 0x13c
   2315c:	ecbd8b04 	vpop	{d8-d9}
   23160:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
   23164:	e320f000 	nop	{0}
	...
   23170:	ffffffff 	.word	0xffffffff
   23174:	7fefffff 	.word	0x7fefffff
   23178:	0002a0a0 	.word	0x0002a0a0
			if (ch == '\0')
   2317c:	e3540000 	cmp	r4, #0
   23180:	0a000519 	beq	245ec <_vfprintf_r+0x18bc>
			sign = '\0';
   23184:	e3a01000 	mov	r1, #0
			*cp = ch;
   23188:	e5cd40d4 	strb	r4, [sp, #212]	@ 0xd4
			sign = '\0';
   2318c:	e5cd106b 	strb	r1, [sp, #107]	@ 0x6b
		dprec = 0;
   23190:	e1a09001 	mov	r9, r1
			cp = buf;
   23194:	e28d50d4 	add	r5, sp, #212	@ 0xd4
			break;
   23198:	e3a03001 	mov	r3, #1
   2319c:	e58d1024 	str	r1, [sp, #36]	@ 0x24
   231a0:	e58d3010 	str	r3, [sp, #16]
			size = 1;
   231a4:	e58d3020 	str	r3, [sp, #32]
		nseps = nrepeats = 0;
   231a8:	e58d103c 	str	r1, [sp, #60]	@ 0x3c
   231ac:	e58d1038 	str	r1, [sp, #56]	@ 0x38
		lead = 0;
   231b0:	e58d1030 	str	r1, [sp, #48]	@ 0x30
		if (flags & HEXPREFIX)
   231b4:	e2173002 	ands	r3, r7, #2
			realsz+= 2;
   231b8:	159d2010 	ldrne	r2, [sp, #16]
   231bc:	12822002 	addne	r2, r2, #2
   231c0:	158d2010 	strne	r2, [sp, #16]
		if ((flags & (LADJUST|ZEROPAD)) == 0)
   231c4:	e2172084 	ands	r2, r7, #132	@ 0x84
   231c8:	e58d202c 	str	r2, [sp, #44]	@ 0x2c
			PRINT (&sign, 1);
   231cc:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
		if ((flags & (LADJUST|ZEROPAD)) == 0)
   231d0:	1a000004 	bne	231e8 <_vfprintf_r+0x4b8>
			PAD (width - realsz, blanks);
   231d4:	e59d0018 	ldr	r0, [sp, #24]
   231d8:	e59dc010 	ldr	ip, [sp, #16]
   231dc:	e040600c 	sub	r6, r0, ip
   231e0:	e3560000 	cmp	r6, #0
   231e4:	ca00026c 	bgt	23b9c <_vfprintf_r+0xe6c>
		if (sign)
   231e8:	e3510000 	cmp	r1, #0
   231ec:	0a00000b 	beq	23220 <_vfprintf_r+0x4f0>
			PRINT (&sign, 1);
   231f0:	e59d108c 	ldr	r1, [sp, #140]	@ 0x8c
   231f4:	e2822001 	add	r2, r2, #1
   231f8:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   231fc:	e2811001 	add	r1, r1, #1
   23200:	e3510007 	cmp	r1, #7
   23204:	e58d108c 	str	r1, [sp, #140]	@ 0x8c
   23208:	e28d106b 	add	r1, sp, #107	@ 0x6b
   2320c:	e58a1000 	str	r1, [sl]
   23210:	e3a01001 	mov	r1, #1
   23214:	e58a1004 	str	r1, [sl, #4]
   23218:	d28aa008 	addle	sl, sl, #8
   2321c:	ca000296 	bgt	23c7c <_vfprintf_r+0xf4c>
		if (flags & HEXPREFIX)
   23220:	e3530000 	cmp	r3, #0
   23224:	0a00000b 	beq	23258 <_vfprintf_r+0x528>
			PRINT (ox, 2);
   23228:	e59d108c 	ldr	r1, [sp, #140]	@ 0x8c
   2322c:	e2822002 	add	r2, r2, #2
   23230:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   23234:	e2811001 	add	r1, r1, #1
   23238:	e3510007 	cmp	r1, #7
   2323c:	e58d108c 	str	r1, [sp, #140]	@ 0x8c
   23240:	e28d106c 	add	r1, sp, #108	@ 0x6c
   23244:	e58a1000 	str	r1, [sl]
   23248:	e3a01002 	mov	r1, #2
   2324c:	e58a1004 	str	r1, [sl, #4]
   23250:	d28aa008 	addle	sl, sl, #8
   23254:	ca000293 	bgt	23ca8 <_vfprintf_r+0xf78>
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   23258:	e59d302c 	ldr	r3, [sp, #44]	@ 0x2c
   2325c:	e3530080 	cmp	r3, #128	@ 0x80
   23260:	0a000166 	beq	23800 <_vfprintf_r+0xad0>
		PAD (dprec - size, zeroes);
   23264:	e59d3020 	ldr	r3, [sp, #32]
   23268:	e0496003 	sub	r6, r9, r3
   2326c:	e3560000 	cmp	r6, #0
   23270:	ca0001a7 	bgt	23914 <_vfprintf_r+0xbe4>
		if ((flags & FPT) == 0) {
   23274:	e3170c01 	tst	r7, #256	@ 0x100
   23278:	1a00011d 	bne	236f4 <_vfprintf_r+0x9c4>
			PRINT (cp, size);
   2327c:	e59d3020 	ldr	r3, [sp, #32]
   23280:	e58a5000 	str	r5, [sl]
   23284:	e0822003 	add	r2, r2, r3
   23288:	e58a3004 	str	r3, [sl, #4]
   2328c:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   23290:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   23294:	e2833001 	add	r3, r3, #1
   23298:	e3530007 	cmp	r3, #7
   2329c:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   232a0:	ca000234 	bgt	23b78 <_vfprintf_r+0xe48>
					PRINTANDPAD (cp, convbuf + ndig,
   232a4:	e28aa008 	add	sl, sl, #8
		if (flags & LADJUST)
   232a8:	e3170004 	tst	r7, #4
   232ac:	0a000004 	beq	232c4 <_vfprintf_r+0x594>
			PAD (width - realsz, blanks);
   232b0:	e59d3018 	ldr	r3, [sp, #24]
   232b4:	e59d1010 	ldr	r1, [sp, #16]
   232b8:	e0434001 	sub	r4, r3, r1
   232bc:	e3540000 	cmp	r4, #0
   232c0:	ca000281 	bgt	23ccc <_vfprintf_r+0xf9c>
		ret += width > realsz ? width : realsz;
   232c4:	e59d301c 	ldr	r3, [sp, #28]
   232c8:	e59d1018 	ldr	r1, [sp, #24]
   232cc:	e59d0010 	ldr	r0, [sp, #16]
   232d0:	e1510000 	cmp	r1, r0
   232d4:	a0833001 	addge	r3, r3, r1
   232d8:	b0833000 	addlt	r3, r3, r0
		FLUSH ();	/* copy out the I/O vectors */
   232dc:	e3520000 	cmp	r2, #0
		ret += width > realsz ? width : realsz;
   232e0:	e58d301c 	str	r3, [sp, #28]
		FLUSH ();	/* copy out the I/O vectors */
   232e4:	1affff8a 	bne	23114 <_vfprintf_r+0x3e4>
                if (malloc_buf != NULL) {
   232e8:	e59d3024 	ldr	r3, [sp, #36]	@ 0x24
   232ec:	e3530000 	cmp	r3, #0
		FLUSH ();	/* copy out the I/O vectors */
   232f0:	e3a03000 	mov	r3, #0
   232f4:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
                if (malloc_buf != NULL) {
   232f8:	0a000002 	beq	23308 <_vfprintf_r+0x5d8>
			_free_r (data, malloc_buf);
   232fc:	e59d1024 	ldr	r1, [sp, #36]	@ 0x24
   23300:	e59d000c 	ldr	r0, [sp, #12]
   23304:	ebfff090 	bl	1f54c <_free_r>
		FLUSH ();	/* copy out the I/O vectors */
   23308:	e28da094 	add	sl, sp, #148	@ 0x94
   2330c:	eafffebf 	b	22e10 <_vfprintf_r+0xe0>
				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
   23310:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
			if (isinf (_fpvalue)) {
   23314:	ed1f7b6b 	vldr	d7, [pc, #-428]	@ 23170 <_vfprintf_r+0x440>
				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
   23318:	e2833007 	add	r3, r3, #7
   2331c:	e3c33007 	bic	r3, r3, #7
   23320:	ecb38b02 	vldmia	r3!, {d8}
   23324:	e58d3028 	str	r3, [sp, #40]	@ 0x28
			if (isinf (_fpvalue)) {
   23328:	eeb06bc8 	vabs.f64	d6, d8
   2332c:	eeb46b47 	vcmp.f64	d6, d7
   23330:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   23334:	da00033b 	ble	24028 <_vfprintf_r+0x12f8>
				if (_fpvalue < 0)
   23338:	eeb58bc0 	vcmpe.f64	d8, #0.0
   2333c:	eef1fa10 	vmrs	APSR_nzcv, fpscr
					sign = '-';
   23340:	43a0102d 	movmi	r1, #45	@ 0x2d
   23344:	45cd106b 	strbmi	r1, [sp, #107]	@ 0x6b
			if (!sign)
   23348:	55dd106b 	ldrbpl	r1, [sp, #107]	@ 0x6b
					cp = "INF";
   2334c:	e30953a8 	movw	r5, #37800	@ 0x93a8
   23350:	e30933a4 	movw	r3, #37796	@ 0x93a4
				flags &= ~ZEROPAD;
   23354:	e3c77080 	bic	r7, r7, #128	@ 0x80
					cp = "INF";
   23358:	e3405002 	movt	r5, #2
   2335c:	e3403002 	movt	r3, #2
					cp = "NAN";
   23360:	e3540047 	cmp	r4, #71	@ 0x47
				break;
   23364:	e3a02003 	mov	r2, #3
					cp = "NAN";
   23368:	d1a05003 	movle	r5, r3
				break;
   2336c:	e3a03000 	mov	r3, #0
		dprec = 0;
   23370:	e1a09003 	mov	r9, r3
				break;
   23374:	e58d3024 	str	r3, [sp, #36]	@ 0x24
   23378:	e58d2010 	str	r2, [sp, #16]
				size = 3;
   2337c:	e58d2020 	str	r2, [sp, #32]
		nseps = nrepeats = 0;
   23380:	e58d303c 	str	r3, [sp, #60]	@ 0x3c
   23384:	e58d3038 	str	r3, [sp, #56]	@ 0x38
		lead = 0;
   23388:	e58d3030 	str	r3, [sp, #48]	@ 0x30
				break;
   2338c:	ea000090 	b	235d4 <_vfprintf_r+0x8a4>
				*cp = GET_ARG (N, ap, int);
   23390:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
			sign = '\0';
   23394:	e3a01000 	mov	r1, #0
   23398:	e5cd106b 	strb	r1, [sp, #107]	@ 0x6b
				*cp = GET_ARG (N, ap, int);
   2339c:	e4932004 	ldr	r2, [r3], #4
   233a0:	e5cd20d4 	strb	r2, [sp, #212]	@ 0xd4
   233a4:	e58d3028 	str	r3, [sp, #40]	@ 0x28
   233a8:	eaffff78 	b	23190 <_vfprintf_r+0x460>
			width = GET_ARG (n, ap, int);
   233ac:	e59d2028 	ldr	r2, [sp, #40]	@ 0x28
			_uquad = SARG ();
   233b0:	e3170010 	tst	r7, #16
			width = GET_ARG (n, ap, int);
   233b4:	e4923004 	ldr	r3, [r2], #4
   233b8:	e58d2028 	str	r2, [sp, #40]	@ 0x28
			_uquad = SARG ();
   233bc:	1a000058 	bne	23524 <_vfprintf_r+0x7f4>
   233c0:	e3170040 	tst	r7, #64	@ 0x40
   233c4:	1a000314 	bne	2401c <_vfprintf_r+0x12ec>
   233c8:	e3170c02 	tst	r7, #512	@ 0x200
   233cc:	0a000054 	beq	23524 <_vfprintf_r+0x7f4>
   233d0:	e6af3073 	sxtb	r3, r3
			if ((long) _uquad < 0)
   233d4:	e1a06003 	mov	r6, r3
   233d8:	ea000052 	b	23528 <_vfprintf_r+0x7f8>
			cp = GET_ARG (N, ap, char_ptr_t);
   233dc:	e59d6028 	ldr	r6, [sp, #40]	@ 0x28
			sign = '\0';
   233e0:	e3a08000 	mov	r8, #0
   233e4:	e5cd806b 	strb	r8, [sp, #107]	@ 0x6b
			cp = GET_ARG (N, ap, char_ptr_t);
   233e8:	e4965004 	ldr	r5, [r6], #4
			if (cp == NULL) {
   233ec:	e1550008 	cmp	r5, r8
   233f0:	0a0003a4 	beq	24288 <_vfprintf_r+0x1558>
			if (prec >= 0) {
   233f4:	e3590000 	cmp	r9, #0
   233f8:	ba000486 	blt	24618 <_vfprintf_r+0x18e8>
				char *p = memchr (cp, 0, prec);
   233fc:	e1a02009 	mov	r2, r9
   23400:	e1a01008 	mov	r1, r8
   23404:	e1a00005 	mov	r0, r5
   23408:	fafff26c 	blx	1fdc0 <memchr>
				if (p != NULL)
   2340c:	e2503000 	subs	r3, r0, #0
   23410:	e58d3024 	str	r3, [sp, #36]	@ 0x24
   23414:	0a000633 	beq	24ce8 <_vfprintf_r+0x1fb8>
					size = p - cp;
   23418:	e59d3024 	ldr	r3, [sp, #36]	@ 0x24
   2341c:	e1a09008 	mov	r9, r8
		if (sign)
   23420:	e5dd106b 	ldrb	r1, [sp, #107]	@ 0x6b
			cp = GET_ARG (N, ap, char_ptr_t);
   23424:	e58d6028 	str	r6, [sp, #40]	@ 0x28
					size = p - cp;
   23428:	e0433005 	sub	r3, r3, r5
   2342c:	e58d3020 	str	r3, [sp, #32]
		realsz = dprec > size ? dprec : size;
   23430:	e1c33fc3 	bic	r3, r3, r3, asr #31
   23434:	e58d3010 	str	r3, [sp, #16]
		dprec = 0;
   23438:	e58d9024 	str	r9, [sp, #36]	@ 0x24
		nseps = nrepeats = 0;
   2343c:	e58d903c 	str	r9, [sp, #60]	@ 0x3c
   23440:	e58d9038 	str	r9, [sp, #56]	@ 0x38
		lead = 0;
   23444:	e58d9030 	str	r9, [sp, #48]	@ 0x30
   23448:	ea000061 	b	235d4 <_vfprintf_r+0x8a4>
			width = GET_ARG (n, ap, int);
   2344c:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
   23450:	e4932004 	ldr	r2, [r3], #4
			if (width >= 0)
   23454:	e3520000 	cmp	r2, #0
			width = GET_ARG (n, ap, int);
   23458:	e58d2018 	str	r2, [sp, #24]
			if (width >= 0)
   2345c:	aa0002eb 	bge	24010 <_vfprintf_r+0x12e0>
			width = -width;
   23460:	e59d2018 	ldr	r2, [sp, #24]
			width = GET_ARG (n, ap, int);
   23464:	e58d3028 	str	r3, [sp, #40]	@ 0x28
			width = -width;
   23468:	e2622000 	rsb	r2, r2, #0
   2346c:	e58d2018 	str	r2, [sp, #24]
			if ((ch = *fmt++) == '*') {
   23470:	e5db4000 	ldrb	r4, [fp]
			flags |= LADJUST;
   23474:	e3877004 	orr	r7, r7, #4
			goto rflag;
   23478:	eafffe88 	b	22ea0 <_vfprintf_r+0x170>
			sign = '+';
   2347c:	e3a0302b 	mov	r3, #43	@ 0x2b
			if ((ch = *fmt++) == '*') {
   23480:	e5db4000 	ldrb	r4, [fp]
			sign = '+';
   23484:	e5cd306b 	strb	r3, [sp, #107]	@ 0x6b
			goto rflag;
   23488:	eafffe84 	b	22ea0 <_vfprintf_r+0x170>
			if ((ch = *fmt++) == '*') {
   2348c:	e5db4000 	ldrb	r4, [fp]
			flags |= ZEROPAD;
   23490:	e3877080 	orr	r7, r7, #128	@ 0x80
			goto rflag;
   23494:	eafffe81 	b	22ea0 <_vfprintf_r+0x170>
			if ((ch = *fmt++) == '*') {
   23498:	e1a0200b 	mov	r2, fp
   2349c:	e4d24001 	ldrb	r4, [r2], #1
   234a0:	e354002a 	cmp	r4, #42	@ 0x2a
   234a4:	0a0006e6 	beq	25044 <_vfprintf_r+0x2314>
			while (is_digit (ch)) {
   234a8:	e2443030 	sub	r3, r4, #48	@ 0x30
   234ac:	e3530009 	cmp	r3, #9
			if ((ch = *fmt++) == '*') {
   234b0:	81a0b002 	movhi	fp, r2
			while (is_digit (ch)) {
   234b4:	83a09000 	movhi	r9, #0
   234b8:	8afffe79 	bhi	22ea4 <_vfprintf_r+0x174>
			n = 0;
   234bc:	e3a09000 	mov	r9, #0
				ch = *fmt++;
   234c0:	e4d24001 	ldrb	r4, [r2], #1
				n = 10 * n + to_digit (ch);
   234c4:	e0899109 	add	r9, r9, r9, lsl #2
   234c8:	e0839089 	add	r9, r3, r9, lsl #1
			while (is_digit (ch)) {
   234cc:	e2443030 	sub	r3, r4, #48	@ 0x30
   234d0:	e3530009 	cmp	r3, #9
   234d4:	9afffff9 	bls	234c0 <_vfprintf_r+0x790>
			prec = n < 0 ? -1 : n;
   234d8:	e1899fc9 	orr	r9, r9, r9, asr #31
   234dc:	e1a0b002 	mov	fp, r2
			goto reswitch;
   234e0:	eafffe6f 	b	22ea4 <_vfprintf_r+0x174>
			if ((ch = *fmt++) == '*') {
   234e4:	e5db4000 	ldrb	r4, [fp]
			flags |= ALT;
   234e8:	e3877001 	orr	r7, r7, #1
			goto rflag;
   234ec:	eafffe6b 	b	22ea0 <_vfprintf_r+0x170>
			if (!sign)
   234f0:	e5dd306b 	ldrb	r3, [sp, #107]	@ 0x6b
			if ((ch = *fmt++) == '*') {
   234f4:	e5db4000 	ldrb	r4, [fp]
			if (!sign)
   234f8:	e3530000 	cmp	r3, #0
				sign = ' ';
   234fc:	03a03020 	moveq	r3, #32
   23500:	05cd306b 	strbeq	r3, [sp, #107]	@ 0x6b
   23504:	eafffe65 	b	22ea0 <_vfprintf_r+0x170>
			if ((ch = *fmt++) == '*') {
   23508:	e5db4000 	ldrb	r4, [fp]
			flags |= LONGDBL;
   2350c:	e3877008 	orr	r7, r7, #8
			goto rflag;
   23510:	eafffe62 	b	22ea0 <_vfprintf_r+0x170>
			width = GET_ARG (n, ap, int);
   23514:	e59d2028 	ldr	r2, [sp, #40]	@ 0x28
			flags |= LONGINT;
   23518:	e3877010 	orr	r7, r7, #16
			width = GET_ARG (n, ap, int);
   2351c:	e4923004 	ldr	r3, [r2], #4
   23520:	e58d2028 	str	r2, [sp, #40]	@ 0x28
   23524:	e1a06003 	mov	r6, r3
			if ((long) _uquad < 0)
   23528:	e3530000 	cmp	r3, #0
   2352c:	ba0002af 	blt	23ff0 <_vfprintf_r+0x12c0>
number:			if ((dprec = prec) >= 0)
   23530:	e3590000 	cmp	r9, #0
   23534:	ba000219 	blt	23da0 <_vfprintf_r+0x1070>
			if (_uquad != 0 || prec != 0) {
   23538:	e1993003 	orrs	r3, r9, r3
				flags &= ~ZEROPAD;
   2353c:	e3c77080 	bic	r7, r7, #128	@ 0x80
			if (_uquad != 0 || prec != 0) {
   23540:	1a000216 	bne	23da0 <_vfprintf_r+0x1070>
   23544:	e1a09003 	mov	r9, r3
			cp = buf + BUF;
   23548:	e28d5f4e 	add	r5, sp, #312	@ 0x138
			if (_uquad != 0 || prec != 0) {
   2354c:	e58d3020 	str	r3, [sp, #32]
   23550:	ea000015 	b	235ac <_vfprintf_r+0x87c>
			width = GET_ARG (n, ap, int);
   23554:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
			flags |= LONGINT;
   23558:	e3870010 	orr	r0, r7, #16
			width = GET_ARG (n, ap, int);
   2355c:	e4936004 	ldr	r6, [r3], #4
   23560:	e58d3028 	str	r3, [sp, #40]	@ 0x28
			base = DEC;
   23564:	e3a03001 	mov	r3, #1
nosign:			sign = '\0';
   23568:	e3a02000 	mov	r2, #0
number:			if ((dprec = prec) >= 0)
   2356c:	e3590000 	cmp	r9, #0
				sign = '-';
   23570:	e5cd206b 	strb	r2, [sp, #107]	@ 0x6b
number:			if ((dprec = prec) >= 0)
   23574:	ba000128 	blt	23a1c <_vfprintf_r+0xcec>
			if (_uquad != 0 || prec != 0) {
   23578:	e1992006 	orrs	r2, r9, r6
				flags &= ~ZEROPAD;
   2357c:	e3c07080 	bic	r7, r0, #128	@ 0x80
			if (_uquad != 0 || prec != 0) {
   23580:	1a000124 	bne	23a18 <_vfprintf_r+0xce8>
                       else if (base == OCT && (flags & ALT))
   23584:	e3530000 	cmp	r3, #0
   23588:	1a000200 	bne	23d90 <_vfprintf_r+0x1060>
   2358c:	e2102001 	ands	r2, r0, #1
                         *--cp = '0';
   23590:	e1a09003 	mov	r9, r3
			cp = buf + BUF;
   23594:	028d5f4e 	addeq	r5, sp, #312	@ 0x138
                       else if (base == OCT && (flags & ALT))
   23598:	e58d2020 	str	r2, [sp, #32]
						*--cp = to_char(_uquad);
   2359c:	128d5f4d 	addne	r5, sp, #308	@ 0x134
                         *--cp = '0';
   235a0:	13a03030 	movne	r3, #48	@ 0x30
						*--cp = to_char(_uquad);
   235a4:	12855003 	addne	r5, r5, #3
                         *--cp = '0';
   235a8:	15cd3137 	strbne	r3, [sp, #311]	@ 0x137
		realsz = dprec > size ? dprec : size;
   235ac:	e59d2020 	ldr	r2, [sp, #32]
   235b0:	e3a03000 	mov	r3, #0
		if (sign)
   235b4:	e5dd106b 	ldrb	r1, [sp, #107]	@ 0x6b
		realsz = dprec > size ? dprec : size;
   235b8:	e58d3024 	str	r3, [sp, #36]	@ 0x24
   235bc:	e1590002 	cmp	r9, r2
		nseps = nrepeats = 0;
   235c0:	e58d303c 	str	r3, [sp, #60]	@ 0x3c
		realsz = dprec > size ? dprec : size;
   235c4:	a1a02009 	movge	r2, r9
		nseps = nrepeats = 0;
   235c8:	e58d3038 	str	r3, [sp, #56]	@ 0x38
		realsz = dprec > size ? dprec : size;
   235cc:	e58d2010 	str	r2, [sp, #16]
		lead = 0;
   235d0:	e58d3030 	str	r3, [sp, #48]	@ 0x30
		if (sign)
   235d4:	e3510000 	cmp	r1, #0
   235d8:	0afffef5 	beq	231b4 <_vfprintf_r+0x484>
			realsz++;
   235dc:	e59d3010 	ldr	r3, [sp, #16]
   235e0:	e2833001 	add	r3, r3, #1
   235e4:	e58d3010 	str	r3, [sp, #16]
   235e8:	eafffef1 	b	231b4 <_vfprintf_r+0x484>
			width = GET_ARG (n, ap, int);
   235ec:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
			flags |= LONGINT;
   235f0:	e3877010 	orr	r7, r7, #16
			width = GET_ARG (n, ap, int);
   235f4:	e4936004 	ldr	r6, [r3], #4
   235f8:	e58d3028 	str	r3, [sp, #40]	@ 0x28
			flags &= ~GROUPING;
   235fc:	e3c70b01 	bic	r0, r7, #1024	@ 0x400
			base = OCT;
   23600:	e3a03000 	mov	r3, #0
			goto nosign;
   23604:	eaffffd7 	b	23568 <_vfprintf_r+0x838>
			if (*fmt == 'h') {
   23608:	e5db4000 	ldrb	r4, [fp]
   2360c:	e3540068 	cmp	r4, #104	@ 0x68
rflag:		ch = *fmt++;
   23610:	05db4001 	ldrbeq	r4, [fp, #1]
				flags |= CHARINT;
   23614:	03877c02 	orreq	r7, r7, #512	@ 0x200
				fmt++;
   23618:	028bb001 	addeq	fp, fp, #1
				flags |= SHORTINT;
   2361c:	13877040 	orrne	r7, r7, #64	@ 0x40
   23620:	eafffe1e 	b	22ea0 <_vfprintf_r+0x170>
			if (flags & LONGINT)
   23624:	e3170010 	tst	r7, #16
   23628:	0a0002ea 	beq	241d8 <_vfprintf_r+0x14a8>
				*GET_ARG (N, ap, int_ptr_t) = ret;
   2362c:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
   23630:	e59d201c 	ldr	r2, [sp, #28]
   23634:	e5933000 	ldr	r3, [r3]
   23638:	e5832000 	str	r2, [r3]
			width = GET_ARG (n, ap, int);
   2363c:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
   23640:	e2833004 	add	r3, r3, #4
   23644:	e58d3028 	str	r3, [sp, #40]	@ 0x28
   23648:	eafffdf0 	b	22e10 <_vfprintf_r+0xe0>
			if (*fmt == 'l') {
   2364c:	e5db4000 	ldrb	r4, [fp]
				flags |= QUADINT;
   23650:	e3877010 	orr	r7, r7, #16
			if (*fmt == 'l') {
   23654:	e354006c 	cmp	r4, #108	@ 0x6c
rflag:		ch = *fmt++;
   23658:	05db4001 	ldrbeq	r4, [fp, #1]
				fmt++;
   2365c:	028bb001 	addeq	fp, fp, #1
   23660:	eafffe0e 	b	22ea0 <_vfprintf_r+0x170>
			width = GET_ARG (n, ap, int);
   23664:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
			_uquad = UARG ();
   23668:	e3170010 	tst	r7, #16
			width = GET_ARG (n, ap, int);
   2366c:	e4936004 	ldr	r6, [r3], #4
   23670:	e58d3028 	str	r3, [sp, #40]	@ 0x28
			_uquad = UARG ();
   23674:	1a0003ad 	bne	24530 <_vfprintf_r+0x1800>
   23678:	e3170040 	tst	r7, #64	@ 0x40
   2367c:	1a0002cb 	bne	241b0 <_vfprintf_r+0x1480>
   23680:	e3170c02 	tst	r7, #512	@ 0x200
   23684:	0a0003a9 	beq	24530 <_vfprintf_r+0x1800>
   23688:	e6ef6076 	uxtb	r6, r6
   2368c:	e1a00007 	mov	r0, r7
			base = DEC;
   23690:	e3a03001 	mov	r3, #1
   23694:	eaffffb3 	b	23568 <_vfprintf_r+0x838>
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   23698:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
			flags |= HEXPREFIX;
   2369c:	e3870002 	orr	r0, r7, #2
			ox[1] = ch = 'x';
   236a0:	e3a04078 	mov	r4, #120	@ 0x78
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   236a4:	e4936004 	ldr	r6, [r3], #4
   236a8:	e58d3028 	str	r3, [sp, #40]	@ 0x28
			ox[0] = '0';
   236ac:	e3073830 	movw	r3, #30768	@ 0x7830
   236b0:	e1cd36bc 	strh	r3, [sp, #108]	@ 0x6c
			xdigs = "0123456789abcdef";
   236b4:	e30931b8 	movw	r3, #37304	@ 0x91b8
   236b8:	e3403002 	movt	r3, #2
   236bc:	e58d304c 	str	r3, [sp, #76]	@ 0x4c
			base = HEX;
   236c0:	e3a03002 	mov	r3, #2
			goto nosign;
   236c4:	eaffffa7 	b	23568 <_vfprintf_r+0x838>
			width = GET_ARG (n, ap, int);
   236c8:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
			_uquad = UARG ();
   236cc:	e3170010 	tst	r7, #16
			width = GET_ARG (n, ap, int);
   236d0:	e4936004 	ldr	r6, [r3], #4
   236d4:	e58d3028 	str	r3, [sp, #40]	@ 0x28
			_uquad = UARG ();
   236d8:	1affffc7 	bne	235fc <_vfprintf_r+0x8cc>
   236dc:	e3170040 	tst	r7, #64	@ 0x40
   236e0:	16ff6076 	uxthne	r6, r6
   236e4:	1affffc4 	bne	235fc <_vfprintf_r+0x8cc>
   236e8:	e3170c02 	tst	r7, #512	@ 0x200
   236ec:	16ef6076 	uxtbne	r6, r6
   236f0:	eaffffc1 	b	235fc <_vfprintf_r+0x8cc>
			if (ch >= 'f') {	/* 'f' or 'g' */
   236f4:	e3540065 	cmp	r4, #101	@ 0x65
   236f8:	da0000eb 	ble	23aac <_vfprintf_r+0xd7c>
				if (_fpvalue == 0) {
   236fc:	eeb58b40 	vcmp.f64	d8, #0.0
   23700:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   23704:	1a0001b0 	bne	23dcc <_vfprintf_r+0x109c>
					PRINT ("0", 1);
   23708:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   2370c:	e2822001 	add	r2, r2, #1
   23710:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   23714:	e2833001 	add	r3, r3, #1
   23718:	e3530007 	cmp	r3, #7
   2371c:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   23720:	e30933b4 	movw	r3, #37812	@ 0x93b4
   23724:	e3403002 	movt	r3, #2
   23728:	e58a3000 	str	r3, [sl]
   2372c:	e3a03001 	mov	r3, #1
   23730:	e58a3004 	str	r3, [sl, #4]
   23734:	d28aa008 	addle	sl, sl, #8
   23738:	ca000373 	bgt	2450c <_vfprintf_r+0x17dc>
					if (expt < ndig || flags & ALT) {
   2373c:	e59d3070 	ldr	r3, [sp, #112]	@ 0x70
   23740:	e59d1034 	ldr	r1, [sp, #52]	@ 0x34
   23744:	e1530001 	cmp	r3, r1
   23748:	aa00022d 	bge	24004 <_vfprintf_r+0x12d4>
						PRINT (decimal_point, decp_len);
   2374c:	e59d3040 	ldr	r3, [sp, #64]	@ 0x40
   23750:	e59d1044 	ldr	r1, [sp, #68]	@ 0x44
   23754:	e0822003 	add	r2, r2, r3
   23758:	e88a000a 	stm	sl, {r1, r3}
   2375c:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   23760:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   23764:	e2833001 	add	r3, r3, #1
   23768:	e3530007 	cmp	r3, #7
   2376c:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   23770:	d28aa008 	addle	sl, sl, #8
   23774:	ca0002ba 	bgt	24264 <_vfprintf_r+0x1534>
						PAD (ndig - 1, zeroes);
   23778:	e59d3034 	ldr	r3, [sp, #52]	@ 0x34
   2377c:	e2434001 	sub	r4, r3, #1
   23780:	e3540000 	cmp	r4, #0
   23784:	dafffec7 	ble	232a8 <_vfprintf_r+0x578>
   23788:	e3540010 	cmp	r4, #16
   2378c:	e51f861c 	ldr	r8, [pc, #-1564]	@ 23178 <_vfprintf_r+0x448>
   23790:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   23794:	da000301 	ble	243a0 <_vfprintf_r+0x1670>
   23798:	e59d600c 	ldr	r6, [sp, #12]
   2379c:	e3a05010 	mov	r5, #16
   237a0:	e59d9014 	ldr	r9, [sp, #20]
   237a4:	ea000002 	b	237b4 <_vfprintf_r+0xa84>
   237a8:	e2444010 	sub	r4, r4, #16
   237ac:	e3540010 	cmp	r4, #16
   237b0:	da0002fa 	ble	243a0 <_vfprintf_r+0x1670>
   237b4:	e2833001 	add	r3, r3, #1
   237b8:	e2822010 	add	r2, r2, #16
   237bc:	e3530007 	cmp	r3, #7
   237c0:	e58a8000 	str	r8, [sl]
   237c4:	e58a5004 	str	r5, [sl, #4]
   237c8:	d28aa008 	addle	sl, sl, #8
   237cc:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   237d0:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   237d4:	dafffff3 	ble	237a8 <_vfprintf_r+0xa78>
   237d8:	e28d2088 	add	r2, sp, #136	@ 0x88
   237dc:	e1a01009 	mov	r1, r9
   237e0:	e1a00006 	mov	r0, r6
   237e4:	ebffd108 	bl	17c0c <__sprint_r>
   237e8:	e3500000 	cmp	r0, #0
   237ec:	1afffe4e 	bne	2312c <_vfprintf_r+0x3fc>
   237f0:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   237f4:	e28da094 	add	sl, sp, #148	@ 0x94
   237f8:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   237fc:	eaffffe9 	b	237a8 <_vfprintf_r+0xa78>
			PAD (width - realsz, zeroes);
   23800:	e59d3018 	ldr	r3, [sp, #24]
   23804:	e59d1010 	ldr	r1, [sp, #16]
   23808:	e0436001 	sub	r6, r3, r1
   2380c:	e3560000 	cmp	r6, #0
   23810:	dafffe93 	ble	23264 <_vfprintf_r+0x534>
   23814:	e3560010 	cmp	r6, #16
   23818:	e51f86a8 	ldr	r8, [pc, #-1704]	@ 23178 <_vfprintf_r+0x448>
   2381c:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   23820:	da000029 	ble	238cc <_vfprintf_r+0xb9c>
   23824:	e1a0000a 	mov	r0, sl
   23828:	e58d402c 	str	r4, [sp, #44]	@ 0x2c
   2382c:	e1a0a009 	mov	sl, r9
   23830:	e59d400c 	ldr	r4, [sp, #12]
   23834:	e1a09007 	mov	r9, r7
   23838:	e1a01003 	mov	r1, r3
   2383c:	e1a07008 	mov	r7, r8
   23840:	e1a08005 	mov	r8, r5
   23844:	e59d5014 	ldr	r5, [sp, #20]
   23848:	ea000002 	b	23858 <_vfprintf_r+0xb28>
   2384c:	e2466010 	sub	r6, r6, #16
   23850:	e3560010 	cmp	r6, #16
   23854:	da000015 	ble	238b0 <_vfprintf_r+0xb80>
   23858:	e2811001 	add	r1, r1, #1
   2385c:	e2822010 	add	r2, r2, #16
   23860:	e3510007 	cmp	r1, #7
   23864:	e3a03010 	mov	r3, #16
   23868:	e5807000 	str	r7, [r0]
   2386c:	e5803004 	str	r3, [r0, #4]
   23870:	d2800008 	addle	r0, r0, #8
   23874:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   23878:	e58d108c 	str	r1, [sp, #140]	@ 0x8c
   2387c:	dafffff2 	ble	2384c <_vfprintf_r+0xb1c>
   23880:	e28d2088 	add	r2, sp, #136	@ 0x88
   23884:	e1a01005 	mov	r1, r5
   23888:	e1a00004 	mov	r0, r4
   2388c:	ebffd0de 	bl	17c0c <__sprint_r>
   23890:	e3500000 	cmp	r0, #0
   23894:	e28d0094 	add	r0, sp, #148	@ 0x94
   23898:	1afffe23 	bne	2312c <_vfprintf_r+0x3fc>
   2389c:	e2466010 	sub	r6, r6, #16
   238a0:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   238a4:	e3560010 	cmp	r6, #16
   238a8:	e59d108c 	ldr	r1, [sp, #140]	@ 0x8c
   238ac:	caffffe9 	bgt	23858 <_vfprintf_r+0xb28>
   238b0:	e59d402c 	ldr	r4, [sp, #44]	@ 0x2c
   238b4:	e1a05008 	mov	r5, r8
   238b8:	e1a03001 	mov	r3, r1
   238bc:	e1a08007 	mov	r8, r7
   238c0:	e1a07009 	mov	r7, r9
   238c4:	e1a0900a 	mov	r9, sl
   238c8:	e1a0a000 	mov	sl, r0
   238cc:	e2833001 	add	r3, r3, #1
   238d0:	e0822006 	add	r2, r2, r6
   238d4:	e3530007 	cmp	r3, #7
   238d8:	e58a8000 	str	r8, [sl]
   238dc:	e58a6004 	str	r6, [sl, #4]
   238e0:	d28aa008 	addle	sl, sl, #8
   238e4:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   238e8:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   238ec:	dafffe5c 	ble	23264 <_vfprintf_r+0x534>
   238f0:	e59d1014 	ldr	r1, [sp, #20]
   238f4:	e28d2088 	add	r2, sp, #136	@ 0x88
   238f8:	e59d000c 	ldr	r0, [sp, #12]
   238fc:	ebffd0c2 	bl	17c0c <__sprint_r>
   23900:	e3500000 	cmp	r0, #0
   23904:	1afffe08 	bne	2312c <_vfprintf_r+0x3fc>
		PAD (dprec - size, zeroes);
   23908:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
			PAD (width - realsz, zeroes);
   2390c:	e28da094 	add	sl, sp, #148	@ 0x94
   23910:	eafffe53 	b	23264 <_vfprintf_r+0x534>
		PAD (dprec - size, zeroes);
   23914:	e3560010 	cmp	r6, #16
   23918:	e51f87a8 	ldr	r8, [pc, #-1960]	@ 23178 <_vfprintf_r+0x448>
   2391c:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   23920:	da00002a 	ble	239d0 <_vfprintf_r+0xca0>
   23924:	e1a0c006 	mov	ip, r6
   23928:	e1a0000a 	mov	r0, sl
   2392c:	e1a06004 	mov	r6, r4
   23930:	e1a0a008 	mov	sl, r8
   23934:	e3a09010 	mov	r9, #16
   23938:	e1a08007 	mov	r8, r7
   2393c:	e1a01003 	mov	r1, r3
   23940:	e1a07005 	mov	r7, r5
   23944:	e1a0400c 	mov	r4, ip
   23948:	e59d5014 	ldr	r5, [sp, #20]
   2394c:	ea000002 	b	2395c <_vfprintf_r+0xc2c>
   23950:	e2444010 	sub	r4, r4, #16
   23954:	e3540010 	cmp	r4, #16
   23958:	da000014 	ble	239b0 <_vfprintf_r+0xc80>
   2395c:	e2811001 	add	r1, r1, #1
   23960:	e51f37f0 	ldr	r3, [pc, #-2032]	@ 23178 <_vfprintf_r+0x448>
   23964:	e3510007 	cmp	r1, #7
   23968:	e2822010 	add	r2, r2, #16
   2396c:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   23970:	e8800208 	stm	r0, {r3, r9}
   23974:	d2800008 	addle	r0, r0, #8
   23978:	e58d108c 	str	r1, [sp, #140]	@ 0x8c
   2397c:	dafffff3 	ble	23950 <_vfprintf_r+0xc20>
   23980:	e59d000c 	ldr	r0, [sp, #12]
   23984:	e28d2088 	add	r2, sp, #136	@ 0x88
   23988:	e1a01005 	mov	r1, r5
   2398c:	ebffd09e 	bl	17c0c <__sprint_r>
   23990:	e3500000 	cmp	r0, #0
   23994:	e28d0094 	add	r0, sp, #148	@ 0x94
   23998:	1afffde3 	bne	2312c <_vfprintf_r+0x3fc>
   2399c:	e2444010 	sub	r4, r4, #16
   239a0:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   239a4:	e3540010 	cmp	r4, #16
   239a8:	e59d108c 	ldr	r1, [sp, #140]	@ 0x8c
   239ac:	caffffea 	bgt	2395c <_vfprintf_r+0xc2c>
   239b0:	e1a0c004 	mov	ip, r4
   239b4:	e1a05007 	mov	r5, r7
   239b8:	e1a04006 	mov	r4, r6
   239bc:	e1a07008 	mov	r7, r8
   239c0:	e1a03001 	mov	r3, r1
   239c4:	e1a0800a 	mov	r8, sl
   239c8:	e1a0600c 	mov	r6, ip
   239cc:	e1a0a000 	mov	sl, r0
   239d0:	e2833001 	add	r3, r3, #1
   239d4:	e0822006 	add	r2, r2, r6
   239d8:	e3530007 	cmp	r3, #7
   239dc:	e58a8000 	str	r8, [sl]
   239e0:	e58a6004 	str	r6, [sl, #4]
   239e4:	d28aa008 	addle	sl, sl, #8
   239e8:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   239ec:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   239f0:	dafffe1f 	ble	23274 <_vfprintf_r+0x544>
   239f4:	e59d1014 	ldr	r1, [sp, #20]
   239f8:	e28d2088 	add	r2, sp, #136	@ 0x88
   239fc:	e59d000c 	ldr	r0, [sp, #12]
   23a00:	ebffd081 	bl	17c0c <__sprint_r>
   23a04:	e3500000 	cmp	r0, #0
   23a08:	1afffdc7 	bne	2312c <_vfprintf_r+0x3fc>
			PRINT (cp, size);
   23a0c:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
		PAD (dprec - size, zeroes);
   23a10:	e28da094 	add	sl, sp, #148	@ 0x94
   23a14:	eafffe16 	b	23274 <_vfprintf_r+0x544>
   23a18:	e1a00007 	mov	r0, r7
				switch (base) {
   23a1c:	e3530001 	cmp	r3, #1
   23a20:	0a0000df 	beq	23da4 <_vfprintf_r+0x1074>
   23a24:	e3530002 	cmp	r3, #2
   23a28:	e28d5f4e 	add	r5, sp, #312	@ 0x138
   23a2c:	1a00000a 	bne	23a5c <_vfprintf_r+0xd2c>
   23a30:	e59d204c 	ldr	r2, [sp, #76]	@ 0x4c
						*--cp = xdigs[_uquad & 15];
   23a34:	e206300f 	and	r3, r6, #15
					} while (_uquad);
   23a38:	e1b06226 	lsrs	r6, r6, #4
						*--cp = xdigs[_uquad & 15];
   23a3c:	e7d23003 	ldrb	r3, [r2, r3]
   23a40:	e5653001 	strb	r3, [r5, #-1]!
					} while (_uquad);
   23a44:	1afffffa 	bne	23a34 <_vfprintf_r+0xd04>
			size = buf + BUF - cp;
   23a48:	e28d3f4e 	add	r3, sp, #312	@ 0x138
   23a4c:	e1a07000 	mov	r7, r0
   23a50:	e0433005 	sub	r3, r3, r5
   23a54:	e58d3020 	str	r3, [sp, #32]
   23a58:	eafffed3 	b	235ac <_vfprintf_r+0x87c>
						*--cp = to_char (_uquad & 7);
   23a5c:	e2063007 	and	r3, r6, #7
					} while (_uquad);
   23a60:	e1b061a6 	lsrs	r6, r6, #3
						*--cp = to_char (_uquad & 7);
   23a64:	e2833030 	add	r3, r3, #48	@ 0x30
   23a68:	e1a02005 	mov	r2, r5
   23a6c:	e5653001 	strb	r3, [r5, #-1]!
					} while (_uquad);
   23a70:	1afffff9 	bne	23a5c <_vfprintf_r+0xd2c>
					if (flags & ALT && *cp != '0')
   23a74:	e3530030 	cmp	r3, #48	@ 0x30
   23a78:	03a01000 	moveq	r1, #0
   23a7c:	12001001 	andne	r1, r0, #1
   23a80:	e3510000 	cmp	r1, #0
   23a84:	0affffef 	beq	23a48 <_vfprintf_r+0xd18>
						*--cp = '0';
   23a88:	e3a03030 	mov	r3, #48	@ 0x30
   23a8c:	e2422002 	sub	r2, r2, #2
   23a90:	e5453001 	strb	r3, [r5, #-1]
			size = buf + BUF - cp;
   23a94:	e28d3f4e 	add	r3, sp, #312	@ 0x138
   23a98:	e0433002 	sub	r3, r3, r2
   23a9c:	e1a07000 	mov	r7, r0
						*--cp = '0';
   23aa0:	e1a05002 	mov	r5, r2
			size = buf + BUF - cp;
   23aa4:	e58d3020 	str	r3, [sp, #32]
   23aa8:	eafffebf 	b	235ac <_vfprintf_r+0x87c>
				if (ndig > 1 || flags & ALT) {
   23aac:	e59d3034 	ldr	r3, [sp, #52]	@ 0x34
					PRINT (cp, 1);
   23ab0:	e2822001 	add	r2, r2, #1
			PRINT (cp, size);
   23ab4:	e28a1008 	add	r1, sl, #8
				if (ndig > 1 || flags & ALT) {
   23ab8:	e3530001 	cmp	r3, #1
					PRINT (cp, 1);
   23abc:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   23ac0:	e2833001 	add	r3, r3, #1
				if (ndig > 1 || flags & ALT) {
   23ac4:	da000116 	ble	23f24 <_vfprintf_r+0x11f4>
					PRINT (cp, 1);
   23ac8:	e3530007 	cmp	r3, #7
   23acc:	e3a00001 	mov	r0, #1
   23ad0:	e58a5000 	str	r5, [sl]
   23ad4:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   23ad8:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   23adc:	e58a0004 	str	r0, [sl, #4]
   23ae0:	ca000241 	bgt	243ec <_vfprintf_r+0x16bc>
					PRINT (decimal_point, decp_len);
   23ae4:	e59d0040 	ldr	r0, [sp, #64]	@ 0x40
   23ae8:	e2833001 	add	r3, r3, #1
   23aec:	e59dc044 	ldr	ip, [sp, #68]	@ 0x44
   23af0:	e3530007 	cmp	r3, #7
   23af4:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   23af8:	e0822000 	add	r2, r2, r0
   23afc:	e5810004 	str	r0, [r1, #4]
   23b00:	e581c000 	str	ip, [r1]
   23b04:	d2811008 	addle	r1, r1, #8
   23b08:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   23b0c:	ca00022c 	bgt	243c4 <_vfprintf_r+0x1694>
						PAD (ndig - 1, zeroes);
   23b10:	e59d0034 	ldr	r0, [sp, #52]	@ 0x34
					if (_fpvalue) {
   23b14:	eeb58b40 	vcmp.f64	d8, #0.0
   23b18:	eef1fa10 	vmrs	APSR_nzcv, fpscr
						PAD (ndig - 1, zeroes);
   23b1c:	e2406001 	sub	r6, r0, #1
					if (_fpvalue) {
   23b20:	0a000112 	beq	23f70 <_vfprintf_r+0x1240>
						PRINT (cp, ndig - 1);
   23b24:	e2833001 	add	r3, r3, #1
					cp++;
   23b28:	e2855001 	add	r5, r5, #1
						PRINT (cp, ndig - 1);
   23b2c:	e5815000 	str	r5, [r1]
						PAD (ndig - 1, zeroes);
   23b30:	e3530007 	cmp	r3, #7
   23b34:	e0822006 	add	r2, r2, r6
   23b38:	e5816004 	str	r6, [r1, #4]
   23b3c:	d2811008 	addle	r1, r1, #8
   23b40:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   23b44:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   23b48:	ca0000fe 	bgt	23f48 <_vfprintf_r+0x1218>
				PRINT (expstr, expsize);
   23b4c:	e59d0048 	ldr	r0, [sp, #72]	@ 0x48
   23b50:	e2833001 	add	r3, r3, #1
   23b54:	e3530007 	cmp	r3, #7
   23b58:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   23b5c:	e28d3078 	add	r3, sp, #120	@ 0x78
   23b60:	d281a008 	addle	sl, r1, #8
   23b64:	e0802002 	add	r2, r0, r2
   23b68:	e5810004 	str	r0, [r1, #4]
   23b6c:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   23b70:	e5813000 	str	r3, [r1]
   23b74:	dafffdcb 	ble	232a8 <_vfprintf_r+0x578>
   23b78:	e59d1014 	ldr	r1, [sp, #20]
   23b7c:	e28d2088 	add	r2, sp, #136	@ 0x88
   23b80:	e59d000c 	ldr	r0, [sp, #12]
   23b84:	ebffd020 	bl	17c0c <__sprint_r>
   23b88:	e3500000 	cmp	r0, #0
   23b8c:	1afffd66 	bne	2312c <_vfprintf_r+0x3fc>
			PAD (width - realsz, blanks);
   23b90:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
				PRINT (expstr, expsize);
   23b94:	e28da094 	add	sl, sp, #148	@ 0x94
   23b98:	eafffdc2 	b	232a8 <_vfprintf_r+0x578>
			PAD (width - realsz, blanks);
   23b9c:	e3560010 	cmp	r6, #16
   23ba0:	e30a8090 	movw	r8, #41104	@ 0xa090
   23ba4:	e59d108c 	ldr	r1, [sp, #140]	@ 0x8c
   23ba8:	e3408002 	movt	r8, #2
   23bac:	da000027 	ble	23c50 <_vfprintf_r+0xf20>
   23bb0:	e1a0000a 	mov	r0, sl
   23bb4:	e1a0a009 	mov	sl, r9
   23bb8:	e1a09007 	mov	r9, r7
   23bbc:	e1a07004 	mov	r7, r4
   23bc0:	e1a04008 	mov	r4, r8
   23bc4:	e1a08005 	mov	r8, r5
   23bc8:	e1a05003 	mov	r5, r3
   23bcc:	ea000002 	b	23bdc <_vfprintf_r+0xeac>
   23bd0:	e2466010 	sub	r6, r6, #16
   23bd4:	e3560010 	cmp	r6, #16
   23bd8:	da000015 	ble	23c34 <_vfprintf_r+0xf04>
   23bdc:	e2811001 	add	r1, r1, #1
   23be0:	e2822010 	add	r2, r2, #16
   23be4:	e3510007 	cmp	r1, #7
   23be8:	e3a03010 	mov	r3, #16
   23bec:	e5804000 	str	r4, [r0]
   23bf0:	e5803004 	str	r3, [r0, #4]
   23bf4:	d2800008 	addle	r0, r0, #8
   23bf8:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   23bfc:	e58d108c 	str	r1, [sp, #140]	@ 0x8c
   23c00:	dafffff2 	ble	23bd0 <_vfprintf_r+0xea0>
   23c04:	e59d1014 	ldr	r1, [sp, #20]
   23c08:	e28d2088 	add	r2, sp, #136	@ 0x88
   23c0c:	e59d000c 	ldr	r0, [sp, #12]
   23c10:	ebffcffd 	bl	17c0c <__sprint_r>
   23c14:	e3500000 	cmp	r0, #0
   23c18:	e28d0094 	add	r0, sp, #148	@ 0x94
   23c1c:	1afffd42 	bne	2312c <_vfprintf_r+0x3fc>
   23c20:	e2466010 	sub	r6, r6, #16
   23c24:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   23c28:	e3560010 	cmp	r6, #16
   23c2c:	e59d108c 	ldr	r1, [sp, #140]	@ 0x8c
   23c30:	caffffe9 	bgt	23bdc <_vfprintf_r+0xeac>
   23c34:	e1a03005 	mov	r3, r5
   23c38:	e1a05008 	mov	r5, r8
   23c3c:	e1a08004 	mov	r8, r4
   23c40:	e1a04007 	mov	r4, r7
   23c44:	e1a07009 	mov	r7, r9
   23c48:	e1a0900a 	mov	r9, sl
   23c4c:	e1a0a000 	mov	sl, r0
   23c50:	e2811001 	add	r1, r1, #1
   23c54:	e0822006 	add	r2, r2, r6
   23c58:	e3510007 	cmp	r1, #7
   23c5c:	e58a8000 	str	r8, [sl]
   23c60:	e58d108c 	str	r1, [sp, #140]	@ 0x8c
   23c64:	e58a6004 	str	r6, [sl, #4]
   23c68:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   23c6c:	ca0001e8 	bgt	24414 <_vfprintf_r+0x16e4>
		if (sign)
   23c70:	e5dd106b 	ldrb	r1, [sp, #107]	@ 0x6b
			PAD (width - realsz, blanks);
   23c74:	e28aa008 	add	sl, sl, #8
   23c78:	eafffd5a 	b	231e8 <_vfprintf_r+0x4b8>
			PRINT (&sign, 1);
   23c7c:	e59d1014 	ldr	r1, [sp, #20]
   23c80:	e28d2088 	add	r2, sp, #136	@ 0x88
   23c84:	e59d000c 	ldr	r0, [sp, #12]
   23c88:	e58d305c 	str	r3, [sp, #92]	@ 0x5c
   23c8c:	ebffcfde 	bl	17c0c <__sprint_r>
   23c90:	e3500000 	cmp	r0, #0
   23c94:	1afffd24 	bne	2312c <_vfprintf_r+0x3fc>
			PRINT (ox, 2);
   23c98:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
			PRINT (&sign, 1);
   23c9c:	e28da094 	add	sl, sp, #148	@ 0x94
   23ca0:	e59d305c 	ldr	r3, [sp, #92]	@ 0x5c
   23ca4:	eafffd5d 	b	23220 <_vfprintf_r+0x4f0>
			PRINT (ox, 2);
   23ca8:	e59d1014 	ldr	r1, [sp, #20]
   23cac:	e28d2088 	add	r2, sp, #136	@ 0x88
   23cb0:	e59d000c 	ldr	r0, [sp, #12]
   23cb4:	ebffcfd4 	bl	17c0c <__sprint_r>
   23cb8:	e3500000 	cmp	r0, #0
   23cbc:	1afffd1a 	bne	2312c <_vfprintf_r+0x3fc>
		PAD (dprec - size, zeroes);
   23cc0:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
			PRINT (ox, 2);
   23cc4:	e28da094 	add	sl, sp, #148	@ 0x94
   23cc8:	eafffd62 	b	23258 <_vfprintf_r+0x528>
			PAD (width - realsz, blanks);
   23ccc:	e3540010 	cmp	r4, #16
   23cd0:	e30a8090 	movw	r8, #41104	@ 0xa090
   23cd4:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   23cd8:	e3408002 	movt	r8, #2
   23cdc:	da00001b 	ble	23d50 <_vfprintf_r+0x1020>
   23ce0:	e59d600c 	ldr	r6, [sp, #12]
   23ce4:	e3a05010 	mov	r5, #16
   23ce8:	e59d7014 	ldr	r7, [sp, #20]
   23cec:	ea000002 	b	23cfc <_vfprintf_r+0xfcc>
   23cf0:	e2444010 	sub	r4, r4, #16
   23cf4:	e3540010 	cmp	r4, #16
   23cf8:	da000014 	ble	23d50 <_vfprintf_r+0x1020>
   23cfc:	e2833001 	add	r3, r3, #1
   23d00:	e2822010 	add	r2, r2, #16
   23d04:	e3530007 	cmp	r3, #7
   23d08:	e58a8000 	str	r8, [sl]
   23d0c:	e58a5004 	str	r5, [sl, #4]
   23d10:	d28aa008 	addle	sl, sl, #8
   23d14:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   23d18:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   23d1c:	dafffff3 	ble	23cf0 <_vfprintf_r+0xfc0>
   23d20:	e28d2088 	add	r2, sp, #136	@ 0x88
   23d24:	e1a01007 	mov	r1, r7
   23d28:	e1a00006 	mov	r0, r6
   23d2c:	e28da094 	add	sl, sp, #148	@ 0x94
   23d30:	ebffcfb5 	bl	17c0c <__sprint_r>
   23d34:	e3500000 	cmp	r0, #0
   23d38:	1afffcfb 	bne	2312c <_vfprintf_r+0x3fc>
   23d3c:	e2444010 	sub	r4, r4, #16
   23d40:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   23d44:	e3540010 	cmp	r4, #16
   23d48:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   23d4c:	caffffea 	bgt	23cfc <_vfprintf_r+0xfcc>
   23d50:	e2833001 	add	r3, r3, #1
   23d54:	e0822004 	add	r2, r2, r4
   23d58:	e3530007 	cmp	r3, #7
   23d5c:	e58a8000 	str	r8, [sl]
   23d60:	e58a4004 	str	r4, [sl, #4]
   23d64:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   23d68:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   23d6c:	dafffd54 	ble	232c4 <_vfprintf_r+0x594>
   23d70:	e59d1014 	ldr	r1, [sp, #20]
   23d74:	e28d2088 	add	r2, sp, #136	@ 0x88
   23d78:	e59d000c 	ldr	r0, [sp, #12]
   23d7c:	ebffcfa2 	bl	17c0c <__sprint_r>
   23d80:	e3500000 	cmp	r0, #0
   23d84:	1afffce8 	bne	2312c <_vfprintf_r+0x3fc>
		FLUSH ();	/* copy out the I/O vectors */
   23d88:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   23d8c:	eafffd4c 	b	232c4 <_vfprintf_r+0x594>
   23d90:	e1a09002 	mov	r9, r2
			cp = buf + BUF;
   23d94:	e28d5f4e 	add	r5, sp, #312	@ 0x138
   23d98:	e58d2020 	str	r2, [sp, #32]
   23d9c:	eafffe02 	b	235ac <_vfprintf_r+0x87c>
				flags &= ~ZEROPAD;
   23da0:	e1a00007 	mov	r0, r7
					if (_uquad < 10) {
   23da4:	e3560009 	cmp	r6, #9
   23da8:	8a0001e2 	bhi	24538 <_vfprintf_r+0x1808>
						*--cp = to_char(_uquad);
   23dac:	e2866030 	add	r6, r6, #48	@ 0x30
						break;
   23db0:	e3a03001 	mov	r3, #1
						*--cp = to_char(_uquad);
   23db4:	e28d5f4d 	add	r5, sp, #308	@ 0x134
						break;
   23db8:	e1a07000 	mov	r7, r0
						*--cp = to_char(_uquad);
   23dbc:	e2855003 	add	r5, r5, #3
   23dc0:	e5cd6137 	strb	r6, [sp, #311]	@ 0x137
						break;
   23dc4:	e58d3020 	str	r3, [sp, #32]
   23dc8:	eafffdf7 	b	235ac <_vfprintf_r+0x87c>
				} else if (expt <= 0) {
   23dcc:	e59d4070 	ldr	r4, [sp, #112]	@ 0x70
   23dd0:	e3540000 	cmp	r4, #0
   23dd4:	da0001a2 	ble	24464 <_vfprintf_r+0x1734>
					PRINTANDPAD(cp, convbuf + ndig,
   23dd8:	e59d3030 	ldr	r3, [sp, #48]	@ 0x30
   23ddc:	e59d1034 	ldr	r1, [sp, #52]	@ 0x34
   23de0:	e1530001 	cmp	r3, r1
   23de4:	b1a06003 	movlt	r6, r3
   23de8:	a1a06001 	movge	r6, r1
   23dec:	e3560000 	cmp	r6, #0
   23df0:	da000008 	ble	23e18 <_vfprintf_r+0x10e8>
   23df4:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   23df8:	e0822006 	add	r2, r2, r6
   23dfc:	e88a0060 	stm	sl, {r5, r6}
   23e00:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   23e04:	e2833001 	add	r3, r3, #1
   23e08:	e3530007 	cmp	r3, #7
   23e0c:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   23e10:	d28aa008 	addle	sl, sl, #8
   23e14:	ca000326 	bgt	24ab4 <_vfprintf_r+0x1d84>
   23e18:	e59d4030 	ldr	r4, [sp, #48]	@ 0x30
   23e1c:	e3560000 	cmp	r6, #0
   23e20:	a0444006 	subge	r4, r4, r6
   23e24:	e3540000 	cmp	r4, #0
   23e28:	ca000125 	bgt	242c4 <_vfprintf_r+0x1594>
					cp += lead;
   23e2c:	e59d3030 	ldr	r3, [sp, #48]	@ 0x30
					if (flags & GROUPING) {
   23e30:	e3170b01 	tst	r7, #1024	@ 0x400
					cp += lead;
   23e34:	e0858003 	add	r8, r5, r3
					if (flags & GROUPING) {
   23e38:	1a00029d 	bne	248b4 <_vfprintf_r+0x1b84>
					if (expt < ndig || flags & ALT)
   23e3c:	e59d4070 	ldr	r4, [sp, #112]	@ 0x70
   23e40:	e59d3034 	ldr	r3, [sp, #52]	@ 0x34
   23e44:	e1540003 	cmp	r4, r3
   23e48:	ba00013f 	blt	2434c <_vfprintf_r+0x161c>
   23e4c:	e3170001 	tst	r7, #1
   23e50:	1a00013d 	bne	2434c <_vfprintf_r+0x161c>
					PRINTANDPAD (cp, convbuf + ndig,
   23e54:	e59d3034 	ldr	r3, [sp, #52]	@ 0x34
   23e58:	e0855003 	add	r5, r5, r3
   23e5c:	e0434004 	sub	r4, r3, r4
   23e60:	e0455008 	sub	r5, r5, r8
   23e64:	e1550004 	cmp	r5, r4
   23e68:	a1a05004 	movge	r5, r4
   23e6c:	e3550000 	cmp	r5, #0
   23e70:	da000009 	ble	23e9c <_vfprintf_r+0x116c>
   23e74:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   23e78:	e0822005 	add	r2, r2, r5
   23e7c:	e58a8000 	str	r8, [sl]
   23e80:	e58a5004 	str	r5, [sl, #4]
   23e84:	e2833001 	add	r3, r3, #1
   23e88:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   23e8c:	e3530007 	cmp	r3, #7
   23e90:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   23e94:	d28aa008 	addle	sl, sl, #8
   23e98:	ca00039b 	bgt	24d0c <_vfprintf_r+0x1fdc>
   23e9c:	e3550000 	cmp	r5, #0
   23ea0:	a0444005 	subge	r4, r4, r5
   23ea4:	e3540000 	cmp	r4, #0
   23ea8:	dafffcfe 	ble	232a8 <_vfprintf_r+0x578>
   23eac:	e3540010 	cmp	r4, #16
   23eb0:	e51f8d40 	ldr	r8, [pc, #-3392]	@ 23178 <_vfprintf_r+0x448>
   23eb4:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   23eb8:	da000138 	ble	243a0 <_vfprintf_r+0x1670>
   23ebc:	e59d600c 	ldr	r6, [sp, #12]
   23ec0:	e3a05010 	mov	r5, #16
   23ec4:	e59d9014 	ldr	r9, [sp, #20]
   23ec8:	ea000002 	b	23ed8 <_vfprintf_r+0x11a8>
   23ecc:	e2444010 	sub	r4, r4, #16
   23ed0:	e3540010 	cmp	r4, #16
   23ed4:	da000131 	ble	243a0 <_vfprintf_r+0x1670>
   23ed8:	e2833001 	add	r3, r3, #1
   23edc:	e2822010 	add	r2, r2, #16
   23ee0:	e3530007 	cmp	r3, #7
   23ee4:	e58a8000 	str	r8, [sl]
   23ee8:	e58a5004 	str	r5, [sl, #4]
   23eec:	d28aa008 	addle	sl, sl, #8
   23ef0:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   23ef4:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   23ef8:	dafffff3 	ble	23ecc <_vfprintf_r+0x119c>
   23efc:	e28d2088 	add	r2, sp, #136	@ 0x88
   23f00:	e1a01009 	mov	r1, r9
   23f04:	e1a00006 	mov	r0, r6
   23f08:	ebffcf3f 	bl	17c0c <__sprint_r>
   23f0c:	e3500000 	cmp	r0, #0
   23f10:	1afffc85 	bne	2312c <_vfprintf_r+0x3fc>
   23f14:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   23f18:	e28da094 	add	sl, sp, #148	@ 0x94
   23f1c:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   23f20:	eaffffe9 	b	23ecc <_vfprintf_r+0x119c>
				if (ndig > 1 || flags & ALT) {
   23f24:	e3170001 	tst	r7, #1
   23f28:	1afffee6 	bne	23ac8 <_vfprintf_r+0xd98>
					PRINT (cp, 1);
   23f2c:	e3530007 	cmp	r3, #7
   23f30:	e3a00001 	mov	r0, #1
   23f34:	e58a5000 	str	r5, [sl]
   23f38:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   23f3c:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   23f40:	e58a0004 	str	r0, [sl, #4]
   23f44:	daffff00 	ble	23b4c <_vfprintf_r+0xe1c>
   23f48:	e59d1014 	ldr	r1, [sp, #20]
   23f4c:	e28d2088 	add	r2, sp, #136	@ 0x88
   23f50:	e59d000c 	ldr	r0, [sp, #12]
   23f54:	ebffcf2c 	bl	17c0c <__sprint_r>
   23f58:	e3500000 	cmp	r0, #0
   23f5c:	1afffc72 	bne	2312c <_vfprintf_r+0x3fc>
				PRINT (expstr, expsize);
   23f60:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
					PRINT (cp, 1);
   23f64:	e28d1094 	add	r1, sp, #148	@ 0x94
				PRINT (expstr, expsize);
   23f68:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   23f6c:	eafffef6 	b	23b4c <_vfprintf_r+0xe1c>
						PAD (ndig - 1, zeroes);
   23f70:	e59d0034 	ldr	r0, [sp, #52]	@ 0x34
   23f74:	e3500001 	cmp	r0, #1
   23f78:	dafffef3 	ble	23b4c <_vfprintf_r+0xe1c>
   23f7c:	e3500011 	cmp	r0, #17
   23f80:	e51f8e10 	ldr	r8, [pc, #-3600]	@ 23178 <_vfprintf_r+0x448>
   23f84:	da0001a0 	ble	2460c <_vfprintf_r+0x18dc>
   23f88:	e59d500c 	ldr	r5, [sp, #12]
   23f8c:	e3a04010 	mov	r4, #16
   23f90:	e59d9014 	ldr	r9, [sp, #20]
   23f94:	ea000002 	b	23fa4 <_vfprintf_r+0x1274>
   23f98:	e2466010 	sub	r6, r6, #16
   23f9c:	e3560010 	cmp	r6, #16
   23fa0:	da000199 	ble	2460c <_vfprintf_r+0x18dc>
   23fa4:	e2833001 	add	r3, r3, #1
   23fa8:	e2822010 	add	r2, r2, #16
   23fac:	e3530007 	cmp	r3, #7
   23fb0:	e5818000 	str	r8, [r1]
   23fb4:	e5814004 	str	r4, [r1, #4]
   23fb8:	d2811008 	addle	r1, r1, #8
   23fbc:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   23fc0:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   23fc4:	dafffff3 	ble	23f98 <_vfprintf_r+0x1268>
   23fc8:	e28d2088 	add	r2, sp, #136	@ 0x88
   23fcc:	e1a01009 	mov	r1, r9
   23fd0:	e1a00005 	mov	r0, r5
   23fd4:	ebffcf0c 	bl	17c0c <__sprint_r>
   23fd8:	e3500000 	cmp	r0, #0
   23fdc:	1afffc52 	bne	2312c <_vfprintf_r+0x3fc>
   23fe0:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   23fe4:	e28d1094 	add	r1, sp, #148	@ 0x94
   23fe8:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   23fec:	eaffffe9 	b	23f98 <_vfprintf_r+0x1268>
				_uquad = -_uquad;
   23ff0:	e2636000 	rsb	r6, r3, #0
   23ff4:	e1a00007 	mov	r0, r7
   23ff8:	e3a0202d 	mov	r2, #45	@ 0x2d
			base = DEC;
   23ffc:	e3a03001 	mov	r3, #1
   24000:	eafffd59 	b	2356c <_vfprintf_r+0x83c>
					if (expt < ndig || flags & ALT) {
   24004:	e3170001 	tst	r7, #1
   24008:	0afffca6 	beq	232a8 <_vfprintf_r+0x578>
   2400c:	eafffdce 	b	2374c <_vfprintf_r+0xa1c>
			if ((ch = *fmt++) == '*') {
   24010:	e5db4000 	ldrb	r4, [fp]
			width = GET_ARG (n, ap, int);
   24014:	e58d3028 	str	r3, [sp, #40]	@ 0x28
   24018:	eafffba0 	b	22ea0 <_vfprintf_r+0x170>
			_uquad = SARG ();
   2401c:	e6bf3073 	sxth	r3, r3
			if ((long) _uquad < 0)
   24020:	e1a06003 	mov	r6, r3
   24024:	eafffd3f 	b	23528 <_vfprintf_r+0x7f8>
			if (isnan (_fpvalue)) {
   24028:	eeb48b48 	vcmp.f64	d8, d8
   2402c:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   24030:	6a0003b5 	bvs	24f0c <_vfprintf_r+0x21dc>
			if (ch == 'a' || ch == 'A') {
   24034:	e3c46020 	bic	r6, r4, #32
   24038:	e3560041 	cmp	r6, #65	@ 0x41
   2403c:	1a000184 	bne	24654 <_vfprintf_r+0x1924>
				ox[0] = '0';
   24040:	e3a03030 	mov	r3, #48	@ 0x30
				ox[1] = ch == 'a' ? 'x' : 'X';
   24044:	e3540061 	cmp	r4, #97	@ 0x61
				ox[0] = '0';
   24048:	e5cd306c 	strb	r3, [sp, #108]	@ 0x6c
				ox[1] = ch == 'a' ? 'x' : 'X';
   2404c:	13a03058 	movne	r3, #88	@ 0x58
   24050:	03a03078 	moveq	r3, #120	@ 0x78
				if (prec >= BUF)
   24054:	e3590063 	cmp	r9, #99	@ 0x63
				ox[1] = ch == 'a' ? 'x' : 'X';
   24058:	e5cd306d 	strb	r3, [sp, #109]	@ 0x6d
				if (prec >= BUF)
   2405c:	d3a03000 	movle	r3, #0
				  cp = buf;
   24060:	d28d50d4 	addle	r5, sp, #212	@ 0xd4
   24064:	d58d3024 	strle	r3, [sp, #36]	@ 0x24
				if (prec >= BUF)
   24068:	ca00029a 	bgt	24ad8 <_vfprintf_r+0x1da8>
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
   2406c:	ee183a90 	vmov	r3, s17
   24070:	e3530000 	cmp	r3, #0
		*sign = '\000';
   24074:	a3a08000 	movge	r8, #0
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
   24078:	aeb00b48 	vmovge.f64	d0, d8
		value = -value;
   2407c:	beb10b48 	vneglt.f64	d0, d8
   24080:	b3a0802d 	movlt	r8, #45	@ 0x2d
		value = FREXP (value, decpt) / 8;
   24084:	e28d0070 	add	r0, sp, #112	@ 0x70
   24088:	ebfff156 	bl	205e8 <frexp>
   2408c:	ed9f7bed 	vldr	d7, [pc, #948]	@ 24448 <_vfprintf_r+0x1718>
		digits = ch == 'a' ? "0123456789abcdef" : "0123456789ABCDEF";
   24090:	e30911a4 	movw	r1, #37284	@ 0x91a4
   24094:	e3401002 	movt	r1, #2
			value *= 16;
   24098:	ed9f4bec 	vldr	d4, [pc, #944]	@ 24450 <_vfprintf_r+0x1720>
   2409c:	e2492001 	sub	r2, r9, #1
		value = FREXP (value, decpt) / 8;
   240a0:	ee207b07 	vmul.f64	d7, d0, d7
		if (!value)
   240a4:	eeb57b40 	vcmp.f64	d7, #0.0
   240a8:	eef1fa10 	vmrs	APSR_nzcv, fpscr
			*decpt = 1;
   240ac:	03a03001 	moveq	r3, #1
   240b0:	058d3070 	streq	r3, [sp, #112]	@ 0x70
		digits = ch == 'a' ? "0123456789abcdef" : "0123456789ABCDEF";
   240b4:	e30931b8 	movw	r3, #37304	@ 0x91b8
   240b8:	e3403002 	movt	r3, #2
   240bc:	e3540061 	cmp	r4, #97	@ 0x61
   240c0:	01a0e003 	moveq	lr, r3
   240c4:	11a0e001 	movne	lr, r1
		bp = buf;
   240c8:	e1a03005 	mov	r3, r5
   240cc:	ea000003 	b	240e0 <_vfprintf_r+0x13b0>
		} while (ndigits-- && value);
   240d0:	eeb57b40 	vcmp.f64	d7, #0.0
   240d4:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   240d8:	0a0003c9 	beq	25004 <_vfprintf_r+0x22d4>
   240dc:	e1a02000 	mov	r2, r0
			value *= 16;
   240e0:	ee277b04 	vmul.f64	d7, d7, d4
		} while (ndigits-- && value);
   240e4:	e3720001 	cmn	r2, #1
   240e8:	e1a0c003 	mov	ip, r3
   240ec:	e2420001 	sub	r0, r2, #1
			mode = (int) value;
   240f0:	eefd6bc7 	vcvt.s32.f64	s13, d7
			*bp++ = digits[mode];
   240f4:	ee161a90 	vmov	r1, s13
			value -= mode;
   240f8:	eeb85be6 	vcvt.f64.s32	d5, s13
			*bp++ = digits[mode];
   240fc:	e7de1001 	ldrb	r1, [lr, r1]
			value -= mode;
   24100:	ee377b45 	vsub.f64	d7, d7, d5
			*bp++ = digits[mode];
   24104:	e4c31001 	strb	r1, [r3], #1
		} while (ndigits-- && value);
   24108:	1afffff0 	bne	240d0 <_vfprintf_r+0x13a0>
		if (value > 0.5 || (value == 0.5 && mode & 1)) {
   2410c:	ed9f5bd1 	vldr	d5, [pc, #836]	@ 24458 <_vfprintf_r+0x1728>
   24110:	eeb47bc5 	vcmpe.f64	d7, d5
   24114:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   24118:	ca000005 	bgt	24134 <_vfprintf_r+0x1404>
   2411c:	eeb47b45 	vcmp.f64	d7, d5
   24120:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   24124:	1a000015 	bne	24180 <_vfprintf_r+0x1450>
   24128:	ee162a90 	vmov	r2, s13
   2412c:	e3120001 	tst	r2, #1
   24130:	0a000012 	beq	24180 <_vfprintf_r+0x1450>
			while (*--rve == digits[0xf]) {
   24134:	e5de000f 	ldrb	r0, [lr, #15]
   24138:	e1a02003 	mov	r2, r3
   2413c:	e58dc080 	str	ip, [sp, #128]	@ 0x80
   24140:	e5531001 	ldrb	r1, [r3, #-1]
   24144:	e1500001 	cmp	r0, r1
   24148:	1a000007 	bne	2416c <_vfprintf_r+0x143c>
				*rve = '0';
   2414c:	e3a0c030 	mov	ip, #48	@ 0x30
   24150:	e542c001 	strb	ip, [r2, #-1]
			while (*--rve == digits[0xf]) {
   24154:	e59d2080 	ldr	r2, [sp, #128]	@ 0x80
   24158:	e2421001 	sub	r1, r2, #1
   2415c:	e58d1080 	str	r1, [sp, #128]	@ 0x80
   24160:	e5521001 	ldrb	r1, [r2, #-1]
   24164:	e1500001 	cmp	r0, r1
   24168:	0afffff8 	beq	24150 <_vfprintf_r+0x1420>
			*rve = *rve == '9' ? digits[0xa] : *rve + 1;
   2416c:	e3510039 	cmp	r1, #57	@ 0x39
   24170:	12811001 	addne	r1, r1, #1
   24174:	05de100a 	ldrbeq	r1, [lr, #10]
   24178:	16ef1071 	uxtbne	r1, r1
   2417c:	e5421001 	strb	r1, [r2, #-1]
			*bp++ = digits[mode];
   24180:	e1a02003 	mov	r2, r3
		*length = bp - buf;
   24184:	e0423005 	sub	r3, r2, r5
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
   24188:	e284200f 	add	r2, r4, #15
		*length = bp - buf;
   2418c:	e58d3034 	str	r3, [sp, #52]	@ 0x34
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
   24190:	e6ef2072 	uxtb	r2, r2
				--expt;
   24194:	e59d3070 	ldr	r3, [sp, #112]	@ 0x70
				flags |= HEXPREFIX;
   24198:	e3877002 	orr	r7, r7, #2
				--expt;
   2419c:	e3a01001 	mov	r1, #1
   241a0:	e58d3030 	str	r3, [sp, #48]	@ 0x30
   241a4:	e2433001 	sub	r3, r3, #1
   241a8:	e58d3070 	str	r3, [sp, #112]	@ 0x70
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
   241ac:	ea00016c 	b	24764 <_vfprintf_r+0x1a34>
			_uquad = UARG ();
   241b0:	e6ff6076 	uxth	r6, r6
   241b4:	e1a00007 	mov	r0, r7
			base = DEC;
   241b8:	e3a03001 	mov	r3, #1
   241bc:	eafffce9 	b	23568 <_vfprintf_r+0x838>
			if (thsnd_len > 0 && grouping && *grouping)
   241c0:	e59d3054 	ldr	r3, [sp, #84]	@ 0x54
rflag:		ch = *fmt++;
   241c4:	e5db4000 	ldrb	r4, [fp]
			if (thsnd_len > 0 && grouping && *grouping)
   241c8:	e5d33000 	ldrb	r3, [r3]
   241cc:	e3530000 	cmp	r3, #0
			  flags |= GROUPING;
   241d0:	13877b01 	orrne	r7, r7, #1024	@ 0x400
   241d4:	eafffb31 	b	22ea0 <_vfprintf_r+0x170>
			else if (flags & SHORTINT)
   241d8:	e3170040 	tst	r7, #64	@ 0x40
   241dc:	0a000115 	beq	24638 <_vfprintf_r+0x1908>
				*GET_ARG (N, ap, short_ptr_t) = ret;
   241e0:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
   241e4:	e59d201c 	ldr	r2, [sp, #28]
   241e8:	e5933000 	ldr	r3, [r3]
   241ec:	e1c320b0 	strh	r2, [r3]
   241f0:	eafffd11 	b	2363c <_vfprintf_r+0x90c>
reswitch:	switch (ch) {
   241f4:	e30931a4 	movw	r3, #37284	@ 0x91a4
   241f8:	e3403002 	movt	r3, #2
   241fc:	e58d304c 	str	r3, [sp, #76]	@ 0x4c
			width = GET_ARG (n, ap, int);
   24200:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
hex:			_uquad = UARG ();
   24204:	e3170010 	tst	r7, #16
			width = GET_ARG (n, ap, int);
   24208:	e4936004 	ldr	r6, [r3], #4
   2420c:	e58d3028 	str	r3, [sp, #40]	@ 0x28
hex:			_uquad = UARG ();
   24210:	1a000004 	bne	24228 <_vfprintf_r+0x14f8>
   24214:	e3170040 	tst	r7, #64	@ 0x40
   24218:	16ff6076 	uxthne	r6, r6
   2421c:	1a000001 	bne	24228 <_vfprintf_r+0x14f8>
   24220:	e3170c02 	tst	r7, #512	@ 0x200
   24224:	16ef6076 	uxtbne	r6, r6
			if (flags & ALT && _uquad != 0) {
   24228:	e3560000 	cmp	r6, #0
   2422c:	03a03000 	moveq	r3, #0
   24230:	12073001 	andne	r3, r7, #1
   24234:	e3530000 	cmp	r3, #0
				ox[0] = '0';
   24238:	13a03030 	movne	r3, #48	@ 0x30
				flags |= HEXPREFIX;
   2423c:	13877002 	orrne	r7, r7, #2
				ox[0] = '0';
   24240:	15cd306c 	strbne	r3, [sp, #108]	@ 0x6c
			flags &= ~GROUPING;
   24244:	e3c70b01 	bic	r0, r7, #1024	@ 0x400
			base = HEX;
   24248:	e3a03002 	mov	r3, #2
				ox[1] = ch;
   2424c:	15cd406d 	strbne	r4, [sp, #109]	@ 0x6d
   24250:	eafffcc4 	b	23568 <_vfprintf_r+0x838>
			xdigs = "0123456789abcdef";
   24254:	e30931b8 	movw	r3, #37304	@ 0x91b8
   24258:	e3403002 	movt	r3, #2
   2425c:	e58d304c 	str	r3, [sp, #76]	@ 0x4c
   24260:	eaffffe6 	b	24200 <_vfprintf_r+0x14d0>
						PRINT (decimal_point, decp_len);
   24264:	e59d1014 	ldr	r1, [sp, #20]
   24268:	e28d2088 	add	r2, sp, #136	@ 0x88
   2426c:	e59d000c 	ldr	r0, [sp, #12]
   24270:	ebffce65 	bl	17c0c <__sprint_r>
   24274:	e3500000 	cmp	r0, #0
   24278:	1afffbab 	bne	2312c <_vfprintf_r+0x3fc>
						PAD (ndig - 1, zeroes);
   2427c:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
						PRINT (decimal_point, decp_len);
   24280:	e28da094 	add	sl, sp, #148	@ 0x94
   24284:	eafffd3b 	b	23778 <_vfprintf_r+0xa48>
				size = ((unsigned) prec > 6U) ? 6 : prec;
   24288:	e3590006 	cmp	r9, #6
   2428c:	e1a01005 	mov	r1, r5
   24290:	31a03009 	movcc	r3, r9
   24294:	23a03006 	movcs	r3, #6
   24298:	e1a09005 	mov	r9, r5
   2429c:	e58d5024 	str	r5, [sp, #36]	@ 0x24
				cp = "(null)";
   242a0:	e30951cc 	movw	r5, #37324	@ 0x91cc
			cp = GET_ARG (N, ap, char_ptr_t);
   242a4:	e58d6028 	str	r6, [sp, #40]	@ 0x28
				cp = "(null)";
   242a8:	e3405002 	movt	r5, #2
				size = ((unsigned) prec > 6U) ? 6 : prec;
   242ac:	e58d3010 	str	r3, [sp, #16]
   242b0:	e58d3020 	str	r3, [sp, #32]
		nseps = nrepeats = 0;
   242b4:	e58d903c 	str	r9, [sp, #60]	@ 0x3c
   242b8:	e58d9038 	str	r9, [sp, #56]	@ 0x38
		lead = 0;
   242bc:	e58d9030 	str	r9, [sp, #48]	@ 0x30
   242c0:	eafffcc3 	b	235d4 <_vfprintf_r+0x8a4>
					PRINTANDPAD(cp, convbuf + ndig,
   242c4:	e3540010 	cmp	r4, #16
   242c8:	e59f8190 	ldr	r8, [pc, #400]	@ 24460 <_vfprintf_r+0x1730>
   242cc:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   242d0:	da000165 	ble	2486c <_vfprintf_r+0x1b3c>
   242d4:	e1a0100a 	mov	r1, sl
   242d8:	e59d900c 	ldr	r9, [sp, #12]
   242dc:	e1a0a008 	mov	sl, r8
   242e0:	e3a06010 	mov	r6, #16
   242e4:	e1a08007 	mov	r8, r7
   242e8:	e1a07005 	mov	r7, r5
   242ec:	e59d5014 	ldr	r5, [sp, #20]
   242f0:	ea000002 	b	24300 <_vfprintf_r+0x15d0>
   242f4:	e2444010 	sub	r4, r4, #16
   242f8:	e3540010 	cmp	r4, #16
   242fc:	da000156 	ble	2485c <_vfprintf_r+0x1b2c>
   24300:	e2833001 	add	r3, r3, #1
   24304:	e2822010 	add	r2, r2, #16
   24308:	e3530007 	cmp	r3, #7
   2430c:	e581a000 	str	sl, [r1]
   24310:	e5816004 	str	r6, [r1, #4]
   24314:	d2811008 	addle	r1, r1, #8
   24318:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   2431c:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   24320:	dafffff3 	ble	242f4 <_vfprintf_r+0x15c4>
   24324:	e28d2088 	add	r2, sp, #136	@ 0x88
   24328:	e1a01005 	mov	r1, r5
   2432c:	e1a00009 	mov	r0, r9
   24330:	ebffce35 	bl	17c0c <__sprint_r>
   24334:	e3500000 	cmp	r0, #0
   24338:	1afffb7b 	bne	2312c <_vfprintf_r+0x3fc>
   2433c:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   24340:	e28d1094 	add	r1, sp, #148	@ 0x94
   24344:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   24348:	eaffffe9 	b	242f4 <_vfprintf_r+0x15c4>
					    PRINT (decimal_point, decp_len);
   2434c:	e59d3040 	ldr	r3, [sp, #64]	@ 0x40
   24350:	e59d1044 	ldr	r1, [sp, #68]	@ 0x44
   24354:	e0822003 	add	r2, r2, r3
   24358:	e88a000a 	stm	sl, {r1, r3}
   2435c:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   24360:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   24364:	e2833001 	add	r3, r3, #1
   24368:	e3530007 	cmp	r3, #7
   2436c:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   24370:	d28aa008 	addle	sl, sl, #8
   24374:	dafffeb6 	ble	23e54 <_vfprintf_r+0x1124>
   24378:	e59d1014 	ldr	r1, [sp, #20]
   2437c:	e28d2088 	add	r2, sp, #136	@ 0x88
   24380:	e59d000c 	ldr	r0, [sp, #12]
   24384:	ebffce20 	bl	17c0c <__sprint_r>
   24388:	e3500000 	cmp	r0, #0
   2438c:	1afffb66 	bne	2312c <_vfprintf_r+0x3fc>
					PRINTANDPAD (cp, convbuf + ndig,
   24390:	e59d4070 	ldr	r4, [sp, #112]	@ 0x70
					    PRINT (decimal_point, decp_len);
   24394:	e28da094 	add	sl, sp, #148	@ 0x94
					PRINTANDPAD (cp, convbuf + ndig,
   24398:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   2439c:	eafffeac 	b	23e54 <_vfprintf_r+0x1124>
   243a0:	e2833001 	add	r3, r3, #1
   243a4:	e0822004 	add	r2, r2, r4
   243a8:	e3530007 	cmp	r3, #7
   243ac:	e58a8000 	str	r8, [sl]
   243b0:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   243b4:	e58a4004 	str	r4, [sl, #4]
   243b8:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   243bc:	dafffbb8 	ble	232a4 <_vfprintf_r+0x574>
   243c0:	eafffdec 	b	23b78 <_vfprintf_r+0xe48>
					PRINT (decimal_point, decp_len);
   243c4:	e59d1014 	ldr	r1, [sp, #20]
   243c8:	e28d2088 	add	r2, sp, #136	@ 0x88
   243cc:	e59d000c 	ldr	r0, [sp, #12]
   243d0:	ebffce0d 	bl	17c0c <__sprint_r>
   243d4:	e3500000 	cmp	r0, #0
   243d8:	1afffb53 	bne	2312c <_vfprintf_r+0x3fc>
						PRINT (cp, ndig - 1);
   243dc:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
					PRINT (decimal_point, decp_len);
   243e0:	e28d1094 	add	r1, sp, #148	@ 0x94
						PRINT (cp, ndig - 1);
   243e4:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   243e8:	eafffdc8 	b	23b10 <_vfprintf_r+0xde0>
					PRINT (cp, 1);
   243ec:	e59d1014 	ldr	r1, [sp, #20]
   243f0:	e28d2088 	add	r2, sp, #136	@ 0x88
   243f4:	e59d000c 	ldr	r0, [sp, #12]
   243f8:	ebffce03 	bl	17c0c <__sprint_r>
   243fc:	e3500000 	cmp	r0, #0
   24400:	1afffb49 	bne	2312c <_vfprintf_r+0x3fc>
					PRINT (decimal_point, decp_len);
   24404:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
					PRINT (cp, 1);
   24408:	e28d1094 	add	r1, sp, #148	@ 0x94
					PRINT (decimal_point, decp_len);
   2440c:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   24410:	eafffdb3 	b	23ae4 <_vfprintf_r+0xdb4>
			PAD (width - realsz, blanks);
   24414:	e59d1014 	ldr	r1, [sp, #20]
   24418:	e28d2088 	add	r2, sp, #136	@ 0x88
   2441c:	e59d000c 	ldr	r0, [sp, #12]
   24420:	e58d305c 	str	r3, [sp, #92]	@ 0x5c
   24424:	ebffcdf8 	bl	17c0c <__sprint_r>
   24428:	e3500000 	cmp	r0, #0
   2442c:	1afffb3e 	bne	2312c <_vfprintf_r+0x3fc>
		if (sign)
   24430:	e5dd106b 	ldrb	r1, [sp, #107]	@ 0x6b
			PAD (width - realsz, blanks);
   24434:	e28da094 	add	sl, sp, #148	@ 0x94
			PRINT (&sign, 1);
   24438:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
			PAD (width - realsz, blanks);
   2443c:	e59d305c 	ldr	r3, [sp, #92]	@ 0x5c
   24440:	eafffb68 	b	231e8 <_vfprintf_r+0x4b8>
   24444:	e320f000 	nop	{0}
   24448:	00000000 	.word	0x00000000
   2444c:	3fc00000 	.word	0x3fc00000
   24450:	00000000 	.word	0x00000000
   24454:	40300000 	.word	0x40300000
   24458:	00000000 	.word	0x00000000
   2445c:	3fe00000 	.word	0x3fe00000
   24460:	0002a0a0 	.word	0x0002a0a0
					PRINT ("0", 1);
   24464:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   24468:	e2822001 	add	r2, r2, #1
   2446c:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   24470:	e2833001 	add	r3, r3, #1
   24474:	e3530007 	cmp	r3, #7
   24478:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   2447c:	e30933b4 	movw	r3, #37812	@ 0x93b4
   24480:	e3403002 	movt	r3, #2
   24484:	e58a3000 	str	r3, [sl]
   24488:	e3a03001 	mov	r3, #1
   2448c:	e58a3004 	str	r3, [sl, #4]
   24490:	d28aa008 	addle	sl, sl, #8
   24494:	ca0001d2 	bgt	24be4 <_vfprintf_r+0x1eb4>
					if (expt || ndig || flags & ALT) {
   24498:	e59d3034 	ldr	r3, [sp, #52]	@ 0x34
   2449c:	e1933004 	orrs	r3, r3, r4
   244a0:	0a0001e4 	beq	24c38 <_vfprintf_r+0x1f08>
						PRINT (decimal_point, decp_len);
   244a4:	e59d3040 	ldr	r3, [sp, #64]	@ 0x40
   244a8:	e59d1044 	ldr	r1, [sp, #68]	@ 0x44
   244ac:	e0832002 	add	r2, r3, r2
   244b0:	e88a000a 	stm	sl, {r1, r3}
   244b4:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   244b8:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   244bc:	e2833001 	add	r3, r3, #1
   244c0:	e3530007 	cmp	r3, #7
   244c4:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   244c8:	d28aa008 	addle	sl, sl, #8
   244cc:	ca0001ce 	bgt	24c0c <_vfprintf_r+0x1edc>
						PAD (-expt, zeroes);
   244d0:	e3540000 	cmp	r4, #0
   244d4:	ba00021f 	blt	24d58 <_vfprintf_r+0x2028>
						PRINT (cp, ndig);
   244d8:	e2833001 	add	r3, r3, #1
   244dc:	e58a5000 	str	r5, [sl]
   244e0:	e3530007 	cmp	r3, #7
   244e4:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   244e8:	e59d3034 	ldr	r3, [sp, #52]	@ 0x34
   244ec:	e0832002 	add	r2, r3, r2
   244f0:	e58a3004 	str	r3, [sl, #4]
   244f4:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   244f8:	dafffb69 	ble	232a4 <_vfprintf_r+0x574>
   244fc:	eafffd9d 	b	23b78 <_vfprintf_r+0xe48>
	CHECK_INIT (data, fp);
   24500:	e59d000c 	ldr	r0, [sp, #12]
   24504:	ebffcff5 	bl	184e0 <__sinit>
   24508:	eafffa1c 	b	22d80 <_vfprintf_r+0x50>
					PRINT ("0", 1);
   2450c:	e59d1014 	ldr	r1, [sp, #20]
   24510:	e28d2088 	add	r2, sp, #136	@ 0x88
   24514:	e59d000c 	ldr	r0, [sp, #12]
   24518:	ebffcdbb 	bl	17c0c <__sprint_r>
   2451c:	e3500000 	cmp	r0, #0
   24520:	1afffb01 	bne	2312c <_vfprintf_r+0x3fc>
						PRINT (decimal_point, decp_len);
   24524:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
					PRINT ("0", 1);
   24528:	e28da094 	add	sl, sp, #148	@ 0x94
   2452c:	eafffc82 	b	2373c <_vfprintf_r+0xa0c>
   24530:	e1a00007 	mov	r0, r7
   24534:	eafffc0a 	b	23564 <_vfprintf_r+0x834>
					  *--cp = to_char (_uquad % 10);
   24538:	e30c7ccd 	movw	r7, #52429	@ 0xcccd
					ndig = 0;
   2453c:	e3a01000 	mov	r1, #0
					  if ((flags & GROUPING)
   24540:	e2008b01 	and	r8, r0, #1024	@ 0x400
			cp = buf + BUF;
   24544:	e58db010 	str	fp, [sp, #16]
   24548:	e59d3054 	ldr	r3, [sp, #84]	@ 0x54
   2454c:	e1a0b00a 	mov	fp, sl
					  *--cp = to_char (_uquad % 10);
   24550:	e34c7ccc 	movt	r7, #52428	@ 0xcccc
			cp = buf + BUF;
   24554:	e1a0a009 	mov	sl, r9
   24558:	e28d2f4e 	add	r2, sp, #312	@ 0x138
   2455c:	e1a09000 	mov	r9, r0
   24560:	e1a00001 	mov	r0, r1
   24564:	ea000005 	b	24580 <_vfprintf_r+0x1850>
					} while (_uquad != 0);
   24568:	e3560009 	cmp	r6, #9
					  _uquad /= 10;
   2456c:	e0816697 	umull	r6, r1, r7, r6
   24570:	e1a011a1 	lsr	r1, r1, #3
					} while (_uquad != 0);
   24574:	9a000015 	bls	245d0 <_vfprintf_r+0x18a0>
					  _uquad /= 10;
   24578:	e1a02005 	mov	r2, r5
   2457c:	e1a06001 	mov	r6, r1
					  *--cp = to_char (_uquad % 10);
   24580:	e081c697 	umull	ip, r1, r7, r6
					  if ((flags & GROUPING)
   24584:	e3580000 	cmp	r8, #0
					  *--cp = to_char (_uquad % 10);
   24588:	e2425001 	sub	r5, r2, #1
					  ndig++;
   2458c:	e2800001 	add	r0, r0, #1
					  *--cp = to_char (_uquad % 10);
   24590:	e1a011a1 	lsr	r1, r1, #3
   24594:	e0811101 	add	r1, r1, r1, lsl #2
   24598:	e0461081 	sub	r1, r6, r1, lsl #1
   2459c:	e2811030 	add	r1, r1, #48	@ 0x30
   245a0:	e5421001 	strb	r1, [r2, #-1]
					  if ((flags & GROUPING)
   245a4:	0affffef 	beq	24568 <_vfprintf_r+0x1838>
					      && ndig == *grouping
   245a8:	e5d32000 	ldrb	r2, [r3]
					      && *grouping != CHAR_MAX
   245ac:	e0421000 	sub	r1, r2, r0
   245b0:	e35200ff 	cmp	r2, #255	@ 0xff
   245b4:	e16f1f11 	clz	r1, r1
   245b8:	e1a012a1 	lsr	r1, r1, #5
   245bc:	03a01000 	moveq	r1, #0
   245c0:	e3510000 	cmp	r1, #0
   245c4:	0affffe7 	beq	24568 <_vfprintf_r+0x1838>
					      && _uquad > 9) {
   245c8:	e3560009 	cmp	r6, #9
   245cc:	8a0001b4 	bhi	24ca4 <_vfprintf_r+0x1f74>
			size = buf + BUF - cp;
   245d0:	e58d0034 	str	r0, [sp, #52]	@ 0x34
   245d4:	e1a00009 	mov	r0, r9
   245d8:	e58d3054 	str	r3, [sp, #84]	@ 0x54
   245dc:	e1a0900a 	mov	r9, sl
   245e0:	e1a0a00b 	mov	sl, fp
   245e4:	e59db010 	ldr	fp, [sp, #16]
   245e8:	eafffd16 	b	23a48 <_vfprintf_r+0xd18>
	FLUSH ();
   245ec:	e59d3090 	ldr	r3, [sp, #144]	@ 0x90
   245f0:	e3530000 	cmp	r3, #0
   245f4:	0afffad2 	beq	23144 <_vfprintf_r+0x414>
   245f8:	e59d1014 	ldr	r1, [sp, #20]
   245fc:	e28d2088 	add	r2, sp, #136	@ 0x88
   24600:	e59d000c 	ldr	r0, [sp, #12]
   24604:	ebffcd80 	bl	17c0c <__sprint_r>
   24608:	eafffacd 	b	23144 <_vfprintf_r+0x414>
						PAD (ndig - 1, zeroes);
   2460c:	e2833001 	add	r3, r3, #1
   24610:	e5818000 	str	r8, [r1]
   24614:	eafffd45 	b	23b30 <_vfprintf_r+0xe00>
				size = strlen (cp);
   24618:	e1a00005 	mov	r0, r5
		realsz = dprec > size ? dprec : size;
   2461c:	e1a09008 	mov	r9, r8
				size = strlen (cp);
   24620:	faffef96 	blx	20480 <strlen>
		if (sign)
   24624:	e5dd106b 	ldrb	r1, [sp, #107]	@ 0x6b
		realsz = dprec > size ? dprec : size;
   24628:	e1c03fc0 	bic	r3, r0, r0, asr #31
				size = strlen (cp);
   2462c:	e58d0020 	str	r0, [sp, #32]
			cp = GET_ARG (N, ap, char_ptr_t);
   24630:	e58d6028 	str	r6, [sp, #40]	@ 0x28
   24634:	eafffb7e 	b	23434 <_vfprintf_r+0x704>
			else if (flags & CHARINT)
   24638:	e3170c02 	tst	r7, #512	@ 0x200
   2463c:	0afffbfa 	beq	2362c <_vfprintf_r+0x8fc>
				*GET_ARG (N, ap, char_ptr_t) = ret;
   24640:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
   24644:	e59d201c 	ldr	r2, [sp, #28]
   24648:	e5933000 	ldr	r3, [r3]
   2464c:	e5c32000 	strb	r2, [r3]
   24650:	eafffbf9 	b	2363c <_vfprintf_r+0x90c>
			if (prec == -1) {
   24654:	e3790001 	cmn	r9, #1
				prec = DEFPREC;
   24658:	03a09006 	moveq	r9, #6
			if (prec == -1) {
   2465c:	0a000002 	beq	2466c <_vfprintf_r+0x193c>
				prec = 1;
   24660:	e3590000 	cmp	r9, #0
   24664:	03560047 	cmpeq	r6, #71	@ 0x47
   24668:	03a09001 	moveq	r9, #1
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
   2466c:	ee183a90 	vmov	r3, s17
   24670:	e3530000 	cmp	r3, #0
			flags |= FPT;
   24674:	e3873c01 	orr	r3, r7, #256	@ 0x100
   24678:	e58d3024 	str	r3, [sp, #36]	@ 0x24
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
   2467c:	ba00011c 	blt	24af4 <_vfprintf_r+0x1dc4>
   24680:	eeb09b48 	vmov.f64	d9, d8
		*sign = '\000';
   24684:	e3a08000 	mov	r8, #0
	if (ch == 'f' || ch == 'F') {
   24688:	e3540065 	cmp	r4, #101	@ 0x65
   2468c:	0a0001aa 	beq	24d3c <_vfprintf_r+0x200c>
   24690:	ca000142 	bgt	24ba0 <_vfprintf_r+0x1e70>
   24694:	e3540045 	cmp	r4, #69	@ 0x45
   24698:	0a0001a7 	beq	24d3c <_vfprintf_r+0x200c>
   2469c:	e3540046 	cmp	r4, #70	@ 0x46
   246a0:	1a000140 	bne	24ba8 <_vfprintf_r+0x1e78>
		mode = 2;		/* ndigits significant digits */
   246a4:	e1a02009 	mov	r2, r9
   246a8:	e3a01003 	mov	r1, #3
	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   246ac:	e28d3080 	add	r3, sp, #128	@ 0x80
   246b0:	e59d000c 	ldr	r0, [sp, #12]
   246b4:	e58d3004 	str	r3, [sp, #4]
   246b8:	e28d3074 	add	r3, sp, #116	@ 0x74
   246bc:	e58d3000 	str	r3, [sp]
   246c0:	e28d3070 	add	r3, sp, #112	@ 0x70
   246c4:	eeb00b49 	vmov.f64	d0, d9
   246c8:	e58d2010 	str	r2, [sp, #16]
   246cc:	eb000678 	bl	260b4 <_dtoa_r>
		bp = digits + ndigits;
   246d0:	e59d2010 	ldr	r2, [sp, #16]
		if (ch == 'f' || ch == 'F') {
   246d4:	e3560046 	cmp	r6, #70	@ 0x46
	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   246d8:	e1a05000 	mov	r5, r0
		bp = digits + ndigits;
   246dc:	e0801002 	add	r1, r0, r2
		if (ch == 'f' || ch == 'F') {
   246e0:	1a000004 	bne	246f8 <_vfprintf_r+0x19c8>
			if (*digits == '0' && value)
   246e4:	e5d53000 	ldrb	r3, [r5]
   246e8:	e3530030 	cmp	r3, #48	@ 0x30
   246ec:	0a0001bb 	beq	24de0 <_vfprintf_r+0x20b0>
			bp += *decpt;
   246f0:	e59d3070 	ldr	r3, [sp, #112]	@ 0x70
   246f4:	e0811003 	add	r1, r1, r3
		if (value == 0)	/* kludge for __dtoa irregularity */
   246f8:	eeb59b40 	vcmp.f64	d9, #0.0
   246fc:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   24700:	0a000190 	beq	24d48 <_vfprintf_r+0x2018>
		while (rve < bp)
   24704:	e59d3080 	ldr	r3, [sp, #128]	@ 0x80
   24708:	e1530001 	cmp	r3, r1
   2470c:	2a000006 	bcs	2472c <_vfprintf_r+0x19fc>
			*rve++ = '0';
   24710:	e3a00030 	mov	r0, #48	@ 0x30
   24714:	e2832001 	add	r2, r3, #1
   24718:	e58d2080 	str	r2, [sp, #128]	@ 0x80
   2471c:	e5c30000 	strb	r0, [r3]
		while (rve < bp)
   24720:	e59d3080 	ldr	r3, [sp, #128]	@ 0x80
   24724:	e1510003 	cmp	r1, r3
   24728:	8afffff9 	bhi	24714 <_vfprintf_r+0x19e4>
				if (expt <= -4 || expt > prec)
   2472c:	e59d2070 	ldr	r2, [sp, #112]	@ 0x70
   24730:	e58d2030 	str	r2, [sp, #48]	@ 0x30
			if (ch == 'g' || ch == 'G') {
   24734:	e3560047 	cmp	r6, #71	@ 0x47
	*length = rve - digits;
   24738:	e0433005 	sub	r3, r3, r5
   2473c:	e58d3034 	str	r3, [sp, #52]	@ 0x34
			if (ch == 'g' || ch == 'G') {
   24740:	0a0000f7 	beq	24b24 <_vfprintf_r+0x1df4>
			else if (ch == 'F')
   24744:	e3560046 	cmp	r6, #70	@ 0x46
				--expt;
   24748:	159d3030 	ldrne	r3, [sp, #48]	@ 0x30
   2474c:	12433001 	subne	r3, r3, #1
			else if (ch == 'F')
   24750:	0a0001aa 	beq	24e00 <_vfprintf_r+0x20d0>
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
   24754:	e6ef2074 	uxtb	r2, r4
   24758:	e3a01000 	mov	r1, #0
				--expt;
   2475c:	e58d3070 	str	r3, [sp, #112]	@ 0x70
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
   24760:	e58d1024 	str	r1, [sp, #36]	@ 0x24
	if (exp < 0) {
   24764:	e3530000 	cmp	r3, #0
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
   24768:	e5cd2078 	strb	r2, [sp, #120]	@ 0x78
		exp = -exp;
   2476c:	b59d3030 	ldrlt	r3, [sp, #48]	@ 0x30
		*p++ = '-';
   24770:	b3a0202d 	movlt	r2, #45	@ 0x2d
		*p++ = '+';
   24774:	a3a0202b 	movge	r2, #43	@ 0x2b
   24778:	e5cd2079 	strb	r2, [sp, #121]	@ 0x79
		exp = -exp;
   2477c:	b2633001 	rsblt	r3, r3, #1
	if (exp > 9) {
   24780:	e3530009 	cmp	r3, #9
   24784:	da0001d2 	ble	24ed4 <_vfprintf_r+0x21a4>
	t = expbuf + MAXEXPLEN;
   24788:	e28de087 	add	lr, sp, #135	@ 0x87
			*--t = to_char (exp % 10);
   2478c:	e30c6ccd 	movw	r6, #52429	@ 0xcccd
   24790:	e34c6ccc 	movt	r6, #52428	@ 0xcccc
	t = expbuf + MAXEXPLEN;
   24794:	e1a0c00e 	mov	ip, lr
			*--t = to_char (exp % 10);
   24798:	e0812396 	umull	r2, r1, r6, r3
		} while ((exp /= 10) > 9);
   2479c:	e3530063 	cmp	r3, #99	@ 0x63
   247a0:	e1a0000c 	mov	r0, ip
			*--t = to_char (exp % 10);
   247a4:	e24cc001 	sub	ip, ip, #1
   247a8:	e1a011a1 	lsr	r1, r1, #3
   247ac:	e0812101 	add	r2, r1, r1, lsl #2
   247b0:	e0432082 	sub	r2, r3, r2, lsl #1
		} while ((exp /= 10) > 9);
   247b4:	e1a03001 	mov	r3, r1
			*--t = to_char (exp % 10);
   247b8:	e2822030 	add	r2, r2, #48	@ 0x30
   247bc:	e5402001 	strb	r2, [r0, #-1]
		} while ((exp /= 10) > 9);
   247c0:	cafffff4 	bgt	24798 <_vfprintf_r+0x1a68>
		*--t = to_char (exp);
   247c4:	e2813030 	add	r3, r1, #48	@ 0x30
   247c8:	e54c3001 	strb	r3, [ip, #-1]
   247cc:	e2403002 	sub	r3, r0, #2
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
   247d0:	e153000e 	cmp	r3, lr
   247d4:	2a00022c 	bcs	2508c <_vfprintf_r+0x235c>
   247d8:	e28d2079 	add	r2, sp, #121	@ 0x79
   247dc:	e4d31001 	ldrb	r1, [r3], #1
   247e0:	e153000e 	cmp	r3, lr
   247e4:	e5e21001 	strb	r1, [r2, #1]!
   247e8:	1afffffb 	bne	247dc <_vfprintf_r+0x1aac>
	return (p - p0);
   247ec:	e28d3f4e 	add	r3, sp, #312	@ 0x138
   247f0:	e0430000 	sub	r0, r3, r0
   247f4:	e24030ad 	sub	r3, r0, #173	@ 0xad
   247f8:	e58d3048 	str	r3, [sp, #72]	@ 0x48
				if (ndig > 1 || flags & ALT)
   247fc:	e59d3034 	ldr	r3, [sp, #52]	@ 0x34
				size = expsize + ndig;
   24800:	e59d2048 	ldr	r2, [sp, #72]	@ 0x48
				if (ndig > 1 || flags & ALT)
   24804:	e3530001 	cmp	r3, #1
				size = expsize + ndig;
   24808:	e0833002 	add	r3, r3, r2
   2480c:	e58d3020 	str	r3, [sp, #32]
				if (ndig > 1 || flags & ALT)
   24810:	da0001ba 	ble	24f00 <_vfprintf_r+0x21d0>
					size += decp_len;
   24814:	e59d3020 	ldr	r3, [sp, #32]
   24818:	e59d2040 	ldr	r2, [sp, #64]	@ 0x40
   2481c:	e0833002 	add	r3, r3, r2
   24820:	e58d3020 	str	r3, [sp, #32]
		realsz = dprec > size ? dprec : size;
   24824:	e59d2020 	ldr	r2, [sp, #32]
   24828:	e3c73b01 	bic	r3, r7, #1024	@ 0x400
				flags &= ~GROUPING;
   2482c:	e3837c01 	orr	r7, r3, #256	@ 0x100
		nseps = nrepeats = 0;
   24830:	e3a03000 	mov	r3, #0
   24834:	e58d303c 	str	r3, [sp, #60]	@ 0x3c
   24838:	e58d3038 	str	r3, [sp, #56]	@ 0x38
		realsz = dprec > size ? dprec : size;
   2483c:	e1c22fc2 	bic	r2, r2, r2, asr #31
		lead = 0;
   24840:	e58d3030 	str	r3, [sp, #48]	@ 0x30
		realsz = dprec > size ? dprec : size;
   24844:	e58d2010 	str	r2, [sp, #16]
			if (softsign)
   24848:	e3580000 	cmp	r8, #0
   2484c:	1a0000ab 	bne	24b00 <_vfprintf_r+0x1dd0>
		if (sign)
   24850:	e5dd106b 	ldrb	r1, [sp, #107]	@ 0x6b
		dprec = 0;
   24854:	e1a09008 	mov	r9, r8
   24858:	eafffb5d 	b	235d4 <_vfprintf_r+0x8a4>
   2485c:	e1a05007 	mov	r5, r7
   24860:	e1a07008 	mov	r7, r8
   24864:	e1a0800a 	mov	r8, sl
   24868:	e1a0a001 	mov	sl, r1
					PRINTANDPAD(cp, convbuf + ndig,
   2486c:	e2833001 	add	r3, r3, #1
   24870:	e0822004 	add	r2, r2, r4
   24874:	e3530007 	cmp	r3, #7
   24878:	e58a8000 	str	r8, [sl]
   2487c:	e58a4004 	str	r4, [sl, #4]
   24880:	d28aa008 	addle	sl, sl, #8
   24884:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   24888:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   2488c:	dafffd66 	ble	23e2c <_vfprintf_r+0x10fc>
   24890:	e59d1014 	ldr	r1, [sp, #20]
   24894:	e28d2088 	add	r2, sp, #136	@ 0x88
   24898:	e59d000c 	ldr	r0, [sp, #12]
   2489c:	ebffccda 	bl	17c0c <__sprint_r>
   248a0:	e3500000 	cmp	r0, #0
   248a4:	1afffa20 	bne	2312c <_vfprintf_r+0x3fc>
					    PRINT (decimal_point, decp_len);
   248a8:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
					PRINTANDPAD(cp, convbuf + ndig,
   248ac:	e28da094 	add	sl, sp, #148	@ 0x94
   248b0:	eafffd5d 	b	23e2c <_vfprintf_r+0x10fc>
					    while (nseps > 0 || nrepeats > 0) {
   248b4:	e59d3038 	ldr	r3, [sp, #56]	@ 0x38
   248b8:	e59d603c 	ldr	r6, [sp, #60]	@ 0x3c
   248bc:	e3560000 	cmp	r6, #0
   248c0:	d3530000 	cmple	r3, #0
   248c4:	da0001fc 	ble	250bc <_vfprintf_r+0x238c>
						PRINTANDPAD (cp, convbuf + ndig,
   248c8:	e59d3034 	ldr	r3, [sp, #52]	@ 0x34
   248cc:	e1a0100a 	mov	r1, sl
   248d0:	e58d7060 	str	r7, [sp, #96]	@ 0x60
   248d4:	e58db064 	str	fp, [sp, #100]	@ 0x64
   248d8:	e0853003 	add	r3, r5, r3
   248dc:	e51f9484 	ldr	r9, [pc, #-1156]	@ 24460 <_vfprintf_r+0x1730>
   248e0:	e59d7054 	ldr	r7, [sp, #84]	@ 0x54
   248e4:	e1a0a003 	mov	sl, r3
   248e8:	e59db058 	ldr	fp, [sp, #88]	@ 0x58
   248ec:	e58d505c 	str	r5, [sp, #92]	@ 0x5c
   248f0:	ea000004 	b	24908 <_vfprintf_r+0x1bd8>
					    while (nseps > 0 || nrepeats > 0) {
   248f4:	e59d3038 	ldr	r3, [sp, #56]	@ 0x38
						cp += *grouping;
   248f8:	e0888000 	add	r8, r8, r0
					    while (nseps > 0 || nrepeats > 0) {
   248fc:	e3560000 	cmp	r6, #0
   24900:	d3530000 	cmple	r3, #0
   24904:	da0001af 	ble	24fc8 <_vfprintf_r+0x2298>
						if (nrepeats > 0)
   24908:	e3560000 	cmp	r6, #0
						PRINT(thousands_sep, thsnd_len);
   2490c:	e59d008c 	ldr	r0, [sp, #140]	@ 0x8c
						    nseps--;
   24910:	d59d3038 	ldrle	r3, [sp, #56]	@ 0x38
						    nrepeats--;
   24914:	c2466001 	subgt	r6, r6, #1
						    grouping--;
   24918:	d2477001 	suble	r7, r7, #1
						PRINT(thousands_sep, thsnd_len);
   2491c:	e082200b 	add	r2, r2, fp
   24920:	e2800001 	add	r0, r0, #1
   24924:	e58d2090 	str	r2, [sp, #144]	@ 0x90
						    nseps--;
   24928:	d2433001 	suble	r3, r3, #1
						PRINT(thousands_sep, thsnd_len);
   2492c:	e58d008c 	str	r0, [sp, #140]	@ 0x8c
						    nseps--;
   24930:	d58d3038 	strle	r3, [sp, #56]	@ 0x38
						PRINT(thousands_sep, thsnd_len);
   24934:	e3500007 	cmp	r0, #7
   24938:	e59d3050 	ldr	r3, [sp, #80]	@ 0x50
   2493c:	e8810808 	stm	r1, {r3, fp}
   24940:	d2811008 	addle	r1, r1, #8
   24944:	ca000047 	bgt	24a68 <_vfprintf_r+0x1d38>
						PRINTANDPAD (cp, convbuf + ndig,
   24948:	e5d70000 	ldrb	r0, [r7]
   2494c:	e04a5008 	sub	r5, sl, r8
   24950:	e58da020 	str	sl, [sp, #32]
   24954:	e1550000 	cmp	r5, r0
   24958:	a1a05000 	movge	r5, r0
   2495c:	e3550000 	cmp	r5, #0
   24960:	da00000a 	ble	24990 <_vfprintf_r+0x1c60>
   24964:	e59d008c 	ldr	r0, [sp, #140]	@ 0x8c
   24968:	e0822005 	add	r2, r2, r5
   2496c:	e5818000 	str	r8, [r1]
   24970:	e5815004 	str	r5, [r1, #4]
   24974:	e2800001 	add	r0, r0, #1
   24978:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   2497c:	e3500007 	cmp	r0, #7
   24980:	e58d008c 	str	r0, [sp, #140]	@ 0x8c
   24984:	ca000040 	bgt	24a8c <_vfprintf_r+0x1d5c>
   24988:	e5d70000 	ldrb	r0, [r7]
   2498c:	e2811008 	add	r1, r1, #8
   24990:	e3550000 	cmp	r5, #0
   24994:	a0404005 	subge	r4, r0, r5
   24998:	b1a04000 	movlt	r4, r0
   2499c:	e3540000 	cmp	r4, #0
   249a0:	daffffd3 	ble	248f4 <_vfprintf_r+0x1bc4>
   249a4:	e3540010 	cmp	r4, #16
   249a8:	e59d008c 	ldr	r0, [sp, #140]	@ 0x8c
   249ac:	d51fc554 	ldrle	ip, [pc, #-1364]	@ 24460 <_vfprintf_r+0x1730>
   249b0:	da000021 	ble	24a3c <_vfprintf_r+0x1d0c>
   249b4:	e58d702c 	str	r7, [sp, #44]	@ 0x2c
   249b8:	e3a05010 	mov	r5, #16
   249bc:	e58d6030 	str	r6, [sp, #48]	@ 0x30
   249c0:	e59d7014 	ldr	r7, [sp, #20]
   249c4:	e59d600c 	ldr	r6, [sp, #12]
   249c8:	e58d903c 	str	r9, [sp, #60]	@ 0x3c
   249cc:	ea000002 	b	249dc <_vfprintf_r+0x1cac>
   249d0:	e2444010 	sub	r4, r4, #16
   249d4:	e3540010 	cmp	r4, #16
   249d8:	da000014 	ble	24a30 <_vfprintf_r+0x1d00>
   249dc:	e2800001 	add	r0, r0, #1
   249e0:	e2822010 	add	r2, r2, #16
   249e4:	e3500007 	cmp	r0, #7
   249e8:	e5819000 	str	r9, [r1]
   249ec:	e5815004 	str	r5, [r1, #4]
   249f0:	d2811008 	addle	r1, r1, #8
   249f4:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   249f8:	e58d008c 	str	r0, [sp, #140]	@ 0x8c
   249fc:	dafffff3 	ble	249d0 <_vfprintf_r+0x1ca0>
   24a00:	e28d2088 	add	r2, sp, #136	@ 0x88
   24a04:	e1a01007 	mov	r1, r7
   24a08:	e1a00006 	mov	r0, r6
   24a0c:	ebffcc7e 	bl	17c0c <__sprint_r>
   24a10:	e3500000 	cmp	r0, #0
   24a14:	1afff9c4 	bne	2312c <_vfprintf_r+0x3fc>
   24a18:	e2444010 	sub	r4, r4, #16
   24a1c:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   24a20:	e3540010 	cmp	r4, #16
   24a24:	e59d008c 	ldr	r0, [sp, #140]	@ 0x8c
   24a28:	e28d1094 	add	r1, sp, #148	@ 0x94
   24a2c:	caffffea 	bgt	249dc <_vfprintf_r+0x1cac>
   24a30:	e59d702c 	ldr	r7, [sp, #44]	@ 0x2c
   24a34:	e59d6030 	ldr	r6, [sp, #48]	@ 0x30
   24a38:	e59dc03c 	ldr	ip, [sp, #60]	@ 0x3c
   24a3c:	e2800001 	add	r0, r0, #1
   24a40:	e0822004 	add	r2, r2, r4
   24a44:	e3500007 	cmp	r0, #7
   24a48:	e581c000 	str	ip, [r1]
   24a4c:	e58d008c 	str	r0, [sp, #140]	@ 0x8c
   24a50:	e5814004 	str	r4, [r1, #4]
   24a54:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   24a58:	ca000084 	bgt	24c70 <_vfprintf_r+0x1f40>
						cp += *grouping;
   24a5c:	e5d70000 	ldrb	r0, [r7]
						PRINTANDPAD (cp, convbuf + ndig,
   24a60:	e2811008 	add	r1, r1, #8
   24a64:	eaffffa2 	b	248f4 <_vfprintf_r+0x1bc4>
						PRINT(thousands_sep, thsnd_len);
   24a68:	e59d1014 	ldr	r1, [sp, #20]
   24a6c:	e28d2088 	add	r2, sp, #136	@ 0x88
   24a70:	e59d000c 	ldr	r0, [sp, #12]
   24a74:	ebffcc64 	bl	17c0c <__sprint_r>
   24a78:	e3500000 	cmp	r0, #0
   24a7c:	1afff9aa 	bne	2312c <_vfprintf_r+0x3fc>
						PRINTANDPAD (cp, convbuf + ndig,
   24a80:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
						PRINT(thousands_sep, thsnd_len);
   24a84:	e28d1094 	add	r1, sp, #148	@ 0x94
   24a88:	eaffffae 	b	24948 <_vfprintf_r+0x1c18>
						PRINTANDPAD (cp, convbuf + ndig,
   24a8c:	e59d1014 	ldr	r1, [sp, #20]
   24a90:	e28d2088 	add	r2, sp, #136	@ 0x88
   24a94:	e59d000c 	ldr	r0, [sp, #12]
   24a98:	ebffcc5b 	bl	17c0c <__sprint_r>
   24a9c:	e3500000 	cmp	r0, #0
   24aa0:	1afff9a1 	bne	2312c <_vfprintf_r+0x3fc>
   24aa4:	e5d70000 	ldrb	r0, [r7]
   24aa8:	e28d1094 	add	r1, sp, #148	@ 0x94
   24aac:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   24ab0:	eaffffb6 	b	24990 <_vfprintf_r+0x1c60>
					PRINTANDPAD(cp, convbuf + ndig,
   24ab4:	e59d1014 	ldr	r1, [sp, #20]
   24ab8:	e28d2088 	add	r2, sp, #136	@ 0x88
   24abc:	e59d000c 	ldr	r0, [sp, #12]
   24ac0:	ebffcc51 	bl	17c0c <__sprint_r>
   24ac4:	e3500000 	cmp	r0, #0
   24ac8:	1afff997 	bne	2312c <_vfprintf_r+0x3fc>
   24acc:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   24ad0:	e28da094 	add	sl, sp, #148	@ 0x94
   24ad4:	eafffccf 	b	23e18 <_vfprintf_r+0x10e8>
					 (char *)_malloc_r (data, prec + 1))
   24ad8:	e59d000c 	ldr	r0, [sp, #12]
   24adc:	e2891001 	add	r1, r9, #1
   24ae0:	ebffea97 	bl	1f544 <_malloc_r>
				    if ((malloc_buf =
   24ae4:	e2505000 	subs	r5, r0, #0
   24ae8:	0a00016a 	beq	25098 <_vfprintf_r+0x2368>
					 (char *)_malloc_r (data, prec + 1))
   24aec:	e58d5024 	str	r5, [sp, #36]	@ 0x24
   24af0:	eafffd5d 	b	2406c <_vfprintf_r+0x133c>
		value = -value;
   24af4:	eeb19b48 	vneg.f64	d9, d8
   24af8:	e3a0802d 	mov	r8, #45	@ 0x2d
   24afc:	eafffee1 	b	24688 <_vfprintf_r+0x1958>
				sign = '-';
   24b00:	e3a0102d 	mov	r1, #45	@ 0x2d
		dprec = 0;
   24b04:	e3a09000 	mov	r9, #0
				sign = '-';
   24b08:	e5cd106b 	strb	r1, [sp, #107]	@ 0x6b
   24b0c:	eafffab2 	b	235dc <_vfprintf_r+0x8ac>
	*length = rve - digits;
   24b10:	e59d3080 	ldr	r3, [sp, #128]	@ 0x80
   24b14:	e0433000 	sub	r3, r3, r0
   24b18:	e58d3034 	str	r3, [sp, #52]	@ 0x34
				if (expt <= -4 || expt > prec)
   24b1c:	e59d3070 	ldr	r3, [sp, #112]	@ 0x70
   24b20:	e58d3030 	str	r3, [sp, #48]	@ 0x30
   24b24:	e59d3030 	ldr	r3, [sp, #48]	@ 0x30
   24b28:	e3730003 	cmn	r3, #3
   24b2c:	a1590003 	cmpge	r9, r3
					ch -= 2; /* 'e' or 'E' */
   24b30:	b2444002 	sublt	r4, r4, #2
				--expt;
   24b34:	b2433001 	sublt	r3, r3, #1
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
   24b38:	baffff05 	blt	24754 <_vfprintf_r+0x1a24>
				} else if (expt >= ndig) { /* fixed g fmt */
   24b3c:	e59d3030 	ldr	r3, [sp, #48]	@ 0x30
   24b40:	e59d2034 	ldr	r2, [sp, #52]	@ 0x34
   24b44:	e1530002 	cmp	r3, r2
   24b48:	ba0000bc 	blt	24e40 <_vfprintf_r+0x2110>
						size += decp_len;
   24b4c:	e59d3030 	ldr	r3, [sp, #48]	@ 0x30
					if (flags & ALT)
   24b50:	e3170001 	tst	r7, #1
					size = expt;
   24b54:	058d3020 	streq	r3, [sp, #32]
						size += decp_len;
   24b58:	159d2040 	ldrne	r2, [sp, #64]	@ 0x40
   24b5c:	10833002 	addne	r3, r3, r2
   24b60:	158d3020 	strne	r3, [sp, #32]
				if ((flags & GROUPING) && expt > 0) {
   24b64:	e3170b01 	tst	r7, #1024	@ 0x400
   24b68:	0a000002 	beq	24b78 <_vfprintf_r+0x1e48>
   24b6c:	e59d3030 	ldr	r3, [sp, #48]	@ 0x30
   24b70:	e3530000 	cmp	r3, #0
   24b74:	ca0000ef 	bgt	24f38 <_vfprintf_r+0x2208>
		realsz = dprec > size ? dprec : size;
   24b78:	e59d3020 	ldr	r3, [sp, #32]
   24b7c:	e3a04067 	mov	r4, #103	@ 0x67
   24b80:	e1c33fc3 	bic	r3, r3, r3, asr #31
   24b84:	e58d3010 	str	r3, [sp, #16]
			flags |= FPT;
   24b88:	e3a03000 	mov	r3, #0
   24b8c:	e59d7024 	ldr	r7, [sp, #36]	@ 0x24
		nseps = nrepeats = 0;
   24b90:	e58d303c 	str	r3, [sp, #60]	@ 0x3c
			flags |= FPT;
   24b94:	e58d3024 	str	r3, [sp, #36]	@ 0x24
		nseps = nrepeats = 0;
   24b98:	e58d3038 	str	r3, [sp, #56]	@ 0x38
   24b9c:	eaffff29 	b	24848 <_vfprintf_r+0x1b18>
   24ba0:	e3540066 	cmp	r4, #102	@ 0x66
   24ba4:	0afffebe 	beq	246a4 <_vfprintf_r+0x1974>
	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   24ba8:	e28d3080 	add	r3, sp, #128	@ 0x80
   24bac:	e59d000c 	ldr	r0, [sp, #12]
   24bb0:	e58d3004 	str	r3, [sp, #4]
   24bb4:	e28d3074 	add	r3, sp, #116	@ 0x74
   24bb8:	e58d3000 	str	r3, [sp]
   24bbc:	e1a02009 	mov	r2, r9
   24bc0:	eeb00b49 	vmov.f64	d0, d9
   24bc4:	e28d3070 	add	r3, sp, #112	@ 0x70
   24bc8:	e3a01002 	mov	r1, #2
   24bcc:	eb000538 	bl	260b4 <_dtoa_r>
	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   24bd0:	e3170001 	tst	r7, #1
	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   24bd4:	e1a05000 	mov	r5, r0
	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   24bd8:	0affffcc 	beq	24b10 <_vfprintf_r+0x1de0>
		bp = digits + ndigits;
   24bdc:	e0801009 	add	r1, r0, r9
		if (ch == 'f' || ch == 'F') {
   24be0:	eafffec4 	b	246f8 <_vfprintf_r+0x19c8>
					PRINT ("0", 1);
   24be4:	e59d1014 	ldr	r1, [sp, #20]
   24be8:	e28d2088 	add	r2, sp, #136	@ 0x88
   24bec:	e59d000c 	ldr	r0, [sp, #12]
   24bf0:	ebffcc05 	bl	17c0c <__sprint_r>
   24bf4:	e3500000 	cmp	r0, #0
   24bf8:	1afff94b 	bne	2312c <_vfprintf_r+0x3fc>
					if (expt || ndig || flags & ALT) {
   24bfc:	e59d4070 	ldr	r4, [sp, #112]	@ 0x70
					PRINT ("0", 1);
   24c00:	e28da094 	add	sl, sp, #148	@ 0x94
						PRINT (decimal_point, decp_len);
   24c04:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   24c08:	eafffe22 	b	24498 <_vfprintf_r+0x1768>
   24c0c:	e59d1014 	ldr	r1, [sp, #20]
   24c10:	e28d2088 	add	r2, sp, #136	@ 0x88
   24c14:	e59d000c 	ldr	r0, [sp, #12]
   24c18:	ebffcbfb 	bl	17c0c <__sprint_r>
   24c1c:	e3500000 	cmp	r0, #0
   24c20:	1afff941 	bne	2312c <_vfprintf_r+0x3fc>
						PAD (-expt, zeroes);
   24c24:	e59d4070 	ldr	r4, [sp, #112]	@ 0x70
						PRINT (decimal_point, decp_len);
   24c28:	e28da094 	add	sl, sp, #148	@ 0x94
						PAD (-expt, zeroes);
   24c2c:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   24c30:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   24c34:	eafffe25 	b	244d0 <_vfprintf_r+0x17a0>
					if (expt || ndig || flags & ALT) {
   24c38:	e3170001 	tst	r7, #1
   24c3c:	0afff999 	beq	232a8 <_vfprintf_r+0x578>
						PRINT (decimal_point, decp_len);
   24c40:	e59d3040 	ldr	r3, [sp, #64]	@ 0x40
   24c44:	e59d1044 	ldr	r1, [sp, #68]	@ 0x44
   24c48:	e0832002 	add	r2, r3, r2
   24c4c:	e88a000a 	stm	sl, {r1, r3}
   24c50:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   24c54:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   24c58:	e2833001 	add	r3, r3, #1
   24c5c:	e3530007 	cmp	r3, #7
   24c60:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   24c64:	caffffe8 	bgt	24c0c <_vfprintf_r+0x1edc>
   24c68:	e28aa008 	add	sl, sl, #8
   24c6c:	eafffe19 	b	244d8 <_vfprintf_r+0x17a8>
						PRINTANDPAD (cp, convbuf + ndig,
   24c70:	e59d1014 	ldr	r1, [sp, #20]
   24c74:	e28d2088 	add	r2, sp, #136	@ 0x88
   24c78:	e59d000c 	ldr	r0, [sp, #12]
   24c7c:	ebffcbe2 	bl	17c0c <__sprint_r>
   24c80:	e3500000 	cmp	r0, #0
   24c84:	1afff928 	bne	2312c <_vfprintf_r+0x3fc>
						cp += *grouping;
   24c88:	e5d70000 	ldrb	r0, [r7]
						PRINTANDPAD (cp, convbuf + ndig,
   24c8c:	e28d1094 	add	r1, sp, #148	@ 0x94
					    PRINT (decimal_point, decp_len);
   24c90:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   24c94:	eaffff16 	b	248f4 <_vfprintf_r+0x1bc4>
		return (EOF);
   24c98:	e3e03000 	mvn	r3, #0
   24c9c:	e58d301c 	str	r3, [sp, #28]
   24ca0:	eafff92b 	b	23154 <_vfprintf_r+0x424>
   24ca4:	e58d3020 	str	r3, [sp, #32]
					    cp -= thsnd_len;
   24ca8:	e59d3058 	ldr	r3, [sp, #88]	@ 0x58
					    strncpy (cp, thousands_sep,
   24cac:	e59d1050 	ldr	r1, [sp, #80]	@ 0x50
					    cp -= thsnd_len;
   24cb0:	e0455003 	sub	r5, r5, r3
					    strncpy (cp, thousands_sep,
   24cb4:	e1a02003 	mov	r2, r3
   24cb8:	e1a00005 	mov	r0, r5
   24cbc:	ebffd754 	bl	1aa14 <strncpy>
					    if (grouping[1] != '\0')
   24cc0:	e59d3020 	ldr	r3, [sp, #32]
					  _uquad /= 10;
   24cc4:	e3a00000 	mov	r0, #0
					    if (grouping[1] != '\0')
   24cc8:	e5d32001 	ldrb	r2, [r3, #1]
   24ccc:	e3520000 	cmp	r2, #0
					  _uquad /= 10;
   24cd0:	e30c2ccd 	movw	r2, #52429	@ 0xcccd
   24cd4:	e34c2ccc 	movt	r2, #52428	@ 0xcccc
					      grouping++;
   24cd8:	12833001 	addne	r3, r3, #1
					  _uquad /= 10;
   24cdc:	e0826692 	umull	r6, r2, r2, r6
   24ce0:	e1a011a2 	lsr	r1, r2, #3
					} while (_uquad != 0);
   24ce4:	eafffe23 	b	24578 <_vfprintf_r+0x1848>
		if (sign)
   24ce8:	e58d9010 	str	r9, [sp, #16]
					size = prec;
   24cec:	e58d9020 	str	r9, [sp, #32]
		dprec = 0;
   24cf0:	e1a09000 	mov	r9, r0
		if (sign)
   24cf4:	e5dd106b 	ldrb	r1, [sp, #107]	@ 0x6b
			cp = GET_ARG (N, ap, char_ptr_t);
   24cf8:	e58d6028 	str	r6, [sp, #40]	@ 0x28
		nseps = nrepeats = 0;
   24cfc:	e58d003c 	str	r0, [sp, #60]	@ 0x3c
   24d00:	e58d0038 	str	r0, [sp, #56]	@ 0x38
		lead = 0;
   24d04:	e58d0030 	str	r0, [sp, #48]	@ 0x30
   24d08:	eafffa31 	b	235d4 <_vfprintf_r+0x8a4>
					PRINTANDPAD (cp, convbuf + ndig,
   24d0c:	e59d1014 	ldr	r1, [sp, #20]
   24d10:	e28d2088 	add	r2, sp, #136	@ 0x88
   24d14:	e59d000c 	ldr	r0, [sp, #12]
   24d18:	ebffcbbb 	bl	17c0c <__sprint_r>
   24d1c:	e3500000 	cmp	r0, #0
   24d20:	1afff901 	bne	2312c <_vfprintf_r+0x3fc>
   24d24:	e59d4070 	ldr	r4, [sp, #112]	@ 0x70
   24d28:	e28da094 	add	sl, sp, #148	@ 0x94
   24d2c:	e59d3034 	ldr	r3, [sp, #52]	@ 0x34
			PAD (width - realsz, blanks);
   24d30:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
					PRINTANDPAD (cp, convbuf + ndig,
   24d34:	e0434004 	sub	r4, r3, r4
   24d38:	eafffc57 	b	23e9c <_vfprintf_r+0x116c>
			ndigits++;
   24d3c:	e2892001 	add	r2, r9, #1
		mode = 2;		/* ndigits significant digits */
   24d40:	e3a01002 	mov	r1, #2
   24d44:	eafffe58 	b	246ac <_vfprintf_r+0x197c>
				if (expt <= -4 || expt > prec)
   24d48:	e59d2070 	ldr	r2, [sp, #112]	@ 0x70
   24d4c:	e1a03001 	mov	r3, r1
   24d50:	e58d2030 	str	r2, [sp, #48]	@ 0x30
		while (rve < bp)
   24d54:	eafffe76 	b	24734 <_vfprintf_r+0x1a04>
						PAD (-expt, zeroes);
   24d58:	e3740010 	cmn	r4, #16
   24d5c:	e51f8904 	ldr	r8, [pc, #-2308]	@ 24460 <_vfprintf_r+0x1730>
   24d60:	e2644000 	rsb	r4, r4, #0
   24d64:	aa000048 	bge	24e8c <_vfprintf_r+0x215c>
   24d68:	e1a0100a 	mov	r1, sl
   24d6c:	e59d900c 	ldr	r9, [sp, #12]
   24d70:	e1a0a008 	mov	sl, r8
   24d74:	e3a06010 	mov	r6, #16
   24d78:	e1a08007 	mov	r8, r7
   24d7c:	e1a07005 	mov	r7, r5
   24d80:	e59d5014 	ldr	r5, [sp, #20]
   24d84:	ea000002 	b	24d94 <_vfprintf_r+0x2064>
   24d88:	e2444010 	sub	r4, r4, #16
   24d8c:	e3540010 	cmp	r4, #16
   24d90:	da000039 	ble	24e7c <_vfprintf_r+0x214c>
   24d94:	e2833001 	add	r3, r3, #1
   24d98:	e2822010 	add	r2, r2, #16
   24d9c:	e3530007 	cmp	r3, #7
   24da0:	e581a000 	str	sl, [r1]
   24da4:	e5816004 	str	r6, [r1, #4]
   24da8:	d2811008 	addle	r1, r1, #8
   24dac:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   24db0:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   24db4:	dafffff3 	ble	24d88 <_vfprintf_r+0x2058>
   24db8:	e28d2088 	add	r2, sp, #136	@ 0x88
   24dbc:	e1a01005 	mov	r1, r5
   24dc0:	e1a00009 	mov	r0, r9
   24dc4:	ebffcb90 	bl	17c0c <__sprint_r>
   24dc8:	e3500000 	cmp	r0, #0
   24dcc:	1afff8d6 	bne	2312c <_vfprintf_r+0x3fc>
   24dd0:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
   24dd4:	e28d1094 	add	r1, sp, #148	@ 0x94
   24dd8:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   24ddc:	eaffffe9 	b	24d88 <_vfprintf_r+0x2058>
			if (*digits == '0' && value)
   24de0:	eeb59b40 	vcmp.f64	d9, #0.0
   24de4:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   24de8:	1a00009c 	bne	25060 <_vfprintf_r+0x2330>
			bp += *decpt;
   24dec:	e59d3070 	ldr	r3, [sp, #112]	@ 0x70
   24df0:	e0811003 	add	r1, r1, r3
   24df4:	e58d3030 	str	r3, [sp, #48]	@ 0x30
	*length = rve - digits;
   24df8:	e0413005 	sub	r3, r1, r5
   24dfc:	e58d3034 	str	r3, [sp, #52]	@ 0x34
					if (expt > 0) {
   24e00:	e59d2030 	ldr	r2, [sp, #48]	@ 0x30
   24e04:	e2073001 	and	r3, r7, #1
   24e08:	e1833009 	orr	r3, r3, r9
   24e0c:	e3520000 	cmp	r2, #0
   24e10:	da000084 	ble	25028 <_vfprintf_r+0x22f8>
						if (prec || flags & ALT)
   24e14:	e3530000 	cmp	r3, #0
   24e18:	1a000073 	bne	24fec <_vfprintf_r+0x22bc>
						size = expt;
   24e1c:	e59d3030 	ldr	r3, [sp, #48]	@ 0x30
   24e20:	e3a04066 	mov	r4, #102	@ 0x66
   24e24:	e58d3020 	str	r3, [sp, #32]
				if ((flags & GROUPING) && expt > 0) {
   24e28:	e3170b01 	tst	r7, #1024	@ 0x400
   24e2c:	1a000042 	bne	24f3c <_vfprintf_r+0x220c>
		realsz = dprec > size ? dprec : size;
   24e30:	e59d3020 	ldr	r3, [sp, #32]
   24e34:	e1c33fc3 	bic	r3, r3, r3, asr #31
   24e38:	e58d3010 	str	r3, [sp, #16]
   24e3c:	eaffff51 	b	24b88 <_vfprintf_r+0x1e58>
					if (expt <= 0)
   24e40:	e59d3030 	ldr	r3, [sp, #48]	@ 0x30
					size = ndig + decp_len;
   24e44:	e59d2034 	ldr	r2, [sp, #52]	@ 0x34
   24e48:	e59d1040 	ldr	r1, [sp, #64]	@ 0x40
					if (expt <= 0)
   24e4c:	e3530000 	cmp	r3, #0
					ch = 'g';
   24e50:	c3a04067 	movgt	r4, #103	@ 0x67
					size = ndig + decp_len;
   24e54:	e0822001 	add	r2, r2, r1
   24e58:	e58d2020 	str	r2, [sp, #32]
					if (expt <= 0)
   24e5c:	cafffff1 	bgt	24e28 <_vfprintf_r+0x20f8>
						size += 1 - expt;
   24e60:	e2633001 	rsb	r3, r3, #1
					ch = 'g';
   24e64:	e3a04067 	mov	r4, #103	@ 0x67
						size += 1 - expt;
   24e68:	e0823003 	add	r3, r2, r3
   24e6c:	e58d3020 	str	r3, [sp, #32]
		realsz = dprec > size ? dprec : size;
   24e70:	e1c33fc3 	bic	r3, r3, r3, asr #31
   24e74:	e58d3010 	str	r3, [sp, #16]
   24e78:	eaffff42 	b	24b88 <_vfprintf_r+0x1e58>
   24e7c:	e1a05007 	mov	r5, r7
   24e80:	e1a07008 	mov	r7, r8
   24e84:	e1a0800a 	mov	r8, sl
   24e88:	e1a0a001 	mov	sl, r1
						PAD (-expt, zeroes);
   24e8c:	e2833001 	add	r3, r3, #1
   24e90:	e0822004 	add	r2, r2, r4
   24e94:	e3530007 	cmp	r3, #7
   24e98:	e58a8000 	str	r8, [sl]
   24e9c:	e58a4004 	str	r4, [sl, #4]
   24ea0:	e58d2090 	str	r2, [sp, #144]	@ 0x90
   24ea4:	e58d308c 	str	r3, [sp, #140]	@ 0x8c
   24ea8:	daffff6e 	ble	24c68 <_vfprintf_r+0x1f38>
   24eac:	e59d1014 	ldr	r1, [sp, #20]
   24eb0:	e28d2088 	add	r2, sp, #136	@ 0x88
   24eb4:	e59d000c 	ldr	r0, [sp, #12]
   24eb8:	ebffcb53 	bl	17c0c <__sprint_r>
   24ebc:	e3500000 	cmp	r0, #0
   24ec0:	1afff899 	bne	2312c <_vfprintf_r+0x3fc>
						PRINT (cp, ndig);
   24ec4:	e59d2090 	ldr	r2, [sp, #144]	@ 0x90
						PAD (-expt, zeroes);
   24ec8:	e28da094 	add	sl, sp, #148	@ 0x94
						PRINT (cp, ndig);
   24ecc:	e59d308c 	ldr	r3, [sp, #140]	@ 0x8c
   24ed0:	eafffd80 	b	244d8 <_vfprintf_r+0x17a8>
		if (!isa)
   24ed4:	e3510000 	cmp	r1, #0
		*p++ = to_char (exp);
   24ed8:	e2833030 	add	r3, r3, #48	@ 0x30
			*p++ = '0';
   24edc:	03a02030 	moveq	r2, #48	@ 0x30
   24ee0:	128d207a 	addne	r2, sp, #122	@ 0x7a
   24ee4:	05cd207a 	strbeq	r2, [sp, #122]	@ 0x7a
   24ee8:	028d207b 	addeq	r2, sp, #123	@ 0x7b
		*p++ = to_char (exp);
   24eec:	e4c23001 	strb	r3, [r2], #1
	return (p - p0);
   24ef0:	e28d3078 	add	r3, sp, #120	@ 0x78
   24ef4:	e0423003 	sub	r3, r2, r3
   24ef8:	e58d3048 	str	r3, [sp, #72]	@ 0x48
   24efc:	eafffe3e 	b	247fc <_vfprintf_r+0x1acc>
				if (ndig > 1 || flags & ALT)
   24f00:	e3170001 	tst	r7, #1
   24f04:	0afffe46 	beq	24824 <_vfprintf_r+0x1af4>
   24f08:	eafffe41 	b	24814 <_vfprintf_r+0x1ae4>
				if (signbit (_fpvalue))
   24f0c:	ee183a90 	vmov	r3, s17
					cp = "NAN";
   24f10:	e30953b0 	movw	r5, #37808	@ 0x93b0
				if (signbit (_fpvalue))
   24f14:	e3530000 	cmp	r3, #0
					cp = "NAN";
   24f18:	e30933ac 	movw	r3, #37804	@ 0x93ac
					sign = '-';
   24f1c:	b3a0102d 	movlt	r1, #45	@ 0x2d
			if (!sign)
   24f20:	a5dd106b 	ldrbge	r1, [sp, #107]	@ 0x6b
				flags &= ~ZEROPAD;
   24f24:	e3c77080 	bic	r7, r7, #128	@ 0x80
					cp = "NAN";
   24f28:	e3405002 	movt	r5, #2
   24f2c:	e3403002 	movt	r3, #2
					sign = '-';
   24f30:	b5cd106b 	strblt	r1, [sp, #107]	@ 0x6b
   24f34:	eafff909 	b	23360 <_vfprintf_r+0x630>
   24f38:	e3a04067 	mov	r4, #103	@ 0x67
					while (*grouping != CHAR_MAX) {
   24f3c:	e59d1054 	ldr	r1, [sp, #84]	@ 0x54
   24f40:	e5d13000 	ldrb	r3, [r1]
   24f44:	e35300ff 	cmp	r3, #255	@ 0xff
   24f48:	0a000057 	beq	250ac <_vfprintf_r+0x237c>
					nseps = nrepeats = 0;
   24f4c:	e3a0c000 	mov	ip, #0
   24f50:	e59d2030 	ldr	r2, [sp, #48]	@ 0x30
   24f54:	e1a0000c 	mov	r0, ip
   24f58:	ea000008 	b	24f80 <_vfprintf_r+0x2250>
						lead -= *grouping;
   24f5c:	e0422003 	sub	r2, r2, r3
						if (grouping[1]) {
   24f60:	e5d13001 	ldrb	r3, [r1, #1]
   24f64:	e3530000 	cmp	r3, #0
					while (*grouping != CHAR_MAX) {
   24f68:	05d13000 	ldrbeq	r3, [r1]
							nseps++;
   24f6c:	12800001 	addne	r0, r0, #1
							grouping++;
   24f70:	12811001 	addne	r1, r1, #1
							nrepeats++;
   24f74:	028cc001 	addeq	ip, ip, #1
					while (*grouping != CHAR_MAX) {
   24f78:	e35300ff 	cmp	r3, #255	@ 0xff
   24f7c:	0a000001 	beq	24f88 <_vfprintf_r+0x2258>
						if (lead <= *grouping)
   24f80:	e1530002 	cmp	r3, r2
   24f84:	bafffff4 	blt	24f5c <_vfprintf_r+0x222c>
   24f88:	e58d1054 	str	r1, [sp, #84]	@ 0x54
   24f8c:	e58d0038 	str	r0, [sp, #56]	@ 0x38
   24f90:	e58dc03c 	str	ip, [sp, #60]	@ 0x3c
   24f94:	e58d2030 	str	r2, [sp, #48]	@ 0x30
					size += (nseps + nrepeats) * thsnd_len;
   24f98:	e1cd23d8 	ldrd	r2, [sp, #56]	@ 0x38
   24f9c:	e59d1058 	ldr	r1, [sp, #88]	@ 0x58
			flags |= FPT;
   24fa0:	e59d7024 	ldr	r7, [sp, #36]	@ 0x24
					size += (nseps + nrepeats) * thsnd_len;
   24fa4:	e0833002 	add	r3, r3, r2
   24fa8:	e59d2020 	ldr	r2, [sp, #32]
   24fac:	e0232391 	mla	r3, r1, r3, r2
   24fb0:	e3a02000 	mov	r2, #0
   24fb4:	e58d2024 	str	r2, [sp, #36]	@ 0x24
   24fb8:	e58d3020 	str	r3, [sp, #32]
		realsz = dprec > size ? dprec : size;
   24fbc:	e1c33fc3 	bic	r3, r3, r3, asr #31
   24fc0:	e58d3010 	str	r3, [sp, #16]
					size += (nseps + nrepeats) * thsnd_len;
   24fc4:	eafffe1f 	b	24848 <_vfprintf_r+0x1b18>
   24fc8:	e58d7054 	str	r7, [sp, #84]	@ 0x54
   24fcc:	e1a0a001 	mov	sl, r1
   24fd0:	e59d505c 	ldr	r5, [sp, #92]	@ 0x5c
   24fd4:	e59d7060 	ldr	r7, [sp, #96]	@ 0x60
   24fd8:	e59db064 	ldr	fp, [sp, #100]	@ 0x64
					    if (cp > convbuf + ndig)
   24fdc:	e59d3020 	ldr	r3, [sp, #32]
   24fe0:	e1580003 	cmp	r8, r3
   24fe4:	21a08003 	movcs	r8, r3
   24fe8:	eafffb93 	b	23e3c <_vfprintf_r+0x110c>
							size += prec + decp_len;
   24fec:	e59d3040 	ldr	r3, [sp, #64]	@ 0x40
   24ff0:	e3a04066 	mov	r4, #102	@ 0x66
   24ff4:	e0893003 	add	r3, r9, r3
   24ff8:	e0833002 	add	r3, r3, r2
   24ffc:	e58d3020 	str	r3, [sp, #32]
   25000:	eaffff88 	b	24e28 <_vfprintf_r+0x20f8>
			while (ndigits-- >= 0) {
   25004:	e3520000 	cmp	r2, #0
   25008:	a2822001 	addge	r2, r2, #1
				*bp++ = '0';
   2500c:	a3a01030 	movge	r1, #48	@ 0x30
   25010:	a0832002 	addge	r2, r3, r2
			while (ndigits-- >= 0) {
   25014:	bafffc59 	blt	24180 <_vfprintf_r+0x1450>
				*bp++ = '0';
   25018:	e4c31001 	strb	r1, [r3], #1
			while (ndigits-- >= 0) {
   2501c:	e1520003 	cmp	r2, r3
   25020:	1afffffc 	bne	25018 <_vfprintf_r+0x22e8>
   25024:	eafffc56 	b	24184 <_vfprintf_r+0x1454>
						size = (prec || flags & ALT)
   25028:	e3530000 	cmp	r3, #0
   2502c:	1a00000e 	bne	2506c <_vfprintf_r+0x233c>
   25030:	e3a03001 	mov	r3, #1
   25034:	e3a04066 	mov	r4, #102	@ 0x66
   25038:	e58d3010 	str	r3, [sp, #16]
							  : 1;
   2503c:	e58d3020 	str	r3, [sp, #32]
				if ((flags & GROUPING) && expt > 0) {
   25040:	eafffed0 	b	24b88 <_vfprintf_r+0x1e58>
				prec = GET_ARG (n, ap, int);
   25044:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
rflag:		ch = *fmt++;
   25048:	e5db4001 	ldrb	r4, [fp, #1]
			if ((ch = *fmt++) == '*') {
   2504c:	e1a0b002 	mov	fp, r2
				if (prec < 0)
   25050:	e4939004 	ldr	r9, [r3], #4
				prec = GET_ARG (n, ap, int);
   25054:	e58d3028 	str	r3, [sp, #40]	@ 0x28
				if (prec < 0)
   25058:	e1899fc9 	orr	r9, r9, r9, asr #31
				goto rflag;
   2505c:	eafff78f 	b	22ea0 <_vfprintf_r+0x170>
				*decpt = -ndigits + 1;
   25060:	e2623001 	rsb	r3, r2, #1
   25064:	e58d3070 	str	r3, [sp, #112]	@ 0x70
   25068:	eafffda1 	b	246f4 <_vfprintf_r+0x19c4>
							  ? prec + 1 + decp_len
   2506c:	e59d3040 	ldr	r3, [sp, #64]	@ 0x40
							  : 1;
   25070:	e3a04066 	mov	r4, #102	@ 0x66
							  ? prec + 1 + decp_len
   25074:	e2837001 	add	r7, r3, #1
   25078:	e0873009 	add	r3, r7, r9
   2507c:	e58d3020 	str	r3, [sp, #32]
		realsz = dprec > size ? dprec : size;
   25080:	e1c33fc3 	bic	r3, r3, r3, asr #31
   25084:	e58d3010 	str	r3, [sp, #16]
							  : 1;
   25088:	eafffebe 	b	24b88 <_vfprintf_r+0x1e58>
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
   2508c:	e3a03002 	mov	r3, #2
   25090:	e58d3048 	str	r3, [sp, #72]	@ 0x48
   25094:	eafffdd8 	b	247fc <_vfprintf_r+0x1acc>
					fp->_flags |= __SERR;
   25098:	e59d2014 	ldr	r2, [sp, #20]
   2509c:	e1d230bc 	ldrh	r3, [r2, #12]
   250a0:	e3833040 	orr	r3, r3, #64	@ 0x40
   250a4:	e1c230bc 	strh	r3, [r2, #12]
	if (malloc_buf != NULL)
   250a8:	eafff825 	b	23144 <_vfprintf_r+0x414>
					nseps = nrepeats = 0;
   250ac:	e3a03000 	mov	r3, #0
   250b0:	e58d303c 	str	r3, [sp, #60]	@ 0x3c
   250b4:	e58d3038 	str	r3, [sp, #56]	@ 0x38
   250b8:	eaffffb6 	b	24f98 <_vfprintf_r+0x2268>
					    if (cp > convbuf + ndig)
   250bc:	e59d3034 	ldr	r3, [sp, #52]	@ 0x34
   250c0:	e0853003 	add	r3, r5, r3
   250c4:	e58d3020 	str	r3, [sp, #32]
   250c8:	eaffffc3 	b	24fdc <_vfprintf_r+0x22ac>

000250cc <vfprintf>:
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
   250cc:	e30bc1e8 	movw	ip, #45544	@ 0xb1e8
{
   250d0:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
   250d4:	e340c002 	movt	ip, #2
{
   250d8:	e1a0e000 	mov	lr, r0
   250dc:	e1a03002 	mov	r3, r2
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
   250e0:	e1a02001 	mov	r2, r1
   250e4:	e59c0000 	ldr	r0, [ip]
   250e8:	e1a0100e 	mov	r1, lr
}
   250ec:	e49de004 	pop	{lr}		@ (ldr lr, [sp], #4)
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
   250f0:	eafff70e 	b	22d30 <_vfprintf_r>

000250f4 <__sbprintf>:
{
   250f4:	e92d40f0 	push	{r4, r5, r6, r7, lr}
   250f8:	e1a04001 	mov	r4, r1
	fake._flags = fp->_flags & ~__SNBF;
   250fc:	e1d110bc 	ldrh	r1, [r1, #12]
{
   25100:	e24dde46 	sub	sp, sp, #1120	@ 0x460
   25104:	e24dd00c 	sub	sp, sp, #12
   25108:	e1a06000 	mov	r6, r0
	fake._bf._base = fake._p = buf;
   2510c:	e28dc068 	add	ip, sp, #104	@ 0x68
	fake._flags = fp->_flags & ~__SNBF;
   25110:	e1a0700d 	mov	r7, sp
   25114:	e3c11002 	bic	r1, r1, #2
	fake._bf._base = fake._p = buf;
   25118:	e58dc000 	str	ip, [sp]
	fake._flags = fp->_flags & ~__SNBF;
   2511c:	e1cd10bc 	strh	r1, [sp, #12]
	fake._flags2 = fp->_flags2;
   25120:	e5941064 	ldr	r1, [r4, #100]	@ 0x64
	fake._bf._base = fake._p = buf;
   25124:	e58dc010 	str	ip, [sp, #16]
	fake._bf._size = fake._w = sizeof (buf);
   25128:	e3a0cb01 	mov	ip, #1024	@ 0x400
   2512c:	e58dc008 	str	ip, [sp, #8]
	fake._flags2 = fp->_flags2;
   25130:	e58d1064 	str	r1, [sp, #100]	@ 0x64
	fake._file = fp->_file;
   25134:	e1d410be 	ldrh	r1, [r4, #14]
	fake._bf._size = fake._w = sizeof (buf);
   25138:	e58dc014 	str	ip, [sp, #20]
	fake._file = fp->_file;
   2513c:	e1cd10be 	strh	r1, [sp, #14]
	fake._cookie = fp->_cookie;
   25140:	e594101c 	ldr	r1, [r4, #28]
   25144:	e58d101c 	str	r1, [sp, #28]
	fake._write = fp->_write;
   25148:	e5941024 	ldr	r1, [r4, #36]	@ 0x24
   2514c:	e58d1024 	str	r1, [sp, #36]	@ 0x24
	fake._bf._size = fake._w = sizeof (buf);
   25150:	e3a01000 	mov	r1, #0
   25154:	e58d1018 	str	r1, [sp, #24]
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
   25158:	e1a01007 	mov	r1, r7
   2515c:	ebfff6f3 	bl	22d30 <_vfprintf_r>
	if (ret >= 0 && _fflush_r (rptr, &fake))
   25160:	e2505000 	subs	r5, r0, #0
   25164:	ba000004 	blt	2517c <__sbprintf+0x88>
   25168:	e1a01007 	mov	r1, r7
   2516c:	e1a00006 	mov	r0, r6
   25170:	ebffcbb1 	bl	1803c <_fflush_r>
		ret = EOF;
   25174:	e3500000 	cmp	r0, #0
   25178:	13e05000 	mvnne	r5, #0
	if (fake._flags & __SERR)
   2517c:	e1dd30bc 	ldrh	r3, [sp, #12]
}
   25180:	e1a00005 	mov	r0, r5
	if (fake._flags & __SERR)
   25184:	e3130040 	tst	r3, #64	@ 0x40
		fp->_flags |= __SERR;
   25188:	11d430bc 	ldrhne	r3, [r4, #12]
   2518c:	13833040 	orrne	r3, r3, #64	@ 0x40
   25190:	11c430bc 	strhne	r3, [r4, #12]
}
   25194:	e28dde46 	add	sp, sp, #1120	@ 0x460
   25198:	e28dd00c 	add	sp, sp, #12
   2519c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

000251a0 <__ssprint_r>:

int
__ssprint_r (struct _reent *ptr,
	FILE *fp,
	register struct __suio *uio)
{
   251a0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
   251a4:	e1a05002 	mov	r5, r2
	register struct __siov *iov = uio->uio_iov;
	register size_t len;
	int ret = 0;

	while (uio->uio_resid > 0 && uio->uio_iovcnt-- > 0) {
   251a8:	e5922008 	ldr	r2, [r2, #8]
	register struct __siov *iov = uio->uio_iov;
   251ac:	e5954000 	ldr	r4, [r5]
	while (uio->uio_resid > 0 && uio->uio_iovcnt-- > 0) {
   251b0:	e3520000 	cmp	r2, #0
   251b4:	0a00001d 	beq	25230 <__ssprint_r+0x90>
   251b8:	e1a07000 	mov	r7, r0
   251bc:	e1a08001 	mov	r8, r1
   251c0:	e2844008 	add	r4, r4, #8
   251c4:	ea000002 	b	251d4 <__ssprint_r+0x34>
   251c8:	e3510000 	cmp	r1, #0
   251cc:	e2844008 	add	r4, r4, #8
   251d0:	0a000016 	beq	25230 <__ssprint_r+0x90>
   251d4:	e5953004 	ldr	r3, [r5, #4]
   251d8:	e1a01002 	mov	r1, r2
   251dc:	e3530000 	cmp	r3, #0
   251e0:	e2433001 	sub	r3, r3, #1
   251e4:	e5853004 	str	r3, [r5, #4]
   251e8:	da000010 	ble	25230 <__ssprint_r+0x90>
		if ((len = iov->iov_len) > 0) {
   251ec:	e5146004 	ldr	r6, [r4, #-4]
   251f0:	e3560000 	cmp	r6, #0
   251f4:	0afffff3 	beq	251c8 <__ssprint_r+0x28>
			if (__ssputs_r (ptr, fp, iov->iov_base, len) == EOF) {
   251f8:	e5142008 	ldr	r2, [r4, #-8]
   251fc:	e1a03006 	mov	r3, r6
   25200:	e1a01008 	mov	r1, r8
   25204:	e1a00007 	mov	r0, r7
   25208:	eb000bf3 	bl	281dc <__ssputs_r>
   2520c:	e3700001 	cmn	r0, #1
   25210:	0a000007 	beq	25234 <__ssprint_r+0x94>
				ret = EOF;
				break;
			}
			uio->uio_resid -= len;	/* pretend we copied all */
   25214:	e5952008 	ldr	r2, [r5, #8]
	while (uio->uio_resid > 0 && uio->uio_iovcnt-- > 0) {
   25218:	e2844008 	add	r4, r4, #8
			uio->uio_resid -= len;	/* pretend we copied all */
   2521c:	e0422006 	sub	r2, r2, r6
   25220:	e1a01002 	mov	r1, r2
   25224:	e5852008 	str	r2, [r5, #8]
	while (uio->uio_resid > 0 && uio->uio_iovcnt-- > 0) {
   25228:	e3510000 	cmp	r1, #0
   2522c:	1affffe8 	bne	251d4 <__ssprint_r+0x34>
	int ret = 0;
   25230:	e3a00000 	mov	r0, #0
		}
		iov++;
	}
	uio->uio_resid = 0;
   25234:	e3a03000 	mov	r3, #0
   25238:	e5853008 	str	r3, [r5, #8]
	uio->uio_iovcnt = 0;
   2523c:	e5853004 	str	r3, [r5, #4]
	return ret;
}
   25240:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

00025244 <__smakebuf_r>:
  register void *p;
  int flags;
  size_t size;
  int couldbetty;

  if (fp->_flags & __SNBF)
   25244:	e1d130fc 	ldrsh	r3, [r1, #12]
{
   25248:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
   2524c:	e1a04001 	mov	r4, r1
   25250:	e24dd058 	sub	sp, sp, #88	@ 0x58
  if (fp->_flags & __SNBF)
   25254:	e3130002 	tst	r3, #2
   25258:	0a000006 	beq	25278 <__smakebuf_r+0x34>
    {
      fp->_bf._base = fp->_p = fp->_nbuf;
   2525c:	e2813043 	add	r3, r1, #67	@ 0x43
      fp->_bf._size = 1;
   25260:	e3a02001 	mov	r2, #1
      fp->_bf._base = fp->_p = fp->_nbuf;
   25264:	e5813000 	str	r3, [r1]
   25268:	e5813010 	str	r3, [r1, #16]
      fp->_bf._size = 1;
   2526c:	e5812014 	str	r2, [r1, #20]
      fp->_bf._size = size;
      if (couldbetty && _isatty_r (ptr, fp->_file))
	fp->_flags = (fp->_flags & ~__SNBF) | __SLBF;
      fp->_flags |= flags;
    }
}
   25270:	e28dd058 	add	sp, sp, #88	@ 0x58
   25274:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

  if (fp->_file < 0 || _fstat64_r (ptr, fp->_file, &st) < 0)
#else
  struct stat st;

  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
   25278:	e1d110fe 	ldrsh	r1, [r1, #14]
   2527c:	e1a06000 	mov	r6, r0
   25280:	e3510000 	cmp	r1, #0
   25284:	ba00001c 	blt	252fc <__smakebuf_r+0xb8>
   25288:	e1a0200d 	mov	r2, sp
   2528c:	ebffd8fb 	bl	1b680 <_fstat_r>
   25290:	e3500000 	cmp	r0, #0
   25294:	ba000017 	blt	252f8 <__smakebuf_r+0xb4>
        *bufsize = BUFSIZ;
      return (0);
    }

  /* could be a tty iff it is a character device */
  *couldbetty = S_ISCHR(st.st_mode);
   25298:	e59d5004 	ldr	r5, [sp, #4]
      *bufsize = st.st_blksize;
      fp->_blksize = st.st_blksize;
      return ((st.st_mode & S_IFMT) == S_IFREG ?  __SOPT : snpt);
    }
#endif
  *bufsize = BUFSIZ;
   2529c:	e3a08b01 	mov	r8, #1024	@ 0x400
  return (snpt);
   252a0:	e3a07b02 	mov	r7, #2048	@ 0x800
  *couldbetty = S_ISCHR(st.st_mode);
   252a4:	e2055a0f 	and	r5, r5, #61440	@ 0xf000
   252a8:	e2455a02 	sub	r5, r5, #8192	@ 0x2000
   252ac:	e16f5f15 	clz	r5, r5
   252b0:	e1a052a5 	lsr	r5, r5, #5
  if ((p = _malloc_r (ptr, size)) == NULL)
   252b4:	e1a01008 	mov	r1, r8
   252b8:	e1a00006 	mov	r0, r6
   252bc:	ebffe8a0 	bl	1f544 <_malloc_r>
   252c0:	e3500000 	cmp	r0, #0
   252c4:	0a000013 	beq	25318 <__smakebuf_r+0xd4>
      fp->_flags |= __SMBF;
   252c8:	e1d430fc 	ldrsh	r3, [r4, #12]
      if (couldbetty && _isatty_r (ptr, fp->_file))
   252cc:	e3550000 	cmp	r5, #0
      fp->_bf._size = size;
   252d0:	e5848014 	str	r8, [r4, #20]
      fp->_bf._base = fp->_p = (unsigned char *) p;
   252d4:	e5840000 	str	r0, [r4]
      fp->_flags |= __SMBF;
   252d8:	e3833080 	orr	r3, r3, #128	@ 0x80
      fp->_bf._base = fp->_p = (unsigned char *) p;
   252dc:	e5840010 	str	r0, [r4, #16]
      fp->_flags |= __SMBF;
   252e0:	e1c430bc 	strh	r3, [r4, #12]
      if (couldbetty && _isatty_r (ptr, fp->_file))
   252e4:	1a000017 	bne	25348 <__smakebuf_r+0x104>
      fp->_flags |= flags;
   252e8:	e1833007 	orr	r3, r3, r7
   252ec:	e1c430bc 	strh	r3, [r4, #12]
}
   252f0:	e28dd058 	add	sp, sp, #88	@ 0x58
   252f4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
   252f8:	e1d430fc 	ldrsh	r3, [r4, #12]
      if (fp->_flags & __SMBF)
   252fc:	e2135080 	ands	r5, r3, #128	@ 0x80
        *bufsize = BUFSIZ;
   25300:	03a08b01 	moveq	r8, #1024	@ 0x400
   25304:	01a07005 	moveq	r7, r5
      *couldbetty = 0;
   25308:	13a05000 	movne	r5, #0
        *bufsize = _DEFAULT_ASPRINTF_BUFSIZE;
   2530c:	13a08040 	movne	r8, #64	@ 0x40
      if (fp->_flags & __SMBF)
   25310:	11a07005 	movne	r7, r5
   25314:	eaffffe6 	b	252b4 <__smakebuf_r+0x70>
      if (!(fp->_flags & __SSTR))
   25318:	e1d430fc 	ldrsh	r3, [r4, #12]
   2531c:	e3130c02 	tst	r3, #512	@ 0x200
   25320:	1affffd2 	bne	25270 <__smakebuf_r+0x2c>
	  fp->_flags = (fp->_flags & ~__SLBF) | __SNBF;
   25324:	e3c33003 	bic	r3, r3, #3
	  fp->_bf._base = fp->_p = fp->_nbuf;
   25328:	e2842043 	add	r2, r4, #67	@ 0x43
	  fp->_flags = (fp->_flags & ~__SLBF) | __SNBF;
   2532c:	e3833002 	orr	r3, r3, #2
	  fp->_bf._size = 1;
   25330:	e3a01001 	mov	r1, #1
	  fp->_flags = (fp->_flags & ~__SLBF) | __SNBF;
   25334:	e1c430bc 	strh	r3, [r4, #12]
	  fp->_bf._base = fp->_p = fp->_nbuf;
   25338:	e5842000 	str	r2, [r4]
   2533c:	e5842010 	str	r2, [r4, #16]
	  fp->_bf._size = 1;
   25340:	e5841014 	str	r1, [r4, #20]
   25344:	eaffffc9 	b	25270 <__smakebuf_r+0x2c>
      if (couldbetty && _isatty_r (ptr, fp->_file))
   25348:	e1d410fe 	ldrsh	r1, [r4, #14]
   2534c:	e1a00006 	mov	r0, r6
   25350:	eb000263 	bl	25ce4 <_isatty_r>
   25354:	e3500000 	cmp	r0, #0
	fp->_flags = (fp->_flags & ~__SNBF) | __SLBF;
   25358:	11d430bc 	ldrhne	r3, [r4, #12]
   2535c:	01d430fc 	ldrsheq	r3, [r4, #12]
   25360:	13c33003 	bicne	r3, r3, #3
   25364:	13833001 	orrne	r3, r3, #1
   25368:	16bf3073 	sxthne	r3, r3
   2536c:	eaffffdd 	b	252e8 <__smakebuf_r+0xa4>

00025370 <__swhatbuf_r>:
{
   25370:	e92d4070 	push	{r4, r5, r6, lr}
   25374:	e1a04001 	mov	r4, r1
  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
   25378:	e1d110fe 	ldrsh	r1, [r1, #14]
{
   2537c:	e24dd058 	sub	sp, sp, #88	@ 0x58
   25380:	e1a05002 	mov	r5, r2
   25384:	e1a06003 	mov	r6, r3
  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
   25388:	e3510000 	cmp	r1, #0
   2538c:	ba00000e 	blt	253cc <__swhatbuf_r+0x5c>
   25390:	e1a0200d 	mov	r2, sp
   25394:	ebffd8b9 	bl	1b680 <_fstat_r>
   25398:	e3500000 	cmp	r0, #0
   2539c:	ba00000a 	blt	253cc <__swhatbuf_r+0x5c>
  *couldbetty = S_ISCHR(st.st_mode);
   253a0:	e59d1004 	ldr	r1, [sp, #4]
  return (snpt);
   253a4:	e3a03b01 	mov	r3, #1024	@ 0x400
   253a8:	e3a00b02 	mov	r0, #2048	@ 0x800
  *couldbetty = S_ISCHR(st.st_mode);
   253ac:	e2011a0f 	and	r1, r1, #61440	@ 0xf000
   253b0:	e2411a02 	sub	r1, r1, #8192	@ 0x2000
   253b4:	e16f1f11 	clz	r1, r1
   253b8:	e1a012a1 	lsr	r1, r1, #5
      *couldbetty = 0;
   253bc:	e5861000 	str	r1, [r6]
        *bufsize = BUFSIZ;
   253c0:	e5853000 	str	r3, [r5]
}
   253c4:	e28dd058 	add	sp, sp, #88	@ 0x58
   253c8:	e8bd8070 	pop	{r4, r5, r6, pc}
      if (fp->_flags & __SMBF)
   253cc:	e1d410bc 	ldrh	r1, [r4, #12]
   253d0:	e2111080 	ands	r1, r1, #128	@ 0x80
   253d4:	03a03b01 	moveq	r3, #1024	@ 0x400
   253d8:	01a00001 	moveq	r0, r1
   253dc:	0afffff6 	beq	253bc <__swhatbuf_r+0x4c>
   253e0:	e3a01000 	mov	r1, #0
   253e4:	e3a03040 	mov	r3, #64	@ 0x40
   253e8:	e1a00001 	mov	r0, r1
      *couldbetty = 0;
   253ec:	e5861000 	str	r1, [r6]
        *bufsize = BUFSIZ;
   253f0:	e5853000 	str	r3, [r5]
}
   253f4:	e28dd058 	add	sp, sp, #88	@ 0x58
   253f8:	e8bd8070 	pop	{r4, r5, r6, pc}

000253fc <lflush>:
#include "local.h"

static int
lflush (struct _reent * ptr __unused, FILE *fp)
{
  if ((fp->_flags & (__SLBF | __SWR)) == (__SLBF | __SWR))
   253fc:	e1d130bc 	ldrh	r3, [r1, #12]
   25400:	e2033009 	and	r3, r3, #9
   25404:	e3530009 	cmp	r3, #9
   25408:	0a000001 	beq	25414 <lflush+0x18>
    return _fflush_r (_REENT, fp);
  return 0;
}
   2540c:	e3a00000 	mov	r0, #0
   25410:	e12fff1e 	bx	lr
    return _fflush_r (_REENT, fp);
   25414:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
   25418:	e3403002 	movt	r3, #2
   2541c:	e5930000 	ldr	r0, [r3]
   25420:	eaffcb05 	b	1803c <_fflush_r>

00025424 <__srefill_r>:
 */

int
__srefill_r (struct _reent * ptr,
       register FILE * fp)
{
   25424:	e92d4070 	push	{r4, r5, r6, lr}
  /* make sure stdio is set up */

  CHECK_INIT (ptr, fp);
   25428:	e2505000 	subs	r5, r0, #0
{
   2542c:	e1a04001 	mov	r4, r1
  CHECK_INIT (ptr, fp);
   25430:	0a000002 	beq	25440 <__srefill_r+0x1c>
   25434:	e5953034 	ldr	r3, [r5, #52]	@ 0x34
   25438:	e3530000 	cmp	r3, #0
   2543c:	0a00004f 	beq	25580 <__srefill_r+0x15c>

  fp->_r = 0;			/* largely a convenience for callers */

  /* SysV does not make this test; take it out for compatibility */
  if (fp->_flags & __SEOF)
   25440:	e1d430fc 	ldrsh	r3, [r4, #12]
  fp->_r = 0;			/* largely a convenience for callers */
   25444:	e3a02000 	mov	r2, #0
   25448:	e5842004 	str	r2, [r4, #4]
  if (fp->_flags & __SEOF)
   2544c:	e3130020 	tst	r3, #32
   25450:	1a000052 	bne	255a0 <__srefill_r+0x17c>
    return EOF;

  /* if not already reading, have to be reading and writing */
  if ((fp->_flags & __SRD) == 0)
   25454:	e3130004 	tst	r3, #4
   25458:	1a000017 	bne	254bc <__srefill_r+0x98>
    {
      if ((fp->_flags & __SRW) == 0)
   2545c:	e3130010 	tst	r3, #16
   25460:	0a000050 	beq	255a8 <__srefill_r+0x184>
	  _REENT_ERRNO(ptr) = EBADF;
	  fp->_flags |= __SERR;
	  return EOF;
	}
      /* switch to reading */
      if (fp->_flags & __SWR)
   25464:	e3130008 	tst	r3, #8
   25468:	1a000036 	bne	25548 <__srefill_r+0x124>
	    return EOF;
	  fp->_flags &= ~__SWR;
	  fp->_w = 0;
	  fp->_lbfsize = 0;
	}
      fp->_flags |= __SRD;
   2546c:	e3833004 	orr	r3, r3, #4
   25470:	e1c430bc 	strh	r3, [r4, #12]
	      return 0;
	    }
	}
    }

  if (fp->_bf._base == NULL)
   25474:	e5943010 	ldr	r3, [r4, #16]
   25478:	e3530000 	cmp	r3, #0
   2547c:	0a00003b 	beq	25570 <__srefill_r+0x14c>
  /*
   * Before reading from a line buffered or unbuffered file,
   * flush all line buffered output files, per the ANSI C
   * standard.
   */
  if (fp->_flags & (__SLBF | __SNBF))
   25480:	e1d460fc 	ldrsh	r6, [r4, #12]
   25484:	e3160003 	tst	r6, #3
   25488:	1a00001d 	bne	25504 <__srefill_r+0xe0>
      /* Now flush this file without locking it. */
      if ((fp->_flags & (__SLBF|__SWR)) == (__SLBF|__SWR))
	__sflush_r (ptr, fp);
    }

  fp->_p = fp->_bf._base;
   2548c:	e5942010 	ldr	r2, [r4, #16]
  fp->_r = fp->_read (ptr, fp->_cookie, (char *) fp->_p, fp->_bf._size);
   25490:	e1a00005 	mov	r0, r5
   25494:	e5946020 	ldr	r6, [r4, #32]
   25498:	e5943014 	ldr	r3, [r4, #20]
   2549c:	e594101c 	ldr	r1, [r4, #28]
  fp->_p = fp->_bf._base;
   254a0:	e5842000 	str	r2, [r4]
  fp->_r = fp->_read (ptr, fp->_cookie, (char *) fp->_p, fp->_bf._size);
   254a4:	e12fff36 	blx	r6
  if (fp->_r <= 0)
   254a8:	e3500000 	cmp	r0, #0
  fp->_r = fp->_read (ptr, fp->_cookie, (char *) fp->_p, fp->_bf._size);
   254ac:	e5840004 	str	r0, [r4, #4]
  if (fp->_r <= 0)
   254b0:	da000034 	ble	25588 <__srefill_r+0x164>
	      return 0;
   254b4:	e3a00000 	mov	r0, #0
	  fp->_flags |= __SERR;
	}
      return EOF;
    }
  return 0;
}
   254b8:	e8bd8070 	pop	{r4, r5, r6, pc}
      if (HASUB (fp))
   254bc:	e5941030 	ldr	r1, [r4, #48]	@ 0x30
   254c0:	e3510000 	cmp	r1, #0
   254c4:	0affffea 	beq	25474 <__srefill_r+0x50>
	  FREEUB (ptr, fp);
   254c8:	e2843040 	add	r3, r4, #64	@ 0x40
   254cc:	e1510003 	cmp	r1, r3
   254d0:	0a000001 	beq	254dc <__srefill_r+0xb8>
   254d4:	e1a00005 	mov	r0, r5
   254d8:	ebffe81b 	bl	1f54c <_free_r>
	  if ((fp->_r = fp->_ur) != 0)
   254dc:	e594303c 	ldr	r3, [r4, #60]	@ 0x3c
	  FREEUB (ptr, fp);
   254e0:	e3a02000 	mov	r2, #0
   254e4:	e5842030 	str	r2, [r4, #48]	@ 0x30
	  if ((fp->_r = fp->_ur) != 0)
   254e8:	e1530002 	cmp	r3, r2
   254ec:	e5843004 	str	r3, [r4, #4]
   254f0:	0affffdf 	beq	25474 <__srefill_r+0x50>
	      fp->_p = fp->_up;
   254f4:	e5943038 	ldr	r3, [r4, #56]	@ 0x38
	      return 0;
   254f8:	e3a00000 	mov	r0, #0
	      fp->_p = fp->_up;
   254fc:	e5843000 	str	r3, [r4]
}
   25500:	e8bd8070 	pop	{r4, r5, r6, pc}
      fp->_flags = 1;
   25504:	e3a03001 	mov	r3, #1
      (void) _fwalk_sglue (_GLOBAL_REENT, lflush, &__sglue);
   25508:	e30b206c 	movw	r2, #45164	@ 0xb06c
   2550c:	e30513fc 	movw	r1, #21500	@ 0x53fc
   25510:	e30b01f0 	movw	r0, #45552	@ 0xb1f0
      fp->_flags = 1;
   25514:	e1c430bc 	strh	r3, [r4, #12]
      (void) _fwalk_sglue (_GLOBAL_REENT, lflush, &__sglue);
   25518:	e3402002 	movt	r2, #2
   2551c:	e3401002 	movt	r1, #2
   25520:	e3400002 	movt	r0, #2
   25524:	ebffcdef 	bl	18ce8 <_fwalk_sglue>
      if ((fp->_flags & (__SLBF|__SWR)) == (__SLBF|__SWR))
   25528:	e2063009 	and	r3, r6, #9
      fp->_flags = orig_flags;
   2552c:	e1c460bc 	strh	r6, [r4, #12]
      if ((fp->_flags & (__SLBF|__SWR)) == (__SLBF|__SWR))
   25530:	e3530009 	cmp	r3, #9
   25534:	1affffd4 	bne	2548c <__srefill_r+0x68>
	__sflush_r (ptr, fp);
   25538:	e1a01004 	mov	r1, r4
   2553c:	e1a00005 	mov	r0, r5
   25540:	ebffca3c 	bl	17e38 <__sflush_r>
   25544:	eaffffd0 	b	2548c <__srefill_r+0x68>
	  if (_fflush_r (ptr, fp))
   25548:	e1a01004 	mov	r1, r4
   2554c:	e1a00005 	mov	r0, r5
   25550:	ebffcab9 	bl	1803c <_fflush_r>
   25554:	e3500000 	cmp	r0, #0
   25558:	1a000010 	bne	255a0 <__srefill_r+0x17c>
	  fp->_flags &= ~__SWR;
   2555c:	e1d430fc 	ldrsh	r3, [r4, #12]
	  fp->_w = 0;
   25560:	e5840008 	str	r0, [r4, #8]
	  fp->_lbfsize = 0;
   25564:	e5840018 	str	r0, [r4, #24]
	  fp->_flags &= ~__SWR;
   25568:	e3c33008 	bic	r3, r3, #8
	  fp->_lbfsize = 0;
   2556c:	eaffffbe 	b	2546c <__srefill_r+0x48>
    __smakebuf_r (ptr, fp);
   25570:	e1a01004 	mov	r1, r4
   25574:	e1a00005 	mov	r0, r5
   25578:	ebffff31 	bl	25244 <__smakebuf_r>
   2557c:	eaffffbf 	b	25480 <__srefill_r+0x5c>
  CHECK_INIT (ptr, fp);
   25580:	ebffcbd6 	bl	184e0 <__sinit>
   25584:	eaffffad 	b	25440 <__srefill_r+0x1c>
	fp->_flags |= __SEOF;
   25588:	e1d430fc 	ldrsh	r3, [r4, #12]
	  fp->_r = 0;
   2558c:	13a02000 	movne	r2, #0
   25590:	15842004 	strne	r2, [r4, #4]
	fp->_flags |= __SEOF;
   25594:	03833020 	orreq	r3, r3, #32
	  fp->_flags |= __SERR;
   25598:	13833040 	orrne	r3, r3, #64	@ 0x40
   2559c:	e1c430bc 	strh	r3, [r4, #12]
    return EOF;
   255a0:	e3e00000 	mvn	r0, #0
   255a4:	e8bd8070 	pop	{r4, r5, r6, pc}
	  _REENT_ERRNO(ptr) = EBADF;
   255a8:	e3a02009 	mov	r2, #9
	  fp->_flags |= __SERR;
   255ac:	e3833040 	orr	r3, r3, #64	@ 0x40
	  _REENT_ERRNO(ptr) = EBADF;
   255b0:	e5852000 	str	r2, [r5]
	  fp->_flags |= __SERR;
   255b4:	e1c430bc 	strh	r3, [r4, #12]
	  return EOF;
   255b8:	eafffff8 	b	255a0 <__srefill_r+0x17c>

000255bc <_strerror_r>:
char *
_strerror_r (struct _reent *ptr,
	int errnum,
	int internal,
	int *errptr)
{
   255bc:	e1a0c001 	mov	ip, r1
  char *error;
  extern char *_user_strerror (int, int, int *);

  switch (errnum)
   255c0:	e351008e 	cmp	r1, #142	@ 0x8e
   255c4:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
   255c8:	ea00008e 	b	25808 <_strerror_r+0x24c>
   255cc:	00025bec 	.word	0x00025bec
   255d0:	00025be0 	.word	0x00025be0
   255d4:	00025bd4 	.word	0x00025bd4
   255d8:	00025bc8 	.word	0x00025bc8
   255dc:	00025bbc 	.word	0x00025bbc
   255e0:	00025bb0 	.word	0x00025bb0
   255e4:	00025ba4 	.word	0x00025ba4
   255e8:	00025b98 	.word	0x00025b98
   255ec:	00025b8c 	.word	0x00025b8c
   255f0:	00025b80 	.word	0x00025b80
   255f4:	00025b74 	.word	0x00025b74
   255f8:	00025b68 	.word	0x00025b68
   255fc:	00025b5c 	.word	0x00025b5c
   25600:	00025b50 	.word	0x00025b50
   25604:	00025b44 	.word	0x00025b44
   25608:	00025808 	.word	0x00025808
   2560c:	00025b38 	.word	0x00025b38
   25610:	00025b2c 	.word	0x00025b2c
   25614:	00025b20 	.word	0x00025b20
   25618:	00025b14 	.word	0x00025b14
   2561c:	00025b08 	.word	0x00025b08
   25620:	00025afc 	.word	0x00025afc
   25624:	00025af0 	.word	0x00025af0
   25628:	00025ae4 	.word	0x00025ae4
   2562c:	00025ad8 	.word	0x00025ad8
   25630:	00025acc 	.word	0x00025acc
   25634:	00025ac0 	.word	0x00025ac0
   25638:	00025ab4 	.word	0x00025ab4
   2563c:	00025aa8 	.word	0x00025aa8
   25640:	00025a9c 	.word	0x00025a9c
   25644:	00025a90 	.word	0x00025a90
   25648:	00025a84 	.word	0x00025a84
   2564c:	00025a78 	.word	0x00025a78
   25650:	00025a6c 	.word	0x00025a6c
   25654:	00025a60 	.word	0x00025a60
   25658:	00025a54 	.word	0x00025a54
   2565c:	00025a48 	.word	0x00025a48
   25660:	00025808 	.word	0x00025808
   25664:	00025808 	.word	0x00025808
   25668:	00025808 	.word	0x00025808
   2566c:	00025808 	.word	0x00025808
   25670:	00025808 	.word	0x00025808
   25674:	00025808 	.word	0x00025808
   25678:	00025808 	.word	0x00025808
   2567c:	00025808 	.word	0x00025808
   25680:	00025a3c 	.word	0x00025a3c
   25684:	00025a30 	.word	0x00025a30
   25688:	00025808 	.word	0x00025808
   2568c:	00025808 	.word	0x00025808
   25690:	00025808 	.word	0x00025808
   25694:	00025808 	.word	0x00025808
   25698:	00025808 	.word	0x00025808
   2569c:	00025808 	.word	0x00025808
   256a0:	00025808 	.word	0x00025808
   256a4:	00025808 	.word	0x00025808
   256a8:	00025808 	.word	0x00025808
   256ac:	00025808 	.word	0x00025808
   256b0:	00025808 	.word	0x00025808
   256b4:	00025808 	.word	0x00025808
   256b8:	00025808 	.word	0x00025808
   256bc:	00025a24 	.word	0x00025a24
   256c0:	00025a18 	.word	0x00025a18
   256c4:	00025a0c 	.word	0x00025a0c
   256c8:	00025a00 	.word	0x00025a00
   256cc:	00025808 	.word	0x00025808
   256d0:	00025808 	.word	0x00025808
   256d4:	00025808 	.word	0x00025808
   256d8:	000259f4 	.word	0x000259f4
   256dc:	00025808 	.word	0x00025808
   256e0:	00025808 	.word	0x00025808
   256e4:	00025808 	.word	0x00025808
   256e8:	000259e8 	.word	0x000259e8
   256ec:	00025808 	.word	0x00025808
   256f0:	00025808 	.word	0x00025808
   256f4:	000259dc 	.word	0x000259dc
   256f8:	00025808 	.word	0x00025808
   256fc:	00025808 	.word	0x00025808
   25700:	000259d0 	.word	0x000259d0
   25704:	00025808 	.word	0x00025808
   25708:	00025808 	.word	0x00025808
   2570c:	00025808 	.word	0x00025808
   25710:	00025808 	.word	0x00025808
   25714:	00025808 	.word	0x00025808
   25718:	00025808 	.word	0x00025808
   2571c:	00025808 	.word	0x00025808
   25720:	00025808 	.word	0x00025808
   25724:	00025808 	.word	0x00025808
   25728:	00025808 	.word	0x00025808
   2572c:	000259c4 	.word	0x000259c4
   25730:	00025808 	.word	0x00025808
   25734:	000259b8 	.word	0x000259b8
   25738:	000259ac 	.word	0x000259ac
   2573c:	000259a0 	.word	0x000259a0
   25740:	00025808 	.word	0x00025808
   25744:	00025808 	.word	0x00025808
   25748:	00025994 	.word	0x00025994
   2574c:	00025808 	.word	0x00025808
   25750:	00025808 	.word	0x00025808
   25754:	00025808 	.word	0x00025808
   25758:	00025808 	.word	0x00025808
   2575c:	00025808 	.word	0x00025808
   25760:	00025808 	.word	0x00025808
   25764:	00025808 	.word	0x00025808
   25768:	00025808 	.word	0x00025808
   2576c:	00025988 	.word	0x00025988
   25770:	0002597c 	.word	0x0002597c
   25774:	00025970 	.word	0x00025970
   25778:	00025964 	.word	0x00025964
   2577c:	00025958 	.word	0x00025958
   25780:	0002594c 	.word	0x0002594c
   25784:	00025808 	.word	0x00025808
   25788:	00025940 	.word	0x00025940
   2578c:	00025934 	.word	0x00025934
   25790:	00025928 	.word	0x00025928
   25794:	0002591c 	.word	0x0002591c
   25798:	00025910 	.word	0x00025910
   2579c:	00025904 	.word	0x00025904
   257a0:	000258f8 	.word	0x000258f8
   257a4:	000258ec 	.word	0x000258ec
   257a8:	000258e0 	.word	0x000258e0
   257ac:	000258d4 	.word	0x000258d4
   257b0:	000258c8 	.word	0x000258c8
   257b4:	000258bc 	.word	0x000258bc
   257b8:	000258b0 	.word	0x000258b0
   257bc:	00025808 	.word	0x00025808
   257c0:	000258a4 	.word	0x000258a4
   257c4:	00025898 	.word	0x00025898
   257c8:	0002588c 	.word	0x0002588c
   257cc:	00025880 	.word	0x00025880
   257d0:	00025808 	.word	0x00025808
   257d4:	00025808 	.word	0x00025808
   257d8:	00025808 	.word	0x00025808
   257dc:	00025808 	.word	0x00025808
   257e0:	00025808 	.word	0x00025808
   257e4:	00025874 	.word	0x00025874
   257e8:	00025808 	.word	0x00025808
   257ec:	00025808 	.word	0x00025808
   257f0:	00025808 	.word	0x00025808
   257f4:	00025868 	.word	0x00025868
   257f8:	0002585c 	.word	0x0002585c
   257fc:	00025850 	.word	0x00025850
   25800:	00025844 	.word	0x00025844
   25804:	00025838 	.word	0x00025838
        break;
#endif
    default:
      if (!errptr)
        errptr = &_REENT_ERRNO(ptr);
      if ((error = _user_strerror (errnum, internal, errptr)) == 0)
   25808:	e3530000 	cmp	r3, #0
   2580c:	e1a01002 	mov	r1, r2
{
   25810:	e92d4010 	push	{r4, lr}
      if ((error = _user_strerror (errnum, internal, errptr)) == 0)
   25814:	11a02003 	movne	r2, r3
   25818:	01a02000 	moveq	r2, r0
   2581c:	e1a0000c 	mov	r0, ip
   25820:	eb000102 	bl	25c30 <_user_strerror>
        error = "";
   25824:	e3083d5c 	movw	r3, #36188	@ 0x8d5c
   25828:	e3500000 	cmp	r0, #0
   2582c:	e3403002 	movt	r3, #2
   25830:	01a00003 	moveq	r0, r3
      break;
    }

  return error;
}
   25834:	e8bd8010 	pop	{r4, pc}
        error = "Previous owner died";
   25838:	e3090a2c 	movw	r0, #39468	@ 0x9a2c
   2583c:	e3400002 	movt	r0, #2
        break;
   25840:	e12fff1e 	bx	lr
        error = "State not recoverable";
   25844:	e3090a14 	movw	r0, #39444	@ 0x9a14
   25848:	e3400002 	movt	r0, #2
        break;
   2584c:	e12fff1e 	bx	lr
        error = "Operation canceled";
   25850:	e3090a00 	movw	r0, #39424	@ 0x9a00
   25854:	e3400002 	movt	r0, #2
        break;
   25858:	e12fff1e 	bx	lr
      error = "Value too large for defined data type";
   2585c:	e3090a64 	movw	r0, #39524	@ 0x9a64
   25860:	e3400002 	movt	r0, #2
      break;
   25864:	e12fff1e 	bx	lr
      error = "Illegal byte sequence";
   25868:	e309075c 	movw	r0, #38748	@ 0x975c
   2586c:	e3400002 	movt	r0, #2
      break;
   25870:	e12fff1e 	bx	lr
      error = "Not supported";
   25874:	e3090694 	movw	r0, #38548	@ 0x9694
   25878:	e3400002 	movt	r0, #2
      break;
   2587c:	e12fff1e 	bx	lr
        error = "Socket is not connected";
   25880:	e30909cc 	movw	r0, #39372	@ 0x99cc
   25884:	e3400002 	movt	r0, #2
        break;
   25888:	e12fff1e 	bx	lr
        error = "Socket is already connected";
   2588c:	e30909e4 	movw	r0, #39396	@ 0x99e4
   25890:	e3400002 	movt	r0, #2
        break;
   25894:	e12fff1e 	bx	lr
      error = "Connection aborted by network";
   25898:	e30905d0 	movw	r0, #38352	@ 0x95d0
   2589c:	e3400002 	movt	r0, #2
      break;
   258a0:	e12fff1e 	bx	lr
      error = "Address not available";
   258a4:	e3090990 	movw	r0, #39312	@ 0x9990
   258a8:	e3400002 	movt	r0, #2
      break;
   258ac:	e12fff1e 	bx	lr
      error = "Unknown protocol";
   258b0:	e3090804 	movw	r0, #38916	@ 0x9804
   258b4:	e3400002 	movt	r0, #2
      break;
   258b8:	e12fff1e 	bx	lr
        error = "Message too long";
   258bc:	e3090a8c 	movw	r0, #39564	@ 0x9a8c
   258c0:	e3400002 	movt	r0, #2
        break;
   258c4:	e12fff1e 	bx	lr
      error = "Destination address required";
   258c8:	e3090498 	movw	r0, #38040	@ 0x9498
   258cc:	e3400002 	movt	r0, #2
      break;
   258d0:	e12fff1e 	bx	lr
      error = "Socket already connected";
   258d4:	e3090460 	movw	r0, #37984	@ 0x9460
   258d8:	e3400002 	movt	r0, #2
      break;
   258dc:	e12fff1e 	bx	lr
      error = "Connection already in progress";
   258e0:	e3090568 	movw	r0, #38248	@ 0x9568
   258e4:	e3400002 	movt	r0, #2
      break;
   258e8:	e12fff1e 	bx	lr
      error = "Host is unreachable";
   258ec:	e3090668 	movw	r0, #38504	@ 0x9668
   258f0:	e3400002 	movt	r0, #2
      break;
   258f4:	e12fff1e 	bx	lr
      error = "Host is down";
   258f8:	e3090558 	movw	r0, #38232	@ 0x9558
   258fc:	e3400002 	movt	r0, #2
      break;
   25900:	e12fff1e 	bx	lr
        error = "Connection timed out";
   25904:	e3090aa0 	movw	r0, #39584	@ 0x9aa0
   25908:	e3400002 	movt	r0, #2
        break;
   2590c:	e12fff1e 	bx	lr
      error = "Network interface is not configured";
   25910:	e30905ac 	movw	r0, #38316	@ 0x95ac
   25914:	e3400002 	movt	r0, #2
      break;
   25918:	e12fff1e 	bx	lr
      error = "Network is unreachable";
   2591c:	e3090780 	movw	r0, #38784	@ 0x9780
   25920:	e3400002 	movt	r0, #2
      break;
   25924:	e12fff1e 	bx	lr
      error = "Software caused connection abort";
   25928:	e30909a8 	movw	r0, #39336	@ 0x99a8
   2592c:	e3400002 	movt	r0, #2
      break;
   25930:	e12fff1e 	bx	lr
      error = "Address already in use";
   25934:	e3090978 	movw	r0, #39288	@ 0x9978
   25938:	e3400002 	movt	r0, #2
      break;
   2593c:	e12fff1e 	bx	lr
      error = "Connection refused";
   25940:	e3090948 	movw	r0, #39240	@ 0x9948
   25944:	e3400002 	movt	r0, #2
      break;
   25948:	e12fff1e 	bx	lr
      error = "Protocol not available";
   2594c:	e3090930 	movw	r0, #39216	@ 0x9930
   25950:	e3400002 	movt	r0, #2
      break;
   25954:	e12fff1e 	bx	lr
      error = "Socket operation on non-socket";
   25958:	e3090910 	movw	r0, #39184	@ 0x9910
   2595c:	e3400002 	movt	r0, #2
      break;
   25960:	e12fff1e 	bx	lr
      error = "Protocol wrong type for socket";
   25964:	e30908f0 	movw	r0, #39152	@ 0x98f0
   25968:	e3400002 	movt	r0, #2
      break;
   2596c:	e12fff1e 	bx	lr
      error = "Address family not supported by protocol family";
   25970:	e30908c0 	movw	r0, #39104	@ 0x98c0
   25974:	e3400002 	movt	r0, #2
      break;
   25978:	e12fff1e 	bx	lr
      error = "No buffer space available";
   2597c:	e309089c 	movw	r0, #39068	@ 0x989c
   25980:	e3400002 	movt	r0, #2
      break;
   25984:	e12fff1e 	bx	lr
      error = "Connection reset by peer";
   25988:	e309095c 	movw	r0, #39260	@ 0x995c
   2598c:	e3400002 	movt	r0, #2
      break;
   25990:	e12fff1e 	bx	lr
        error = "Operation not supported on socket";
   25994:	e3090a40 	movw	r0, #39488	@ 0x9a40
   25998:	e3400002 	movt	r0, #2
        break;
   2599c:	e12fff1e 	bx	lr
      error = "Too many symbolic links";
   259a0:	e3090884 	movw	r0, #39044	@ 0x9884
   259a4:	e3400002 	movt	r0, #2
      break;
   259a8:	e12fff1e 	bx	lr
      error = "File or path name too long";
   259ac:	e3090868 	movw	r0, #39016	@ 0x9868
   259b0:	e3400002 	movt	r0, #2
      break;
   259b4:	e12fff1e 	bx	lr
      error = "Directory not empty";
   259b8:	e3090854 	movw	r0, #38996	@ 0x9854
   259bc:	e3400002 	movt	r0, #2
      break;
   259c0:	e12fff1e 	bx	lr
      error = "Function not implemented";
   259c4:	e3090838 	movw	r0, #38968	@ 0x9838
   259c8:	e3400002 	movt	r0, #2
      break;
   259cc:	e12fff1e 	bx	lr
      error = "Bad message";
   259d0:	e309082c 	movw	r0, #38956	@ 0x982c
   259d4:	e3400002 	movt	r0, #2
      break;
   259d8:	e12fff1e 	bx	lr
      error = "Multihop attempted";
   259dc:	e3090818 	movw	r0, #38936	@ 0x9818
   259e0:	e3400002 	movt	r0, #2
      break;
   259e4:	e12fff1e 	bx	lr
      error = "Protocol error";
   259e8:	e30907f4 	movw	r0, #38900	@ 0x97f4
   259ec:	e3400002 	movt	r0, #2
      break;
   259f0:	e12fff1e 	bx	lr
      error = "Virtual circuit is gone";
   259f4:	e30907dc 	movw	r0, #38876	@ 0x97dc
   259f8:	e3400002 	movt	r0, #2
      break;
   259fc:	e12fff1e 	bx	lr
      error = "No stream resources";
   25a00:	e30907c8 	movw	r0, #38856	@ 0x97c8
   25a04:	e3400002 	movt	r0, #2
      break;
   25a08:	e12fff1e 	bx	lr
      error = "Stream ioctl timeout";
   25a0c:	e30907b0 	movw	r0, #38832	@ 0x97b0
   25a10:	e3400002 	movt	r0, #2
      break;
   25a14:	e12fff1e 	bx	lr
      error = "No data";
   25a18:	e30908b8 	movw	r0, #39096	@ 0x98b8
   25a1c:	e3400002 	movt	r0, #2
      break;
   25a20:	e12fff1e 	bx	lr
      error = "Not a stream";
   25a24:	e30907a0 	movw	r0, #38816	@ 0x97a0
   25a28:	e3400002 	movt	r0, #2
      break;
   25a2c:	e12fff1e 	bx	lr
      error = "No lock";
   25a30:	e3090798 	movw	r0, #38808	@ 0x9798
   25a34:	e3400002 	movt	r0, #2
      break;
   25a38:	e12fff1e 	bx	lr
      error = "Deadlock";
   25a3c:	e3090774 	movw	r0, #38772	@ 0x9774
   25a40:	e3400002 	movt	r0, #2
      break;
   25a44:	e12fff1e 	bx	lr
      error = "Identifier removed";
   25a48:	e3090748 	movw	r0, #38728	@ 0x9748
   25a4c:	e3400002 	movt	r0, #2
      break;
   25a50:	e12fff1e 	bx	lr
      error = "No message of desired type";
   25a54:	e309072c 	movw	r0, #38700	@ 0x972c
   25a58:	e3400002 	movt	r0, #2
      break;
   25a5c:	e12fff1e 	bx	lr
      error = "Result too large";
   25a60:	e3090718 	movw	r0, #38680	@ 0x9718
   25a64:	e3400002 	movt	r0, #2
      break;
   25a68:	e12fff1e 	bx	lr
      error = "Mathematics argument out of domain of function";
   25a6c:	e30906e8 	movw	r0, #38632	@ 0x96e8
   25a70:	e3400002 	movt	r0, #2
      break;
   25a74:	e12fff1e 	bx	lr
      error = "Broken pipe";
   25a78:	e30906dc 	movw	r0, #38620	@ 0x96dc
   25a7c:	e3400002 	movt	r0, #2
      break;
   25a80:	e12fff1e 	bx	lr
      error = "Too many links";
   25a84:	e30906cc 	movw	r0, #38604	@ 0x96cc
   25a88:	e3400002 	movt	r0, #2
      break;
   25a8c:	e12fff1e 	bx	lr
      error = "Read-only file system";
   25a90:	e30906b4 	movw	r0, #38580	@ 0x96b4
   25a94:	e3400002 	movt	r0, #2
      break;
   25a98:	e12fff1e 	bx	lr
      error = "Illegal seek";
   25a9c:	e30906a4 	movw	r0, #38564	@ 0x96a4
   25aa0:	e3400002 	movt	r0, #2
      break;
   25aa4:	e12fff1e 	bx	lr
      error = "No space left on device";
   25aa8:	e309067c 	movw	r0, #38524	@ 0x967c
   25aac:	e3400002 	movt	r0, #2
      break;
   25ab0:	e12fff1e 	bx	lr
      error = "File too large";
   25ab4:	e3090658 	movw	r0, #38488	@ 0x9658
   25ab8:	e3400002 	movt	r0, #2
      break;
   25abc:	e12fff1e 	bx	lr
      error = "Text file busy";
   25ac0:	e3090648 	movw	r0, #38472	@ 0x9648
   25ac4:	e3400002 	movt	r0, #2
      break;
   25ac8:	e12fff1e 	bx	lr
      error = "Not a character device";
   25acc:	e3090630 	movw	r0, #38448	@ 0x9630
   25ad0:	e3400002 	movt	r0, #2
      break;
   25ad4:	e12fff1e 	bx	lr
      error = "File descriptor value too large";
   25ad8:	e3090610 	movw	r0, #38416	@ 0x9610
   25adc:	e3400002 	movt	r0, #2
      break;
   25ae0:	e12fff1e 	bx	lr
      error = "Too many open files in system";
   25ae4:	e30905f0 	movw	r0, #38384	@ 0x95f0
   25ae8:	e3400002 	movt	r0, #2
      break;
   25aec:	e12fff1e 	bx	lr
      error = "Invalid argument";
   25af0:	e3090598 	movw	r0, #38296	@ 0x9598
   25af4:	e3400002 	movt	r0, #2
      break;
   25af8:	e12fff1e 	bx	lr
      error = "Is a directory";
   25afc:	e3090588 	movw	r0, #38280	@ 0x9588
   25b00:	e3400002 	movt	r0, #2
      break;
   25b04:	e12fff1e 	bx	lr
      error = "Not a directory";
   25b08:	e3090548 	movw	r0, #38216	@ 0x9548
   25b0c:	e3400002 	movt	r0, #2
      break;
   25b10:	e12fff1e 	bx	lr
      error = "No such device";
   25b14:	e3090538 	movw	r0, #38200	@ 0x9538
   25b18:	e3400002 	movt	r0, #2
      break;
   25b1c:	e12fff1e 	bx	lr
      error = "Cross-device link";
   25b20:	e3090524 	movw	r0, #38180	@ 0x9524
   25b24:	e3400002 	movt	r0, #2
      break;
   25b28:	e12fff1e 	bx	lr
      error = "File exists";
   25b2c:	e3090518 	movw	r0, #38168	@ 0x9518
   25b30:	e3400002 	movt	r0, #2
      break;
   25b34:	e12fff1e 	bx	lr
      error = "Device or resource busy";
   25b38:	e3090500 	movw	r0, #38144	@ 0x9500
   25b3c:	e3400002 	movt	r0, #2
      break;
   25b40:	e12fff1e 	bx	lr
      error = "Bad address";
   25b44:	e30904f4 	movw	r0, #38132	@ 0x94f4
   25b48:	e3400002 	movt	r0, #2
      break;
   25b4c:	e12fff1e 	bx	lr
      error = "Permission denied";
   25b50:	e30904e0 	movw	r0, #38112	@ 0x94e0
   25b54:	e3400002 	movt	r0, #2
      break;
   25b58:	e12fff1e 	bx	lr
      error = "Not enough space";
   25b5c:	e30904cc 	movw	r0, #38092	@ 0x94cc
   25b60:	e3400002 	movt	r0, #2
      break;
   25b64:	e12fff1e 	bx	lr
      error = "No more processes";
   25b68:	e30904b8 	movw	r0, #38072	@ 0x94b8
   25b6c:	e3400002 	movt	r0, #2
      break;
   25b70:	e12fff1e 	bx	lr
      error = "No children";
   25b74:	e309048c 	movw	r0, #38028	@ 0x948c
   25b78:	e3400002 	movt	r0, #2
      break;
   25b7c:	e12fff1e 	bx	lr
      error = "Bad file number";
   25b80:	e309047c 	movw	r0, #38012	@ 0x947c
   25b84:	e3400002 	movt	r0, #2
      break;
   25b88:	e12fff1e 	bx	lr
      error = "Exec format error";
   25b8c:	e309044c 	movw	r0, #37964	@ 0x944c
   25b90:	e3400002 	movt	r0, #2
      break;
   25b94:	e12fff1e 	bx	lr
      error = "Arg list too long";
   25b98:	e3090438 	movw	r0, #37944	@ 0x9438
   25b9c:	e3400002 	movt	r0, #2
      break;
   25ba0:	e12fff1e 	bx	lr
      error = "No such device or address";
   25ba4:	e309041c 	movw	r0, #37916	@ 0x941c
   25ba8:	e3400002 	movt	r0, #2
      break;
   25bac:	e12fff1e 	bx	lr
      error = "I/O error";
   25bb0:	e3090410 	movw	r0, #37904	@ 0x9410
   25bb4:	e3400002 	movt	r0, #2
      break;
   25bb8:	e12fff1e 	bx	lr
      error = "Interrupted system call";
   25bbc:	e30903f8 	movw	r0, #37880	@ 0x93f8
   25bc0:	e3400002 	movt	r0, #2
      break;
   25bc4:	e12fff1e 	bx	lr
      error = "No such process";
   25bc8:	e30903e8 	movw	r0, #37864	@ 0x93e8
   25bcc:	e3400002 	movt	r0, #2
      break;
   25bd0:	e12fff1e 	bx	lr
      error = "No such file or directory";
   25bd4:	e30903cc 	movw	r0, #37836	@ 0x93cc
   25bd8:	e3400002 	movt	r0, #2
      break;
   25bdc:	e12fff1e 	bx	lr
  switch (errnum)
   25be0:	e30903c0 	movw	r0, #37824	@ 0x93c0
   25be4:	e3400002 	movt	r0, #2
}
   25be8:	e12fff1e 	bx	lr
      error = "Success";
   25bec:	e30903b8 	movw	r0, #37816	@ 0x93b8
   25bf0:	e3400002 	movt	r0, #2
   25bf4:	e12fff1e 	bx	lr

00025bf8 <strerror>:

char *
strerror (int errnum)
{
  return _strerror_r (_REENT, errnum, 0, NULL);
   25bf8:	e30b21e8 	movw	r2, #45544	@ 0xb1e8
   25bfc:	e3a03000 	mov	r3, #0
   25c00:	e3402002 	movt	r2, #2
{
   25c04:	e1a01000 	mov	r1, r0
  return _strerror_r (_REENT, errnum, 0, NULL);
   25c08:	e5920000 	ldr	r0, [r2]
   25c0c:	e1a02003 	mov	r2, r3
   25c10:	eafffe69 	b	255bc <_strerror_r>

00025c14 <strerror_l>:

char *
strerror_l (int errnum, locale_t locale)
{
  /* We don't support per-locale error messages. */
  return _strerror_r (_REENT, errnum, 0, NULL);
   25c14:	e30b21e8 	movw	r2, #45544	@ 0xb1e8
   25c18:	e3a03000 	mov	r3, #0
   25c1c:	e3402002 	movt	r2, #2
{
   25c20:	e1a01000 	mov	r1, r0
  return _strerror_r (_REENT, errnum, 0, NULL);
   25c24:	e5920000 	ldr	r0, [r2]
   25c28:	e1a02003 	mov	r2, r3
   25c2c:	eafffe62 	b	255bc <_strerror_r>

00025c30 <_user_strerror>:
  (void) errnum;
  (void) internal;
  (void) errptr;

  return 0;
}
   25c30:	e3a00000 	mov	r0, #0
   25c34:	e12fff1e 	bx	lr

00025c38 <time>:
{
  struct timeval now;

  now.tv_sec = (time_t) -1;

  if (_gettimeofday_r (_REENT, &now, NULL) < 0)
   25c38:	e30b31e8 	movw	r3, #45544	@ 0xb1e8
{
   25c3c:	e92d4070 	push	{r4, r5, r6, lr}
  if (_gettimeofday_r (_REENT, &now, NULL) < 0)
   25c40:	e3403002 	movt	r3, #2
{
   25c44:	e24dd010 	sub	sp, sp, #16
  if (_gettimeofday_r (_REENT, &now, NULL) < 0)
   25c48:	e1a0100d 	mov	r1, sp
  now.tv_sec = (time_t) -1;
   25c4c:	e3e06000 	mvn	r6, #0
{
   25c50:	e1a04000 	mov	r4, r0
  if (_gettimeofday_r (_REENT, &now, NULL) < 0)
   25c54:	e3a02000 	mov	r2, #0
   25c58:	e5930000 	ldr	r0, [r3]
  now.tv_sec = (time_t) -1;
   25c5c:	e58d6000 	str	r6, [sp]
   25c60:	e58d6004 	str	r6, [sp, #4]
  if (_gettimeofday_r (_REENT, &now, NULL) < 0)
   25c64:	eb00000e 	bl	25ca4 <_gettimeofday_r>
   25c68:	e3500000 	cmp	r0, #0
    now.tv_sec = (time_t) -1;

  if (t)
    *t = now.tv_sec;
   25c6c:	a1cd00d0 	ldrdge	r0, [sp]
   25c70:	b1a05006 	movlt	r5, r6
   25c74:	b1a00006 	movlt	r0, r6
   25c78:	b1a01005 	movlt	r1, r5
  if (t)
   25c7c:	e3540000 	cmp	r4, #0
    *t = now.tv_sec;
   25c80:	11c400f0 	strdne	r0, [r4]
  return now.tv_sec;
}
   25c84:	e28dd010 	add	sp, sp, #16
   25c88:	e8bd8070 	pop	{r4, r5, r6, pc}

00025c8c <__messages_load_locale>:
    }
#else
  /* TODO */
#endif
  return ret;
}
   25c8c:	e3a00000 	mov	r0, #0
   25c90:	e12fff1e 	bx	lr

00025c94 <__numeric_load_locale>:
    }
#else
  /* TODO */
#endif
  return ret;
}
   25c94:	e3a00000 	mov	r0, #0
   25c98:	e12fff1e 	bx	lr

00025c9c <__monetary_load_locale>:
    }
#else
  /* TODO */
#endif
  return ret;
}
   25c9c:	e3a00000 	mov	r0, #0
   25ca0:	e12fff1e 	bx	lr

00025ca4 <_gettimeofday_r>:

int
_gettimeofday_r (struct _reent *ptr,
     struct timeval *ptimeval,
     void *ptimezone)
{
   25ca4:	e92d4070 	push	{r4, r5, r6, lr}
   25ca8:	e1a0e001 	mov	lr, r1
  int ret;

  errno = 0;
   25cac:	e30b4668 	movw	r4, #46696	@ 0xb668
   25cb0:	e3a0c000 	mov	ip, #0
{
   25cb4:	e1a05000 	mov	r5, r0
  errno = 0;
   25cb8:	e3404002 	movt	r4, #2
  if ((ret = _gettimeofday (ptimeval, ptimezone)) == -1 && errno != 0)
   25cbc:	e1a01002 	mov	r1, r2
   25cc0:	e1a0000e 	mov	r0, lr
  errno = 0;
   25cc4:	e584c000 	str	ip, [r4]
  if ((ret = _gettimeofday (ptimeval, ptimezone)) == -1 && errno != 0)
   25cc8:	eb00004d 	bl	25e04 <_gettimeofday>
   25ccc:	e3700001 	cmn	r0, #1
   25cd0:	18bd8070 	popne	{r4, r5, r6, pc}
   25cd4:	e5943000 	ldr	r3, [r4]
   25cd8:	e3530000 	cmp	r3, #0
    _REENT_ERRNO(ptr) = errno;
   25cdc:	15853000 	strne	r3, [r5]
  return ret;
}
   25ce0:	e8bd8070 	pop	{r4, r5, r6, pc}

00025ce4 <_isatty_r>:

int
_isatty_r (ptr, fd)
     struct _reent *ptr;
     int fd;
{
   25ce4:	e92d4070 	push	{r4, r5, r6, lr}
  int ret;

  errno = 0;
   25ce8:	e30b4668 	movw	r4, #46696	@ 0xb668
   25cec:	e3a02000 	mov	r2, #0
{
   25cf0:	e1a05000 	mov	r5, r0
  errno = 0;
   25cf4:	e3404002 	movt	r4, #2
  if ((ret = _isatty (fd)) == -1 && errno != 0)
   25cf8:	e1a00001 	mov	r0, r1
  errno = 0;
   25cfc:	e5842000 	str	r2, [r4]
  if ((ret = _isatty (fd)) == -1 && errno != 0)
   25d00:	eb000005 	bl	25d1c <_isatty>
   25d04:	e3700001 	cmn	r0, #1
   25d08:	18bd8070 	popne	{r4, r5, r6, pc}
   25d0c:	e5943000 	ldr	r3, [r4]
   25d10:	e3530000 	cmp	r3, #0
    _REENT_ERRNO(ptr) = errno;
   25d14:	15853000 	strne	r3, [r5]
  return ret;
}
   25d18:	e8bd8070 	pop	{r4, r5, r6, pc}

00025d1c <_isatty>:
#include <sys/stat.h>
#include <errno.h>

int
_isatty (int fd)
{
   25d1c:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
   25d20:	e24dd05c 	sub	sp, sp, #92	@ 0x5c
  struct stat buf;

  if (fstat (fd, &buf) < 0) {
   25d24:	e1a0100d 	mov	r1, sp
   25d28:	ebffe636 	bl	1f608 <fstat>
   25d2c:	e3500000 	cmp	r0, #0
   25d30:	ba00000a 	blt	25d60 <_isatty+0x44>
    errno = EBADF;
    return 0;
  }
  if (S_ISCHR (buf.st_mode))
   25d34:	e59d3004 	ldr	r3, [sp, #4]
   25d38:	e2033a0f 	and	r3, r3, #61440	@ 0xf000
   25d3c:	e3530a02 	cmp	r3, #8192	@ 0x2000
    return 1;
   25d40:	03a00001 	moveq	r0, #1
  if (S_ISCHR (buf.st_mode))
   25d44:	0a000003 	beq	25d58 <_isatty+0x3c>
  errno = ENOTTY;
   25d48:	ebffd6b1 	bl	1b814 <__errno>
   25d4c:	e3a03019 	mov	r3, #25
   25d50:	e5803000 	str	r3, [r0]
    return 0;
   25d54:	e3a00000 	mov	r0, #0
  return 0;
}
   25d58:	e28dd05c 	add	sp, sp, #92	@ 0x5c
   25d5c:	e49df004 	pop	{pc}		@ (ldr pc, [sp], #4)
    errno = EBADF;
   25d60:	ebffd6ab 	bl	1b814 <__errno>
   25d64:	e3a03009 	mov	r3, #9
   25d68:	e5803000 	str	r3, [r0]
    return 0;
   25d6c:	eafffff8 	b	25d54 <_isatty+0x38>

00025d70 <__chk_fail>:
#include <unistd.h>

void
__attribute__((__noreturn__))
__chk_fail(void)
{
   25d70:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
  char msg[] = "*** buffer overflow detected ***: terminated\n";
   25d74:	e309ead0 	movw	lr, #39632	@ 0x9ad0
   25d78:	e340e002 	movt	lr, #2
{
   25d7c:	e24dd034 	sub	sp, sp, #52	@ 0x34
  char msg[] = "*** buffer overflow detected ***: terminated\n";
   25d80:	e1a0c00d 	mov	ip, sp
   25d84:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
   25d88:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
   25d8c:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
   25d90:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
   25d94:	e89e000f 	ldm	lr, {r0, r1, r2, r3}
   25d98:	e8ac0007 	stmia	ip!, {r0, r1, r2}
  write (2, msg, strlen (msg));
   25d9c:	e1a0000d 	mov	r0, sp
  char msg[] = "*** buffer overflow detected ***: terminated\n";
   25da0:	e1cc30b0 	strh	r3, [ip]
  write (2, msg, strlen (msg));
   25da4:	faffe9b5 	blx	20480 <strlen>
   25da8:	e1a0100d 	mov	r1, sp
   25dac:	e1a02000 	mov	r2, r0
   25db0:	e3a00002 	mov	r0, #2
   25db4:	ebffe6fa 	bl	1f9a4 <write>
  raise (SIGABRT);
   25db8:	e3a00006 	mov	r0, #6
   25dbc:	ebffd41f 	bl	1ae40 <raise>
  _exit (127);
   25dc0:	e3a0007f 	mov	r0, #127	@ 0x7f
   25dc4:	ebffe63a 	bl	1f6b4 <_exit>

00025dc8 <clock_gettime>:
  register int32_t r2 asm("r2") = a3;
   25dc8:	e3a02000 	mov	r2, #0
#include <sys/syscall.h>
#include <sys/time.h>

int
clock_gettime(clockid_t clock_id, struct timespec *tp)
{
   25dcc:	e92d4070 	push	{r4, r5, r6, lr}
  register int32_t r3 asm("r3") = a4;
   25dd0:	e1a03002 	mov	r3, r2
  register int32_t r4 asm("r4") = a5;
   25dd4:	e1a04002 	mov	r4, r2
  register int32_t r5 asm("r5") = a6;
   25dd8:	e1a05002 	mov	r5, r2
  asm volatile("svc %1\n"
   25ddc:	ef00001b 	svc	0x0000001b
  if (r < 0) {
   25de0:	e2504000 	subs	r4, r0, #0
   25de4:	ba000001 	blt	25df0 <clock_gettime+0x28>
  return __syscall2(__SYS_CLOCK_TIME, clock_id, tp);
}
   25de8:	e1a00004 	mov	r0, r4
   25dec:	e8bd8070 	pop	{r4, r5, r6, pc}
    errno = -r;
   25df0:	ebffd687 	bl	1b814 <__errno>
   25df4:	e2643000 	rsb	r3, r4, #0
    return -1;
   25df8:	e3e04000 	mvn	r4, #0
    errno = -r;
   25dfc:	e5803000 	str	r3, [r0]
  return __syscall2(__SYS_CLOCK_TIME, clock_id, tp);
   25e00:	eafffff8 	b	25de8 <clock_gettime+0x20>

00025e04 <_gettimeofday>:
  register int32_t r2 asm("r2") = a3;
   25e04:	e3a02000 	mov	r2, #0

int
_gettimeofday (struct timeval *tp, void *tzp)
{
   25e08:	e92d4030 	push	{r4, r5, lr}
   25e0c:	e24dd014 	sub	sp, sp, #20
   25e10:	e1a0c000 	mov	ip, r0
  register int32_t r1 asm("r1") = a2;
   25e14:	e1a0100d 	mov	r1, sp
  register int32_t r0 asm("r0") = a1;
   25e18:	e3a00001 	mov	r0, #1
  register int32_t r3 asm("r3") = a4;
   25e1c:	e1a03002 	mov	r3, r2
  register int32_t r4 asm("r4") = a5;
   25e20:	e1a04002 	mov	r4, r2
  register int32_t r5 asm("r5") = a6;
   25e24:	e1a05002 	mov	r5, r2
  asm volatile("svc %1\n"
   25e28:	ef00001b 	svc	0x0000001b
  if (r < 0) {
   25e2c:	e2504000 	subs	r4, r0, #0
   25e30:	ba00000c 	blt	25e68 <_gettimeofday+0x64>
  (void) tzp;

  // TODO: replace by CLOCK_MONOTONIC
  ret = clock_gettime(CLOCK_REALTIME, &t);

  if (ret == 0) {
   25e34:	1a000008 	bne	25e5c <_gettimeofday+0x58>
    tp->tv_sec  = t.tv_sec;
    tp->tv_usec = t.tv_nsec / 1000;
   25e38:	e59d3008 	ldr	r3, [sp, #8]
   25e3c:	e3042dd3 	movw	r2, #19923	@ 0x4dd3
    tp->tv_sec  = t.tv_sec;
   25e40:	e1cd00d0 	ldrd	r0, [sp]
    tp->tv_usec = t.tv_nsec / 1000;
   25e44:	e3412062 	movt	r2, #4194	@ 0x1062
    tp->tv_sec  = t.tv_sec;
   25e48:	e1cc00f0 	strd	r0, [ip]
    tp->tv_usec = t.tv_nsec / 1000;
   25e4c:	e0c21392 	smull	r1, r2, r2, r3
   25e50:	e1a03fc3 	asr	r3, r3, #31
   25e54:	e0633342 	rsb	r3, r3, r2, asr #6
   25e58:	e58c3008 	str	r3, [ip, #8]
  }

  return ret;
}
   25e5c:	e1a00004 	mov	r0, r4
   25e60:	e28dd014 	add	sp, sp, #20
   25e64:	e8bd8030 	pop	{r4, r5, pc}
    errno = -r;
   25e68:	ebffd669 	bl	1b814 <__errno>
   25e6c:	e2643000 	rsb	r3, r4, #0
    return -1;
   25e70:	e3e04000 	mvn	r4, #0
    errno = -r;
   25e74:	e5803000 	str	r3, [r0]
  if (ret == 0) {
   25e78:	eafffff7 	b	25e5c <_gettimeofday+0x58>

00025e7c <gettimeofday>:
  register int32_t r2 asm("r2") = a3;
   25e7c:	e3a02000 	mov	r2, #0

int
gettimeofday (struct timeval *tp, void *tzp)
{
   25e80:	e92d4030 	push	{r4, r5, lr}
   25e84:	e24dd014 	sub	sp, sp, #20
   25e88:	e1a0c000 	mov	ip, r0
  register int32_t r1 asm("r1") = a2;
   25e8c:	e1a0100d 	mov	r1, sp
  register int32_t r0 asm("r0") = a1;
   25e90:	e3a00001 	mov	r0, #1
  register int32_t r3 asm("r3") = a4;
   25e94:	e1a03002 	mov	r3, r2
  register int32_t r4 asm("r4") = a5;
   25e98:	e1a04002 	mov	r4, r2
  register int32_t r5 asm("r5") = a6;
   25e9c:	e1a05002 	mov	r5, r2
  asm volatile("svc %1\n"
   25ea0:	ef00001b 	svc	0x0000001b
  if (r < 0) {
   25ea4:	e2504000 	subs	r4, r0, #0
   25ea8:	ba00000c 	blt	25ee0 <gettimeofday+0x64>
  if (ret == 0) {
   25eac:	1a000008 	bne	25ed4 <gettimeofday+0x58>
    tp->tv_usec = t.tv_nsec / 1000;
   25eb0:	e59d3008 	ldr	r3, [sp, #8]
   25eb4:	e3042dd3 	movw	r2, #19923	@ 0x4dd3
    tp->tv_sec  = t.tv_sec;
   25eb8:	e1cd00d0 	ldrd	r0, [sp]
    tp->tv_usec = t.tv_nsec / 1000;
   25ebc:	e3412062 	movt	r2, #4194	@ 0x1062
    tp->tv_sec  = t.tv_sec;
   25ec0:	e1cc00f0 	strd	r0, [ip]
    tp->tv_usec = t.tv_nsec / 1000;
   25ec4:	e0c21392 	smull	r1, r2, r2, r3
   25ec8:	e1a03fc3 	asr	r3, r3, #31
   25ecc:	e0633342 	rsb	r3, r3, r2, asr #6
   25ed0:	e58c3008 	str	r3, [ip, #8]
  return _gettimeofday(tp, tzp);
}
   25ed4:	e1a00004 	mov	r0, r4
   25ed8:	e28dd014 	add	sp, sp, #20
   25edc:	e8bd8030 	pop	{r4, r5, pc}
    errno = -r;
   25ee0:	ebffd64b 	bl	1b814 <__errno>
   25ee4:	e2643000 	rsb	r3, r4, #0
    return -1;
   25ee8:	e3e04000 	mvn	r4, #0
    errno = -r;
   25eec:	e5803000 	str	r3, [r0]
  if (ret == 0) {
   25ef0:	eafffff7 	b	25ed4 <gettimeofday+0x58>
   25ef4:	00000000 	andeq	r0, r0, r0

00025ef8 <quorem>:
  n = S->_wds;
#ifdef DEBUG
  /*debug*/ if (b->_wds > n)
    /*debug*/ Bug ("oversize b in quorem");
#endif
  if (b->_wds < n)
   25ef8:	e5903010 	ldr	r3, [r0, #16]
{
   25efc:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   25f00:	e24dd014 	sub	sp, sp, #20
  n = S->_wds;
   25f04:	e5915010 	ldr	r5, [r1, #16]
  if (b->_wds < n)
   25f08:	e1530005 	cmp	r3, r5
    return 0;
   25f0c:	b3a00000 	movlt	r0, #0
  if (b->_wds < n)
   25f10:	ba000065 	blt	260ac <quorem+0x1b4>
  sx = S->_x;
  sxe = sx + --n;
   25f14:	e2455001 	sub	r5, r5, #1
  sx = S->_x;
   25f18:	e2814014 	add	r4, r1, #20
  bx = b->_x;
   25f1c:	e2808014 	add	r8, r0, #20
  bxe = bx + n;
  q = *bxe / (*sxe + 1);	/* ensure q <= true quotient */
   25f20:	e794a105 	ldr	sl, [r4, r5, lsl #2]
   25f24:	e7986105 	ldr	r6, [r8, r5, lsl #2]
  sxe = sx + --n;
   25f28:	e1a02105 	lsl	r2, r5, #2
   25f2c:	e1a09000 	mov	r9, r0
  q = *bxe / (*sxe + 1);	/* ensure q <= true quotient */
   25f30:	e28aa001 	add	sl, sl, #1
  bxe = bx + n;
   25f34:	e0883002 	add	r3, r8, r2
  q = *bxe / (*sxe + 1);	/* ensure q <= true quotient */
   25f38:	e1a00006 	mov	r0, r6
   25f3c:	e1a0b001 	mov	fp, r1
   25f40:	e1a0100a 	mov	r1, sl
  sxe = sx + --n;
   25f44:	e0847002 	add	r7, r4, r2
  bxe = bx + n;
   25f48:	e1cd20f4 	strd	r2, [sp, #4]
  q = *bxe / (*sxe + 1);	/* ensure q <= true quotient */
   25f4c:	ebffc083 	bl	16160 <__udivsi3>
#ifdef DEBUG
  /*debug*/ if (q > 9)
    /*debug*/ Bug ("oversized quotient in quorem");
#endif
  if (q)
   25f50:	e156000a 	cmp	r6, sl
  q = *bxe / (*sxe + 1);	/* ensure q <= true quotient */
   25f54:	e1a06000 	mov	r6, r0
  if (q)
   25f58:	3a00002b 	bcc	2600c <quorem+0x114>
    {
      borrow = 0;
      carry = 0;
   25f5c:	e3a01000 	mov	r1, #0
  sx = S->_x;
   25f60:	e1a0a004 	mov	sl, r4
  bx = b->_x;
   25f64:	e1a0e008 	mov	lr, r8
      borrow = 0;
   25f68:	e1a03001 	mov	r3, r1
   25f6c:	e1a00001 	mov	r0, r1
   25f70:	e58d400c 	str	r4, [sp, #12]
      do
	{
#ifdef Pack_32
	  si = *sx++;
   25f74:	e49ac004 	ldr	ip, [sl], #4
	  ys = (si & 0xffff) * q + carry;
	  zs = (si >> 16) * q + (ys >> 16);
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   25f78:	e59e4000 	ldr	r4, [lr]
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  *bx++ = y & 0xffff;
#endif
	}
      while (sx <= sxe);
   25f7c:	e157000a 	cmp	r7, sl
	  ys = (si & 0xffff) * q + carry;
   25f80:	e6ff107c 	uxth	r1, ip
	  zs = (si >> 16) * q + (ys >> 16);
   25f84:	e1a0c82c 	lsr	ip, ip, #16
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   25f88:	e6ff2074 	uxth	r2, r4
	  ys = (si & 0xffff) * q + carry;
   25f8c:	e0210196 	mla	r1, r6, r1, r0
	  zs = (si >> 16) * q + (ys >> 16);
   25f90:	e1a00821 	lsr	r0, r1, #16
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   25f94:	e6ff1071 	uxth	r1, r1
	  zs = (si >> 16) * q + (ys >> 16);
   25f98:	e0200c96 	mla	r0, r6, ip, r0
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   25f9c:	e0422001 	sub	r2, r2, r1
   25fa0:	e0822003 	add	r2, r2, r3
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
   25fa4:	e6ff3070 	uxth	r3, r0
	  carry = zs >> 16;
   25fa8:	e1a00820 	lsr	r0, r0, #16
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
   25fac:	e0633842 	rsb	r3, r3, r2, asr #16
	  Storeinc (bx, z, y);
   25fb0:	e6ff2072 	uxth	r2, r2
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
   25fb4:	e0833824 	add	r3, r3, r4, lsr #16
	  Storeinc (bx, z, y);
   25fb8:	e1822803 	orr	r2, r2, r3, lsl #16
	  borrow = z >> 16;
   25fbc:	e1a03843 	asr	r3, r3, #16
	  Storeinc (bx, z, y);
   25fc0:	e48e2004 	str	r2, [lr], #4
      while (sx <= sxe);
   25fc4:	2affffea 	bcs	25f74 <quorem+0x7c>
      if (!*bxe)
   25fc8:	e59d2004 	ldr	r2, [sp, #4]
   25fcc:	e59d400c 	ldr	r4, [sp, #12]
   25fd0:	e7983002 	ldr	r3, [r8, r2]
   25fd4:	e3530000 	cmp	r3, #0
   25fd8:	1a00000b 	bne	2600c <quorem+0x114>
	{
	  bx = b->_x;
	  while (--bxe > bx && !*bxe)
   25fdc:	e59d3008 	ldr	r3, [sp, #8]
   25fe0:	e2433004 	sub	r3, r3, #4
   25fe4:	e1580003 	cmp	r8, r3
   25fe8:	3a000003 	bcc	25ffc <quorem+0x104>
   25fec:	ea000005 	b	26008 <quorem+0x110>
   25ff0:	e1580003 	cmp	r8, r3
	    --n;
   25ff4:	e2455001 	sub	r5, r5, #1
	  while (--bxe > bx && !*bxe)
   25ff8:	2a000002 	bcs	26008 <quorem+0x110>
   25ffc:	e4132004 	ldr	r2, [r3], #-4
   26000:	e3520000 	cmp	r2, #0
   26004:	0afffff9 	beq	25ff0 <quorem+0xf8>
	  b->_wds = n;
   26008:	e5895010 	str	r5, [r9, #16]
	}
    }
  if (cmp (b, S) >= 0)
   2600c:	e1a0100b 	mov	r1, fp
   26010:	e1a00009 	mov	r0, r9
   26014:	eb0006db 	bl	27b88 <__mcmp>
   26018:	e3500000 	cmp	r0, #0
   2601c:	ba000021 	blt	260a8 <quorem+0x1b0>
    {
      q++;
      borrow = 0;
   26020:	e3a02000 	mov	r2, #0
      carry = 0;
      bx = b->_x;
   26024:	e1a01008 	mov	r1, r8
      borrow = 0;
   26028:	e1a0c002 	mov	ip, r2
      sx = S->_x;
      do
	{
#ifdef Pack_32
	  si = *sx++;
   2602c:	e4940004 	ldr	r0, [r4], #4
	  ys = (si & 0xffff) + carry;
	  zs = (si >> 16) + (ys >> 16);
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   26030:	e5913000 	ldr	r3, [r1]
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  *bx++ = y & 0xffff;
#endif
	}
      while (sx <= sxe);
   26034:	e1570004 	cmp	r7, r4
	  ys = (si & 0xffff) + carry;
   26038:	e6ffe070 	uxth	lr, r0
	  zs = (si >> 16) + (ys >> 16);
   2603c:	e1a00820 	lsr	r0, r0, #16
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   26040:	e6ff2073 	uxth	r2, r3
   26044:	e042200e 	sub	r2, r2, lr
   26048:	e082200c 	add	r2, r2, ip
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
   2604c:	e0600842 	rsb	r0, r0, r2, asr #16
	  Storeinc (bx, z, y);
   26050:	e6ff2072 	uxth	r2, r2
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
   26054:	e0800823 	add	r0, r0, r3, lsr #16
	  Storeinc (bx, z, y);
   26058:	e1823800 	orr	r3, r2, r0, lsl #16
	  borrow = z >> 16;
   2605c:	e1a0c840 	asr	ip, r0, #16
	  Storeinc (bx, z, y);
   26060:	e4813004 	str	r3, [r1], #4
      while (sx <= sxe);
   26064:	2afffff0 	bcs	2602c <quorem+0x134>
      bx = b->_x;
      bxe = bx + n;
      if (!*bxe)
   26068:	e7982105 	ldr	r2, [r8, r5, lsl #2]
      bxe = bx + n;
   2606c:	e0883105 	add	r3, r8, r5, lsl #2
      if (!*bxe)
   26070:	e3520000 	cmp	r2, #0
   26074:	1a00000a 	bne	260a4 <quorem+0x1ac>
	{
	  while (--bxe > bx && !*bxe)
   26078:	e2433004 	sub	r3, r3, #4
   2607c:	e1530008 	cmp	r3, r8
   26080:	8a000003 	bhi	26094 <quorem+0x19c>
   26084:	ea000005 	b	260a0 <quorem+0x1a8>
   26088:	e1580003 	cmp	r8, r3
	    --n;
   2608c:	e2455001 	sub	r5, r5, #1
	  while (--bxe > bx && !*bxe)
   26090:	2a000002 	bcs	260a0 <quorem+0x1a8>
   26094:	e4132004 	ldr	r2, [r3], #-4
   26098:	e3520000 	cmp	r2, #0
   2609c:	0afffff9 	beq	26088 <quorem+0x190>
	  b->_wds = n;
   260a0:	e5895010 	str	r5, [r9, #16]
      q++;
   260a4:	e2866001 	add	r6, r6, #1
	}
    }
  return q;
   260a8:	e1a00006 	mov	r0, r6
}
   260ac:	e28dd014 	add	sp, sp, #20
   260b0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

000260b4 <_dtoa_r>:
	int mode,
	int ndigits,
	int *decpt,
	int *sign,
	char **rve)
{
   260b4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   260b8:	e1a04000 	mov	r4, r0
   260bc:	ed2d8b02 	vpush	{d8}
   260c0:	e24dd03c 	sub	sp, sp, #60	@ 0x3c
   260c4:	e58d1008 	str	r1, [sp, #8]
  char *s, *s0;

  d.d = _d;

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_RESULT(ptr))
   260c8:	e5901038 	ldr	r1, [r0, #56]	@ 0x38
{
   260cc:	e59d5068 	ldr	r5, [sp, #104]	@ 0x68
   260d0:	ec576b10 	vmov	r6, r7, d0
  if (_REENT_MP_RESULT(ptr))
   260d4:	e3510000 	cmp	r1, #0
{
   260d8:	e58d2014 	str	r2, [sp, #20]
   260dc:	e58d3010 	str	r3, [sp, #16]
  d.d = _d;
   260e0:	ed8d0b00 	vstr	d0, [sp]
  if (_REENT_MP_RESULT(ptr))
   260e4:	0a000007 	beq	26108 <_dtoa_r+0x54>
    {
      _REENT_MP_RESULT(ptr)->_k = _REENT_MP_RESULT_K(ptr);
   260e8:	e590203c 	ldr	r2, [r0, #60]	@ 0x3c
      _REENT_MP_RESULT(ptr)->_maxwds = 1 << _REENT_MP_RESULT_K(ptr);
   260ec:	e3a03001 	mov	r3, #1
      _REENT_MP_RESULT(ptr)->_k = _REENT_MP_RESULT_K(ptr);
   260f0:	e5812004 	str	r2, [r1, #4]
      _REENT_MP_RESULT(ptr)->_maxwds = 1 << _REENT_MP_RESULT_K(ptr);
   260f4:	e1a03213 	lsl	r3, r3, r2
   260f8:	e5813008 	str	r3, [r1, #8]
      Bfree (ptr, _REENT_MP_RESULT(ptr));
   260fc:	eb000499 	bl	27368 <_Bfree>
      _REENT_MP_RESULT(ptr) = 0;
   26100:	e3a03000 	mov	r3, #0
   26104:	e5843038 	str	r3, [r4, #56]	@ 0x38
    }

  if (word0 (d) & Sign_bit)
   26108:	e2578000 	subs	r8, r7, #0
    {
      /* set sign for everything, including 0's and NaNs */
      *sign = 1;
   2610c:	b3a03001 	movlt	r3, #1
      word0 (d) &= ~Sign_bit;	/* clear sign bit */
    }
  else
    *sign = 0;
   26110:	a3a03000 	movge	r3, #0
   26114:	e5853000 	str	r3, [r5]

#if defined(IEEE_Arith) + defined(VAX)
#ifdef IEEE_Arith
  if ((word0 (d) & Exp_mask) == Exp_mask)
   26118:	e3a03000 	mov	r3, #0
      word0 (d) &= ~Sign_bit;	/* clear sign bit */
   2611c:	b3c88102 	biclt	r8, r8, #-2147483648	@ 0x80000000
  if ((word0 (d) & Exp_mask) == Exp_mask)
   26120:	e3473ff0 	movt	r3, #32752	@ 0x7ff0
      word0 (d) &= ~Sign_bit;	/* clear sign bit */
   26124:	b58d8004 	strlt	r8, [sp, #4]
  if ((word0 (d) & Exp_mask) == Exp_mask)
   26128:	e1d33008 	bics	r3, r3, r8
   2612c:	0a00006e 	beq	262ec <_dtoa_r+0x238>
    }
#endif
#ifdef IBM
  d.d += 0;			/* normalize */
#endif
  if (!d.d)
   26130:	ed9d8b00 	vldr	d8, [sp]
   26134:	eeb58b40 	vcmp.f64	d8, #0.0
   26138:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   2613c:	1a00000d 	bne	26178 <_dtoa_r+0xc4>
    {
      *decpt = 1;
      s = "0";
      if (rve)
   26140:	e59d306c 	ldr	r3, [sp, #108]	@ 0x6c
	*rve = s + 1;
      return s;
   26144:	e30993b4 	movw	r9, #37812	@ 0x93b4
      *decpt = 1;
   26148:	e59d2010 	ldr	r2, [sp, #16]
      return s;
   2614c:	e3409002 	movt	r9, #2
      if (rve)
   26150:	e3530000 	cmp	r3, #0
      *decpt = 1;
   26154:	e3a03001 	mov	r3, #1
   26158:	e5823000 	str	r3, [r2]
	*rve = s + 1;
   2615c:	159f344c 	ldrne	r3, [pc, #1100]	@ 265b0 <_dtoa_r+0x4fc>
   26160:	159d206c 	ldrne	r2, [sp, #108]	@ 0x6c
   26164:	15823000 	strne	r3, [r2]
  *s = 0;
  *decpt = k + 1;
  if (rve)
    *rve = s;
  return s0;
}
   26168:	e1a00009 	mov	r0, r9
   2616c:	e28dd03c 	add	sp, sp, #60	@ 0x3c
   26170:	ecbd8b02 	vpop	{d8}
   26174:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  b = d2b (ptr, d.d, &be, &bbits);
   26178:	eeb00b48 	vmov.f64	d0, d8
   2617c:	e28d2030 	add	r2, sp, #48	@ 0x30
   26180:	e28d1034 	add	r1, sp, #52	@ 0x34
   26184:	e1a00004 	mov	r0, r4
   26188:	eb000765 	bl	27f24 <__d2b>
  if ((i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1))) != 0)
   2618c:	e1b0ca28 	lsrs	ip, r8, #20
  b = d2b (ptr, d.d, &be, &bbits);
   26190:	e1a05000 	mov	r5, r0
  if ((i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1))) != 0)
   26194:	1a000066 	bne	26334 <_dtoa_r+0x280>
      i = bbits + be + (Bias + (P - 1) - 1);
   26198:	e59d1030 	ldr	r1, [sp, #48]	@ 0x30
      denorm = 1;
   2619c:	e3a07001 	mov	r7, #1
      i = bbits + be + (Bias + (P - 1) - 1);
   261a0:	e59dc034 	ldr	ip, [sp, #52]	@ 0x34
   261a4:	e081c00c 	add	ip, r1, ip
   261a8:	e28c2e43 	add	r2, ip, #1072	@ 0x430
   261ac:	e2822002 	add	r2, r2, #2
       : (word1 (d) << (32 - i));
   261b0:	e3520020 	cmp	r2, #32
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
   261b4:	c28c3e41 	addgt	r3, ip, #1040	@ 0x410
   261b8:	c2622040 	rsbgt	r2, r2, #64	@ 0x40
   261bc:	c2833002 	addgt	r3, r3, #2
       : (word1 (d) << (32 - i));
   261c0:	d2622020 	rsble	r2, r2, #32
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
   261c4:	c1a03336 	lsrgt	r3, r6, r3
       : (word1 (d) << (32 - i));
   261c8:	d1a03216 	lslle	r3, r6, r2
   261cc:	c1833218 	orrgt	r3, r3, r8, lsl r2
      i -= (Bias + (P - 1) - 1) + 1;
   261d0:	e24cc001 	sub	ip, ip, #1
       : (word1 (d) << (32 - i));
   261d4:	ee073a10 	vmov	s14, r3
      d2.d = x;
   261d8:	eeb87b47 	vcvt.f64.u32	d7, s14
      word0 (d2) -= 31 * Exp_msk1;	/* adjust exponent */
   261dc:	ee170a90 	vmov	r0, s15
      d2.d = x;
   261e0:	ec532b17 	vmov	r2, r3, d7
      word0 (d2) -= 31 * Exp_msk1;	/* adjust exponent */
   261e4:	e240361f 	sub	r3, r0, #32505856	@ 0x1f00000
  ds = (d2.d - 1.5) * 0.289529654602168 + 0.1760912590558 + i * 0.301029995663981;
   261e8:	ed9f6be0 	vldr	d6, [pc, #896]	@ 26570 <_dtoa_r+0x4bc>
   261ec:	ec432b17 	vmov	d7, r2, r3
   261f0:	ed9f4be0 	vldr	d4, [pc, #896]	@ 26578 <_dtoa_r+0x4c4>
   261f4:	ed9f5be1 	vldr	d5, [pc, #900]	@ 26580 <_dtoa_r+0x4cc>
   261f8:	ee376b46 	vsub.f64	d6, d7, d6
   261fc:	ed9f7be1 	vldr	d7, [pc, #900]	@ 26588 <_dtoa_r+0x4d4>
   26200:	ee067b04 	vmla.f64	d7, d6, d4
   26204:	ee06ca90 	vmov	s13, ip
   26208:	eeb86be6 	vcvt.f64.s32	d6, s13
   2620c:	ee067b05 	vmla.f64	d7, d6, d5
  k = (int) ds;
   26210:	eefd6bc7 	vcvt.s32.f64	s13, d7
  if (ds < 0. && ds != k)
   26214:	eeb57bc0 	vcmpe.f64	d7, #0.0
   26218:	eef1fa10 	vmrs	APSR_nzcv, fpscr
  k = (int) ds;
   2621c:	ee16aa90 	vmov	sl, s13
  if (ds < 0. && ds != k)
   26220:	5a000003 	bpl	26234 <_dtoa_r+0x180>
   26224:	eeb86be6 	vcvt.f64.s32	d6, s13
   26228:	eeb46b47 	vcmp.f64	d6, d7
   2622c:	eef1fa10 	vmrs	APSR_nzcv, fpscr
    k--;			/* want k = floor(ds) */
   26230:	124aa001 	subne	sl, sl, #1
  if (k >= 0 && k <= Ten_pmax)
   26234:	e35a0016 	cmp	sl, #22
  j = bbits - i - 1;
   26238:	e041300c 	sub	r3, r1, ip
   2623c:	e2439001 	sub	r9, r3, #1
  if (k >= 0 && k <= Ten_pmax)
   26240:	8a000105 	bhi	2665c <_dtoa_r+0x5a8>
      if (d.d < tens[k])
   26244:	e30a2118 	movw	r2, #41240	@ 0xa118
   26248:	e3402002 	movt	r2, #2
   2624c:	e082218a 	add	r2, r2, sl, lsl #3
   26250:	ed927b00 	vldr	d7, [r2]
   26254:	eeb48bc7 	vcmpe.f64	d8, d7
   26258:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   2625c:	5a000045 	bpl	26378 <_dtoa_r+0x2c4>
	k--;
   26260:	e24aa001 	sub	sl, sl, #1
      k_check = 0;
   26264:	e3a02000 	mov	r2, #0
   26268:	e58d2024 	str	r2, [sp, #36]	@ 0x24
  if (j >= 0)
   2626c:	e3590000 	cmp	r9, #0
      b2 = -j;
   26270:	b2633001 	rsblt	r3, r3, #1
      b2 = 0;
   26274:	a3a03000 	movge	r3, #0
      s2 = 0;
   26278:	b3a09000 	movlt	r9, #0
      b2 = -j;
   2627c:	b58d3018 	strlt	r3, [sp, #24]
      b2 = 0;
   26280:	a58d3018 	strge	r3, [sp, #24]
  if (k >= 0)
   26284:	e35a0000 	cmp	sl, #0
   26288:	aa00003f 	bge	2638c <_dtoa_r+0x2d8>
      b2 -= k;
   2628c:	e59d3018 	ldr	r3, [sp, #24]
      b5 = -k;
   26290:	e58da01c 	str	sl, [sp, #28]
      b2 -= k;
   26294:	e043300a 	sub	r3, r3, sl
   26298:	e58d3018 	str	r3, [sp, #24]
      b5 = -k;
   2629c:	e26a3000 	rsb	r3, sl, #0
   262a0:	e58d300c 	str	r3, [sp, #12]
      s5 = 0;
   262a4:	e3a0a000 	mov	sl, #0
  if (mode < 0 || mode > 9)
   262a8:	e59d3008 	ldr	r3, [sp, #8]
   262ac:	e3530009 	cmp	r3, #9
   262b0:	8a00003c 	bhi	263a8 <_dtoa_r+0x2f4>
  if (mode > 5)
   262b4:	e3530005 	cmp	r3, #5
  try_quick = 1;
   262b8:	d3a06001 	movle	r6, #1
      try_quick = 0;
   262bc:	c3a06000 	movgt	r6, #0
      mode -= 4;
   262c0:	c2433004 	subgt	r3, r3, #4
   262c4:	c58d3008 	strgt	r3, [sp, #8]
  switch (mode)
   262c8:	e59d3008 	ldr	r3, [sp, #8]
   262cc:	e2433002 	sub	r3, r3, #2
   262d0:	e3530003 	cmp	r3, #3
   262d4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   262d8:	ea0003e1 	b	27264 <_dtoa_r+0x11b0>
   262dc:	00026bd8 	.word	0x00026bd8
   262e0:	00026bcc 	.word	0x00026bcc
   262e4:	00026ba0 	.word	0x00026ba0
   262e8:	00026b40 	.word	0x00026b40
      *decpt = 9999;
   262ec:	e59d2010 	ldr	r2, [sp, #16]
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
   262f0:	e7f38058 	ubfx	r8, r8, #0, #20
   262f4:	e1988006 	orrs	r8, r8, r6
      *decpt = 9999;
   262f8:	e302370f 	movw	r3, #9999	@ 0x270f
   262fc:	e5823000 	str	r3, [r2]
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
   26300:	0a000015 	beq	2635c <_dtoa_r+0x2a8>
      if (rve)
   26304:	e59d306c 	ldr	r3, [sp, #108]	@ 0x6c
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
   26308:	e3099b0c 	movw	r9, #39692	@ 0x9b0c
   2630c:	e3409002 	movt	r9, #2
      if (rve)
   26310:	e3530000 	cmp	r3, #0
   26314:	0affff93 	beq	26168 <_dtoa_r+0xb4>
	  s[3] ? s + 8 :
   26318:	e2893003 	add	r3, r9, #3
	*rve =
   2631c:	e59d206c 	ldr	r2, [sp, #108]	@ 0x6c
}
   26320:	e1a00009 	mov	r0, r9
	*rve =
   26324:	e5823000 	str	r3, [r2]
}
   26328:	e28dd03c 	add	sp, sp, #60	@ 0x3c
   2632c:	ecbd8b02 	vpop	{d8}
   26330:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
      word0 (d2) &= Frac_mask1;
   26334:	ee180a90 	vmov	r0, s17
      i -= Bias;
   26338:	e24ccfff 	sub	ip, ip, #1020	@ 0x3fc
      word0 (d2) &= Frac_mask1;
   2633c:	e7f30050 	ubfx	r0, r0, #0, #20
      d2.d = d.d;
   26340:	ec532b18 	vmov	r2, r3, d8
      word0 (d2) |= Exp_11;
   26344:	e38035ff 	orr	r3, r0, #1069547520	@ 0x3fc00000
      i = bbits + be + (Bias + (P - 1) - 1);
   26348:	e59d1030 	ldr	r1, [sp, #48]	@ 0x30
      i -= Bias;
   2634c:	e24cc003 	sub	ip, ip, #3
      denorm = 0;
   26350:	e3a07000 	mov	r7, #0
      word0 (d2) |= Exp_11;
   26354:	e3833603 	orr	r3, r3, #3145728	@ 0x300000
      denorm = 0;
   26358:	eaffffa2 	b	261e8 <_dtoa_r+0x134>
      if (rve)
   2635c:	e59d306c 	ldr	r3, [sp, #108]	@ 0x6c
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
   26360:	e3099b00 	movw	r9, #39680	@ 0x9b00
   26364:	e3409002 	movt	r9, #2
      if (rve)
   26368:	e3530000 	cmp	r3, #0
	  s[3] ? s + 8 :
   2636c:	12893008 	addne	r3, r9, #8
      if (rve)
   26370:	1affffe9 	bne	2631c <_dtoa_r+0x268>
   26374:	eaffff7b 	b	26168 <_dtoa_r+0xb4>
  if (j >= 0)
   26378:	e3530000 	cmp	r3, #0
   2637c:	da000335 	ble	27058 <_dtoa_r+0xfa4>
      k_check = 0;
   26380:	e3a03000 	mov	r3, #0
   26384:	e58d3024 	str	r3, [sp, #36]	@ 0x24
      b2 = 0;
   26388:	e58d3018 	str	r3, [sp, #24]
      b5 = 0;
   2638c:	e3a03000 	mov	r3, #0
      s2 += k;
   26390:	e089900a 	add	r9, r9, sl
      b5 = 0;
   26394:	e58d300c 	str	r3, [sp, #12]
  if (mode < 0 || mode > 9)
   26398:	e59d3008 	ldr	r3, [sp, #8]
   2639c:	e58da01c 	str	sl, [sp, #28]
   263a0:	e3530009 	cmp	r3, #9
   263a4:	9affffc2 	bls	262b4 <_dtoa_r+0x200>
  ilim = ilim1 = -1;
   263a8:	e3e0b000 	mvn	fp, #0
    mode = 0;
   263ac:	e3a03000 	mov	r3, #0
  try_quick = 1;
   263b0:	e3a06001 	mov	r6, #1
    mode = 0;
   263b4:	e58d3008 	str	r3, [sp, #8]
  leftright = 1;
   263b8:	e58d6020 	str	r6, [sp, #32]
      ndigits = 0;
   263bc:	e58d3014 	str	r3, [sp, #20]
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   263c0:	e3a01000 	mov	r1, #0
   263c4:	e58db028 	str	fp, [sp, #40]	@ 0x28
   263c8:	e584103c 	str	r1, [r4, #60]	@ 0x3c
  _REENT_MP_RESULT(ptr) = eBalloc (ptr, _REENT_MP_RESULT_K(ptr));
   263cc:	e1a00004 	mov	r0, r4
   263d0:	eb0003c2 	bl	272e0 <_Balloc>
   263d4:	e2508000 	subs	r8, r0, #0
   263d8:	0a0003a8 	beq	27280 <_dtoa_r+0x11cc>
  if (ilim >= 0 && ilim <= Quick_max && try_quick)
   263dc:	e35b000e 	cmp	fp, #14
   263e0:	83a06000 	movhi	r6, #0
   263e4:	92066001 	andls	r6, r6, #1
  _REENT_MP_RESULT(ptr) = eBalloc (ptr, _REENT_MP_RESULT_K(ptr));
   263e8:	e5848038 	str	r8, [r4, #56]	@ 0x38
  if (ilim >= 0 && ilim <= Quick_max && try_quick)
   263ec:	e3560000 	cmp	r6, #0
   263f0:	0a000080 	beq	265f8 <_dtoa_r+0x544>
      if (k > 0)
   263f4:	e59d101c 	ldr	r1, [sp, #28]
   263f8:	e3510000 	cmp	r1, #0
   263fc:	da000099 	ble	26668 <_dtoa_r+0x5b4>
	  ds = tens[k & 0xf];
   26400:	e30a3118 	movw	r3, #41240	@ 0xa118
	  if (j & Bletch)
   26404:	e3110c01 	tst	r1, #256	@ 0x100
	  ds = tens[k & 0xf];
   26408:	e201200f 	and	r2, r1, #15
   2640c:	e3403002 	movt	r3, #2
   26410:	e0833182 	add	r3, r3, r2, lsl #3
	      d.d /= bigtens[n_bigtens - 1];
   26414:	130a2208 	movwne	r2, #41480	@ 0xa208
   26418:	13402002 	movtne	r2, #2
   2641c:	0eb05b48 	vmoveq.f64	d5, d8
   26420:	1d927b08 	vldrne	d7, [r2, #32]
	  ds = tens[k & 0xf];
   26424:	ed936b00 	vldr	d6, [r3]
	  j = k >> 4;
   26428:	e1a03241 	asr	r3, r1, #4
	      ieps++;
   2642c:	13a01003 	movne	r1, #3
	      j &= Bletch - 1;
   26430:	1203300f 	andne	r3, r3, #15
      ieps = 2;			/* conservative */
   26434:	03a01002 	moveq	r1, #2
	      d.d /= bigtens[n_bigtens - 1];
   26438:	1e885b07 	vdivne.f64	d5, d8, d7
	  for (; j; j >>= 1, i++)
   2643c:	e3530000 	cmp	r3, #0
   26440:	0a000008 	beq	26468 <_dtoa_r+0x3b4>
   26444:	e30a2208 	movw	r2, #41480	@ 0xa208
   26448:	e3402002 	movt	r2, #2
	    if (j & 1)
   2644c:	e3130001 	tst	r3, #1
	  for (; j; j >>= 1, i++)
   26450:	e2822008 	add	r2, r2, #8
		ds *= bigtens[i];
   26454:	1d127b02 	vldrne	d7, [r2, #-8]
		ieps++;
   26458:	12811001 	addne	r1, r1, #1
		ds *= bigtens[i];
   2645c:	1e266b07 	vmulne.f64	d6, d6, d7
	  for (; j; j >>= 1, i++)
   26460:	e1b030c3 	asrs	r3, r3, #1
   26464:	1afffff8 	bne	2644c <_dtoa_r+0x398>
	  d.d /= ds;
   26468:	ee857b06 	vdiv.f64	d7, d5, d6
      if (k_check && d.d < 1. && ilim > 0)
   2646c:	e59d3024 	ldr	r3, [sp, #36]	@ 0x24
   26470:	e3530000 	cmp	r3, #0
   26474:	0a000003 	beq	26488 <_dtoa_r+0x3d4>
   26478:	ed9f6b44 	vldr	d6, [pc, #272]	@ 26590 <_dtoa_r+0x4dc>
   2647c:	eeb47bc6 	vcmpe.f64	d7, d6
   26480:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   26484:	4a0002e0 	bmi	2700c <_dtoa_r+0xf58>
      eps.d = ieps * d.d + 7.;
   26488:	ee061a90 	vmov	s13, r1
      if (ilim == 0)
   2648c:	e35b0000 	cmp	fp, #0
      eps.d = ieps * d.d + 7.;
   26490:	eeb85be6 	vcvt.f64.s32	d5, s13
   26494:	ed9f6b3f 	vldr	d6, [pc, #252]	@ 26598 <_dtoa_r+0x4e4>
   26498:	ee056b07 	vmla.f64	d6, d5, d7
      word0 (eps) -= (P - 1) * Exp_msk1;
   2649c:	ee161a90 	vmov	r1, s13
      eps.d = ieps * d.d + 7.;
   264a0:	ec532b16 	vmov	r2, r3, d6
      word0 (eps) -= (P - 1) * Exp_msk1;
   264a4:	e241350d 	sub	r3, r1, #54525952	@ 0x3400000
      if (ilim == 0)
   264a8:	0a000048 	beq	265d0 <_dtoa_r+0x51c>
   264ac:	e59d601c 	ldr	r6, [sp, #28]
   264b0:	e1a0100b 	mov	r1, fp
	      L = d.d;
   264b4:	eefd6bc7 	vcvt.s32.f64	s13, d7
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
   264b8:	e30a0118 	movw	r0, #41240	@ 0xa118
   264bc:	ec432b14 	vmov	d4, r2, r3
   264c0:	e3400002 	movt	r0, #2
      if (leftright)
   264c4:	e59d3020 	ldr	r3, [sp, #32]
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
   264c8:	e0802181 	add	r2, r0, r1, lsl #3
	      d.d -= L;
   264cc:	eeb85be6 	vcvt.f64.s32	d5, s13
      if (leftright)
   264d0:	e3530000 	cmp	r3, #0
	      *s++ = '0' + (int) L;
   264d4:	ee163a90 	vmov	r3, s13
   264d8:	e2833030 	add	r3, r3, #48	@ 0x30
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
   264dc:	ed126b02 	vldr	d6, [r2, #-8]
	      *s++ = '0' + (int) L;
   264e0:	e6ef3073 	uxtb	r3, r3
   264e4:	e2882001 	add	r2, r8, #1
	      d.d -= L;
   264e8:	ee377b45 	vsub.f64	d7, d7, d5
	      *s++ = '0' + (int) L;
   264ec:	e5c83000 	strb	r3, [r8]
      if (leftright)
   264f0:	0a0001bb 	beq	26be4 <_dtoa_r+0xb30>
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
   264f4:	ed9f3b29 	vldr	d3, [pc, #164]	@ 265a0 <_dtoa_r+0x4ec>
   264f8:	ee835b06 	vdiv.f64	d5, d3, d6
   264fc:	ee355b44 	vsub.f64	d5, d5, d4
	      if (d.d < eps.d)
   26500:	eeb45bc7 	vcmpe.f64	d5, d7
   26504:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   26508:	ca00021b 	bgt	26d7c <_dtoa_r+0xcc8>
	      if (1. - d.d < eps.d)
   2650c:	ed9f2b1f 	vldr	d2, [pc, #124]	@ 26590 <_dtoa_r+0x4dc>
	  for (i = 0;;)
   26510:	e3a00000 	mov	r0, #0
	      eps.d *= 10.;
   26514:	ed9f4b23 	vldr	d4, [pc, #140]	@ 265a8 <_dtoa_r+0x4f4>
   26518:	ea00000d 	b	26554 <_dtoa_r+0x4a0>
	      if (++i >= ilim)
   2651c:	e2800001 	add	r0, r0, #1
   26520:	e1500001 	cmp	r0, r1
   26524:	aa000033 	bge	265f8 <_dtoa_r+0x544>
	      d.d *= 10.;
   26528:	ee277b04 	vmul.f64	d7, d7, d4
	      eps.d *= 10.;
   2652c:	ee255b04 	vmul.f64	d5, d5, d4
	      L = d.d;
   26530:	eefd6bc7 	vcvt.s32.f64	s13, d7
	      d.d -= L;
   26534:	eeb83be6 	vcvt.f64.s32	d3, s13
	      *s++ = '0' + (int) L;
   26538:	ee163a90 	vmov	r3, s13
   2653c:	e2833030 	add	r3, r3, #48	@ 0x30
   26540:	e4c23001 	strb	r3, [r2], #1
	      d.d -= L;
   26544:	ee377b43 	vsub.f64	d7, d7, d3
	      if (d.d < eps.d)
   26548:	eeb47bc5 	vcmpe.f64	d7, d5
   2654c:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   26550:	4a000209 	bmi	26d7c <_dtoa_r+0xcc8>
	      if (1. - d.d < eps.d)
   26554:	ee326b47 	vsub.f64	d6, d2, d7
   26558:	eeb46bc5 	vcmpe.f64	d6, d5
   2655c:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   26560:	5affffed 	bpl	2651c <_dtoa_r+0x468>
	      *s++ = '0' + (int) L;
   26564:	e1a01002 	mov	r1, r2
   26568:	ea0001f5 	b	26d44 <_dtoa_r+0xc90>
   2656c:	e320f000 	nop	{0}
   26570:	00000000 	.word	0x00000000
   26574:	3ff80000 	.word	0x3ff80000
   26578:	636f4361 	.word	0x636f4361
   2657c:	3fd287a7 	.word	0x3fd287a7
   26580:	509f79fb 	.word	0x509f79fb
   26584:	3fd34413 	.word	0x3fd34413
   26588:	8b60c8b3 	.word	0x8b60c8b3
   2658c:	3fc68a28 	.word	0x3fc68a28
   26590:	00000000 	.word	0x00000000
   26594:	3ff00000 	.word	0x3ff00000
   26598:	00000000 	.word	0x00000000
   2659c:	401c0000 	.word	0x401c0000
   265a0:	00000000 	.word	0x00000000
   265a4:	3fe00000 	.word	0x3fe00000
   265a8:	00000000 	.word	0x00000000
   265ac:	40240000 	.word	0x40240000
   265b0:	000293b5 	.word	0x000293b5
      eps.d = ieps * d.d + 7.;
   265b4:	ee061a90 	vmov	s13, r1
   265b8:	ed9f5bb6 	vldr	d5, [pc, #728]	@ 26898 <_dtoa_r+0x7e4>
   265bc:	eeb86be6 	vcvt.f64.s32	d6, s13
   265c0:	ee065b07 	vmla.f64	d5, d6, d7
      word0 (eps) -= (P - 1) * Exp_msk1;
   265c4:	ee151a90 	vmov	r1, s11
      eps.d = ieps * d.d + 7.;
   265c8:	ec532b15 	vmov	r2, r3, d5
      word0 (eps) -= (P - 1) * Exp_msk1;
   265cc:	e241350d 	sub	r3, r1, #54525952	@ 0x3400000
	  d.d -= 5.;
   265d0:	ed9f6bb2 	vldr	d6, [pc, #712]	@ 268a0 <_dtoa_r+0x7ec>
	  if (d.d > eps.d)
   265d4:	ec432b15 	vmov	d5, r2, r3
	  d.d -= 5.;
   265d8:	ee377b46 	vsub.f64	d7, d7, d6
	  if (d.d > eps.d)
   265dc:	eeb47bc5 	vcmpe.f64	d7, d5
   265e0:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   265e4:	ca0002ad 	bgt	270a0 <_dtoa_r+0xfec>
	  if (d.d < -eps.d)
   265e8:	eeb15b45 	vneg.f64	d5, d5
   265ec:	eeb47bc5 	vcmpe.f64	d7, d5
   265f0:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   265f4:	4a00010f 	bmi	26a38 <_dtoa_r+0x984>
  if (be >= 0 && k <= Int_max)
   265f8:	e59d3034 	ldr	r3, [sp, #52]	@ 0x34
   265fc:	e59d101c 	ldr	r1, [sp, #28]
   26600:	e1e02003 	mvn	r2, r3
   26604:	e1a02fa2 	lsr	r2, r2, #31
   26608:	e351000e 	cmp	r1, #14
   2660c:	c3a02000 	movgt	r2, #0
   26610:	e3520000 	cmp	r2, #0
   26614:	1a0000f6 	bne	269f4 <_dtoa_r+0x940>
  if (leftright)
   26618:	e59d1020 	ldr	r1, [sp, #32]
   2661c:	e3510000 	cmp	r1, #0
   26620:	0a00002d 	beq	266dc <_dtoa_r+0x628>
      if (mode < 2)
   26624:	e59d1008 	ldr	r1, [sp, #8]
   26628:	e3510001 	cmp	r1, #1
   2662c:	da00028e 	ble	2706c <_dtoa_r+0xfb8>
	  if (m5 >= j)
   26630:	e59d100c 	ldr	r1, [sp, #12]
	  j = ilim - 1;
   26634:	e24b3001 	sub	r3, fp, #1
	  if (m5 >= j)
   26638:	e1510003 	cmp	r1, r3
   2663c:	ba00020b 	blt	26e70 <_dtoa_r+0xdbc>
	  if ((i = ilim) < 0)
   26640:	e35b0000 	cmp	fp, #0
	    m5 -= j;
   26644:	e0413003 	sub	r3, r1, r3
   26648:	e58d302c 	str	r3, [sp, #44]	@ 0x2c
	  if ((i = ilim) < 0)
   2664c:	aa0002d8 	bge	271b4 <_dtoa_r+0x1100>
	      m2 -= i;
   26650:	e59d3018 	ldr	r3, [sp, #24]
   26654:	e043600b 	sub	r6, r3, fp
	      i = 0;
   26658:	ea00020e 	b	26e98 <_dtoa_r+0xde4>
  k_check = 1;
   2665c:	e3a02001 	mov	r2, #1
   26660:	e58d2024 	str	r2, [sp, #36]	@ 0x24
   26664:	eaffff00 	b	2626c <_dtoa_r+0x1b8>
      else if ((j1 = -k) != 0)
   26668:	0eb07b48 	vmoveq.f64	d7, d8
      ieps = 2;			/* conservative */
   2666c:	03a01002 	moveq	r1, #2
      else if ((j1 = -k) != 0)
   26670:	0affff7d 	beq	2646c <_dtoa_r+0x3b8>
   26674:	e59d301c 	ldr	r3, [sp, #28]
	  d.d *= tens[j1 & 0xf];
   26678:	e30a2118 	movw	r2, #41240	@ 0xa118
   2667c:	e3402002 	movt	r2, #2
      else if ((j1 = -k) != 0)
   26680:	e2633000 	rsb	r3, r3, #0
	  d.d *= tens[j1 & 0xf];
   26684:	e203100f 	and	r1, r3, #15
	  for (j = j1 >> 4; j; j >>= 1, i++)
   26688:	e1b03243 	asrs	r3, r3, #4
	  d.d *= tens[j1 & 0xf];
   2668c:	e0822181 	add	r2, r2, r1, lsl #3
   26690:	ed925b00 	vldr	d5, [r2]
   26694:	ee285b05 	vmul.f64	d5, d8, d5
	  for (j = j1 >> 4; j; j >>= 1, i++)
   26698:	eeb07b45 	vmov.f64	d7, d5
   2669c:	0a0002e3 	beq	27230 <_dtoa_r+0x117c>
   266a0:	e30a2208 	movw	r2, #41480	@ 0xa208
   266a4:	e3a00000 	mov	r0, #0
   266a8:	e3402002 	movt	r2, #2
      ieps = 2;			/* conservative */
   266ac:	e3a01002 	mov	r1, #2
	    if (j & 1)
   266b0:	e3130001 	tst	r3, #1
	  for (j = j1 >> 4; j; j >>= 1, i++)
   266b4:	e2822008 	add	r2, r2, #8
		d.d *= bigtens[i];
   266b8:	1d126b02 	vldrne	d6, [r2, #-8]
		ieps++;
   266bc:	12811001 	addne	r1, r1, #1
		d.d *= bigtens[i];
   266c0:	11a00006 	movne	r0, r6
   266c4:	1e277b06 	vmulne.f64	d7, d7, d6
	  for (j = j1 >> 4; j; j >>= 1, i++)
   266c8:	e1b030c3 	asrs	r3, r3, #1
   266cc:	1afffff7 	bne	266b0 <_dtoa_r+0x5fc>
   266d0:	e3500000 	cmp	r0, #0
   266d4:	0eb07b45 	vmoveq.f64	d7, d5
   266d8:	eaffff63 	b	2646c <_dtoa_r+0x3b8>
  m2 = b2;
   266dc:	e59d6018 	ldr	r6, [sp, #24]
   266e0:	e3a07000 	mov	r7, #0
  m5 = b5;
   266e4:	e59d300c 	ldr	r3, [sp, #12]
  m2 = b2;
   266e8:	e58d7020 	str	r7, [sp, #32]
  m5 = b5;
   266ec:	e58d302c 	str	r3, [sp, #44]	@ 0x2c
  if (m2 > 0 && s2 > 0)
   266f0:	e3560000 	cmp	r6, #0
   266f4:	c3590000 	cmpgt	r9, #0
   266f8:	da000007 	ble	2671c <_dtoa_r+0x668>
      i = m2 < s2 ? m2 : s2;
   266fc:	e1560009 	cmp	r6, r9
      b2 -= i;
   26700:	e59d2018 	ldr	r2, [sp, #24]
      i = m2 < s2 ? m2 : s2;
   26704:	b1a03006 	movlt	r3, r6
   26708:	a1a03009 	movge	r3, r9
      m2 -= i;
   2670c:	e0466003 	sub	r6, r6, r3
      s2 -= i;
   26710:	e0499003 	sub	r9, r9, r3
      b2 -= i;
   26714:	e0422003 	sub	r2, r2, r3
   26718:	e58d2018 	str	r2, [sp, #24]
  if (b5 > 0)
   2671c:	e59d300c 	ldr	r3, [sp, #12]
   26720:	e3530000 	cmp	r3, #0
   26724:	0a00000a 	beq	26754 <_dtoa_r+0x6a0>
      if (leftright)
   26728:	e59d3020 	ldr	r3, [sp, #32]
   2672c:	e3530000 	cmp	r3, #0
   26730:	0a000002 	beq	26740 <_dtoa_r+0x68c>
	  if (m5 > 0)
   26734:	e59d302c 	ldr	r3, [sp, #44]	@ 0x2c
   26738:	e3530000 	cmp	r3, #0
   2673c:	1a0001e6 	bne	26edc <_dtoa_r+0xe28>
	b = pow5mult (ptr, b, b5);
   26740:	e1a01005 	mov	r1, r5
   26744:	e59d200c 	ldr	r2, [sp, #12]
   26748:	e1a00004 	mov	r0, r4
   2674c:	eb000476 	bl	2792c <__pow5mult>
   26750:	e1a05000 	mov	r5, r0
  S = i2b (ptr, 1);
   26754:	e3a01001 	mov	r1, #1
   26758:	e1a00004 	mov	r0, r4
   2675c:	eb0003c8 	bl	27684 <__i2b>
  if (s5 > 0)
   26760:	e35a0000 	cmp	sl, #0
  S = i2b (ptr, 1);
   26764:	e58d000c 	str	r0, [sp, #12]
  if (s5 > 0)
   26768:	1a0000b6 	bne	26a48 <_dtoa_r+0x994>
  if (mode < 2)
   2676c:	e59d3008 	ldr	r3, [sp, #8]
   26770:	e3530001 	cmp	r3, #1
   26774:	da0000dc 	ble	26aec <_dtoa_r+0xa38>
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0x1f) != 0)
   26778:	e3a03001 	mov	r3, #1
   2677c:	e0893003 	add	r3, r9, r3
   26780:	e213301f 	ands	r3, r3, #31
   26784:	0a000041 	beq	26890 <_dtoa_r+0x7dc>
    i = 32 - i;
   26788:	e2632020 	rsb	r2, r3, #32
  if (i > 4)
   2678c:	e3520004 	cmp	r2, #4
      i -= 4;
   26790:	c263301c 	rsbgt	r3, r3, #28
  if (i > 4)
   26794:	da000153 	ble	26ce8 <_dtoa_r+0xc34>
      b2 += i;
   26798:	e59d2018 	ldr	r2, [sp, #24]
      m2 += i;
   2679c:	e0866003 	add	r6, r6, r3
      s2 += i;
   267a0:	e0899003 	add	r9, r9, r3
      b2 += i;
   267a4:	e0822003 	add	r2, r2, r3
   267a8:	e58d2018 	str	r2, [sp, #24]
  if (b2 > 0)
   267ac:	e59d3018 	ldr	r3, [sp, #24]
   267b0:	e3530000 	cmp	r3, #0
   267b4:	da000004 	ble	267cc <_dtoa_r+0x718>
    b = lshift (ptr, b, b2);
   267b8:	e1a01005 	mov	r1, r5
   267bc:	e1a02003 	mov	r2, r3
   267c0:	e1a00004 	mov	r0, r4
   267c4:	eb00049f 	bl	27a48 <__lshift>
   267c8:	e1a05000 	mov	r5, r0
  if (s2 > 0)
   267cc:	e3590000 	cmp	r9, #0
   267d0:	da000004 	ble	267e8 <_dtoa_r+0x734>
    S = lshift (ptr, S, s2);
   267d4:	e59d100c 	ldr	r1, [sp, #12]
   267d8:	e1a02009 	mov	r2, r9
   267dc:	e1a00004 	mov	r0, r4
   267e0:	eb000498 	bl	27a48 <__lshift>
   267e4:	e58d000c 	str	r0, [sp, #12]
  if (ilim <= 0 && mode > 2)
   267e8:	e59d3008 	ldr	r3, [sp, #8]
   267ec:	e3530002 	cmp	r3, #2
  if (k_check)
   267f0:	e59d3024 	ldr	r3, [sp, #36]	@ 0x24
  if (ilim <= 0 && mode > 2)
   267f4:	d3a09000 	movle	r9, #0
   267f8:	c3a09001 	movgt	r9, #1
  if (k_check)
   267fc:	e3530000 	cmp	r3, #0
   26800:	1a0000a0 	bne	26a88 <_dtoa_r+0x9d4>
  if (ilim <= 0 && mode > 2)
   26804:	e35b0000 	cmp	fp, #0
   26808:	c3a03000 	movgt	r3, #0
   2680c:	d2093001 	andle	r3, r9, #1
   26810:	e3530000 	cmp	r3, #0
   26814:	0a000027 	beq	268b8 <_dtoa_r+0x804>
      if (ilim < 0 || cmp (b, S = multadd (ptr, S, 5, 0)) <= 0)
   26818:	e35b0000 	cmp	fp, #0
   2681c:	0a000134 	beq	26cf4 <_dtoa_r+0xc40>
	  k = -1 - ndigits;
   26820:	e59d3014 	ldr	r3, [sp, #20]
	  goto ret;
   26824:	e1a09008 	mov	r9, r8
	  k = -1 - ndigits;
   26828:	e1e06003 	mvn	r6, r3
  Bfree (ptr, S);
   2682c:	e59d100c 	ldr	r1, [sp, #12]
   26830:	e1a00004 	mov	r0, r4
   26834:	eb0002cb 	bl	27368 <_Bfree>
  if (mhi)
   26838:	e3570000 	cmp	r7, #0
   2683c:	0a000002 	beq	2684c <_dtoa_r+0x798>
      Bfree (ptr, mhi);
   26840:	e1a01007 	mov	r1, r7
   26844:	e1a00004 	mov	r0, r4
   26848:	eb0002c6 	bl	27368 <_Bfree>
  Bfree (ptr, b);
   2684c:	e1a01005 	mov	r1, r5
   26850:	e1a00004 	mov	r0, r4
   26854:	eb0002c3 	bl	27368 <_Bfree>
  if (rve)
   26858:	e59d306c 	ldr	r3, [sp, #108]	@ 0x6c
  *decpt = k + 1;
   2685c:	e2866001 	add	r6, r6, #1
  if (rve)
   26860:	e3530000 	cmp	r3, #0
  *s = 0;
   26864:	e3a03000 	mov	r3, #0
   26868:	e5c83000 	strb	r3, [r8]
  *decpt = k + 1;
   2686c:	e59d3010 	ldr	r3, [sp, #16]
   26870:	e5836000 	str	r6, [r3]
  if (rve)
   26874:	0afffe3b 	beq	26168 <_dtoa_r+0xb4>
    *rve = s;
   26878:	e59d306c 	ldr	r3, [sp, #108]	@ 0x6c
}
   2687c:	e1a00009 	mov	r0, r9
    *rve = s;
   26880:	e5838000 	str	r8, [r3]
}
   26884:	e28dd03c 	add	sp, sp, #60	@ 0x3c
   26888:	ecbd8b02 	vpop	{d8}
   2688c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
   26890:	e3a0301c 	mov	r3, #28
   26894:	eaffffbf 	b	26798 <_dtoa_r+0x6e4>
   26898:	00000000 	.word	0x00000000
   2689c:	401c0000 	.word	0x401c0000
   268a0:	00000000 	.word	0x00000000
   268a4:	40140000 	.word	0x40140000
   268a8:	00000000 	.word	0x00000000
   268ac:	3fe00000 	.word	0x3fe00000
   268b0:	00000000 	.word	0x00000000
   268b4:	40240000 	.word	0x40240000
  if (leftright)
   268b8:	e59d3020 	ldr	r3, [sp, #32]
   268bc:	e3530000 	cmp	r3, #0
   268c0:	0a000130 	beq	26d88 <_dtoa_r+0xcd4>
      if (m2 > 0)
   268c4:	e3560000 	cmp	r6, #0
   268c8:	da000004 	ble	268e0 <_dtoa_r+0x82c>
	mhi = lshift (ptr, mhi, m2);
   268cc:	e1a01007 	mov	r1, r7
   268d0:	e1a02006 	mov	r2, r6
   268d4:	e1a00004 	mov	r0, r4
   268d8:	eb00045a 	bl	27a48 <__lshift>
   268dc:	e1a07000 	mov	r7, r0
      if (spec_case)
   268e0:	e35a0000 	cmp	sl, #0
   268e4:	01a0a007 	moveq	sl, r7
   268e8:	1a000207 	bne	2710c <_dtoa_r+0x1058>
   268ec:	e2483001 	sub	r3, r8, #1
   268f0:	e1a06008 	mov	r6, r8
   268f4:	e083300b 	add	r3, r3, fp
	      && !(word1 (d) & 1)
   268f8:	e58d8024 	str	r8, [sp, #36]	@ 0x24
   268fc:	e58d3018 	str	r3, [sp, #24]
   26900:	e59d3000 	ldr	r3, [sp]
   26904:	e2033001 	and	r3, r3, #1
   26908:	e58d3020 	str	r3, [sp, #32]
	  dig = quorem (b, S) + '0';
   2690c:	e59d100c 	ldr	r1, [sp, #12]
   26910:	e1a00005 	mov	r0, r5
   26914:	ebfffd77 	bl	25ef8 <quorem>
	  j = cmp (b, mlo);
   26918:	e1a01007 	mov	r1, r7
	  dig = quorem (b, S) + '0';
   2691c:	e1a0b000 	mov	fp, r0
	  j = cmp (b, mlo);
   26920:	e1a00005 	mov	r0, r5
	  dig = quorem (b, S) + '0';
   26924:	e28b8030 	add	r8, fp, #48	@ 0x30
	  j = cmp (b, mlo);
   26928:	eb000496 	bl	27b88 <__mcmp>
	  delta = diff (ptr, S, mhi);
   2692c:	e59d100c 	ldr	r1, [sp, #12]
	  j = cmp (b, mlo);
   26930:	e1a09000 	mov	r9, r0
	  delta = diff (ptr, S, mhi);
   26934:	e1a0200a 	mov	r2, sl
   26938:	e1a00004 	mov	r0, r4
   2693c:	eb0004a8 	bl	27be4 <__mdiff>
	  j1 = delta->_sign ? 1 : cmp (b, delta);
   26940:	e590300c 	ldr	r3, [r0, #12]
	  delta = diff (ptr, S, mhi);
   26944:	e1a01000 	mov	r1, r0
	  j1 = delta->_sign ? 1 : cmp (b, delta);
   26948:	e3530000 	cmp	r3, #0
   2694c:	1a000175 	bne	26f28 <_dtoa_r+0xe74>
   26950:	e58d0014 	str	r0, [sp, #20]
   26954:	e1a00005 	mov	r0, r5
   26958:	eb00048a 	bl	27b88 <__mcmp>
	  Bfree (ptr, delta);
   2695c:	e59d1014 	ldr	r1, [sp, #20]
	  j1 = delta->_sign ? 1 : cmp (b, delta);
   26960:	e58d0014 	str	r0, [sp, #20]
	  Bfree (ptr, delta);
   26964:	e1a00004 	mov	r0, r4
   26968:	eb00027e 	bl	27368 <_Bfree>
	  if (j1 == 0 && !mode && !(word1 (d) & 1))
   2696c:	e59d3008 	ldr	r3, [sp, #8]
   26970:	e59d2014 	ldr	r2, [sp, #20]
   26974:	e1933002 	orrs	r3, r3, r2
   26978:	1a00018f 	bne	26fbc <_dtoa_r+0xf08>
   2697c:	e59d3020 	ldr	r3, [sp, #32]
   26980:	e3530000 	cmp	r3, #0
   26984:	0a000213 	beq	271d8 <_dtoa_r+0x1124>
         if ((j < 0) || ((j == 0) && !mode
   26988:	e3590000 	cmp	r9, #0
   2698c:	ba00020e 	blt	271cc <_dtoa_r+0x1118>
	  if (i == ilim)
   26990:	e59d3018 	ldr	r3, [sp, #24]
   26994:	e1530006 	cmp	r3, r6
	  *s++ = dig;
   26998:	e4c68001 	strb	r8, [r6], #1
	  if (i == ilim)
   2699c:	0a0001fa 	beq	2718c <_dtoa_r+0x10d8>
	  b = multadd (ptr, b, 10, 0);
   269a0:	e1a01005 	mov	r1, r5
   269a4:	e3a03000 	mov	r3, #0
   269a8:	e3a0200a 	mov	r2, #10
   269ac:	e1a00004 	mov	r0, r4
   269b0:	eb000273 	bl	27384 <__multadd>
	  if (mlo == mhi)
   269b4:	e157000a 	cmp	r7, sl
	  b = multadd (ptr, b, 10, 0);
   269b8:	e1a05000 	mov	r5, r0
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
   269bc:	e1a01007 	mov	r1, r7
   269c0:	e3a03000 	mov	r3, #0
   269c4:	e3a0200a 	mov	r2, #10
   269c8:	e1a00004 	mov	r0, r4
	  if (mlo == mhi)
   269cc:	0a000176 	beq	26fac <_dtoa_r+0xef8>
	      mlo = multadd (ptr, mlo, 10, 0);
   269d0:	eb00026b 	bl	27384 <__multadd>
	      mhi = multadd (ptr, mhi, 10, 0);
   269d4:	e1a0100a 	mov	r1, sl
	      mlo = multadd (ptr, mlo, 10, 0);
   269d8:	e1a07000 	mov	r7, r0
	      mhi = multadd (ptr, mhi, 10, 0);
   269dc:	e3a03000 	mov	r3, #0
   269e0:	e3a0200a 	mov	r2, #10
   269e4:	e1a00004 	mov	r0, r4
   269e8:	eb000265 	bl	27384 <__multadd>
   269ec:	e1a0a000 	mov	sl, r0
	  dig = quorem (b, S) + '0';
   269f0:	eaffffc5 	b	2690c <_dtoa_r+0x858>
      ds = tens[k];
   269f4:	e30a3118 	movw	r3, #41240	@ 0xa118
      if (ndigits < 0 && ilim <= 0)
   269f8:	e59d2014 	ldr	r2, [sp, #20]
      ds = tens[k];
   269fc:	e3403002 	movt	r3, #2
      if (ndigits < 0 && ilim <= 0)
   26a00:	e35b0000 	cmp	fp, #0
      ds = tens[k];
   26a04:	e0833181 	add	r3, r3, r1, lsl #3
   26a08:	ed936b00 	vldr	d6, [r3]
      if (ndigits < 0 && ilim <= 0)
   26a0c:	c3a03000 	movgt	r3, #0
   26a10:	d3a03001 	movle	r3, #1
   26a14:	e0133fa2 	ands	r3, r3, r2, lsr #31
   26a18:	0a00012c 	beq	26ed0 <_dtoa_r+0xe1c>
	  if (ilim < 0 || d.d <= 5 * ds)
   26a1c:	e35b0000 	cmp	fp, #0
   26a20:	1a000004 	bne	26a38 <_dtoa_r+0x984>
   26a24:	ed1f7b63 	vldr	d7, [pc, #-396]	@ 268a0 <_dtoa_r+0x7ec>
   26a28:	ee267b07 	vmul.f64	d7, d6, d7
   26a2c:	eeb48bc7 	vcmpe.f64	d8, d7
   26a30:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   26a34:	8a000199 	bhi	270a0 <_dtoa_r+0xfec>
	  S = mhi = 0;
   26a38:	e3a03000 	mov	r3, #0
   26a3c:	e1a07003 	mov	r7, r3
   26a40:	e58d300c 	str	r3, [sp, #12]
   26a44:	eaffff75 	b	26820 <_dtoa_r+0x76c>
    S = pow5mult (ptr, S, s5);
   26a48:	e1a01000 	mov	r1, r0
   26a4c:	e1a0200a 	mov	r2, sl
   26a50:	e1a00004 	mov	r0, r4
   26a54:	eb0003b4 	bl	2792c <__pow5mult>
  if (mode < 2)
   26a58:	e59d3008 	ldr	r3, [sp, #8]
    S = pow5mult (ptr, S, s5);
   26a5c:	e58d000c 	str	r0, [sp, #12]
  if (mode < 2)
   26a60:	e3530001 	cmp	r3, #1
   26a64:	da000110 	ble	26eac <_dtoa_r+0xdf8>
  spec_case = 0;
   26a68:	e3a0a000 	mov	sl, #0
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0x1f) != 0)
   26a6c:	e59d200c 	ldr	r2, [sp, #12]
   26a70:	e5923010 	ldr	r3, [r2, #16]
   26a74:	e0823103 	add	r3, r2, r3, lsl #2
   26a78:	e5930010 	ldr	r0, [r3, #16]
   26a7c:	eb0002c1 	bl	27588 <__hi0bits>
   26a80:	e2603020 	rsb	r3, r0, #32
   26a84:	eaffff3c 	b	2677c <_dtoa_r+0x6c8>
      if (cmp (b, S) < 0)
   26a88:	e59d100c 	ldr	r1, [sp, #12]
   26a8c:	e1a00005 	mov	r0, r5
   26a90:	eb00043c 	bl	27b88 <__mcmp>
   26a94:	e3500000 	cmp	r0, #0
   26a98:	aaffff59 	bge	26804 <_dtoa_r+0x750>
	  k--;
   26a9c:	e59d301c 	ldr	r3, [sp, #28]
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
   26aa0:	e1a01005 	mov	r1, r5
   26aa4:	e3a0200a 	mov	r2, #10
   26aa8:	e1a00004 	mov	r0, r4
	  k--;
   26aac:	e2433001 	sub	r3, r3, #1
   26ab0:	e58d301c 	str	r3, [sp, #28]
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
   26ab4:	e3a03000 	mov	r3, #0
   26ab8:	eb000231 	bl	27384 <__multadd>
	  if (leftright)
   26abc:	e59d3020 	ldr	r3, [sp, #32]
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
   26ac0:	e1a05000 	mov	r5, r0
	  if (leftright)
   26ac4:	e3530000 	cmp	r3, #0
   26ac8:	1a0001cb 	bne	271fc <_dtoa_r+0x1148>
  if (ilim <= 0 && mode > 2)
   26acc:	e59db028 	ldr	fp, [sp, #40]	@ 0x28
   26ad0:	e35b0000 	cmp	fp, #0
   26ad4:	c3a06000 	movgt	r6, #0
   26ad8:	d2096001 	andle	r6, r9, #1
   26adc:	e3560000 	cmp	r6, #0
   26ae0:	0a0000a8 	beq	26d88 <_dtoa_r+0xcd4>
	  ilim = ilim1;
   26ae4:	e59db028 	ldr	fp, [sp, #40]	@ 0x28
   26ae8:	eaffff4a 	b	26818 <_dtoa_r+0x764>
      if (!word1 (d) && !(word0 (d) & Bndry_mask)
   26aec:	e59d3000 	ldr	r3, [sp]
   26af0:	e3530000 	cmp	r3, #0
   26af4:	1affff1f 	bne	26778 <_dtoa_r+0x6c4>
   26af8:	e1cd00d0 	ldrd	r0, [sp]
   26afc:	e7f33051 	ubfx	r3, r1, #0, #20
   26b00:	e1a02001 	mov	r2, r1
   26b04:	e3530000 	cmp	r3, #0
   26b08:	1affff1a 	bne	26778 <_dtoa_r+0x6c4>
	  && word0 (d) & Exp_mask
   26b0c:	e3a03000 	mov	r3, #0
   26b10:	e3473ff0 	movt	r3, #32752	@ 0x7ff0
   26b14:	e0033002 	and	r3, r3, r2
   26b18:	e3530000 	cmp	r3, #0
	  b2 += Log2P;
   26b1c:	159d3018 	ldrne	r3, [sp, #24]
	  s2 += Log2P;
   26b20:	12899001 	addne	r9, r9, #1
	  b2 += Log2P;
   26b24:	12833001 	addne	r3, r3, #1
   26b28:	158d3018 	strne	r3, [sp, #24]
	  spec_case = 1;
   26b2c:	13a03001 	movne	r3, #1
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0x1f) != 0)
   26b30:	e35a0000 	cmp	sl, #0
   26b34:	e1a0a003 	mov	sl, r3
   26b38:	0affff0e 	beq	26778 <_dtoa_r+0x6c4>
   26b3c:	eaffffca 	b	26a6c <_dtoa_r+0x9b8>
  leftright = 1;
   26b40:	e3a03001 	mov	r3, #1
   26b44:	e58d3020 	str	r3, [sp, #32]
      i = ndigits + k + 1;
   26b48:	e59d3014 	ldr	r3, [sp, #20]
   26b4c:	e59d201c 	ldr	r2, [sp, #28]
   26b50:	e0833002 	add	r3, r3, r2
   26b54:	e283b001 	add	fp, r3, #1
   26b58:	e58d3028 	str	r3, [sp, #40]	@ 0x28
      if (i <= 0)
   26b5c:	e35b0001 	cmp	fp, #1
   26b60:	a1a0c00b 	movge	ip, fp
   26b64:	b3a0c001 	movlt	ip, #1
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   26b68:	e35c0017 	cmp	ip, #23
   26b6c:	d3a01000 	movle	r1, #0
   26b70:	d584103c 	strle	r1, [r4, #60]	@ 0x3c
   26b74:	dafffe14 	ble	263cc <_dtoa_r+0x318>
   26b78:	e3a02001 	mov	r2, #1
  j = sizeof (__ULong);
   26b7c:	e3a03004 	mov	r3, #4
       j <<= 1)
   26b80:	e1a03083 	lsl	r3, r3, #1
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   26b84:	e1a01002 	mov	r1, r2
   26b88:	e2822001 	add	r2, r2, #1
   26b8c:	e2830014 	add	r0, r3, #20
   26b90:	e150000c 	cmp	r0, ip
   26b94:	9afffff9 	bls	26b80 <_dtoa_r+0xacc>
   26b98:	e584103c 	str	r1, [r4, #60]	@ 0x3c
   26b9c:	eafffe0a 	b	263cc <_dtoa_r+0x318>
  leftright = 1;
   26ba0:	e3a03001 	mov	r3, #1
   26ba4:	e58d3020 	str	r3, [sp, #32]
      if (ndigits <= 0)
   26ba8:	e59dc014 	ldr	ip, [sp, #20]
   26bac:	e35c0000 	cmp	ip, #0
   26bb0:	c1a0b00c 	movgt	fp, ip
   26bb4:	c58dc028 	strgt	ip, [sp, #40]	@ 0x28
   26bb8:	caffffea 	bgt	26b68 <_dtoa_r+0xab4>
	ndigits = 1;
   26bbc:	e3a03001 	mov	r3, #1
   26bc0:	e1a0b003 	mov	fp, r3
   26bc4:	e58d3014 	str	r3, [sp, #20]
   26bc8:	eafffdfc 	b	263c0 <_dtoa_r+0x30c>
  switch (mode)
   26bcc:	e3a03000 	mov	r3, #0
   26bd0:	e58d3020 	str	r3, [sp, #32]
   26bd4:	eaffffdb 	b	26b48 <_dtoa_r+0xa94>
   26bd8:	e3a03000 	mov	r3, #0
   26bdc:	e58d3020 	str	r3, [sp, #32]
   26be0:	eafffff0 	b	26ba8 <_dtoa_r+0xaf4>
	      if (i == ilim)
   26be4:	e3510001 	cmp	r1, #1
	  eps.d *= tens[ilim - 1];
   26be8:	ee243b06 	vmul.f64	d3, d4, d6
	      if (i == ilim)
   26bec:	0a000180 	beq	271f4 <_dtoa_r+0x1140>
	  for (i = 1;; i++, d.d *= 10.)
   26bf0:	ed1f4bd2 	vldr	d4, [pc, #-840]	@ 268b0 <_dtoa_r+0x7fc>
   26bf4:	e0881001 	add	r1, r8, r1
	      *s++ = '0' + (int) L;
   26bf8:	e1a0c002 	mov	ip, r2
	  for (i = 1;; i++, d.d *= 10.)
   26bfc:	ee277b04 	vmul.f64	d7, d7, d4
	      L = d.d;
   26c00:	eefd6bc7 	vcvt.s32.f64	s13, d7
	      d.d -= L;
   26c04:	eeb85be6 	vcvt.f64.s32	d5, s13
	      *s++ = '0' + (int) L;
   26c08:	ee163a90 	vmov	r3, s13
   26c0c:	e2833030 	add	r3, r3, #48	@ 0x30
   26c10:	e4cc3001 	strb	r3, [ip], #1
	      if (i == ilim)
   26c14:	e151000c 	cmp	r1, ip
	      d.d -= L;
   26c18:	ee377b45 	vsub.f64	d7, d7, d5
	      if (i == ilim)
   26c1c:	1afffff6 	bne	26bfc <_dtoa_r+0xb48>
		  if (d.d > 0.5 + eps.d)
   26c20:	ed1f6be0 	vldr	d6, [pc, #-896]	@ 268a8 <_dtoa_r+0x7f4>
   26c24:	ee335b06 	vadd.f64	d5, d3, d6
   26c28:	eeb45bc7 	vcmpe.f64	d5, d7
   26c2c:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   26c30:	4a000043 	bmi	26d44 <_dtoa_r+0xc90>
		  else if (d.d < 0.5 - eps.d)
   26c34:	ee366b43 	vsub.f64	d6, d6, d3
   26c38:	eeb46bc7 	vcmpe.f64	d6, d7
   26c3c:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   26c40:	ca000049 	bgt	26d6c <_dtoa_r+0xcb8>
  if (be >= 0 && k <= Int_max)
   26c44:	e59d3034 	ldr	r3, [sp, #52]	@ 0x34
   26c48:	e59d101c 	ldr	r1, [sp, #28]
   26c4c:	e1e03003 	mvn	r3, r3
   26c50:	e1a03fa3 	lsr	r3, r3, #31
   26c54:	e351000e 	cmp	r1, #14
   26c58:	c3a03000 	movgt	r3, #0
   26c5c:	e3530000 	cmp	r3, #0
   26c60:	0afffe9d 	beq	266dc <_dtoa_r+0x628>
      ds = tens[k];
   26c64:	e59d301c 	ldr	r3, [sp, #28]
   26c68:	e1a09008 	mov	r9, r8
   26c6c:	e0800183 	add	r0, r0, r3, lsl #3
   26c70:	ed906b00 	vldr	d6, [r0]
	  L = d.d / ds;
   26c74:	ee887b06 	vdiv.f64	d7, d8, d6
	  if (i == ilim)
   26c78:	e35b0001 	cmp	fp, #1
	  L = d.d / ds;
   26c7c:	eebd7bc7 	vcvt.s32.f64	s14, d7
	  d.d -= L * ds;
   26c80:	eeb85bc7 	vcvt.f64.s32	d5, s14
	  *s++ = '0' + (int) L;
   26c84:	ee173a10 	vmov	r3, s14
   26c88:	e2833030 	add	r3, r3, #48	@ 0x30
   26c8c:	e5c83000 	strb	r3, [r8]
	  d.d -= L * ds;
   26c90:	ee058b46 	vmls.f64	d8, d5, d6
	  if (i == ilim)
   26c94:	0a00012d 	beq	27150 <_dtoa_r+0x109c>
	  *s++ = '0' + (int) L;
   26c98:	e1a08002 	mov	r8, r2
	  if (!(d.d *= 10.))
   26c9c:	ed1f4bfd 	vldr	d4, [pc, #-1012]	@ 268b0 <_dtoa_r+0x7fc>
	  if (i == ilim)
   26ca0:	e2622001 	rsb	r2, r2, #1
   26ca4:	ea000009 	b	26cd0 <_dtoa_r+0xc1c>
	  L = d.d / ds;
   26ca8:	ee887b06 	vdiv.f64	d7, d8, d6
   26cac:	eebd7bc7 	vcvt.s32.f64	s14, d7
	  *s++ = '0' + (int) L;
   26cb0:	ee173a10 	vmov	r3, s14
   26cb4:	e2833030 	add	r3, r3, #48	@ 0x30
	  d.d -= L * ds;
   26cb8:	eeb85bc7 	vcvt.f64.s32	d5, s14
	  *s++ = '0' + (int) L;
   26cbc:	e4c83001 	strb	r3, [r8], #1
	  if (i == ilim)
   26cc0:	e0883002 	add	r3, r8, r2
   26cc4:	e153000b 	cmp	r3, fp
	  d.d -= L * ds;
   26cc8:	ee058b46 	vmls.f64	d8, d5, d6
	  if (i == ilim)
   26ccc:	0a000120 	beq	27154 <_dtoa_r+0x10a0>
	  if (!(d.d *= 10.))
   26cd0:	ee288b04 	vmul.f64	d8, d8, d4
   26cd4:	eeb58b40 	vcmp.f64	d8, #0.0
   26cd8:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   26cdc:	1afffff1 	bne	26ca8 <_dtoa_r+0xbf4>
   26ce0:	e59d601c 	ldr	r6, [sp, #28]
   26ce4:	eafffed8 	b	2684c <_dtoa_r+0x798>
      i += 28;
   26ce8:	1263303c 	rsbne	r3, r3, #60	@ 0x3c
  else if (i < 4)
   26cec:	0afffeae 	beq	267ac <_dtoa_r+0x6f8>
   26cf0:	eafffea8 	b	26798 <_dtoa_r+0x6e4>
      if (ilim < 0 || cmp (b, S = multadd (ptr, S, 5, 0)) <= 0)
   26cf4:	e59d100c 	ldr	r1, [sp, #12]
   26cf8:	e1a0300b 	mov	r3, fp
   26cfc:	e3a02005 	mov	r2, #5
   26d00:	e1a00004 	mov	r0, r4
   26d04:	eb00019e 	bl	27384 <__multadd>
   26d08:	e1a01000 	mov	r1, r0
   26d0c:	e58d000c 	str	r0, [sp, #12]
   26d10:	e1a00005 	mov	r0, r5
   26d14:	eb00039b 	bl	27b88 <__mcmp>
   26d18:	e3500000 	cmp	r0, #0
    one_digit:
   26d1c:	c1a09008 	movgt	r9, r8
      if (ilim < 0 || cmp (b, S = multadd (ptr, S, 5, 0)) <= 0)
   26d20:	dafffebe 	ble	26820 <_dtoa_r+0x76c>
      k++;
   26d24:	e59d301c 	ldr	r3, [sp, #28]
      *s++ = '1';
   26d28:	e2888001 	add	r8, r8, #1
      k++;
   26d2c:	e2836001 	add	r6, r3, #1
      *s++ = '1';
   26d30:	e3a03031 	mov	r3, #49	@ 0x31
   26d34:	e5c93000 	strb	r3, [r9]
      goto ret;
   26d38:	eafffebb 	b	2682c <_dtoa_r+0x778>
		    if (s == s0)
   26d3c:	e1580001 	cmp	r8, r1
   26d40:	0a0000ee 	beq	27100 <_dtoa_r+0x104c>
		  while (*--s == '9')
   26d44:	e1a02001 	mov	r2, r1
   26d48:	e5713001 	ldrb	r3, [r1, #-1]!
   26d4c:	e3530039 	cmp	r3, #57	@ 0x39
   26d50:	0afffff9 	beq	26d3c <_dtoa_r+0xc88>
		  ++*s++;
   26d54:	e2833001 	add	r3, r3, #1
   26d58:	e6ef3073 	uxtb	r3, r3
   26d5c:	e1a09008 	mov	r9, r8
   26d60:	e5c13000 	strb	r3, [r1]
   26d64:	e1a08002 	mov	r8, r2
   26d68:	eafffeb7 	b	2684c <_dtoa_r+0x798>
		      while (*--s == '0');
   26d6c:	e1a02001 	mov	r2, r1
   26d70:	e5713001 	ldrb	r3, [r1, #-1]!
   26d74:	e3530030 	cmp	r3, #48	@ 0x30
   26d78:	0afffffb 	beq	26d6c <_dtoa_r+0xcb8>
   26d7c:	e1a09008 	mov	r9, r8
	      *s++ = '0' + (int) L;
   26d80:	e1a08002 	mov	r8, r2
   26d84:	eafffeb0 	b	2684c <_dtoa_r+0x798>
   26d88:	e59da00c 	ldr	sl, [sp, #12]
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
   26d8c:	e1a09008 	mov	r9, r8
    for (i = 1;; i++)
   26d90:	e3a06001 	mov	r6, #1
   26d94:	ea000006 	b	26db4 <_dtoa_r+0xd00>
	b = multadd (ptr, b, 10, 0);
   26d98:	e1a01005 	mov	r1, r5
   26d9c:	e3a03000 	mov	r3, #0
   26da0:	e3a0200a 	mov	r2, #10
   26da4:	e1a00004 	mov	r0, r4
   26da8:	eb000175 	bl	27384 <__multadd>
    for (i = 1;; i++)
   26dac:	e2866001 	add	r6, r6, #1
	b = multadd (ptr, b, 10, 0);
   26db0:	e1a05000 	mov	r5, r0
	*s++ = dig = quorem (b, S) + '0';
   26db4:	e1a0100a 	mov	r1, sl
   26db8:	e1a00005 	mov	r0, r5
   26dbc:	ebfffc4d 	bl	25ef8 <quorem>
	if (i >= ilim)
   26dc0:	e156000b 	cmp	r6, fp
	*s++ = dig = quorem (b, S) + '0';
   26dc4:	e2803030 	add	r3, r0, #48	@ 0x30
   26dc8:	e4c93001 	strb	r3, [r9], #1
	if (i >= ilim)
   26dcc:	bafffff1 	blt	26d98 <_dtoa_r+0xce4>
	*s++ = dig = quorem (b, S) + '0';
   26dd0:	e35b0000 	cmp	fp, #0
  mhi = mlo = 0;
   26dd4:	e3a09000 	mov	r9, #0
	*s++ = dig = quorem (b, S) + '0';
   26dd8:	c1a0600b 	movgt	r6, fp
   26ddc:	d3a06001 	movle	r6, #1
   26de0:	e0886006 	add	r6, r8, r6
  b = lshift (ptr, b, 1);
   26de4:	e1a01005 	mov	r1, r5
   26de8:	e3a02001 	mov	r2, #1
   26dec:	e1a00004 	mov	r0, r4
   26df0:	e58d3008 	str	r3, [sp, #8]
   26df4:	eb000313 	bl	27a48 <__lshift>
  j = cmp (b, S);
   26df8:	e59d100c 	ldr	r1, [sp, #12]
  b = lshift (ptr, b, 1);
   26dfc:	e1a05000 	mov	r5, r0
  j = cmp (b, S);
   26e00:	eb000360 	bl	27b88 <__mcmp>
  if ((j > 0) || ((j == 0) && (dig & 1)))
   26e04:	e3500000 	cmp	r0, #0
   26e08:	ca000002 	bgt	26e18 <_dtoa_r+0xd64>
   26e0c:	ea0000a8 	b	270b4 <_dtoa_r+0x1000>
	if (s == s0)
   26e10:	e1560008 	cmp	r6, r8
   26e14:	0a0000b1 	beq	270e0 <_dtoa_r+0x102c>
      while (*--s == '9')
   26e18:	e5563001 	ldrb	r3, [r6, #-1]
   26e1c:	e1a0b006 	mov	fp, r6
   26e20:	e2466001 	sub	r6, r6, #1
   26e24:	e3530039 	cmp	r3, #57	@ 0x39
   26e28:	0afffff8 	beq	26e10 <_dtoa_r+0xd5c>
      ++*s++;
   26e2c:	e2833001 	add	r3, r3, #1
   26e30:	e5c63000 	strb	r3, [r6]
   26e34:	e59d601c 	ldr	r6, [sp, #28]
  Bfree (ptr, S);
   26e38:	e59d100c 	ldr	r1, [sp, #12]
   26e3c:	e1a00004 	mov	r0, r4
   26e40:	eb000148 	bl	27368 <_Bfree>
  if (mhi)
   26e44:	e3570000 	cmp	r7, #0
   26e48:	0a0000a9 	beq	270f4 <_dtoa_r+0x1040>
      if (mlo && mlo != mhi)
   26e4c:	e3590000 	cmp	r9, #0
   26e50:	11590007 	cmpne	r9, r7
   26e54:	0a000002 	beq	26e64 <_dtoa_r+0xdb0>
	Bfree (ptr, mlo);
   26e58:	e1a01009 	mov	r1, r9
   26e5c:	e1a00004 	mov	r0, r4
   26e60:	eb000140 	bl	27368 <_Bfree>
	      goto ret;
   26e64:	e1a09008 	mov	r9, r8
   26e68:	e1a0800b 	mov	r8, fp
   26e6c:	eafffe73 	b	26840 <_dtoa_r+0x78c>
	      s5 += j -= m5;
   26e70:	e59d100c 	ldr	r1, [sp, #12]
      s2 += i;
   26e74:	e089900b 	add	r9, r9, fp
	      b5 += j;
   26e78:	e58d300c 	str	r3, [sp, #12]
	      m5 = 0;
   26e7c:	e58d202c 	str	r2, [sp, #44]	@ 0x2c
	      s5 += j -= m5;
   26e80:	e0431001 	sub	r1, r3, r1
  m2 = b2;
   26e84:	e59d3018 	ldr	r3, [sp, #24]
	      s5 += j -= m5;
   26e88:	e08aa001 	add	sl, sl, r1
  m2 = b2;
   26e8c:	e1a06003 	mov	r6, r3
      s2 += i;
   26e90:	e083300b 	add	r3, r3, fp
   26e94:	e58d3018 	str	r3, [sp, #24]
      mhi = i2b (ptr, 1);
   26e98:	e3a01001 	mov	r1, #1
   26e9c:	e1a00004 	mov	r0, r4
   26ea0:	eb0001f7 	bl	27684 <__i2b>
   26ea4:	e1a07000 	mov	r7, r0
   26ea8:	eafffe10 	b	266f0 <_dtoa_r+0x63c>
      if (!word1 (d) && !(word0 (d) & Bndry_mask)
   26eac:	e59d3000 	ldr	r3, [sp]
   26eb0:	e3530000 	cmp	r3, #0
   26eb4:	1afffeeb 	bne	26a68 <_dtoa_r+0x9b4>
   26eb8:	e1cd00d0 	ldrd	r0, [sp]
   26ebc:	e7f33051 	ubfx	r3, r1, #0, #20
   26ec0:	e1a02001 	mov	r2, r1
   26ec4:	e3530000 	cmp	r3, #0
   26ec8:	0affff0f 	beq	26b0c <_dtoa_r+0xa58>
   26ecc:	eafffee5 	b	26a68 <_dtoa_r+0x9b4>
	      *s++ = '0' + (int) L;
   26ed0:	e2882001 	add	r2, r8, #1
   26ed4:	e1a09008 	mov	r9, r8
   26ed8:	eaffff65 	b	26c74 <_dtoa_r+0xbc0>
	      mhi = pow5mult (ptr, mhi, m5);
   26edc:	e1a02003 	mov	r2, r3
   26ee0:	e1a01007 	mov	r1, r7
   26ee4:	e1a00004 	mov	r0, r4
   26ee8:	eb00028f 	bl	2792c <__pow5mult>
	      b1 = mult (ptr, mhi, b);
   26eec:	e1a02005 	mov	r2, r5
   26ef0:	e1a01000 	mov	r1, r0
	      mhi = pow5mult (ptr, mhi, m5);
   26ef4:	e1a07000 	mov	r7, r0
	      b1 = mult (ptr, mhi, b);
   26ef8:	e1a00004 	mov	r0, r4
   26efc:	eb000208 	bl	27724 <__multiply>
	      Bfree (ptr, b);
   26f00:	e1a01005 	mov	r1, r5
	      b1 = mult (ptr, mhi, b);
   26f04:	e1a05000 	mov	r5, r0
	      Bfree (ptr, b);
   26f08:	e1a00004 	mov	r0, r4
   26f0c:	eb000115 	bl	27368 <_Bfree>
         if ((j = b5 - m5) != 0)
   26f10:	e59d100c 	ldr	r1, [sp, #12]
   26f14:	e59d302c 	ldr	r3, [sp, #44]	@ 0x2c
   26f18:	e0513003 	subs	r3, r1, r3
   26f1c:	e58d300c 	str	r3, [sp, #12]
   26f20:	0afffe0b 	beq	26754 <_dtoa_r+0x6a0>
   26f24:	eafffe05 	b	26740 <_dtoa_r+0x68c>
	  Bfree (ptr, delta);
   26f28:	e1a00004 	mov	r0, r4
   26f2c:	e58d8014 	str	r8, [sp, #20]
   26f30:	e59d8024 	ldr	r8, [sp, #36]	@ 0x24
   26f34:	eb00010b 	bl	27368 <_Bfree>
         if ((j < 0) || ((j == 0) && !mode
   26f38:	e3590000 	cmp	r9, #0
   26f3c:	e59d3014 	ldr	r3, [sp, #20]
   26f40:	ba000005 	blt	26f5c <_dtoa_r+0xea8>
	      && !(word1 (d) & 1)
   26f44:	e59d2000 	ldr	r2, [sp]
         if ((j < 0) || ((j == 0) && !mode
   26f48:	e59d1008 	ldr	r1, [sp, #8]
	      && !(word1 (d) & 1)
   26f4c:	e2022001 	and	r2, r2, #1
         if ((j < 0) || ((j == 0) && !mode
   26f50:	e1819009 	orr	r9, r1, r9
	      && !(word1 (d) & 1)
   26f54:	e1922009 	orrs	r2, r2, r9
   26f58:	1a000022 	bne	26fe8 <_dtoa_r+0xf34>
		  b = lshift (ptr, b, 1);
   26f5c:	e1a01005 	mov	r1, r5
   26f60:	e3a02001 	mov	r2, #1
   26f64:	e1a00004 	mov	r0, r4
   26f68:	e58d3008 	str	r3, [sp, #8]
   26f6c:	eb0002b5 	bl	27a48 <__lshift>
		  j1 = cmp (b, S);
   26f70:	e59d100c 	ldr	r1, [sp, #12]
		  b = lshift (ptr, b, 1);
   26f74:	e1a05000 	mov	r5, r0
		  j1 = cmp (b, S);
   26f78:	eb000302 	bl	27b88 <__mcmp>
                 if (((j1 > 0) || ((j1 == 0) && (dig & 1)))
   26f7c:	e3500000 	cmp	r0, #0
   26f80:	e59d3008 	ldr	r3, [sp, #8]
   26f84:	da0000ab 	ble	27238 <_dtoa_r+0x1184>
		      && dig++ == '9')
   26f88:	e3530039 	cmp	r3, #57	@ 0x39
   26f8c:	0a000083 	beq	271a0 <_dtoa_r+0x10ec>
   26f90:	e28b3031 	add	r3, fp, #49	@ 0x31
	      *s++ = dig;
   26f94:	e1a0b006 	mov	fp, r6
	      goto ret;
   26f98:	e1a09007 	mov	r9, r7
   26f9c:	e59d601c 	ldr	r6, [sp, #28]
   26fa0:	e1a0700a 	mov	r7, sl
	      *s++ = dig;
   26fa4:	e4cb3001 	strb	r3, [fp], #1
	      goto ret;
   26fa8:	eaffffa2 	b	26e38 <_dtoa_r+0xd84>
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
   26fac:	eb0000f4 	bl	27384 <__multadd>
   26fb0:	e1a07000 	mov	r7, r0
   26fb4:	e1a0a000 	mov	sl, r0
   26fb8:	eafffe53 	b	2690c <_dtoa_r+0x858>
         if ((j < 0) || ((j == 0) && !mode
   26fbc:	e3590000 	cmp	r9, #0
   26fc0:	ba0000b5 	blt	2729c <_dtoa_r+0x11e8>
   26fc4:	e59d3008 	ldr	r3, [sp, #8]
   26fc8:	e1839009 	orr	r9, r3, r9
	      && !(word1 (d) & 1)
   26fcc:	e59d3020 	ldr	r3, [sp, #32]
   26fd0:	e1939009 	orrs	r9, r3, r9
   26fd4:	0a0000b0 	beq	2729c <_dtoa_r+0x11e8>
	  if (j1 > 0)
   26fd8:	e3520000 	cmp	r2, #0
   26fdc:	dafffe6b 	ble	26990 <_dtoa_r+0x8dc>
   26fe0:	e1a03008 	mov	r3, r8
   26fe4:	e59d8024 	ldr	r8, [sp, #36]	@ 0x24
	      if (dig == '9')
   26fe8:	e3530039 	cmp	r3, #57	@ 0x39
   26fec:	0a00006b 	beq	271a0 <_dtoa_r+0x10ec>
	      *s++ = dig + 1;
   26ff0:	e1a0b006 	mov	fp, r6
   26ff4:	e2833001 	add	r3, r3, #1
	      goto ret;
   26ff8:	e1a09007 	mov	r9, r7
   26ffc:	e59d601c 	ldr	r6, [sp, #28]
   27000:	e1a0700a 	mov	r7, sl
	      *s++ = dig + 1;
   27004:	e4cb3001 	strb	r3, [fp], #1
	      goto ret;
   27008:	eaffff8a 	b	26e38 <_dtoa_r+0xd84>
      if (k_check && d.d < 1. && ilim > 0)
   2700c:	e35b0000 	cmp	fp, #0
   27010:	0afffd67 	beq	265b4 <_dtoa_r+0x500>
	  if (ilim1 <= 0)
   27014:	e59d3028 	ldr	r3, [sp, #40]	@ 0x28
   27018:	e3530000 	cmp	r3, #0
   2701c:	dafffd75 	ble	265f8 <_dtoa_r+0x544>
	  ieps++;
   27020:	e2811001 	add	r1, r1, #1
	  d.d *= 10.;
   27024:	ed9f4ba9 	vldr	d4, [pc, #676]	@ 272d0 <_dtoa_r+0x121c>
	  k--;
   27028:	e59d201c 	ldr	r2, [sp, #28]
      eps.d = ieps * d.d + 7.;
   2702c:	ee061a90 	vmov	s13, r1
	  ilim = ilim1;
   27030:	e1a01003 	mov	r1, r3
      eps.d = ieps * d.d + 7.;
   27034:	eeb85be6 	vcvt.f64.s32	d5, s13
	  d.d *= 10.;
   27038:	ee277b04 	vmul.f64	d7, d7, d4
	  k--;
   2703c:	e2426001 	sub	r6, r2, #1
      eps.d = ieps * d.d + 7.;
   27040:	ed9f6ba4 	vldr	d6, [pc, #656]	@ 272d8 <_dtoa_r+0x1224>
   27044:	ee056b07 	vmla.f64	d6, d5, d7
      word0 (eps) -= (P - 1) * Exp_msk1;
   27048:	ee160a90 	vmov	r0, s13
      eps.d = ieps * d.d + 7.;
   2704c:	ec532b16 	vmov	r2, r3, d6
      word0 (eps) -= (P - 1) * Exp_msk1;
   27050:	e240350d 	sub	r3, r0, #54525952	@ 0x3400000
      if (ilim == 0)
   27054:	eafffd16 	b	264b4 <_dtoa_r+0x400>
      b2 = -j;
   27058:	e2633001 	rsb	r3, r3, #1
      s2 = 0;
   2705c:	e3a09000 	mov	r9, #0
      b2 = -j;
   27060:	e58d3018 	str	r3, [sp, #24]
      k_check = 0;
   27064:	e58d9024 	str	r9, [sp, #36]	@ 0x24
   27068:	eafffcc7 	b	2638c <_dtoa_r+0x2d8>
	    denorm ? be + (Bias + (P - 1) - 1 + 1) :
   2706c:	e3570000 	cmp	r7, #0
  m2 = b2;
   27070:	e59d2018 	ldr	r2, [sp, #24]
	    denorm ? be + (Bias + (P - 1) - 1 + 1) :
   27074:	059d3030 	ldreq	r3, [sp, #48]	@ 0x30
   27078:	12833e43 	addne	r3, r3, #1072	@ 0x430
   2707c:	12833003 	addne	r3, r3, #3
  m2 = b2;
   27080:	e1a06002 	mov	r6, r2
	    denorm ? be + (Bias + (P - 1) - 1 + 1) :
   27084:	02633036 	rsbeq	r3, r3, #54	@ 0x36
      s2 += i;
   27088:	e0899003 	add	r9, r9, r3
   2708c:	e0823003 	add	r3, r2, r3
   27090:	e58d3018 	str	r3, [sp, #24]
  m5 = b5;
   27094:	e59d300c 	ldr	r3, [sp, #12]
   27098:	e58d302c 	str	r3, [sp, #44]	@ 0x2c
   2709c:	eaffff7d 	b	26e98 <_dtoa_r+0xde4>
	  S = mhi = 0;
   270a0:	e3a03000 	mov	r3, #0
   270a4:	e1a09008 	mov	r9, r8
   270a8:	e1a07003 	mov	r7, r3
   270ac:	e58d300c 	str	r3, [sp, #12]
   270b0:	eaffff1b 	b	26d24 <_dtoa_r+0xc70>
  if ((j > 0) || ((j == 0) && (dig & 1)))
   270b4:	1a000002 	bne	270c4 <_dtoa_r+0x1010>
   270b8:	e59d3008 	ldr	r3, [sp, #8]
   270bc:	e3130001 	tst	r3, #1
   270c0:	1affff54 	bne	26e18 <_dtoa_r+0xd64>
      while (*--s == '0');
   270c4:	e5563001 	ldrb	r3, [r6, #-1]
   270c8:	e1a0b006 	mov	fp, r6
   270cc:	e2466001 	sub	r6, r6, #1
   270d0:	e3530030 	cmp	r3, #48	@ 0x30
   270d4:	0afffffa 	beq	270c4 <_dtoa_r+0x1010>
   270d8:	e59d601c 	ldr	r6, [sp, #28]
   270dc:	eaffff55 	b	26e38 <_dtoa_r+0xd84>
	    k++;
   270e0:	e59d301c 	ldr	r3, [sp, #28]
   270e4:	e2836001 	add	r6, r3, #1
	    *s++ = '1';
   270e8:	e3a03031 	mov	r3, #49	@ 0x31
   270ec:	e5c83000 	strb	r3, [r8]
	    goto ret;
   270f0:	eaffff50 	b	26e38 <_dtoa_r+0xd84>
ret1:
   270f4:	e1a09008 	mov	r9, r8
   270f8:	e1a0800b 	mov	r8, fp
   270fc:	eafffdd2 	b	2684c <_dtoa_r+0x798>
			k++;
   27100:	e2866001 	add	r6, r6, #1
			break;
   27104:	e3a03031 	mov	r3, #49	@ 0x31
   27108:	eaffff13 	b	26d5c <_dtoa_r+0xca8>
	  mhi = eBalloc (ptr, mhi->_k);
   2710c:	e5971004 	ldr	r1, [r7, #4]
   27110:	e1a00004 	mov	r0, r4
   27114:	eb000071 	bl	272e0 <_Balloc>
   27118:	e2506000 	subs	r6, r0, #0
   2711c:	0a000049 	beq	27248 <_dtoa_r+0x1194>
	  Bcopy (mhi, mlo);
   27120:	e5972010 	ldr	r2, [r7, #16]
   27124:	e287100c 	add	r1, r7, #12
   27128:	e286000c 	add	r0, r6, #12
   2712c:	e2822002 	add	r2, r2, #2
   27130:	e1a02102 	lsl	r2, r2, #2
   27134:	ebffe351 	bl	1fe80 <memcpy>
	  mhi = lshift (ptr, mhi, Log2P);
   27138:	e1a01006 	mov	r1, r6
   2713c:	e3a02001 	mov	r2, #1
   27140:	e1a00004 	mov	r0, r4
   27144:	eb00023f 	bl	27a48 <__lshift>
   27148:	e1a0a000 	mov	sl, r0
   2714c:	eafffde6 	b	268ec <_dtoa_r+0x838>
	  *s++ = '0' + (int) L;
   27150:	e1a08002 	mov	r8, r2
	      d.d += d.d;
   27154:	ee388b08 	vadd.f64	d8, d8, d8
             if ((d.d > ds) || ((d.d == ds) && (L & 1)))
   27158:	eeb48bc6 	vcmpe.f64	d8, d6
   2715c:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   27160:	ca000005 	bgt	2717c <_dtoa_r+0x10c8>
   27164:	eeb48b46 	vcmp.f64	d8, d6
   27168:	eef1fa10 	vmrs	APSR_nzcv, fpscr
   2716c:	1afffedb 	bne	26ce0 <_dtoa_r+0xc2c>
   27170:	ee173a10 	vmov	r3, s14
   27174:	e3130001 	tst	r3, #1
   27178:	0afffed8 	beq	26ce0 <_dtoa_r+0xc2c>
	  *s++ = '0' + (int) L;
   2717c:	e1a01008 	mov	r1, r8
		bump_up:
   27180:	e59d601c 	ldr	r6, [sp, #28]
   27184:	e1a08009 	mov	r8, r9
   27188:	eafffeed 	b	26d44 <_dtoa_r+0xc90>
	  *s++ = dig;
   2718c:	e1a03008 	mov	r3, r8
   27190:	e1a09007 	mov	r9, r7
   27194:	e59d8024 	ldr	r8, [sp, #36]	@ 0x24
   27198:	e1a0700a 	mov	r7, sl
   2719c:	eaffff10 	b	26de4 <_dtoa_r+0xd30>
		  *s++ = '9';
   271a0:	e3a03039 	mov	r3, #57	@ 0x39
		  goto roundoff;
   271a4:	e1a09007 	mov	r9, r7
		  *s++ = '9';
   271a8:	e4c63001 	strb	r3, [r6], #1
		  goto roundoff;
   271ac:	e1a0700a 	mov	r7, sl
   271b0:	eaffff18 	b	26e18 <_dtoa_r+0xd64>
  m2 = b2;
   271b4:	e59d3018 	ldr	r3, [sp, #24]
      s2 += i;
   271b8:	e089900b 	add	r9, r9, fp
  m2 = b2;
   271bc:	e1a06003 	mov	r6, r3
      s2 += i;
   271c0:	e083300b 	add	r3, r3, fp
   271c4:	e58d3018 	str	r3, [sp, #24]
   271c8:	eaffff32 	b	26e98 <_dtoa_r+0xde4>
   271cc:	e1a03008 	mov	r3, r8
   271d0:	e59d8024 	ldr	r8, [sp, #36]	@ 0x24
   271d4:	eaffff6e 	b	26f94 <_dtoa_r+0xee0>
	      if (dig == '9')
   271d8:	e1a03008 	mov	r3, r8
   271dc:	e59d8024 	ldr	r8, [sp, #36]	@ 0x24
   271e0:	e3530039 	cmp	r3, #57	@ 0x39
   271e4:	0affffed 	beq	271a0 <_dtoa_r+0x10ec>
	      if (j > 0)
   271e8:	e3590000 	cmp	r9, #0
   271ec:	caffff67 	bgt	26f90 <_dtoa_r+0xedc>
   271f0:	eaffff67 	b	26f94 <_dtoa_r+0xee0>
	      *s++ = '0' + (int) L;
   271f4:	e1a01002 	mov	r1, r2
   271f8:	eafffe88 	b	26c20 <_dtoa_r+0xb6c>
	    mhi = multadd (ptr, mhi, 10, 0);
   271fc:	e1a01007 	mov	r1, r7
   27200:	e3a03000 	mov	r3, #0
   27204:	e3a0200a 	mov	r2, #10
   27208:	e1a00004 	mov	r0, r4
   2720c:	eb00005c 	bl	27384 <__multadd>
  if (ilim <= 0 && mode > 2)
   27210:	e59db028 	ldr	fp, [sp, #40]	@ 0x28
	    mhi = multadd (ptr, mhi, 10, 0);
   27214:	e1a07000 	mov	r7, r0
  if (ilim <= 0 && mode > 2)
   27218:	e35b0000 	cmp	fp, #0
   2721c:	c3a03000 	movgt	r3, #0
   27220:	d2093001 	andle	r3, r9, #1
   27224:	e3530000 	cmp	r3, #0
   27228:	0afffda5 	beq	268c4 <_dtoa_r+0x810>
   2722c:	eafffe2c 	b	26ae4 <_dtoa_r+0xa30>
      ieps = 2;			/* conservative */
   27230:	e3a01002 	mov	r1, #2
   27234:	eafffc8c 	b	2646c <_dtoa_r+0x3b8>
                 if (((j1 > 0) || ((j1 == 0) && (dig & 1)))
   27238:	1affff55 	bne	26f94 <_dtoa_r+0xee0>
   2723c:	e3130001 	tst	r3, #1
   27240:	1affff50 	bne	26f88 <_dtoa_r+0xed4>
   27244:	eaffff52 	b	26f94 <_dtoa_r+0xee0>
	  mhi = eBalloc (ptr, mhi->_k);
   27248:	e3093b10 	movw	r3, #39696	@ 0x9b10
   2724c:	e3090b24 	movw	r0, #39716	@ 0x9b24
   27250:	e3403002 	movt	r3, #2
   27254:	e1a02006 	mov	r2, r6
   27258:	e30012ef 	movw	r1, #751	@ 0x2ef
   2725c:	e3400002 	movt	r0, #2
   27260:	ebffbd2e 	bl	16720 <__assert_func>
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   27264:	e3a06000 	mov	r6, #0
  _REENT_MP_RESULT(ptr) = eBalloc (ptr, _REENT_MP_RESULT_K(ptr));
   27268:	e1a00004 	mov	r0, r4
   2726c:	e1a01006 	mov	r1, r6
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   27270:	e584603c 	str	r6, [r4, #60]	@ 0x3c
  _REENT_MP_RESULT(ptr) = eBalloc (ptr, _REENT_MP_RESULT_K(ptr));
   27274:	eb000019 	bl	272e0 <_Balloc>
   27278:	e2508000 	subs	r8, r0, #0
   2727c:	1a00000b 	bne	272b0 <_dtoa_r+0x11fc>
   27280:	e3093b10 	movw	r3, #39696	@ 0x9b10
   27284:	e3090b24 	movw	r0, #39716	@ 0x9b24
   27288:	e3403002 	movt	r3, #2
   2728c:	e3a02000 	mov	r2, #0
   27290:	e30011af 	movw	r1, #431	@ 0x1af
   27294:	e3400002 	movt	r0, #2
   27298:	ebffbd20 	bl	16720 <__assert_func>
	      if (j1 > 0)
   2729c:	e3520000 	cmp	r2, #0
   272a0:	e1a03008 	mov	r3, r8
   272a4:	e59d8024 	ldr	r8, [sp, #36]	@ 0x24
   272a8:	caffff2b 	bgt	26f5c <_dtoa_r+0xea8>
   272ac:	eaffff38 	b	26f94 <_dtoa_r+0xee0>
  ilim = ilim1 = -1;
   272b0:	e3e0b000 	mvn	fp, #0
  leftright = 1;
   272b4:	e3a03001 	mov	r3, #1
      ndigits = 0;
   272b8:	e58d6014 	str	r6, [sp, #20]
  _REENT_MP_RESULT(ptr) = eBalloc (ptr, _REENT_MP_RESULT_K(ptr));
   272bc:	e5848038 	str	r8, [r4, #56]	@ 0x38
  ilim = ilim1 = -1;
   272c0:	e58db028 	str	fp, [sp, #40]	@ 0x28
  leftright = 1;
   272c4:	e58d3020 	str	r3, [sp, #32]
   272c8:	eafffcca 	b	265f8 <_dtoa_r+0x544>
   272cc:	e320f000 	nop	{0}
   272d0:	00000000 	.word	0x00000000
   272d4:	40240000 	.word	0x40240000
   272d8:	00000000 	.word	0x00000000
   272dc:	401c0000 	.word	0x401c0000

000272e0 <_Balloc>:
{
  int x;
  _Bigint *rv ;

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_FREELIST(ptr) == NULL)
   272e0:	e5903044 	ldr	r3, [r0, #68]	@ 0x44
{
   272e4:	e92d4070 	push	{r4, r5, r6, lr}
   272e8:	e1a05000 	mov	r5, r0
   272ec:	e1a04001 	mov	r4, r1
  if (_REENT_MP_FREELIST(ptr) == NULL)
   272f0:	e3530000 	cmp	r3, #0
   272f4:	0a000008 	beq	2731c <_Balloc+0x3c>
	{
	  return NULL;
	}
    }

  if ((rv = _REENT_MP_FREELIST(ptr)[k]) != 0)
   272f8:	e7930104 	ldr	r0, [r3, r4, lsl #2]
   272fc:	e3500000 	cmp	r0, #0
   27300:	0a00000e 	beq	27340 <_Balloc+0x60>
    {
      _REENT_MP_FREELIST(ptr)[k] = rv->_next;
   27304:	e5902000 	ldr	r2, [r0]
   27308:	e7832104 	str	r2, [r3, r4, lsl #2]
				  (x-1) * sizeof(rv->_x));
      if (rv == NULL) return NULL;
      rv->_k = k;
      rv->_maxwds = x;
    }
  rv->_sign = rv->_wds = 0;
   2730c:	e3a03000 	mov	r3, #0
   27310:	e580300c 	str	r3, [r0, #12]
   27314:	e5803010 	str	r3, [r0, #16]
  return rv;
}
   27318:	e8bd8070 	pop	{r4, r5, r6, pc}
      _REENT_MP_FREELIST(ptr) = (struct _Bigint **) _calloc_r (ptr, 
   2731c:	e3a02021 	mov	r2, #33	@ 0x21
   27320:	e3a01004 	mov	r1, #4
   27324:	eb0003f6 	bl	28304 <_calloc_r>
      if (_REENT_MP_FREELIST(ptr) == NULL)
   27328:	e3500000 	cmp	r0, #0
      _REENT_MP_FREELIST(ptr) = (struct _Bigint **) _calloc_r (ptr, 
   2732c:	e1a03000 	mov	r3, r0
   27330:	e5850044 	str	r0, [r5, #68]	@ 0x44
      if (_REENT_MP_FREELIST(ptr) == NULL)
   27334:	1affffef 	bne	272f8 <_Balloc+0x18>
	  return NULL;
   27338:	e3a00000 	mov	r0, #0
   2733c:	e8bd8070 	pop	{r4, r5, r6, pc}
      x = 1 << k;
   27340:	e3a01001 	mov	r1, #1
      rv = (_Bigint *) _calloc_r (ptr,
   27344:	e1a00005 	mov	r0, r5
      x = 1 << k;
   27348:	e1a05411 	lsl	r5, r1, r4
				  sizeof (_Bigint) +
   2734c:	e2852005 	add	r2, r5, #5
      rv = (_Bigint *) _calloc_r (ptr,
   27350:	e1a02102 	lsl	r2, r2, #2
   27354:	eb0003ea 	bl	28304 <_calloc_r>
      if (rv == NULL) return NULL;
   27358:	e3500000 	cmp	r0, #0
   2735c:	0afffff5 	beq	27338 <_Balloc+0x58>
      rv->_maxwds = x;
   27360:	e1c040f4 	strd	r4, [r0, #4]
   27364:	eaffffe8 	b	2730c <_Balloc+0x2c>

00027368 <_Bfree>:

void
Bfree (struct _reent *ptr, _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
   27368:	e3510000 	cmp	r1, #0
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   2736c:	15903044 	ldrne	r3, [r0, #68]	@ 0x44
   27370:	15912004 	ldrne	r2, [r1, #4]
   27374:	17930102 	ldrne	r0, [r3, r2, lsl #2]
   27378:	15810000 	strne	r0, [r1]
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
   2737c:	17831102 	strne	r1, [r3, r2, lsl #2]
    }
}
   27380:	e12fff1e 	bx	lr

00027384 <__multadd>:
_Bigint *
multadd (struct _reent *ptr,
	_Bigint * b,
	int m,
	int a)
{
   27384:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
   27388:	e1a07000 	mov	r7, r0
#ifdef Pack_32
  __ULong xi, z;
#endif
  _Bigint *b1;

  wds = b->_wds;
   2738c:	e5915010 	ldr	r5, [r1, #16]
{
   27390:	e1a06001 	mov	r6, r1
   27394:	e1a04003 	mov	r4, r3
  x = b->_x;
   27398:	e281e014 	add	lr, r1, #20
  i = 0;
   2739c:	e3a00000 	mov	r0, #0
  do
    {
#ifdef Pack_32
      xi = *x;
   273a0:	e59e1000 	ldr	r1, [lr]
      y = *x * m + a;
      a = (int) (y >> 16);
      *x++ = y & 0xffff;
#endif
    }
  while (++i < wds);
   273a4:	e2800001 	add	r0, r0, #1
   273a8:	e1550000 	cmp	r5, r0
      y = (xi & 0xffff) * m + a;
   273ac:	e6ff3071 	uxth	r3, r1
      z = (xi >> 16) * m + (y >> 16);
   273b0:	e1a01821 	lsr	r1, r1, #16
      y = (xi & 0xffff) * m + a;
   273b4:	e0234392 	mla	r3, r2, r3, r4
      z = (xi >> 16) * m + (y >> 16);
   273b8:	e1a0c823 	lsr	ip, r3, #16
      *x++ = (z << 16) + (y & 0xffff);
   273bc:	e6ff3073 	uxth	r3, r3
      z = (xi >> 16) * m + (y >> 16);
   273c0:	e02cc192 	mla	ip, r2, r1, ip
      *x++ = (z << 16) + (y & 0xffff);
   273c4:	e083380c 	add	r3, r3, ip, lsl #16
      a = (int) (z >> 16);
   273c8:	e1a0482c 	lsr	r4, ip, #16
      *x++ = (z << 16) + (y & 0xffff);
   273cc:	e48e3004 	str	r3, [lr], #4
  while (++i < wds);
   273d0:	cafffff2 	bgt	273a0 <__multadd+0x1c>
  if (a)
   273d4:	e3540000 	cmp	r4, #0
   273d8:	0a000006 	beq	273f8 <__multadd+0x74>
    {
      if (wds >= b->_maxwds)
   273dc:	e5963008 	ldr	r3, [r6, #8]
   273e0:	e1530005 	cmp	r3, r5
   273e4:	da000005 	ble	27400 <__multadd+0x7c>
	  b1 = eBalloc (ptr, b->_k + 1);
	  Bcopy (b1, b);
	  Bfree (ptr, b);
	  b = b1;
	}
      b->_x[wds++] = a;
   273e8:	e0863105 	add	r3, r6, r5, lsl #2
   273ec:	e2855001 	add	r5, r5, #1
   273f0:	e5834014 	str	r4, [r3, #20]
      b->_wds = wds;
   273f4:	e5865010 	str	r5, [r6, #16]
    }
  return b;
}
   273f8:	e1a00006 	mov	r0, r6
   273fc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
	  b1 = eBalloc (ptr, b->_k + 1);
   27400:	e5961004 	ldr	r1, [r6, #4]
   27404:	e1a00007 	mov	r0, r7
   27408:	e2811001 	add	r1, r1, #1
   2740c:	ebffffb3 	bl	272e0 <_Balloc>
   27410:	e2508000 	subs	r8, r0, #0
   27414:	0a000010 	beq	2745c <__multadd+0xd8>
	  Bcopy (b1, b);
   27418:	e5962010 	ldr	r2, [r6, #16]
   2741c:	e286100c 	add	r1, r6, #12
   27420:	e288000c 	add	r0, r8, #12
   27424:	e2822002 	add	r2, r2, #2
   27428:	e1a02102 	lsl	r2, r2, #2
   2742c:	ebffe293 	bl	1fe80 <memcpy>
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   27430:	e5973044 	ldr	r3, [r7, #68]	@ 0x44
   27434:	e5962004 	ldr	r2, [r6, #4]
   27438:	e7931102 	ldr	r1, [r3, r2, lsl #2]
   2743c:	e5861000 	str	r1, [r6]
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
   27440:	e7836102 	str	r6, [r3, r2, lsl #2]
	  b = b1;
   27444:	e1a06008 	mov	r6, r8
      b->_x[wds++] = a;
   27448:	e0863105 	add	r3, r6, r5, lsl #2
   2744c:	e2855001 	add	r5, r5, #1
   27450:	e5834014 	str	r4, [r3, #20]
      b->_wds = wds;
   27454:	e5865010 	str	r5, [r6, #16]
   27458:	eaffffe6 	b	273f8 <__multadd+0x74>
	  b1 = eBalloc (ptr, b->_k + 1);
   2745c:	e3093b10 	movw	r3, #39696	@ 0x9b10
   27460:	e3090b64 	movw	r0, #39780	@ 0x9b64
   27464:	e3403002 	movt	r3, #2
   27468:	e1a02008 	mov	r2, r8
   2746c:	e3a010ba 	mov	r1, #186	@ 0xba
   27470:	e3400002 	movt	r0, #2
   27474:	ebffbca9 	bl	16720 <__assert_func>

00027478 <__s2b>:
s2b (struct _reent * ptr,
	const char *s,
	int nd0,
	int nd,
	__ULong y9)
{
   27478:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
   2747c:	e1a07002 	mov	r7, r2
  _Bigint *b;
  int i, k;
  __Long x, y;

  x = (nd + 8) / 9;
   27480:	e3082e39 	movw	r2, #36409	@ 0x8e39
{
   27484:	e1a05003 	mov	r5, r3
  for (k = 0, y = 1; x > y; y <<= 1, k++);
   27488:	e3530009 	cmp	r3, #9
  x = (nd + 8) / 9;
   2748c:	e34328e3 	movt	r2, #14563	@ 0x38e3
   27490:	e2833008 	add	r3, r3, #8
{
   27494:	e1a04001 	mov	r4, r1
  x = (nd + 8) / 9;
   27498:	e0c21392 	smull	r1, r2, r2, r3
   2749c:	e1a03fc3 	asr	r3, r3, #31
{
   274a0:	e1a06000 	mov	r6, r0
  x = (nd + 8) / 9;
   274a4:	e06330c2 	rsb	r3, r3, r2, asr #1
  for (k = 0, y = 1; x > y; y <<= 1, k++);
   274a8:	da00002d 	ble	27564 <__s2b+0xec>
   274ac:	e3a0c001 	mov	ip, #1
   274b0:	e3a01000 	mov	r1, #0
   274b4:	e1a0c08c 	lsl	ip, ip, #1
   274b8:	e2811001 	add	r1, r1, #1
   274bc:	e153000c 	cmp	r3, ip
   274c0:	cafffffb 	bgt	274b4 <__s2b+0x3c>
#ifdef Pack_32
  b = eBalloc (ptr, k);
   274c4:	e1a00006 	mov	r0, r6
   274c8:	ebffff84 	bl	272e0 <_Balloc>
   274cc:	e2501000 	subs	r1, r0, #0
   274d0:	0a000025 	beq	2756c <__s2b+0xf4>
  b->_x[0] = y9;
   274d4:	e59d3020 	ldr	r3, [sp, #32]
  b->_x[0] = y9 & 0xffff;
  b->_wds = (b->_x[1] = y9 >> 16) ? 2 : 1;
#endif

  i = 9;
  if (9 < nd0)
   274d8:	e3570009 	cmp	r7, #9
	b = multadd (ptr, b, 10, *s++ - '0');
      while (++i < nd0);
      s++;
    }
  else
    s += 10;
   274dc:	d284400a 	addle	r4, r4, #10
  i = 9;
   274e0:	d3a07009 	movle	r7, #9
  b->_x[0] = y9;
   274e4:	e5813014 	str	r3, [r1, #20]
  b->_wds = 1;
   274e8:	e3a03001 	mov	r3, #1
   274ec:	e5813010 	str	r3, [r1, #16]
  if (9 < nd0)
   274f0:	ca00000d 	bgt	2752c <__s2b+0xb4>
  for (; i < nd; i++)
   274f4:	e1550007 	cmp	r5, r7
   274f8:	da000009 	ble	27524 <__s2b+0xac>
   274fc:	e0455007 	sub	r5, r5, r7
   27500:	e0845005 	add	r5, r4, r5
    b = multadd (ptr, b, 10, *s++ - '0');
   27504:	e4d43001 	ldrb	r3, [r4], #1
   27508:	e3a0200a 	mov	r2, #10
   2750c:	e1a00006 	mov	r0, r6
   27510:	e2433030 	sub	r3, r3, #48	@ 0x30
   27514:	ebffff9a 	bl	27384 <__multadd>
  for (; i < nd; i++)
   27518:	e1540005 	cmp	r4, r5
    b = multadd (ptr, b, 10, *s++ - '0');
   2751c:	e1a01000 	mov	r1, r0
  for (; i < nd; i++)
   27520:	1afffff7 	bne	27504 <__s2b+0x8c>
  return b;
}
   27524:	e1a00001 	mov	r0, r1
   27528:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
      s += 9;
   2752c:	e2848009 	add	r8, r4, #9
   27530:	e0849007 	add	r9, r4, r7
   27534:	e1a04008 	mov	r4, r8
	b = multadd (ptr, b, 10, *s++ - '0');
   27538:	e4d43001 	ldrb	r3, [r4], #1
   2753c:	e3a0200a 	mov	r2, #10
   27540:	e1a00006 	mov	r0, r6
   27544:	e2433030 	sub	r3, r3, #48	@ 0x30
   27548:	ebffff8d 	bl	27384 <__multadd>
      while (++i < nd0);
   2754c:	e1540009 	cmp	r4, r9
	b = multadd (ptr, b, 10, *s++ - '0');
   27550:	e1a01000 	mov	r1, r0
      while (++i < nd0);
   27554:	1afffff7 	bne	27538 <__s2b+0xc0>
      s++;
   27558:	e2474008 	sub	r4, r7, #8
   2755c:	e0884004 	add	r4, r8, r4
   27560:	eaffffe3 	b	274f4 <__s2b+0x7c>
  for (k = 0, y = 1; x > y; y <<= 1, k++);
   27564:	e3a01000 	mov	r1, #0
   27568:	eaffffd5 	b	274c4 <__s2b+0x4c>
  b = eBalloc (ptr, k);
   2756c:	e3093b10 	movw	r3, #39696	@ 0x9b10
   27570:	e3090b64 	movw	r0, #39780	@ 0x9b64
   27574:	e1a02001 	mov	r2, r1
   27578:	e3403002 	movt	r3, #2
   2757c:	e3a010d3 	mov	r1, #211	@ 0xd3
   27580:	e3400002 	movt	r0, #2
   27584:	ebffbc65 	bl	16720 <__assert_func>

00027588 <__hi0bits>:
int
hi0bits (register __ULong x)
{
  register int k = 0;

  if (!(x & 0xffff0000))
   27588:	e3500801 	cmp	r0, #65536	@ 0x10000
{
   2758c:	e1a03000 	mov	r3, r0
    {
      k = 16;
      x <<= 16;
   27590:	31a03800 	lslcc	r3, r0, #16
  register int k = 0;
   27594:	23a00000 	movcs	r0, #0
      k = 16;
   27598:	33a00010 	movcc	r0, #16
    }
  if (!(x & 0xff000000))
   2759c:	e3530401 	cmp	r3, #16777216	@ 0x1000000
    {
      k += 8;
      x <<= 8;
   275a0:	31a03403 	lslcc	r3, r3, #8
      k += 8;
   275a4:	32800008 	addcc	r0, r0, #8
    }
  if (!(x & 0xf0000000))
   275a8:	e373021f 	cmn	r3, #-268435455	@ 0xf0000001
    {
      k += 4;
      x <<= 4;
   275ac:	91a03203 	lslls	r3, r3, #4
      k += 4;
   275b0:	92800004 	addls	r0, r0, #4
    }
  if (!(x & 0xc0000000))
   275b4:	e3730107 	cmn	r3, #-1073741823	@ 0xc0000001
   275b8:	9a000002 	bls	275c8 <__hi0bits+0x40>
    {
      k += 2;
      x <<= 2;
    }
  if (!(x & 0x80000000))
   275bc:	e3530000 	cmp	r3, #0
    {
      k++;
   275c0:	a2800001 	addge	r0, r0, #1
      if (!(x & 0x40000000))
   275c4:	e12fff1e 	bx	lr
  if (!(x & 0x80000000))
   275c8:	e1b03103 	lsls	r3, r3, #2
   275cc:	4a000003 	bmi	275e0 <__hi0bits+0x58>
      if (!(x & 0x40000000))
   275d0:	e3130101 	tst	r3, #1073741824	@ 0x40000000
      k++;
   275d4:	12800003 	addne	r0, r0, #3
	return 32;
   275d8:	03a00020 	moveq	r0, #32
    }
  return k;
}
   275dc:	e12fff1e 	bx	lr
      k += 2;
   275e0:	e2800002 	add	r0, r0, #2
   275e4:	e12fff1e 	bx	lr

000275e8 <__lo0bits>:

int
lo0bits (__ULong *y)
{
  register int k;
  register __ULong x = *y;
   275e8:	e5903000 	ldr	r3, [r0]
{
   275ec:	e1a01000 	mov	r1, r0

  if (x & 7)
   275f0:	e2132007 	ands	r2, r3, #7
   275f4:	0a000008 	beq	2761c <__lo0bits+0x34>
    {
      if (x & 1)
   275f8:	e3130001 	tst	r3, #1
   275fc:	1a00001c 	bne	27674 <__lo0bits+0x8c>
	return 0;
      if (x & 2)
   27600:	e3130002 	tst	r3, #2
	{
	  *y = x >> 1;
   27604:	11a030a3 	lsrne	r3, r3, #1
	  return 1;
	}
      *y = x >> 2;
   27608:	01a03123 	lsreq	r3, r3, #2
	  return 1;
   2760c:	13a00001 	movne	r0, #1
      return 2;
   27610:	03a00002 	moveq	r0, #2
      *y = x >> 2;
   27614:	e5813000 	str	r3, [r1]
      return 2;
   27618:	e12fff1e 	bx	lr
    }
  k = 0;
  if (!(x & 0xffff))
   2761c:	e6ff0073 	uxth	r0, r3
   27620:	e3500000 	cmp	r0, #0
    {
      k = 16;
      x >>= 16;
   27624:	01a03823 	lsreq	r3, r3, #16
  k = 0;
   27628:	11a00002 	movne	r0, r2
      k = 16;
   2762c:	03a00010 	moveq	r0, #16
    }
  if (!(x & 0xff))
   27630:	e6ef2073 	uxtb	r2, r3
   27634:	e3520000 	cmp	r2, #0
    {
      k += 8;
      x >>= 8;
   27638:	01a03423 	lsreq	r3, r3, #8
      k += 8;
   2763c:	02800008 	addeq	r0, r0, #8
    }
  if (!(x & 0xf))
   27640:	e313000f 	tst	r3, #15
    {
      k += 4;
      x >>= 4;
   27644:	01a03223 	lsreq	r3, r3, #4
      k += 4;
   27648:	02800004 	addeq	r0, r0, #4
    }
  if (!(x & 0x3))
   2764c:	e3130003 	tst	r3, #3
    {
      k += 2;
      x >>= 2;
   27650:	01a03123 	lsreq	r3, r3, #2
      k += 2;
   27654:	02800002 	addeq	r0, r0, #2
    }
  if (!(x & 1))
   27658:	e3130001 	tst	r3, #1
   2765c:	1a000002 	bne	2766c <__lo0bits+0x84>
    {
      k++;
      x >>= 1;
      if (!x & 1)
   27660:	e1b030a3 	lsrs	r3, r3, #1
      k++;
   27664:	e2800001 	add	r0, r0, #1
      if (!x & 1)
   27668:	0a000003 	beq	2767c <__lo0bits+0x94>
	return 32;
    }
  *y = x;
   2766c:	e5813000 	str	r3, [r1]
  return k;
   27670:	e12fff1e 	bx	lr
	return 0;
   27674:	e3a00000 	mov	r0, #0
   27678:	e12fff1e 	bx	lr
	return 32;
   2767c:	e3a00020 	mov	r0, #32
}
   27680:	e12fff1e 	bx	lr

00027684 <__i2b>:
  if (_REENT_MP_FREELIST(ptr) == NULL)
   27684:	e5903044 	ldr	r3, [r0, #68]	@ 0x44

_Bigint *
i2b (struct _reent * ptr, int i)
{
   27688:	e92d4070 	push	{r4, r5, r6, lr}
   2768c:	e1a04000 	mov	r4, r0
   27690:	e1a05001 	mov	r5, r1
  if (_REENT_MP_FREELIST(ptr) == NULL)
   27694:	e3530000 	cmp	r3, #0
   27698:	0a000009 	beq	276c4 <__i2b+0x40>
  if ((rv = _REENT_MP_FREELIST(ptr)[k]) != 0)
   2769c:	e5930004 	ldr	r0, [r3, #4]
   276a0:	e3500000 	cmp	r0, #0
   276a4:	0a000014 	beq	276fc <__i2b+0x78>
      _REENT_MP_FREELIST(ptr)[k] = rv->_next;
   276a8:	e5902000 	ldr	r2, [r0]
   276ac:	e5832004 	str	r2, [r3, #4]
  rv->_sign = rv->_wds = 0;
   276b0:	e3a02000 	mov	r2, #0
   276b4:	e3a03001 	mov	r3, #1
  _Bigint *b;

  b = eBalloc (ptr, 1);
  b->_x[0] = i;
   276b8:	e5805014 	str	r5, [r0, #20]
  rv->_sign = rv->_wds = 0;
   276bc:	e1c020fc 	strd	r2, [r0, #12]
  b->_wds = 1;
  return b;
}
   276c0:	e8bd8070 	pop	{r4, r5, r6, pc}
      _REENT_MP_FREELIST(ptr) = (struct _Bigint **) _calloc_r (ptr, 
   276c4:	e3a02021 	mov	r2, #33	@ 0x21
   276c8:	e3a01004 	mov	r1, #4
   276cc:	eb00030c 	bl	28304 <_calloc_r>
      if (_REENT_MP_FREELIST(ptr) == NULL)
   276d0:	e3500000 	cmp	r0, #0
      _REENT_MP_FREELIST(ptr) = (struct _Bigint **) _calloc_r (ptr, 
   276d4:	e1a03000 	mov	r3, r0
   276d8:	e5840044 	str	r0, [r4, #68]	@ 0x44
      if (_REENT_MP_FREELIST(ptr) == NULL)
   276dc:	1affffee 	bne	2769c <__i2b+0x18>
  b = eBalloc (ptr, 1);
   276e0:	e3093b10 	movw	r3, #39696	@ 0x9b10
   276e4:	e3090b64 	movw	r0, #39780	@ 0x9b64
   276e8:	e3403002 	movt	r3, #2
   276ec:	e3a02000 	mov	r2, #0
   276f0:	e3001145 	movw	r1, #325	@ 0x145
   276f4:	e3400002 	movt	r0, #2
   276f8:	ebffbc08 	bl	16720 <__assert_func>
      rv = (_Bigint *) _calloc_r (ptr,
   276fc:	e3a0201c 	mov	r2, #28
   27700:	e3a01001 	mov	r1, #1
   27704:	e1a00004 	mov	r0, r4
   27708:	eb0002fd 	bl	28304 <_calloc_r>
      if (rv == NULL) return NULL;
   2770c:	e3500000 	cmp	r0, #0
   27710:	0afffff2 	beq	276e0 <__i2b+0x5c>
      rv->_k = k;
   27714:	e3a02001 	mov	r2, #1
   27718:	e3a03002 	mov	r3, #2
   2771c:	e1c020f4 	strd	r2, [r0, #4]
   27720:	eaffffe2 	b	276b0 <__i2b+0x2c>

00027724 <__multiply>:

_Bigint *
mult (struct _reent * ptr, _Bigint * a, _Bigint * b)
{
   27724:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   27728:	e1a0a002 	mov	sl, r2
  __ULong *x, *xa, *xae, *xb, *xbe, *xc, *xc0;
#ifdef Pack_32
  __ULong z2;
#endif

  if (a->_wds < b->_wds)
   2772c:	e5918010 	ldr	r8, [r1, #16]
{
   27730:	e1a06001 	mov	r6, r1
   27734:	e24dd014 	sub	sp, sp, #20
  if (a->_wds < b->_wds)
   27738:	e5923010 	ldr	r3, [r2, #16]
   2773c:	e1580003 	cmp	r8, r3
   27740:	b1a0a002 	movlt	sl, r2
   27744:	a1a0a001 	movge	sl, r1
   27748:	a1a06002 	movge	r6, r2
    }
  k = a->_k;
  wa = a->_wds;
  wb = b->_wds;
  wc = wa + wb;
  if (wc > a->_maxwds)
   2774c:	e59a2008 	ldr	r2, [sl, #8]
  if (a->_wds < b->_wds)
   27750:	b1a05003 	movlt	r5, r3
   27754:	a1a05008 	movge	r5, r8
   27758:	b1a06001 	movlt	r6, r1
   2775c:	a1a08003 	movge	r8, r3
  k = a->_k;
   27760:	e59a1004 	ldr	r1, [sl, #4]
  wc = wa + wb;
   27764:	e0854008 	add	r4, r5, r8
  if (wc > a->_maxwds)
   27768:	e1520004 	cmp	r2, r4
    k++;
   2776c:	b2811001 	addlt	r1, r1, #1
  c = eBalloc (ptr, k);
   27770:	ebfffeda 	bl	272e0 <_Balloc>
   27774:	e250c000 	subs	ip, r0, #0
   27778:	0a000064 	beq	27910 <__multiply+0x1ec>
  for (x = c->_x, xa = x + wc; x < xa; x++)
   2777c:	e28c7014 	add	r7, ip, #20
   27780:	e087e104 	add	lr, r7, r4, lsl #2
   27784:	e157000e 	cmp	r7, lr
   27788:	31a03007 	movcc	r3, r7
    *x = 0;
   2778c:	33a02000 	movcc	r2, #0
  for (x = c->_x, xa = x + wc; x < xa; x++)
   27790:	2a000002 	bcs	277a0 <__multiply+0x7c>
    *x = 0;
   27794:	e4832004 	str	r2, [r3], #4
  for (x = c->_x, xa = x + wc; x < xa; x++)
   27798:	e15e0003 	cmp	lr, r3
   2779c:	8afffffc 	bhi	27794 <__multiply+0x70>
  xa = a->_x;
  xae = xa + wa;
  xb = b->_x;
   277a0:	e2866014 	add	r6, r6, #20
  xa = a->_x;
   277a4:	e28a9014 	add	r9, sl, #20
  xbe = xb + wb;
   277a8:	e0868108 	add	r8, r6, r8, lsl #2
  xae = xa + wa;
   277ac:	e0895105 	add	r5, r9, r5, lsl #2
  xc0 = c->_x;
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
   277b0:	e1560008 	cmp	r6, r8
   277b4:	2a000049 	bcs	278e0 <__multiply+0x1bc>
   277b8:	e045300a 	sub	r3, r5, sl
   277bc:	e28aa015 	add	sl, sl, #21
   277c0:	e2433015 	sub	r3, r3, #21
   277c4:	e155000a 	cmp	r5, sl
   277c8:	e3c33003 	bic	r3, r3, #3
   277cc:	33a0b004 	movcc	fp, #4
   277d0:	e2833004 	add	r3, r3, #4
   277d4:	e1a0a00c 	mov	sl, ip
   277d8:	21a0b003 	movcs	fp, r3
   277dc:	e58de008 	str	lr, [sp, #8]
   277e0:	e58d400c 	str	r4, [sp, #12]
   277e4:	ea000004 	b	277fc <__multiply+0xd8>
	      Storeinc (xc, z2, z);
	    }
	  while (x < xae);
	  *xc = carry;
	}
      if ((y = *xb >> 16) != 0)
   277e8:	e1b01821 	lsrs	r1, r1, #16
   277ec:	1a00001f 	bne	27870 <__multiply+0x14c>
  for (; xb < xbe; xb++, xc0++)
   277f0:	e1580006 	cmp	r8, r6
   277f4:	e2877004 	add	r7, r7, #4
   277f8:	9a000035 	bls	278d4 <__multiply+0x1b0>
      if ((y = *xb & 0xffff) != 0)
   277fc:	e4961004 	ldr	r1, [r6], #4
   27800:	e6ff4071 	uxth	r4, r1
   27804:	e3540000 	cmp	r4, #0
   27808:	0afffff6 	beq	277e8 <__multiply+0xc4>
   2780c:	e1a0e009 	mov	lr, r9
	  xc = xc0;
   27810:	e1a0c007 	mov	ip, r7
	  carry = 0;
   27814:	e3a03000 	mov	r3, #0
   27818:	e58d6004 	str	r6, [sp, #4]
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
   2781c:	e49e0004 	ldr	r0, [lr], #4
   27820:	e59c1000 	ldr	r1, [ip]
	  while (x < xae);
   27824:	e155000e 	cmp	r5, lr
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
   27828:	e6ff6070 	uxth	r6, r0
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
   2782c:	e1a00820 	lsr	r0, r0, #16
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
   27830:	e6ff2071 	uxth	r2, r1
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
   27834:	e1a01821 	lsr	r1, r1, #16
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
   27838:	e0222694 	mla	r2, r4, r6, r2
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
   2783c:	e0211094 	mla	r1, r4, r0, r1
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
   27840:	e0822003 	add	r2, r2, r3
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
   27844:	e0811822 	add	r1, r1, r2, lsr #16
	      Storeinc (xc, z2, z);
   27848:	e6ff2072 	uxth	r2, r2
   2784c:	e1822801 	orr	r2, r2, r1, lsl #16
	      carry = z2 >> 16;
   27850:	e1a03821 	lsr	r3, r1, #16
	      Storeinc (xc, z2, z);
   27854:	e48c2004 	str	r2, [ip], #4
	  while (x < xae);
   27858:	8affffef 	bhi	2781c <__multiply+0xf8>
	  *xc = carry;
   2785c:	e59d6004 	ldr	r6, [sp, #4]
   27860:	e787300b 	str	r3, [r7, fp]
      if ((y = *xb >> 16) != 0)
   27864:	e5161004 	ldr	r1, [r6, #-4]
   27868:	e1b01821 	lsrs	r1, r1, #16
   2786c:	0affffdf 	beq	277f0 <__multiply+0xcc>
	{
	  x = xa;
	  xc = xc0;
	  carry = 0;
	  z2 = *xc;
   27870:	e5973000 	ldr	r3, [r7]
	  carry = 0;
   27874:	e3a02000 	mov	r2, #0
   27878:	e1a00009 	mov	r0, r9
	  xc = xc0;
   2787c:	e1a0e007 	mov	lr, r7
	  z2 = *xc;
   27880:	e1a04002 	mov	r4, r2
   27884:	e1a0c003 	mov	ip, r3
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc >> 16) + carry;
   27888:	e1d020b0 	ldrh	r2, [r0]
	      carry = z >> 16;
	      Storeinc (xc, z, z2);
   2788c:	e6ff3073 	uxth	r3, r3
	      z = (*x & 0xffff) * y + (*xc >> 16) + carry;
   27890:	e0224291 	mla	r2, r1, r2, r4
   27894:	e082282c 	add	r2, r2, ip, lsr #16
	      Storeinc (xc, z, z2);
   27898:	e1833802 	orr	r3, r3, r2, lsl #16
   2789c:	e48e3004 	str	r3, [lr], #4
	      z2 = (*x++ >> 16) * y + (*xc & 0xffff) + carry;
   278a0:	e4904004 	ldr	r4, [r0], #4
   278a4:	e59ec000 	ldr	ip, [lr]
	      carry = z2 >> 16;
	    }
	  while (x < xae);
   278a8:	e1500005 	cmp	r0, r5
	      z2 = (*x++ >> 16) * y + (*xc & 0xffff) + carry;
   278ac:	e1a04824 	lsr	r4, r4, #16
   278b0:	e6ff307c 	uxth	r3, ip
   278b4:	e0233491 	mla	r3, r1, r4, r3
   278b8:	e0833822 	add	r3, r3, r2, lsr #16
	      carry = z2 >> 16;
   278bc:	e1a04823 	lsr	r4, r3, #16
	  while (x < xae);
   278c0:	3afffff0 	bcc	27888 <__multiply+0x164>
  for (; xb < xbe; xb++, xc0++)
   278c4:	e1580006 	cmp	r8, r6
	  *xc = z2;
   278c8:	e787300b 	str	r3, [r7, fp]
  for (; xb < xbe; xb++, xc0++)
   278cc:	e2877004 	add	r7, r7, #4
   278d0:	8affffc9 	bhi	277fc <__multiply+0xd8>
   278d4:	e59de008 	ldr	lr, [sp, #8]
   278d8:	e1a0c00a 	mov	ip, sl
   278dc:	e59d400c 	ldr	r4, [sp, #12]
	  while (x < xae);
	  *xc = carry;
	}
    }
#endif
  for (xc0 = c->_x, xc = xc0 + wc; wc > 0 && !*--xc; --wc);
   278e0:	e3540000 	cmp	r4, #0
   278e4:	ca000002 	bgt	278f4 <__multiply+0x1d0>
   278e8:	ea000004 	b	27900 <__multiply+0x1dc>
   278ec:	e2544001 	subs	r4, r4, #1
   278f0:	0a000002 	beq	27900 <__multiply+0x1dc>
   278f4:	e53e3004 	ldr	r3, [lr, #-4]!
   278f8:	e3530000 	cmp	r3, #0
   278fc:	0afffffa 	beq	278ec <__multiply+0x1c8>
  c->_wds = wc;
  return c;
}
   27900:	e1a0000c 	mov	r0, ip
  c->_wds = wc;
   27904:	e58c4010 	str	r4, [ip, #16]
}
   27908:	e28dd014 	add	sp, sp, #20
   2790c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  c = eBalloc (ptr, k);
   27910:	e3093b10 	movw	r3, #39696	@ 0x9b10
   27914:	e3090b64 	movw	r0, #39780	@ 0x9b64
   27918:	e3403002 	movt	r3, #2
   2791c:	e1a0200c 	mov	r2, ip
   27920:	e3001162 	movw	r1, #354	@ 0x162
   27924:	e3400002 	movt	r0, #2
   27928:	ebffbb7c 	bl	16720 <__assert_func>

0002792c <__pow5mult>:
{
  _Bigint *b1, *p5, *p51;
  int i;
  static const int p05[3] = {5, 25, 125};

  if ((i = k & 3) != 0)
   2792c:	e2123003 	ands	r3, r2, #3
{
   27930:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
   27934:	e1a04002 	mov	r4, r2
   27938:	e1a07000 	mov	r7, r0
   2793c:	01a05001 	moveq	r5, r1
  if ((i = k & 3) != 0)
   27940:	1a000025 	bne	279dc <__pow5mult+0xb0>
    b = multadd (ptr, b, p05[i - 1], 0);

  if (!(k >>= 2))
   27944:	e1b04144 	asrs	r4, r4, #2
   27948:	0a00001a 	beq	279b8 <__pow5mult+0x8c>
    return b;
  _REENT_CHECK_MP(ptr);
  if (!(p5 = _REENT_MP_P5S(ptr)))
   2794c:	e5976040 	ldr	r6, [r7, #64]	@ 0x40
   27950:	e3560000 	cmp	r6, #0
   27954:	0a000028 	beq	279fc <__pow5mult+0xd0>
      if (!(k >>= 1))
	break;
      if (!(p51 = p5->_next))
	{
	  p51 = p5->_next = mult (ptr, p5, p5);
	  p51->_next = 0;
   27958:	e3a08000 	mov	r8, #0
   2795c:	ea000005 	b	27978 <__pow5mult+0x4c>
      if (!(k >>= 1))
   27960:	e1b040c4 	asrs	r4, r4, #1
   27964:	0a000013 	beq	279b8 <__pow5mult+0x8c>
      if (!(p51 = p5->_next))
   27968:	e5960000 	ldr	r0, [r6]
   2796c:	e3500000 	cmp	r0, #0
   27970:	0a000012 	beq	279c0 <__pow5mult+0x94>
{
   27974:	e1a06000 	mov	r6, r0
      if (k & 1)
   27978:	e3140001 	tst	r4, #1
   2797c:	0afffff7 	beq	27960 <__pow5mult+0x34>
	  b1 = mult (ptr, b, p5);
   27980:	e1a02006 	mov	r2, r6
   27984:	e1a01005 	mov	r1, r5
   27988:	e1a00007 	mov	r0, r7
   2798c:	ebffff64 	bl	27724 <__multiply>
  if (v)
   27990:	e3550000 	cmp	r5, #0
   27994:	0a000004 	beq	279ac <__pow5mult+0x80>
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   27998:	e5973044 	ldr	r3, [r7, #68]	@ 0x44
   2799c:	e5952004 	ldr	r2, [r5, #4]
   279a0:	e7931102 	ldr	r1, [r3, r2, lsl #2]
   279a4:	e5851000 	str	r1, [r5]
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
   279a8:	e7835102 	str	r5, [r3, r2, lsl #2]
      if (!(k >>= 1))
   279ac:	e1b040c4 	asrs	r4, r4, #1
	  b = b1;
   279b0:	e1a05000 	mov	r5, r0
      if (!(k >>= 1))
   279b4:	1affffeb 	bne	27968 <__pow5mult+0x3c>
	}
      p5 = p51;
    }
  return b;
}
   279b8:	e1a00005 	mov	r0, r5
   279bc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
	  p51 = p5->_next = mult (ptr, p5, p5);
   279c0:	e1a02006 	mov	r2, r6
   279c4:	e1a01006 	mov	r1, r6
   279c8:	e1a00007 	mov	r0, r7
   279cc:	ebffff54 	bl	27724 <__multiply>
   279d0:	e5860000 	str	r0, [r6]
	  p51->_next = 0;
   279d4:	e5808000 	str	r8, [r0]
   279d8:	eaffffe5 	b	27974 <__pow5mult+0x48>
    b = multadd (ptr, b, p05[i - 1], 0);
   279dc:	e30a2108 	movw	r2, #41224	@ 0xa108
   279e0:	e2433001 	sub	r3, r3, #1
   279e4:	e3402002 	movt	r2, #2
   279e8:	e7922103 	ldr	r2, [r2, r3, lsl #2]
   279ec:	e3a03000 	mov	r3, #0
   279f0:	ebfffe63 	bl	27384 <__multadd>
   279f4:	e1a05000 	mov	r5, r0
   279f8:	eaffffd1 	b	27944 <__pow5mult+0x18>
  b = eBalloc (ptr, 1);
   279fc:	e3a01001 	mov	r1, #1
   27a00:	e1a00007 	mov	r0, r7
   27a04:	ebfffe35 	bl	272e0 <_Balloc>
   27a08:	e2506000 	subs	r6, r0, #0
   27a0c:	0a000006 	beq	27a2c <__pow5mult+0x100>
  b->_wds = 1;
   27a10:	e3a00001 	mov	r0, #1
   27a14:	e3001271 	movw	r1, #625	@ 0x271
      p5->_next = 0;
   27a18:	e3a03000 	mov	r3, #0
  b->_wds = 1;
   27a1c:	e1c601f0 	strd	r0, [r6, #16]
      p5 = _REENT_MP_P5S(ptr) = i2b (ptr, 625);
   27a20:	e5876040 	str	r6, [r7, #64]	@ 0x40
      p5->_next = 0;
   27a24:	e5863000 	str	r3, [r6]
   27a28:	eaffffca 	b	27958 <__pow5mult+0x2c>
  b = eBalloc (ptr, 1);
   27a2c:	e3093b10 	movw	r3, #39696	@ 0x9b10
   27a30:	e3090b64 	movw	r0, #39780	@ 0x9b64
   27a34:	e3403002 	movt	r3, #2
   27a38:	e1a02006 	mov	r2, r6
   27a3c:	e3001145 	movw	r1, #325	@ 0x145
   27a40:	e3400002 	movt	r0, #2
   27a44:	ebffbb35 	bl	16720 <__assert_func>

00027a48 <__lshift>:

_Bigint *
lshift (struct _reent * ptr, _Bigint * b, int k)
{
   27a48:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
   27a4c:	e1a04001 	mov	r4, r1
  n = k >> 5;
#else
  n = k >> 4;
#endif
  k1 = b->_k;
  n1 = n + b->_wds + 1;
   27a50:	e5947010 	ldr	r7, [r4, #16]
  n = k >> 5;
   27a54:	e1a092c2 	asr	r9, r2, #5
{
   27a58:	e1a08002 	mov	r8, r2
  for (i = b->_maxwds; n1 > i; i <<= 1)
   27a5c:	e5943008 	ldr	r3, [r4, #8]
{
   27a60:	e1a06000 	mov	r6, r0
  n1 = n + b->_wds + 1;
   27a64:	e0897007 	add	r7, r9, r7
  k1 = b->_k;
   27a68:	e5911004 	ldr	r1, [r1, #4]
  n1 = n + b->_wds + 1;
   27a6c:	e2875001 	add	r5, r7, #1
  for (i = b->_maxwds; n1 > i; i <<= 1)
   27a70:	e1550003 	cmp	r5, r3
   27a74:	da000003 	ble	27a88 <__lshift+0x40>
   27a78:	e1a03083 	lsl	r3, r3, #1
    k1++;
   27a7c:	e2811001 	add	r1, r1, #1
  for (i = b->_maxwds; n1 > i; i <<= 1)
   27a80:	e1550003 	cmp	r5, r3
   27a84:	cafffffb 	bgt	27a78 <__lshift+0x30>
  b1 = eBalloc (ptr, k1);
   27a88:	e1a00006 	mov	r0, r6
   27a8c:	ebfffe13 	bl	272e0 <_Balloc>
   27a90:	e250e000 	subs	lr, r0, #0
   27a94:	0a000034 	beq	27b6c <__lshift+0x124>
  x1 = b1->_x;
  for (i = 0; i < n; i++)
   27a98:	e3590000 	cmp	r9, #0
  x1 = b1->_x;
   27a9c:	e28e0014 	add	r0, lr, #20
  for (i = 0; i < n; i++)
   27aa0:	da000009 	ble	27acc <__lshift+0x84>
   27aa4:	e2899005 	add	r9, r9, #5
  x1 = b1->_x;
   27aa8:	e1a03000 	mov	r3, r0
   27aac:	e1a09109 	lsl	r9, r9, #2
    *x1++ = 0;
   27ab0:	e3a01000 	mov	r1, #0
   27ab4:	e08e2009 	add	r2, lr, r9
   27ab8:	e4831004 	str	r1, [r3], #4
  for (i = 0; i < n; i++)
   27abc:	e1530002 	cmp	r3, r2
   27ac0:	1afffffc 	bne	27ab8 <__lshift+0x70>
   27ac4:	e2499014 	sub	r9, r9, #20
   27ac8:	e0800009 	add	r0, r0, r9
  x = b->_x;
  xe = x + b->_wds;
   27acc:	e5942010 	ldr	r2, [r4, #16]
#ifdef Pack_32
  if (k &= 0x1f)
   27ad0:	e218801f 	ands	r8, r8, #31
  x = b->_x;
   27ad4:	e2843014 	add	r3, r4, #20
  xe = x + b->_wds;
   27ad8:	e0832102 	add	r2, r3, r2, lsl #2
  if (k &= 0x1f)
   27adc:	0a00001c 	beq	27b54 <__lshift+0x10c>
    {
      k1 = 32 - k;
   27ae0:	e268a020 	rsb	sl, r8, #32
   27ae4:	e1a09000 	mov	r9, r0
      z = 0;
   27ae8:	e3a0c000 	mov	ip, #0
      do
	{
	  *x1++ = *x << k | z;
   27aec:	e5931000 	ldr	r1, [r3]
   27af0:	e18c1811 	orr	r1, ip, r1, lsl r8
   27af4:	e4891004 	str	r1, [r9], #4
	  z = *x++ >> k1;
   27af8:	e493c004 	ldr	ip, [r3], #4
	}
      while (x < xe);
   27afc:	e1520003 	cmp	r2, r3
	  z = *x++ >> k1;
   27b00:	e1a0ca3c 	lsr	ip, ip, sl
      while (x < xe);
   27b04:	8afffff8 	bhi	27aec <__lshift+0xa4>
      if ((*x1 = z) != 0)
   27b08:	e0423004 	sub	r3, r2, r4
   27b0c:	e2841015 	add	r1, r4, #21
   27b10:	e2433015 	sub	r3, r3, #21
   27b14:	e1520001 	cmp	r2, r1
   27b18:	e3c33003 	bic	r3, r3, #3
   27b1c:	e2833004 	add	r3, r3, #4
   27b20:	33a03004 	movcc	r3, #4
   27b24:	e35c0000 	cmp	ip, #0
   27b28:	e780c003 	str	ip, [r0, r3]
   27b2c:	1a000000 	bne	27b34 <__lshift+0xec>
      z = 0;
   27b30:	e1a05007 	mov	r5, r7
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   27b34:	e5963044 	ldr	r3, [r6, #68]	@ 0x44
      *x1++ = *x++;
    while (x < xe);
  b1->_wds = n1 - 1;
  Bfree (ptr, b);
  return b1;
}
   27b38:	e1a0000e 	mov	r0, lr
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   27b3c:	e5942004 	ldr	r2, [r4, #4]
  b1->_wds = n1 - 1;
   27b40:	e58e5010 	str	r5, [lr, #16]
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   27b44:	e7931102 	ldr	r1, [r3, r2, lsl #2]
   27b48:	e5841000 	str	r1, [r4]
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
   27b4c:	e7834102 	str	r4, [r3, r2, lsl #2]
}
   27b50:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
   27b54:	e2401004 	sub	r1, r0, #4
      *x1++ = *x++;
   27b58:	e4930004 	ldr	r0, [r3], #4
    while (x < xe);
   27b5c:	e1520003 	cmp	r2, r3
      *x1++ = *x++;
   27b60:	e5a10004 	str	r0, [r1, #4]!
    while (x < xe);
   27b64:	8afffffb 	bhi	27b58 <__lshift+0x110>
   27b68:	eafffff0 	b	27b30 <__lshift+0xe8>
  b1 = eBalloc (ptr, k1);
   27b6c:	e3093b10 	movw	r3, #39696	@ 0x9b10
   27b70:	e3090b64 	movw	r0, #39780	@ 0x9b64
   27b74:	e3403002 	movt	r3, #2
   27b78:	e1a0200e 	mov	r2, lr
   27b7c:	e30011de 	movw	r1, #478	@ 0x1de
   27b80:	e3400002 	movt	r0, #2
   27b84:	ebffbae5 	bl	16720 <__assert_func>

00027b88 <__mcmp>:

int
cmp (_Bigint * a, _Bigint * b)
{
   27b88:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
   27b8c:	e1a0e000 	mov	lr, r0
  __ULong *xa, *xa0, *xb, *xb0;
  int i, j;

  i = a->_wds;
  j = b->_wds;
   27b90:	e5913010 	ldr	r3, [r1, #16]
  i = a->_wds;
   27b94:	e5900010 	ldr	r0, [r0, #16]
  if (i > 1 && !a->_x[i - 1])
    Bug ("cmp called with a->_x[a->_wds-1] == 0");
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
   27b98:	e0500003 	subs	r0, r0, r3
   27b9c:	149df004 	popne	{pc}		@ (ldrne pc, [sp], #4)
    return i;
  xa0 = a->_x;
  xa = xa0 + j;
   27ba0:	e1a03103 	lsl	r3, r3, #2
  xa0 = a->_x;
   27ba4:	e28ee014 	add	lr, lr, #20
  xb0 = b->_x;
   27ba8:	e2811014 	add	r1, r1, #20
  xa = xa0 + j;
   27bac:	e08e2003 	add	r2, lr, r3
  xb = xb0 + j;
   27bb0:	e0813003 	add	r3, r1, r3
   27bb4:	ea000001 	b	27bc0 <__mcmp+0x38>
  for (;;)
    {
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
      if (xa <= xa0)
   27bb8:	e15e0002 	cmp	lr, r2
   27bbc:	249df004 	popcs	{pc}		@ (ldrcs pc, [sp], #4)
      if (*--xa != *--xb)
   27bc0:	e532c004 	ldr	ip, [r2, #-4]!
   27bc4:	e5331004 	ldr	r1, [r3, #-4]!
   27bc8:	e15c0001 	cmp	ip, r1
   27bcc:	0afffff9 	beq	27bb8 <__mcmp+0x30>
	return *xa < *xb ? -1 : 1;
   27bd0:	2a000001 	bcs	27bdc <__mcmp+0x54>
   27bd4:	e3e00000 	mvn	r0, #0
   27bd8:	e49df004 	pop	{pc}		@ (ldr pc, [sp], #4)
   27bdc:	e3a00001 	mov	r0, #1
	break;
    }
  return 0;
}
   27be0:	e49df004 	pop	{pc}		@ (ldr pc, [sp], #4)

00027be4 <__mdiff>:

_Bigint *
diff (struct _reent * ptr,
	_Bigint * a, _Bigint * b)
{
   27be4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   27be8:	e1a04002 	mov	r4, r2
  j = b->_wds;
   27bec:	e5943010 	ldr	r3, [r4, #16]
{
   27bf0:	e24dd00c 	sub	sp, sp, #12
   27bf4:	e1a07001 	mov	r7, r1
  i = a->_wds;
   27bf8:	e5912010 	ldr	r2, [r1, #16]
  if (i -= j)
   27bfc:	e0422003 	sub	r2, r2, r3
   27c00:	e3520000 	cmp	r2, #0
   27c04:	1a00005b 	bne	27d78 <__mdiff+0x194>
  xa = xa0 + j;
   27c08:	e1a03103 	lsl	r3, r3, #2
  xa0 = a->_x;
   27c0c:	e281e014 	add	lr, r1, #20
  xb0 = b->_x;
   27c10:	e2841014 	add	r1, r4, #20
  xb = xb0 + j;
   27c14:	e0811003 	add	r1, r1, r3
  xa = xa0 + j;
   27c18:	e08e3003 	add	r3, lr, r3
  xb = xb0 + j;
   27c1c:	ea000001 	b	27c28 <__mdiff+0x44>
      if (xa <= xa0)
   27c20:	e15e0003 	cmp	lr, r3
   27c24:	2a000056 	bcs	27d84 <__mdiff+0x1a0>
      if (*--xa != *--xb)
   27c28:	e533c004 	ldr	ip, [r3, #-4]!
   27c2c:	e5312004 	ldr	r2, [r1, #-4]!
   27c30:	e15c0002 	cmp	ip, r2
   27c34:	0afffff9 	beq	27c20 <__mdiff+0x3c>
	return *xa < *xb ? -1 : 1;
   27c38:	3a00004f 	bcc	27d7c <__mdiff+0x198>
      c = eBalloc (ptr, 0);
      c->_wds = 1;
      c->_x[0] = 0;
      return c;
    }
  if (i < 0)
   27c3c:	e1a03004 	mov	r3, r4
      a = b;
      b = c;
      i = 1;
    }
  else
    i = 0;
   27c40:	e3a06000 	mov	r6, #0
  if (i < 0)
   27c44:	e1a04007 	mov	r4, r7
   27c48:	e1a07003 	mov	r7, r3
  c = eBalloc (ptr, a->_k);
   27c4c:	e5941004 	ldr	r1, [r4, #4]
   27c50:	ebfffda2 	bl	272e0 <_Balloc>
   27c54:	e2508000 	subs	r8, r0, #0
   27c58:	0a00005c 	beq	27dd0 <__mdiff+0x1ec>
  c->_sign = i;
  wa = a->_wds;
   27c5c:	e5945010 	ldr	r5, [r4, #16]
  xa = a->_x;
   27c60:	e284b014 	add	fp, r4, #20
  xae = xa + wa;
  wb = b->_wds;
  xb = b->_x;
  xbe = xb + wb;
   27c64:	e5979010 	ldr	r9, [r7, #16]
  xb = b->_x;
   27c68:	e2870014 	add	r0, r7, #20
  xc = c->_x;
   27c6c:	e288a014 	add	sl, r8, #20
  c->_sign = i;
   27c70:	e588600c 	str	r6, [r8, #12]
  xae = xa + wa;
   27c74:	e2842010 	add	r2, r4, #16
  xc = c->_x;
   27c78:	e1a0600a 	mov	r6, sl
  xae = xa + wa;
   27c7c:	e08b1105 	add	r1, fp, r5, lsl #2
  borrow = 0;
   27c80:	e3a03000 	mov	r3, #0
  xbe = xb + wb;
   27c84:	e0809109 	add	r9, r0, r9, lsl #2
  borrow = 0;
   27c88:	e58db004 	str	fp, [sp, #4]
#ifdef Pack_32
  do
    {
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
   27c8c:	e490e004 	ldr	lr, [r0], #4
   27c90:	e5b24004 	ldr	r4, [r2, #4]!
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
    }
  while (xb < xbe);
   27c94:	e1590000 	cmp	r9, r0
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
   27c98:	e6ffb07e 	uxth	fp, lr
   27c9c:	e6ffc074 	uxth	ip, r4
   27ca0:	e04cc00b 	sub	ip, ip, fp
   27ca4:	e08cc003 	add	ip, ip, r3
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
   27ca8:	e1a0382e 	lsr	r3, lr, #16
   27cac:	e0633824 	rsb	r3, r3, r4, lsr #16
   27cb0:	e083384c 	add	r3, r3, ip, asr #16
      Storeinc (xc, z, y);
   27cb4:	e6ffc07c 	uxth	ip, ip
   27cb8:	e18ce803 	orr	lr, ip, r3, lsl #16
      borrow = z >> 16;
   27cbc:	e1a03843 	asr	r3, r3, #16
      Storeinc (xc, z, y);
   27cc0:	e486e004 	str	lr, [r6], #4
  while (xb < xbe);
   27cc4:	8afffff0 	bhi	27c8c <__mdiff+0xa8>
   27cc8:	e0492007 	sub	r2, r9, r7
   27ccc:	e2877015 	add	r7, r7, #21
   27cd0:	e2422015 	sub	r2, r2, #21
   27cd4:	e1590007 	cmp	r9, r7
   27cd8:	e1a02122 	lsr	r2, r2, #2
   27cdc:	e59db004 	ldr	fp, [sp, #4]
   27ce0:	33a07000 	movcc	r7, #0
   27ce4:	23a07001 	movcs	r7, #1
   27ce8:	e282c001 	add	ip, r2, #1
   27cec:	e3570000 	cmp	r7, #0
   27cf0:	03a0c004 	moveq	ip, #4
   27cf4:	11a0c10c 	lslne	ip, ip, #2
   27cf8:	e08b400c 	add	r4, fp, ip
   27cfc:	e08ac00c 	add	ip, sl, ip
  while (xa < xae)
   27d00:	e1510004 	cmp	r1, r4
   27d04:	81a0600c 	movhi	r6, ip
   27d08:	81a00004 	movhi	r0, r4
   27d0c:	9a00002a 	bls	27dbc <__mdiff+0x1d8>
    {
      y = (*xa & 0xffff) + borrow;
   27d10:	e4902004 	ldr	r2, [r0], #4
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) + borrow;
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   27d14:	e082e003 	add	lr, r2, r3
  while (xa < xae)
   27d18:	e1510000 	cmp	r1, r0
      y = (*xa & 0xffff) + borrow;
   27d1c:	e6ff7072 	uxth	r7, r2
      z = (*xa++ >> 16) + borrow;
   27d20:	e1a02822 	lsr	r2, r2, #16
      Storeinc (xc, z, y);
   27d24:	e6ffe07e 	uxth	lr, lr
      y = (*xa & 0xffff) + borrow;
   27d28:	e0873003 	add	r3, r7, r3
      z = (*xa++ >> 16) + borrow;
   27d2c:	e0822843 	add	r2, r2, r3, asr #16
      Storeinc (xc, z, y);
   27d30:	e18ee802 	orr	lr, lr, r2, lsl #16
      borrow = z >> 16;
   27d34:	e1a03842 	asr	r3, r2, #16
      Storeinc (xc, z, y);
   27d38:	e486e004 	str	lr, [r6], #4
  while (xa < xae)
   27d3c:	8afffff3 	bhi	27d10 <__mdiff+0x12c>
   27d40:	e2411001 	sub	r1, r1, #1
   27d44:	e0411004 	sub	r1, r1, r4
   27d48:	e3c11003 	bic	r1, r1, #3
   27d4c:	e08cc001 	add	ip, ip, r1
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      *xc++ = y & 0xffff;
    }
#endif
  while (!*--xc)
   27d50:	e35e0000 	cmp	lr, #0
   27d54:	1a000003 	bne	27d68 <__mdiff+0x184>
   27d58:	e53c3004 	ldr	r3, [ip, #-4]!
    wa--;
   27d5c:	e2455001 	sub	r5, r5, #1
  while (!*--xc)
   27d60:	e3530000 	cmp	r3, #0
   27d64:	0afffffb 	beq	27d58 <__mdiff+0x174>
  c->_wds = wa;
   27d68:	e5885010 	str	r5, [r8, #16]
  return c;
}
   27d6c:	e1a00008 	mov	r0, r8
   27d70:	e28dd00c 	add	sp, sp, #12
   27d74:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (i < 0)
   27d78:	aaffffaf 	bge	27c3c <__mdiff+0x58>
      i = 1;
   27d7c:	e3a06001 	mov	r6, #1
   27d80:	eaffffb1 	b	27c4c <__mdiff+0x68>
      c = eBalloc (ptr, 0);
   27d84:	e3a01000 	mov	r1, #0
   27d88:	ebfffd54 	bl	272e0 <_Balloc>
   27d8c:	e2508000 	subs	r8, r0, #0
      c->_x[0] = 0;
   27d90:	13a02001 	movne	r2, #1
   27d94:	13a03000 	movne	r3, #0
   27d98:	11c821f0 	strdne	r2, [r8, #16]
      c = eBalloc (ptr, 0);
   27d9c:	1afffff2 	bne	27d6c <__mdiff+0x188>
   27da0:	e3093b10 	movw	r3, #39696	@ 0x9b10
   27da4:	e3090b64 	movw	r0, #39780	@ 0x9b64
   27da8:	e3403002 	movt	r3, #2
   27dac:	e1a02008 	mov	r2, r8
   27db0:	e3001237 	movw	r1, #567	@ 0x237
   27db4:	e3400002 	movt	r0, #2
   27db8:	ebffba58 	bl	16720 <__assert_func>
   27dbc:	e3570000 	cmp	r7, #0
   27dc0:	03a02000 	moveq	r2, #0
   27dc4:	11a02102 	lslne	r2, r2, #2
   27dc8:	e08ac002 	add	ip, sl, r2
   27dcc:	eaffffdf 	b	27d50 <__mdiff+0x16c>
  c = eBalloc (ptr, a->_k);
   27dd0:	e3093b10 	movw	r3, #39696	@ 0x9b10
   27dd4:	e3090b64 	movw	r0, #39780	@ 0x9b64
   27dd8:	e3403002 	movt	r3, #2
   27ddc:	e1a02008 	mov	r2, r8
   27de0:	e3001245 	movw	r1, #581	@ 0x245
   27de4:	e3400002 	movt	r0, #2
   27de8:	ebffba4c 	bl	16720 <__assert_func>

00027dec <__ulp>:
  union double_union x, a;
  register __Long L;

  x.d = _x;

  L = (word0 (x) & Exp_mask) - (P - 1) * Exp_msk1;
   27dec:	e3a03000 	mov	r3, #0
   27df0:	ee102a90 	vmov	r2, s1
   27df4:	e3473ff0 	movt	r3, #32752	@ 0x7ff0
   27df8:	e0033002 	and	r3, r3, r2
   27dfc:	e243350d 	sub	r3, r3, #54525952	@ 0x3400000
#ifndef Sudden_Underflow
  if (L > 0)
   27e00:	e3530000 	cmp	r3, #0
   27e04:	c3a02000 	movgt	r2, #0
   27e08:	da000003 	ble	27e1c <__ulp+0x30>
    {
#endif
#ifdef IBM
      L |= Exp_msk1 >> 4;
#endif
      word0 (a) = L;
   27e0c:	e1a01003 	mov	r1, r3
#ifndef _DOUBLE_IS_32BITS
      word1 (a) = 0;
   27e10:	e1a00002 	mov	r0, r2
         word1 (a) = L >= 31 ? 1 : 1 << (31 - L);
#endif
	}
    }
#endif
  return a.d;
   27e14:	ec410b10 	vmov	d0, r0, r1
}
   27e18:	e12fff1e 	bx	lr
      L = -L >> Exp_shift;
   27e1c:	e2633000 	rsb	r3, r3, #0
      if (L < Exp_shift)
   27e20:	e3530505 	cmp	r3, #20971520	@ 0x1400000
      L = -L >> Exp_shift;
   27e24:	e1a03a43 	asr	r3, r3, #20
	  word0 (a) = 0x80000 >> L;
   27e28:	b3a01702 	movlt	r1, #524288	@ 0x80000
   27e2c:	b3a02000 	movlt	r2, #0
   27e30:	b1a03351 	asrlt	r3, r1, r3
	  word1 (a) = 0;
   27e34:	bafffff4 	blt	27e0c <__ulp+0x20>
	  L -= Exp_shift;
   27e38:	e2433014 	sub	r3, r3, #20
         word1 (a) = L >= 31 ? 1 : 1 << (31 - L);
   27e3c:	e353001e 	cmp	r3, #30
   27e40:	d3a02102 	movle	r2, #-2147483648	@ 0x80000000
   27e44:	c3a02001 	movgt	r2, #1
   27e48:	d1a02332 	lsrle	r2, r2, r3
   27e4c:	e3a03000 	mov	r3, #0
   27e50:	eaffffed 	b	27e0c <__ulp+0x20>

00027e54 <__b2d>:

double
b2d (_Bigint * a, int *e)
{
   27e54:	e92d4070 	push	{r4, r5, r6, lr}
#else
#define d0 word0(d)
#define d1 word1(d)
#endif

  xa0 = a->_x;
   27e58:	e2802014 	add	r2, r0, #20
  xa = xa0 + a->_wds;
   27e5c:	e5904010 	ldr	r4, [r0, #16]
   27e60:	e0824104 	add	r4, r2, r4, lsl #2
  y = *--xa;
   27e64:	e5145004 	ldr	r5, [r4, #-4]
   27e68:	e2446004 	sub	r6, r4, #4
#ifdef DEBUG
  if (!y)
    Bug ("zero y in b2d");
#endif
  k = hi0bits (y);
   27e6c:	e1a00005 	mov	r0, r5
   27e70:	ebfffdc4 	bl	27588 <__hi0bits>
  *e = 32 - k;
#ifdef Pack_32
  if (k < Ebits)
   27e74:	e350000a 	cmp	r0, #10
  *e = 32 - k;
   27e78:	e2603020 	rsb	r3, r0, #32
   27e7c:	e5813000 	str	r3, [r1]
  if (k < Ebits)
   27e80:	da000018 	ble	27ee8 <__b2d+0x94>
#ifndef _DOUBLE_IS_32BITS
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
#endif
      goto ret_d;
    }
  z = xa > xa0 ? *--xa : 0;
   27e84:	e1520006 	cmp	r2, r6
  if (k -= Ebits)
   27e88:	e240c00b 	sub	ip, r0, #11
  z = xa > xa0 ? *--xa : 0;
   27e8c:	2a00000d 	bcs	27ec8 <__b2d+0x74>
  if (k -= Ebits)
   27e90:	e35c0000 	cmp	ip, #0
  z = xa > xa0 ? *--xa : 0;
   27e94:	e5141008 	ldr	r1, [r4, #-8]
  if (k -= Ebits)
   27e98:	0a00000d 	beq	27ed4 <__b2d+0x80>
    {
      d0 = Exp_1 | y << k | z >> (32 - k);
   27e9c:	e26ce020 	rsb	lr, ip, #32
  z = xa > xa0 ? *--xa : 0;
   27ea0:	e2443008 	sub	r3, r4, #8
      d0 = Exp_1 | y << k | z >> (32 - k);
   27ea4:	e1a00e31 	lsr	r0, r1, lr
      y = xa > xa0 ? *--xa : 0;
   27ea8:	e1520003 	cmp	r2, r3
#ifndef _DOUBLE_IS_32BITS
      d1 = z << k | y >> (32 - k);
   27eac:	e1a01c11 	lsl	r1, r1, ip
      d0 = Exp_1 | y << k | z >> (32 - k);
   27eb0:	e1800c15 	orr	r0, r0, r5, lsl ip
   27eb4:	e38035ff 	orr	r3, r0, #1069547520	@ 0x3fc00000
   27eb8:	e3833603 	orr	r3, r3, #3145728	@ 0x300000
      d1 = z << k | y >> (32 - k);
   27ebc:	3514000c 	ldrcc	r0, [r4, #-12]
   27ec0:	31811e30 	orrcc	r1, r1, r0, lsr lr
   27ec4:	ea000004 	b	27edc <__b2d+0x88>
  if (k -= Ebits)
   27ec8:	e350000b 	cmp	r0, #11
      d0 = Exp_1 | y << k | z >> (32 - k);
   27ecc:	e3a01000 	mov	r1, #0
  if (k -= Ebits)
   27ed0:	1a00000f 	bne	27f14 <__b2d+0xc0>
#endif
    }
  else
    {
      d0 = Exp_1 | y;
   27ed4:	e38535ff 	orr	r3, r5, #1069547520	@ 0x3fc00000
   27ed8:	e3833603 	orr	r3, r3, #3145728	@ 0x300000
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
   27edc:	e1a02001 	mov	r2, r1
  word1 (d) = d1 >> 16 | d1 << 16;
#else
#undef d0
#undef d1
#endif
  return d.d;
   27ee0:	ec432b10 	vmov	d0, r2, r3
}
   27ee4:	e8bd8070 	pop	{r4, r5, r6, pc}
      d0 = Exp_1 | y >> (Ebits - k);
   27ee8:	e3a01000 	mov	r1, #0
      w = xa > xa0 ? *--xa : 0;
   27eec:	e1520006 	cmp	r2, r6
      d0 = Exp_1 | y >> (Ebits - k);
   27ef0:	e3431ff0 	movt	r1, #16368	@ 0x3ff0
   27ef4:	e260c00b 	rsb	ip, r0, #11
   27ef8:	e1813c35 	orr	r3, r1, r5, lsr ip
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
   27efc:	35141008 	ldrcc	r1, [r4, #-8]
   27f00:	23a01000 	movcs	r1, #0
   27f04:	e2800015 	add	r0, r0, #21
   27f08:	31a01c31 	lsrcc	r1, r1, ip
   27f0c:	e1811015 	orr	r1, r1, r5, lsl r0
      goto ret_d;
   27f10:	eafffff1 	b	27edc <__b2d+0x88>
      d0 = Exp_1 | y << k | z >> (32 - k);
   27f14:	e3431ff0 	movt	r1, #16368	@ 0x3ff0
   27f18:	e1813c15 	orr	r3, r1, r5, lsl ip
   27f1c:	e3a01000 	mov	r1, #0
   27f20:	eaffffed 	b	27edc <__b2d+0x88>

00027f24 <__d2b>:
d2b (struct _reent * ptr,
	double _d,
	int *e,
	int *bits)

{
   27f24:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
   27f28:	e1a06001 	mov	r6, r1
   27f2c:	e24dd00c 	sub	sp, sp, #12
#define d1 word1(d)
  d.d = _d;
#endif

#ifdef Pack_32
  b = eBalloc (ptr, 1);
   27f30:	e3a01001 	mov	r1, #1
{
   27f34:	e1a05002 	mov	r5, r2
   27f38:	ec598b10 	vmov	r8, r9, d0
  b = eBalloc (ptr, 1);
   27f3c:	ebfffce7 	bl	272e0 <_Balloc>
   27f40:	e2504000 	subs	r4, r0, #0
   27f44:	0a000035 	beq	28020 <__d2b+0xfc>
  de = (int) (d0 >> Exp_shift);
#ifndef IBM
  z |= Exp_msk11;
#endif
#else
  if ((de = (int) (d0 >> Exp_shift)) != 0)
   27f48:	e7ea7a59 	ubfx	r7, r9, #20, #11
  z = d0 & Frac_mask;
   27f4c:	e7f33059 	ubfx	r3, r9, #0, #20
  if ((de = (int) (d0 >> Exp_shift)) != 0)
   27f50:	e3570000 	cmp	r7, #0
    z |= Exp_msk1;
   27f54:	13833601 	orrne	r3, r3, #1048576	@ 0x100000
#endif
#ifdef Pack_32
#ifndef _DOUBLE_IS_32BITS
  if (d1)
   27f58:	e3580000 	cmp	r8, #0
  z = d0 & Frac_mask;
   27f5c:	e58d3004 	str	r3, [sp, #4]
  if (d1)
   27f60:	1a000011 	bne	27fac <__d2b+0x88>
    {
#ifdef DEBUG
      if (!z)
	Bug ("Zero passed to d2b");
#endif
      k = lo0bits (&z);
   27f64:	e28d0004 	add	r0, sp, #4
   27f68:	ebfffd9e 	bl	275e8 <__lo0bits>
      x[0] = z;
   27f6c:	e59d3004 	ldr	r3, [sp, #4]
  while (!x[i])
    --i;
  b->_wds = i + 1;
#endif
#ifndef Sudden_Underflow
  if (de)
   27f70:	e3570000 	cmp	r7, #0
      i = b->_wds = 1;
   27f74:	e3a02001 	mov	r2, #1
      k += 32;
   27f78:	e2800020 	add	r0, r0, #32
      i = b->_wds = (x[1] = z) ? 2 : 1;
   27f7c:	e5842010 	str	r2, [r4, #16]
      x[0] = z;
   27f80:	e5843014 	str	r3, [r4, #20]
  if (de)
   27f84:	0a00001a 	beq	27ff4 <__d2b+0xd0>
#endif
#ifdef IBM
      *e = (de - Bias - (P - 1) << 2) + k;
      *bits = 4 * P + 8 - k - hi0bits (word0 (d) & Frac_mask);
#else
      *e = de - Bias - (P - 1) + k;
   27f88:	e2477e43 	sub	r7, r7, #1072	@ 0x430
   27f8c:	e2477003 	sub	r7, r7, #3
   27f90:	e0877000 	add	r7, r7, r0
      *bits = P - k;
   27f94:	e2600035 	rsb	r0, r0, #53	@ 0x35
      *e = de - Bias - (P - 1) + k;
   27f98:	e5867000 	str	r7, [r6]
      *bits = P - k;
   27f9c:	e5850000 	str	r0, [r5]
      *bits = (i + 2) * 16 - hi0bits (x[i]);
#endif
    }
#endif
  return b;
}
   27fa0:	e1a00004 	mov	r0, r4
   27fa4:	e28dd00c 	add	sp, sp, #12
   27fa8:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
      k = lo0bits (&y);
   27fac:	e1a0000d 	mov	r0, sp
      y = d1;
   27fb0:	e58d8000 	str	r8, [sp]
      k = lo0bits (&y);
   27fb4:	ebfffd8b 	bl	275e8 <__lo0bits>
         x[0] = y | z << (32 - k);
   27fb8:	e59d2000 	ldr	r2, [sp]
      if (k)
   27fbc:	e3500000 	cmp	r0, #0
         x[0] = y | z << (32 - k);
   27fc0:	e59d3004 	ldr	r3, [sp, #4]
   27fc4:	12601020 	rsbne	r1, r0, #32
   27fc8:	11822113 	orrne	r2, r2, r3, lsl r1
	  z >>= k;
   27fcc:	11a03033 	lsrne	r3, r3, r0
   27fd0:	158d3004 	strne	r3, [sp, #4]
      i = b->_wds = (x[1] = z) ? 2 : 1;
   27fd4:	e3530000 	cmp	r3, #0
   27fd8:	e5842014 	str	r2, [r4, #20]
   27fdc:	03a02001 	moveq	r2, #1
   27fe0:	13a02002 	movne	r2, #2
  if (de)
   27fe4:	e3570000 	cmp	r7, #0
      i = b->_wds = (x[1] = z) ? 2 : 1;
   27fe8:	e5843018 	str	r3, [r4, #24]
   27fec:	e5842010 	str	r2, [r4, #16]
  if (de)
   27ff0:	1affffe4 	bne	27f88 <__d2b+0x64>
      *bits = 32 * i - hi0bits (x[i - 1]);
   27ff4:	e0843102 	add	r3, r4, r2, lsl #2
      *e = de - Bias - (P - 1) + 1 + k;
   27ff8:	e2400e43 	sub	r0, r0, #1072	@ 0x430
   27ffc:	e2400002 	sub	r0, r0, #2
   28000:	e5860000 	str	r0, [r6]
      *bits = 32 * i - hi0bits (x[i - 1]);
   28004:	e5930010 	ldr	r0, [r3, #16]
   28008:	ebfffd5e 	bl	27588 <__hi0bits>
   2800c:	e0600282 	rsb	r0, r0, r2, lsl #5
      *bits = P - k;
   28010:	e5850000 	str	r0, [r5]
}
   28014:	e1a00004 	mov	r0, r4
   28018:	e28dd00c 	add	sp, sp, #12
   2801c:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
  b = eBalloc (ptr, 1);
   28020:	e3093b10 	movw	r3, #39696	@ 0x9b10
   28024:	e3090b64 	movw	r0, #39780	@ 0x9b64
   28028:	e3403002 	movt	r3, #2
   2802c:	e1a02004 	mov	r2, r4
   28030:	e300130f 	movw	r1, #783	@ 0x30f
   28034:	e3400002 	movt	r0, #2
   28038:	ebffb9b8 	bl	16720 <__assert_func>

0002803c <__ratio>:
#undef d1

double
ratio (_Bigint * a, _Bigint * b)

{
   2803c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
   28040:	e24dd00c 	sub	sp, sp, #12
   28044:	e1a06001 	mov	r6, r1
  union double_union da, db;
  int k, ka, kb;

  da.d = b2d (a, &ka);
   28048:	e1a0100d 	mov	r1, sp
{
   2804c:	e1a07000 	mov	r7, r0
  da.d = b2d (a, &ka);
   28050:	ebffff7f 	bl	27e54 <__b2d>
  db.d = b2d (b, &kb);
   28054:	e1a00006 	mov	r0, r6
   28058:	e28d1004 	add	r1, sp, #4
  da.d = b2d (a, &ka);
   2805c:	eeb07b40 	vmov.f64	d7, d0
   28060:	ec554b10 	vmov	r4, r5, d0
  db.d = b2d (b, &kb);
   28064:	ebffff7a 	bl	27e54 <__b2d>
#ifdef Pack_32
  k = ka - kb + 32 * (a->_wds - b->_wds);
   28068:	e5963010 	ldr	r3, [r6, #16]
   2806c:	e5972010 	ldr	r2, [r7, #16]
   28070:	e59d1004 	ldr	r1, [sp, #4]
   28074:	e0422003 	sub	r2, r2, r3
   28078:	e59d3000 	ldr	r3, [sp]
   2807c:	e0433001 	sub	r3, r3, r1
   28080:	e0833282 	add	r3, r3, r2, lsl #5
      word0 (db) += (k >> 2) * Exp_msk1;
      if (k &= 3)
	db.d *= 1 << k;
    }
#else
  if (k > 0)
   28084:	e3530000 	cmp	r3, #0
    word0 (da) += k * Exp_msk1;
  else
    {
      k = -k;
      word0 (db) += k * Exp_msk1;
   28088:	de102a90 	vmovle	r2, s1
    word0 (da) += k * Exp_msk1;
   2808c:	ce172a90 	vmovgt	r2, s15
   28090:	dc510b10 	vmovle	r0, r1, d0
   28094:	c0825a03 	addgt	r5, r2, r3, lsl #20
      word0 (db) += k * Exp_msk1;
   28098:	d0421a03 	suble	r1, r2, r3, lsl #20
    }
#endif
  return da.d / db.d;
   2809c:	cc454b17 	vmovgt	d7, r4, r5
   280a0:	dc410b10 	vmovle	d0, r0, r1
}
   280a4:	ee870b00 	vdiv.f64	d0, d7, d0
   280a8:	e28dd00c 	add	sp, sp, #12
   280ac:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

000280b0 <_mprec_log10>:

double
_mprec_log10 (int dig)
{
  double v = 1.0;
  if (dig < 24)
   280b0:	e3500017 	cmp	r0, #23
   280b4:	da000005 	ble	280d0 <_mprec_log10+0x20>
  double v = 1.0;
   280b8:	ed9f0b0a 	vldr	d0, [pc, #40]	@ 280e8 <_mprec_log10+0x38>
    return tens[dig];
  while (dig > 0)
    {
      v *= 10;
   280bc:	ed9f7b0b 	vldr	d7, [pc, #44]	@ 280f0 <_mprec_log10+0x40>
  while (dig > 0)
   280c0:	e2500001 	subs	r0, r0, #1
      v *= 10;
   280c4:	ee200b07 	vmul.f64	d0, d0, d7
  while (dig > 0)
   280c8:	1afffffc 	bne	280c0 <_mprec_log10+0x10>
   280cc:	e12fff1e 	bx	lr
    return tens[dig];
   280d0:	e30a3108 	movw	r3, #41224	@ 0xa108
   280d4:	e3403002 	movt	r3, #2
   280d8:	e0833180 	add	r3, r3, r0, lsl #3
   280dc:	ed930b04 	vldr	d0, [r3, #16]
   280e0:	e12fff1e 	bx	lr
   280e4:	e320f000 	nop	{0}
   280e8:	00000000 	.word	0x00000000
   280ec:	3ff00000 	.word	0x3ff00000
   280f0:	00000000 	.word	0x00000000
   280f4:	40240000 	.word	0x40240000

000280f8 <__copybits>:
	__ULong *ce, *x, *xe;
#ifdef Pack_16
	int nw, nw1;
#endif

	ce = c + ((n-1) >> kshift) + 1;
   280f8:	e241c001 	sub	ip, r1, #1
	x = b->_x;
#ifdef Pack_32
	xe = x + b->_wds;
   280fc:	e5921010 	ldr	r1, [r2, #16]
	x = b->_x;
   28100:	e2823014 	add	r3, r2, #20
	ce = c + ((n-1) >> kshift) + 1;
   28104:	e1a0c2cc 	asr	ip, ip, #5
   28108:	e28cc001 	add	ip, ip, #1
	xe = x + b->_wds;
   2810c:	e0831101 	add	r1, r3, r1, lsl #2
	ce = c + ((n-1) >> kshift) + 1;
   28110:	e080c10c 	add	ip, r0, ip, lsl #2
	while(x < xe)
   28114:	e1530001 	cmp	r3, r1
   28118:	2a000011 	bcs	28164 <__copybits+0x6c>
{
   2811c:	e92d4010 	push	{r4, lr}
   28120:	e240e004 	sub	lr, r0, #4
		*c++ = *x++;
   28124:	e4934004 	ldr	r4, [r3], #4
	while(x < xe)
   28128:	e1510003 	cmp	r1, r3
		*c++ = *x++;
   2812c:	e5ae4004 	str	r4, [lr, #4]!
	while(x < xe)
   28130:	8afffffb 	bhi	28124 <__copybits+0x2c>
   28134:	e0413002 	sub	r3, r1, r2
   28138:	e2433015 	sub	r3, r3, #21
   2813c:	e3c33003 	bic	r3, r3, #3
   28140:	e2833004 	add	r3, r3, #4
   28144:	e0800003 	add	r0, r0, r3
	for(xe = x + (nw - nw1); x < xe; x += 2)
		Storeinc(c, x[1], x[0]);
	if (nw1)
		*c++ = *x;
#endif
	while(c < ce)
   28148:	e15c0000 	cmp	ip, r0
   2814c:	98bd8010 	popls	{r4, pc}
		*c++ = 0;
   28150:	e3a03000 	mov	r3, #0
   28154:	e4803004 	str	r3, [r0], #4
	while(c < ce)
   28158:	e15c0000 	cmp	ip, r0
   2815c:	8afffffc 	bhi	28154 <__copybits+0x5c>
   28160:	e8bd8010 	pop	{r4, pc}
   28164:	e15c0000 	cmp	ip, r0
   28168:	912fff1e 	bxls	lr
		*c++ = 0;
   2816c:	e3a03000 	mov	r3, #0
   28170:	e4803004 	str	r3, [r0], #4
	while(c < ce)
   28174:	e15c0000 	cmp	ip, r0
   28178:	8afffffc 	bhi	28170 <__copybits+0x78>
   2817c:	e12fff1e 	bx	lr

00028180 <__any_on>:
{
	int n, nwds;
	__ULong *x, *x0, x1, x2;

	x = b->_x;
	nwds = b->_wds;
   28180:	e5903010 	ldr	r3, [r0, #16]
	n = k >> kshift;
   28184:	e1a022c1 	asr	r2, r1, #5
	x = b->_x;
   28188:	e2800014 	add	r0, r0, #20
	if (n > nwds)
   2818c:	e1530002 	cmp	r3, r2
		x1 <<= k;
		if (x1 != x2)
			return 1;
		}
	x0 = x;
	x += n;
   28190:	b0803103 	addlt	r3, r0, r3, lsl #2
	if (n > nwds)
   28194:	ba00000c 	blt	281cc <__any_on+0x4c>
		x1 = x2 = x[n];
   28198:	e0803102 	add	r3, r0, r2, lsl #2
	else if (n < nwds && (k &= kmask)) {
   2819c:	da00000a 	ble	281cc <__any_on+0x4c>
   281a0:	e211101f 	ands	r1, r1, #31
   281a4:	0a000008 	beq	281cc <__any_on+0x4c>
		x1 = x2 = x[n];
   281a8:	e7902102 	ldr	r2, [r0, r2, lsl #2]
		x1 >>= k;
   281ac:	e1a0c132 	lsr	ip, r2, r1
		if (x1 != x2)
   281b0:	e152011c 	cmp	r2, ip, lsl r1
   281b4:	0a000004 	beq	281cc <__any_on+0x4c>
			return 1;
   281b8:	e3a00001 	mov	r0, #1
	while(x > x0)
		if (*--x)
			return 1;
	return 0;
}
   281bc:	e12fff1e 	bx	lr
		if (*--x)
   281c0:	e5332004 	ldr	r2, [r3, #-4]!
   281c4:	e3520000 	cmp	r2, #0
   281c8:	1afffffa 	bne	281b8 <__any_on+0x38>
	while(x > x0)
   281cc:	e1530000 	cmp	r3, r0
   281d0:	8afffffa 	bhi	281c0 <__any_on+0x40>
	return 0;
   281d4:	e3a00000 	mov	r0, #0
   281d8:	e12fff1e 	bx	lr

000281dc <__ssputs_r>:
int
__ssputs_r (struct _reent *ptr,
	FILE *fp,
	const char *buf,
	size_t len)
{
   281dc:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
   281e0:	e1a04001 	mov	r4, r1
	register int w;

	w = fp->_w;
   281e4:	e5917008 	ldr	r7, [r1, #8]
{
   281e8:	e1a05003 	mov	r5, r3
   281ec:	e1a06002 	mov	r6, r2
	if (len >= w && fp->_flags & (__SMBF | __SOPT)) {
		/* must be asprintf family */
		unsigned char *str;
		int curpos = (fp->_p - fp->_bf._base);
   281f0:	e591a000 	ldr	sl, [r1]
	if (len >= w && fp->_flags & (__SMBF | __SOPT)) {
   281f4:	e1570003 	cmp	r7, r3
   281f8:	8a00002a 	bhi	282a8 <__ssputs_r+0xcc>
   281fc:	e1d1c0fc 	ldrsh	ip, [r1, #12]
   28200:	e31c0d12 	tst	ip, #1152	@ 0x480
   28204:	1a00000c 	bne	2823c <__ssputs_r+0x60>
   28208:	e1a05007 	mov	r5, r7
		w = len;
		fp->_w = newsize - curpos;
	}
	if (len < w)
		w = len;
	memmove ((void *) fp->_p, (void *) buf, (size_t) (w));
   2820c:	e1a02005 	mov	r2, r5
   28210:	e1a01006 	mov	r1, r6
   28214:	e1a0000a 	mov	r0, sl
   28218:	ebffc8ce 	bl	1a558 <memmove>
	fp->_w -= w;
   2821c:	e5942008 	ldr	r2, [r4, #8]
	fp->_p += w;

	return 0;
   28220:	e3a00000 	mov	r0, #0
	fp->_p += w;
   28224:	e5943000 	ldr	r3, [r4]
	fp->_w -= w;
   28228:	e0422007 	sub	r2, r2, r7
	fp->_p += w;
   2822c:	e0833005 	add	r3, r3, r5
	fp->_w -= w;
   28230:	e5842008 	str	r2, [r4, #8]
	fp->_p += w;
   28234:	e5843000 	str	r3, [r4]
	return 0;
   28238:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
		int newsize = fp->_bf._size * 3 / 2;
   2823c:	e5912014 	ldr	r2, [r1, #20]
		if (newsize < curpos + len + 1)
   28240:	e2833001 	add	r3, r3, #1
		int curpos = (fp->_p - fp->_bf._base);
   28244:	e5911010 	ldr	r1, [r1, #16]
   28248:	e1a08000 	mov	r8, r0
		int newsize = fp->_bf._size * 3 / 2;
   2824c:	e0822082 	add	r2, r2, r2, lsl #1
		int curpos = (fp->_p - fp->_bf._base);
   28250:	e04a7001 	sub	r7, sl, r1
		if (newsize < curpos + len + 1)
   28254:	e0833007 	add	r3, r3, r7
		int newsize = fp->_bf._size * 3 / 2;
   28258:	e0822fa2 	add	r2, r2, r2, lsr #31
   2825c:	e1a020c2 	asr	r2, r2, #1
			newsize = curpos + len + 1;
   28260:	e1530002 	cmp	r3, r2
   28264:	91a09002 	movls	r9, r2
   28268:	81a09003 	movhi	r9, r3
   2826c:	81a02003 	movhi	r2, r3
		if (fp->_flags & __SOPT)
   28270:	e31c0b01 	tst	ip, #1024	@ 0x400
   28274:	0a00000d 	beq	282b0 <__ssputs_r+0xd4>
			str = (unsigned char *)_malloc_r (ptr, newsize);
   28278:	e1a01002 	mov	r1, r2
   2827c:	ebffdcb0 	bl	1f544 <_malloc_r>
			if (!str)
   28280:	e250a000 	subs	sl, r0, #0
   28284:	0a000017 	beq	282e8 <__ssputs_r+0x10c>
			memcpy (str, fp->_bf._base, curpos);
   28288:	e5941010 	ldr	r1, [r4, #16]
   2828c:	e1a02007 	mov	r2, r7
   28290:	ebffdefa 	bl	1fe80 <memcpy>
			fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
   28294:	e1d430bc 	ldrh	r3, [r4, #12]
   28298:	e3c33d12 	bic	r3, r3, #1152	@ 0x480
   2829c:	e3833080 	orr	r3, r3, #128	@ 0x80
   282a0:	e1c430bc 	strh	r3, [r4, #12]
   282a4:	ea000004 	b	282bc <__ssputs_r+0xe0>
		w = len;
   282a8:	e1a07003 	mov	r7, r3
   282ac:	eaffffd6 	b	2820c <__ssputs_r+0x30>
			str = (unsigned char *)_realloc_r (ptr, fp->_bf._base,
   282b0:	ebffdca7 	bl	1f554 <_realloc_r>
			if (!str) {
   282b4:	e250a000 	subs	sl, r0, #0
   282b8:	0a000007 	beq	282dc <__ssputs_r+0x100>
		fp->_bf._base = str;
   282bc:	e584a010 	str	sl, [r4, #16]
		fp->_p = str + curpos;
   282c0:	e08aa007 	add	sl, sl, r7
		fp->_w = newsize - curpos;
   282c4:	e0497007 	sub	r7, r9, r7
		fp->_bf._size = newsize;
   282c8:	e5849014 	str	r9, [r4, #20]
		fp->_w = newsize - curpos;
   282cc:	e5847008 	str	r7, [r4, #8]
		w = len;
   282d0:	e1a07005 	mov	r7, r5
		fp->_p = str + curpos;
   282d4:	e584a000 	str	sl, [r4]
	if (len < w)
   282d8:	eaffffcb 	b	2820c <__ssputs_r+0x30>
				_free_r (ptr, fp->_bf._base);
   282dc:	e5941010 	ldr	r1, [r4, #16]
   282e0:	e1a00008 	mov	r0, r8
   282e4:	ebffdc98 	bl	1f54c <_free_r>

err:
	_REENT_ERRNO(ptr) = ENOMEM;
	fp->_flags |= __SERR;
   282e8:	e1d430bc 	ldrh	r3, [r4, #12]
	_REENT_ERRNO(ptr) = ENOMEM;
   282ec:	e3a0200c 	mov	r2, #12
   282f0:	e5882000 	str	r2, [r8]
	return EOF;
   282f4:	e3e00000 	mvn	r0, #0
	fp->_flags |= __SERR;
   282f8:	e3833040 	orr	r3, r3, #64	@ 0x40
   282fc:	e1c430bc 	strh	r3, [r4, #12]
}
   28300:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}

00028304 <_calloc_r>:
#include <stdlib.h>

void *
_calloc_r (struct _reent *ptr, size_t size, size_t len)
{
   28304:	e1a00001 	mov	r0, r1
  return calloc (size, len);
   28308:	e1a01002 	mov	r1, r2
   2830c:	eaffda99 	b	1ed78 <calloc>

Disassembly of section .fini:

00028310 <_fini>:
   28310:	e1a0c00d 	mov	ip, sp
   28314:	e92ddff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
   28318:	e24cb004 	sub	fp, ip, #4
   2831c:	e24bd028 	sub	sp, fp, #40	@ 0x28
   28320:	e89d6ff0 	ldm	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
   28324:	e12fff1e 	bx	lr
